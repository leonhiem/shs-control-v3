
shsmaster3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000bd10  00000000  00000000  00010000  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000002e4  20000000  0000bd10  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000a78  200002e8  0000bff8  000202e4  2**3
                  ALLOC
  3 .stack        00000800  20000d60  0000ca70  000202e4  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000202e4  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002030c  2**0
                  CONTENTS, READONLY
  6 .debug_info   00088aed  00000000  00000000  00020365  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000069a1  00000000  00000000  000a8e52  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000246ee  00000000  00000000  000af7f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000019f8  00000000  00000000  000d3ee1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00002228  00000000  00000000  000d58d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0000652b  00000000  00000000  000d7b01  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000fcee  00000000  00000000  000de02c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00055862  00000000  00000000  000edd1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00006388  00000000  00000000  0014357c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	60 15 00 20 95 0f 00 00 91 0f 00 00 91 0f 00 00     `.. ............
	...
      2c:	91 0f 00 00 00 00 00 00 00 00 00 00 91 0f 00 00     ................
      3c:	91 0f 00 00 91 0f 00 00 25 17 00 00 c9 7e 00 00     ........%....~..
      4c:	45 39 00 00 b1 4e 00 00 91 0f 00 00 91 0f 00 00     E9...N..........
      5c:	8d 4e 00 00 51 7a 00 00 51 78 00 00 f9 1e 00 00     .N..Qz..Qx......
	...
      74:	91 0f 00 00 d1 15 00 00 69 75 00 00 01 70 00 00     ........iu...p..
      84:	91 0f 00 00 91 0f 00 00 00 00 00 00 00 00 00 00     ................
      94:	91 0f 00 00 91 0f 00 00 91 0f 00 00 91 0f 00 00     ................

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	200002e8 	.word	0x200002e8
      c4:	00000000 	.word	0x00000000
      c8:	0000bd10 	.word	0x0000bd10

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	200002ec 	.word	0x200002ec
      f8:	0000bd10 	.word	0x0000bd10
      fc:	0000bd10 	.word	0x0000bd10
     100:	00000000 	.word	0x00000000

00000104 <bt_read_bluetooth_status>:

extern sysVals_t sysval;
extern sim_task_queue_t sim_task_queue;

int bt_read_bluetooth_status(void)
{
     104:	b510      	push	{r4, lr}
	char sim_rxbuf[60];
	char *ptr;
	int found,stat;
	char *cmd="AT+BTSTATUS?\r";

	sim_tx(cmd,strlen(cmd));
     106:	4c13      	ldr	r4, [pc, #76]	; (154 <bt_read_bluetooth_status+0x50>)
{
     108:	b090      	sub	sp, #64	; 0x40
	sim_tx(cmd,strlen(cmd));
     10a:	0020      	movs	r0, r4
     10c:	210d      	movs	r1, #13
     10e:	4b12      	ldr	r3, [pc, #72]	; (158 <bt_read_bluetooth_status+0x54>)
     110:	4798      	blx	r3
	sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
     112:	0021      	movs	r1, r4
     114:	233c      	movs	r3, #60	; 0x3c
     116:	4c11      	ldr	r4, [pc, #68]	; (15c <bt_read_bluetooth_status+0x58>)
     118:	220a      	movs	r2, #10
     11a:	a801      	add	r0, sp, #4
     11c:	47a0      	blx	r4
	sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf));
     11e:	233c      	movs	r3, #60	; 0x3c
     120:	2214      	movs	r2, #20
     122:	490f      	ldr	r1, [pc, #60]	; (160 <bt_read_bluetooth_status+0x5c>)
     124:	a801      	add	r0, sp, #4
     126:	47a0      	blx	r4

	// response looks like: +BTSTATUS: 5\r\nOK
	ptr=sim_rxbuf;
	found=sscanf(ptr,"\r\n+BTSTATUS: %d",&stat);
     128:	4b0e      	ldr	r3, [pc, #56]	; (164 <bt_read_bluetooth_status+0x60>)
     12a:	466a      	mov	r2, sp
     12c:	490e      	ldr	r1, [pc, #56]	; (168 <bt_read_bluetooth_status+0x64>)
     12e:	a801      	add	r0, sp, #4
     130:	4798      	blx	r3
	sim_rxflush();
     132:	4b0e      	ldr	r3, [pc, #56]	; (16c <bt_read_bluetooth_status+0x68>)
	found=sscanf(ptr,"\r\n+BTSTATUS: %d",&stat);
     134:	0004      	movs	r4, r0
	sim_rxflush();
     136:	4798      	blx	r3
	if(found==1) {
     138:	2c01      	cmp	r4, #1
     13a:	d107      	bne.n	14c <bt_read_bluetooth_status+0x48>
		uart_print(0,"BTSTATUS:%d\n\r",stat);
     13c:	2000      	movs	r0, #0
     13e:	9a00      	ldr	r2, [sp, #0]
     140:	490b      	ldr	r1, [pc, #44]	; (170 <bt_read_bluetooth_status+0x6c>)
     142:	4b0c      	ldr	r3, [pc, #48]	; (174 <bt_read_bluetooth_status+0x70>)
     144:	4798      	blx	r3
		return stat;
     146:	9800      	ldr	r0, [sp, #0]
	} else return -1;
}
     148:	b010      	add	sp, #64	; 0x40
     14a:	bd10      	pop	{r4, pc}
	} else return -1;
     14c:	2001      	movs	r0, #1
     14e:	4240      	negs	r0, r0
     150:	e7fa      	b.n	148 <bt_read_bluetooth_status+0x44>
     152:	46c0      	nop			; (mov r8, r8)
     154:	00009d80 	.word	0x00009d80
     158:	0000525d 	.word	0x0000525d
     15c:	00005021 	.word	0x00005021
     160:	0000afa0 	.word	0x0000afa0
     164:	000089ad 	.word	0x000089ad
     168:	00009d8e 	.word	0x00009d8e
     16c:	00004fc1 	.word	0x00004fc1
     170:	00009d9e 	.word	0x00009d9e
     174:	00007b99 	.word	0x00007b99

00000178 <bt_bluetooth_power_on>:

uint8_t bt_bluetooth_power_on(void)
{
     178:	b570      	push	{r4, r5, r6, lr}
	char *cmd="AT+BTPOWER=1\r";
	uart_print(0,"sim_bluetooth_power_on\n\r");	
	sim_tx(cmd,strlen(cmd)); // power on BT
	sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
	//wdt_reset();
	delay_ms(500);
     17a:	25fa      	movs	r5, #250	; 0xfa
{
     17c:	b088      	sub	sp, #32
	uart_print(0,"sim_bluetooth_power_on\n\r");	
     17e:	490f      	ldr	r1, [pc, #60]	; (1bc <bt_bluetooth_power_on+0x44>)
     180:	2000      	movs	r0, #0
     182:	4b0f      	ldr	r3, [pc, #60]	; (1c0 <bt_bluetooth_power_on+0x48>)
     184:	4798      	blx	r3
	sim_tx(cmd,strlen(cmd)); // power on BT
     186:	4c0f      	ldr	r4, [pc, #60]	; (1c4 <bt_bluetooth_power_on+0x4c>)
     188:	210d      	movs	r1, #13
     18a:	0020      	movs	r0, r4
     18c:	4b0e      	ldr	r3, [pc, #56]	; (1c8 <bt_bluetooth_power_on+0x50>)
     18e:	4798      	blx	r3
	delay_ms(500);
     190:	006d      	lsls	r5, r5, #1
	sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
     192:	0021      	movs	r1, r4
     194:	2320      	movs	r3, #32
     196:	220a      	movs	r2, #10
     198:	4e0c      	ldr	r6, [pc, #48]	; (1cc <bt_bluetooth_power_on+0x54>)
     19a:	4668      	mov	r0, sp
     19c:	47b0      	blx	r6
	delay_ms(500);
     19e:	4c0c      	ldr	r4, [pc, #48]	; (1d0 <bt_bluetooth_power_on+0x58>)
     1a0:	0028      	movs	r0, r5
     1a2:	47a0      	blx	r4
	//wdt_reset();
	delay_ms(500);
     1a4:	0028      	movs	r0, r5
     1a6:	47a0      	blx	r4
	//wdt_reset();
	delay_ms(500);
     1a8:	0028      	movs	r0, r5
     1aa:	47a0      	blx	r4
	//wdt_reset();
	return (uint8_t)sim_read(sim_rxbuf,"OK\r\n",40,sizeof(sim_rxbuf));
     1ac:	2320      	movs	r3, #32
     1ae:	2228      	movs	r2, #40	; 0x28
     1b0:	4908      	ldr	r1, [pc, #32]	; (1d4 <bt_bluetooth_power_on+0x5c>)
     1b2:	4668      	mov	r0, sp
     1b4:	47b0      	blx	r6
     1b6:	b2c0      	uxtb	r0, r0
}
     1b8:	b008      	add	sp, #32
     1ba:	bd70      	pop	{r4, r5, r6, pc}
     1bc:	00009dac 	.word	0x00009dac
     1c0:	00007b99 	.word	0x00007b99
     1c4:	00009dc5 	.word	0x00009dc5
     1c8:	0000525d 	.word	0x0000525d
     1cc:	00005021 	.word	0x00005021
     1d0:	00007c05 	.word	0x00007c05
     1d4:	0000afa0 	.word	0x0000afa0

000001d8 <bt_bluetooth_power_off>:

uint8_t bt_bluetooth_power_off(void)
{
     1d8:	b510      	push	{r4, lr}
	char sim_rxbuf[32];
	char *cmd="AT+BTPOWER=0\r"; // power off BT
	uart_print(0,"sim_stop_bluetooth\n\r");
     1da:	490e      	ldr	r1, [pc, #56]	; (214 <bt_bluetooth_power_off+0x3c>)
{
     1dc:	b088      	sub	sp, #32
	uart_print(0,"sim_stop_bluetooth\n\r");
     1de:	2000      	movs	r0, #0
     1e0:	4b0d      	ldr	r3, [pc, #52]	; (218 <bt_bluetooth_power_off+0x40>)
     1e2:	4798      	blx	r3
	sim_tx(cmd,strlen(cmd));
     1e4:	4c0d      	ldr	r4, [pc, #52]	; (21c <bt_bluetooth_power_off+0x44>)
     1e6:	210d      	movs	r1, #13
     1e8:	0020      	movs	r0, r4
     1ea:	4b0d      	ldr	r3, [pc, #52]	; (220 <bt_bluetooth_power_off+0x48>)
     1ec:	4798      	blx	r3
	sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
     1ee:	0021      	movs	r1, r4
     1f0:	220a      	movs	r2, #10
     1f2:	4c0c      	ldr	r4, [pc, #48]	; (224 <bt_bluetooth_power_off+0x4c>)
     1f4:	2320      	movs	r3, #32
     1f6:	4668      	mov	r0, sp
     1f8:	47a0      	blx	r4
	//wdt_reset();
	delay_ms(500);
     1fa:	20fa      	movs	r0, #250	; 0xfa
     1fc:	4b0a      	ldr	r3, [pc, #40]	; (228 <bt_bluetooth_power_off+0x50>)
     1fe:	0040      	lsls	r0, r0, #1
     200:	4798      	blx	r3
	return (uint8_t)sim_read(sim_rxbuf,"OK\r\n",40,sizeof(sim_rxbuf));
     202:	2320      	movs	r3, #32
     204:	2228      	movs	r2, #40	; 0x28
     206:	4909      	ldr	r1, [pc, #36]	; (22c <bt_bluetooth_power_off+0x54>)
     208:	4668      	mov	r0, sp
     20a:	47a0      	blx	r4
     20c:	b2c0      	uxtb	r0, r0
}
     20e:	b008      	add	sp, #32
     210:	bd10      	pop	{r4, pc}
     212:	46c0      	nop			; (mov r8, r8)
     214:	00009dd3 	.word	0x00009dd3
     218:	00007b99 	.word	0x00007b99
     21c:	00009de8 	.word	0x00009de8
     220:	0000525d 	.word	0x0000525d
     224:	00005021 	.word	0x00005021
     228:	00007c05 	.word	0x00007c05
     22c:	0000afa0 	.word	0x0000afa0

00000230 <bt_set_bluetooth>:

uint8_t bt_set_bluetooth(void)
{
     230:	b5f0      	push	{r4, r5, r6, r7, lr}
	char *bthostname =          "Kamworks_SHS";
	char *cmd_btpaircfg = "AT+BTPAIRCFG=1,0000\r"; // sets the pairing mode to 1 with pincode="0000"
	char *cmd_btsppcfg = "AT+BTSPPCFG=MC,0\r"; // do not support multiconnections
	char *found_ptr=NULL;
	
	sim_tx(cmd_gethost,strlen(cmd_gethost)); // get BT hostname
     232:	4c20      	ldr	r4, [pc, #128]	; (2b4 <bt_set_bluetooth+0x84>)
{
     234:	b08f      	sub	sp, #60	; 0x3c
	sim_tx(cmd_gethost,strlen(cmd_gethost)); // get BT hostname
     236:	0020      	movs	r0, r4
     238:	210b      	movs	r1, #11
     23a:	4e1f      	ldr	r6, [pc, #124]	; (2b8 <bt_set_bluetooth+0x88>)
     23c:	47b0      	blx	r6
	sim_read(sim_rxbuf,cmd_gethost,10,sizeof(sim_rxbuf)); // read echo
     23e:	0021      	movs	r1, r4
     240:	2332      	movs	r3, #50	; 0x32
     242:	220a      	movs	r2, #10
     244:	4c1d      	ldr	r4, [pc, #116]	; (2bc <bt_set_bluetooth+0x8c>)
     246:	a801      	add	r0, sp, #4
     248:	47a0      	blx	r4
	sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf));
     24a:	4d1d      	ldr	r5, [pc, #116]	; (2c0 <bt_set_bluetooth+0x90>)
     24c:	2214      	movs	r2, #20
     24e:	2332      	movs	r3, #50	; 0x32
     250:	0029      	movs	r1, r5
     252:	a801      	add	r0, sp, #4
     254:	47a0      	blx	r4
	// response looks like: +BTHOST: Kamworks_SHS,38:1c:4a:98:b4:24\r\n\r\nOK
	found_ptr = strstr(sim_rxbuf,bthostname);
     256:	4b1b      	ldr	r3, [pc, #108]	; (2c4 <bt_set_bluetooth+0x94>)
     258:	491b      	ldr	r1, [pc, #108]	; (2c8 <bt_set_bluetooth+0x98>)
     25a:	a801      	add	r0, sp, #4
     25c:	4798      	blx	r3
	sim_rxflush();
     25e:	4b1b      	ldr	r3, [pc, #108]	; (2cc <bt_set_bluetooth+0x9c>)
	found_ptr = strstr(sim_rxbuf,bthostname);
     260:	0007      	movs	r7, r0
	sim_rxflush();
     262:	4798      	blx	r3
     264:	4b1a      	ldr	r3, [pc, #104]	; (2d0 <bt_set_bluetooth+0xa0>)
	if(found_ptr != NULL) {
     266:	2f00      	cmp	r7, #0
     268:	d005      	beq.n	276 <bt_set_bluetooth+0x46>
		uart_print(0,"sim_set_bluetooth: bthost already set\n\r");
     26a:	491a      	ldr	r1, [pc, #104]	; (2d4 <bt_set_bluetooth+0xa4>)
     26c:	2000      	movs	r0, #0
     26e:	4798      	blx	r3
		sim_tx(cmd_btpaircfg,strlen(cmd_btpaircfg)); // set BT pairing mode and pincode (needs bt reboot)
		sim_read(sim_rxbuf,"OK\r\n",5,sizeof(sim_rxbuf));
		sim_rxflush();
	}
	return 1;
}
     270:	2001      	movs	r0, #1
     272:	b00f      	add	sp, #60	; 0x3c
     274:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uart_print(0,"sim_set_bluetooth: setting up\n\r");
     276:	0038      	movs	r0, r7
     278:	4917      	ldr	r1, [pc, #92]	; (2d8 <bt_set_bluetooth+0xa8>)
     27a:	4798      	blx	r3
		sim_tx(cmd_sethost,strlen(cmd_sethost)); // set BT hostname
     27c:	2117      	movs	r1, #23
     27e:	4817      	ldr	r0, [pc, #92]	; (2dc <bt_set_bluetooth+0xac>)
     280:	47b0      	blx	r6
		sim_read(sim_rxbuf,"OK\r\n",5,sizeof(sim_rxbuf));
     282:	2332      	movs	r3, #50	; 0x32
     284:	2205      	movs	r2, #5
     286:	0029      	movs	r1, r5
     288:	a801      	add	r0, sp, #4
     28a:	47a0      	blx	r4
		sim_tx(cmd_btsppcfg,strlen(cmd_btsppcfg)); // disable multiconnections
     28c:	2111      	movs	r1, #17
     28e:	4814      	ldr	r0, [pc, #80]	; (2e0 <bt_set_bluetooth+0xb0>)
     290:	47b0      	blx	r6
		sim_read(sim_rxbuf,"OK\r\n",5,sizeof(sim_rxbuf));
     292:	2332      	movs	r3, #50	; 0x32
     294:	2205      	movs	r2, #5
     296:	0029      	movs	r1, r5
     298:	a801      	add	r0, sp, #4
     29a:	47a0      	blx	r4
		sim_tx(cmd_btpaircfg,strlen(cmd_btpaircfg)); // set BT pairing mode and pincode (needs bt reboot)
     29c:	2114      	movs	r1, #20
     29e:	4811      	ldr	r0, [pc, #68]	; (2e4 <bt_set_bluetooth+0xb4>)
     2a0:	47b0      	blx	r6
		sim_read(sim_rxbuf,"OK\r\n",5,sizeof(sim_rxbuf));
     2a2:	2332      	movs	r3, #50	; 0x32
     2a4:	2205      	movs	r2, #5
     2a6:	0029      	movs	r1, r5
     2a8:	a801      	add	r0, sp, #4
     2aa:	47a0      	blx	r4
		sim_rxflush();
     2ac:	4b07      	ldr	r3, [pc, #28]	; (2cc <bt_set_bluetooth+0x9c>)
     2ae:	4798      	blx	r3
     2b0:	e7de      	b.n	270 <bt_set_bluetooth+0x40>
     2b2:	46c0      	nop			; (mov r8, r8)
     2b4:	00009df6 	.word	0x00009df6
     2b8:	0000525d 	.word	0x0000525d
     2bc:	00005021 	.word	0x00005021
     2c0:	0000afa0 	.word	0x0000afa0
     2c4:	00008ae1 	.word	0x00008ae1
     2c8:	00009e02 	.word	0x00009e02
     2cc:	00004fc1 	.word	0x00004fc1
     2d0:	00007b99 	.word	0x00007b99
     2d4:	00009e0f 	.word	0x00009e0f
     2d8:	00009e37 	.word	0x00009e37
     2dc:	00009e57 	.word	0x00009e57
     2e0:	00009e6f 	.word	0x00009e6f
     2e4:	00009e81 	.word	0x00009e81

000002e8 <bt_start_bluetooth>:


void bt_start_bluetooth(void)
{
     2e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uart_print(0,"sim_start_bluetooth\n\r");
     2ea:	490e      	ldr	r1, [pc, #56]	; (324 <bt_start_bluetooth+0x3c>)
     2ec:	2000      	movs	r0, #0
     2ee:	4d0e      	ldr	r5, [pc, #56]	; (328 <bt_start_bluetooth+0x40>)
     2f0:	47a8      	blx	r5
	sysval.bluetooth_status=bt_read_bluetooth_status();
     2f2:	4f0e      	ldr	r7, [pc, #56]	; (32c <bt_start_bluetooth+0x44>)
     2f4:	47b8      	blx	r7
     2f6:	4c0e      	ldr	r4, [pc, #56]	; (330 <bt_start_bluetooth+0x48>)
     2f8:	b2c0      	uxtb	r0, r0
     2fa:	0026      	movs	r6, r4
     2fc:	36c3      	adds	r6, #195	; 0xc3
     2fe:	7030      	strb	r0, [r6, #0]
	if(sysval.bluetooth_status==0) {
     300:	2800      	cmp	r0, #0
     302:	d109      	bne.n	318 <bt_start_bluetooth+0x30>
		bt_set_bluetooth();
     304:	4b0b      	ldr	r3, [pc, #44]	; (334 <bt_start_bluetooth+0x4c>)
     306:	4798      	blx	r3
		bt_bluetooth_power_on();		
     308:	4b0b      	ldr	r3, [pc, #44]	; (338 <bt_start_bluetooth+0x50>)
     30a:	4798      	blx	r3
	    delay_ms(500);
     30c:	20fa      	movs	r0, #250	; 0xfa
     30e:	4b0b      	ldr	r3, [pc, #44]	; (33c <bt_start_bluetooth+0x54>)
     310:	0040      	lsls	r0, r0, #1
     312:	4798      	blx	r3
	    //wdt_reset();	
	    sysval.bluetooth_status=bt_read_bluetooth_status();
     314:	47b8      	blx	r7
     316:	7030      	strb	r0, [r6, #0]
	}
	uart_print(0,"Bluetooth status=%d\n\r",sysval.bluetooth_status);
     318:	34c3      	adds	r4, #195	; 0xc3
     31a:	7822      	ldrb	r2, [r4, #0]
     31c:	4908      	ldr	r1, [pc, #32]	; (340 <bt_start_bluetooth+0x58>)
     31e:	2000      	movs	r0, #0
     320:	47a8      	blx	r5
}
     322:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     324:	00009e96 	.word	0x00009e96
     328:	00007b99 	.word	0x00007b99
     32c:	00000105 	.word	0x00000105
     330:	20000a58 	.word	0x20000a58
     334:	00000231 	.word	0x00000231
     338:	00000179 	.word	0x00000179
     33c:	00007c05 	.word	0x00007c05
     340:	00009eac 	.word	0x00009eac

00000344 <bt_bluetooth_connect>:

int bt_bluetooth_connect(void)
{
     344:	b510      	push	{r4, lr}
	char sim_rxbuf[32];
	char *cmd="AT+BTACPT=1\r"; // accept connection
	uart_print(0,"sim_bluetooth_connect\n\r");
     346:	490c      	ldr	r1, [pc, #48]	; (378 <bt_bluetooth_connect+0x34>)
{
     348:	b088      	sub	sp, #32
	uart_print(0,"sim_bluetooth_connect\n\r");
     34a:	2000      	movs	r0, #0
     34c:	4b0b      	ldr	r3, [pc, #44]	; (37c <bt_bluetooth_connect+0x38>)
     34e:	4798      	blx	r3
	sim_tx(cmd,strlen(cmd));
     350:	4c0b      	ldr	r4, [pc, #44]	; (380 <bt_bluetooth_connect+0x3c>)
     352:	210c      	movs	r1, #12
     354:	0020      	movs	r0, r4
     356:	4b0b      	ldr	r3, [pc, #44]	; (384 <bt_bluetooth_connect+0x40>)
     358:	4798      	blx	r3
	sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
     35a:	0021      	movs	r1, r4
     35c:	2320      	movs	r3, #32
     35e:	4c0a      	ldr	r4, [pc, #40]	; (388 <bt_bluetooth_connect+0x44>)
     360:	220a      	movs	r2, #10
     362:	4668      	mov	r0, sp
     364:	47a0      	blx	r4
	return (uint8_t)sim_read(sim_rxbuf,"OK\r\n",40,sizeof(sim_rxbuf));
     366:	2320      	movs	r3, #32
     368:	2228      	movs	r2, #40	; 0x28
     36a:	4908      	ldr	r1, [pc, #32]	; (38c <bt_bluetooth_connect+0x48>)
     36c:	4668      	mov	r0, sp
     36e:	47a0      	blx	r4
     370:	b2c0      	uxtb	r0, r0
}
     372:	b008      	add	sp, #32
     374:	bd10      	pop	{r4, pc}
     376:	46c0      	nop			; (mov r8, r8)
     378:	00009ec2 	.word	0x00009ec2
     37c:	00007b99 	.word	0x00007b99
     380:	00009eda 	.word	0x00009eda
     384:	0000525d 	.word	0x0000525d
     388:	00005021 	.word	0x00005021
     38c:	0000afa0 	.word	0x0000afa0

00000390 <bt_bluetooth_read>:

char * bt_bluetooth_read(char *sim_rxbuf, uint16_t maxlen)
{
     390:	b5f0      	push	{r4, r5, r6, r7, lr}
     392:	b08b      	sub	sp, #44	; 0x2c
	char *sim_bufptr=NULL;
	char *ptr;
	char c;
	uint8_t match;
	int found,bt_ch,bt_len;
	const char *expect[] = { "+BTSPPDATA:", 
     394:	ad07      	add	r5, sp, #28
     396:	002a      	movs	r2, r5
{
     398:	0004      	movs	r4, r0
	const char *expect[] = { "+BTSPPDATA:", 
     39a:	4b32      	ldr	r3, [pc, #200]	; (464 <bt_bluetooth_read+0xd4>)
{
     39c:	9103      	str	r1, [sp, #12]
	const char *expect[] = { "+BTSPPDATA:", 
     39e:	cb43      	ldmia	r3!, {r0, r1, r6}
     3a0:	c243      	stmia	r2!, {r0, r1, r6}
                             "+BTDISCONN:",
                             "+BTCONNECT" };
    //wdt_reset();
    sim_bufptr=sim_read_multi(sim_rxbuf, expect, 3, 10,maxlen);
     3a2:	9b03      	ldr	r3, [sp, #12]
     3a4:	4e30      	ldr	r6, [pc, #192]	; (468 <bt_bluetooth_read+0xd8>)
     3a6:	9300      	str	r3, [sp, #0]
     3a8:	2203      	movs	r2, #3
     3aa:	230a      	movs	r3, #10
     3ac:	0029      	movs	r1, r5
     3ae:	0020      	movs	r0, r4
     3b0:	47b0      	blx	r6
     3b2:	1e06      	subs	r6, r0, #0
	if(sim_bufptr==NULL) return NULL;
     3b4:	d102      	bne.n	3bc <bt_bluetooth_read+0x2c>
     3b6:	2000      	movs	r0, #0
			break;
		}
		ptr++;
	}
	return sim_bufptr;
}
     3b8:	b00b      	add	sp, #44	; 0x2c
     3ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uart_print(0,"sim_bluetooth_read:%s\n\r",sim_bufptr);
     3bc:	0002      	movs	r2, r0
     3be:	492b      	ldr	r1, [pc, #172]	; (46c <bt_bluetooth_read+0xdc>)
     3c0:	2000      	movs	r0, #0
     3c2:	4b2b      	ldr	r3, [pc, #172]	; (470 <bt_bluetooth_read+0xe0>)
     3c4:	4798      	blx	r3
	if(strncasecmp(expect[2],sim_rxbuf,strlen(expect[2])) == 0) {
     3c6:	68af      	ldr	r7, [r5, #8]
     3c8:	4b2a      	ldr	r3, [pc, #168]	; (474 <bt_bluetooth_read+0xe4>)
     3ca:	0038      	movs	r0, r7
     3cc:	4798      	blx	r3
     3ce:	0021      	movs	r1, r4
     3d0:	0002      	movs	r2, r0
     3d2:	0038      	movs	r0, r7
     3d4:	4f28      	ldr	r7, [pc, #160]	; (478 <bt_bluetooth_read+0xe8>)
     3d6:	47b8      	blx	r7
     3d8:	2800      	cmp	r0, #0
     3da:	d10f      	bne.n	3fc <bt_bluetooth_read+0x6c>
		sim_rxflush();
     3dc:	4b27      	ldr	r3, [pc, #156]	; (47c <bt_bluetooth_read+0xec>)
     3de:	4798      	blx	r3
		if(sysval.bluetooth_connected==0) {
     3e0:	4d27      	ldr	r5, [pc, #156]	; (480 <bt_bluetooth_read+0xf0>)
     3e2:	35c2      	adds	r5, #194	; 0xc2
     3e4:	782c      	ldrb	r4, [r5, #0]
     3e6:	2c00      	cmp	r4, #0
     3e8:	d1e5      	bne.n	3b6 <bt_bluetooth_read+0x26>
		    bt_bluetooth_connect();
     3ea:	4b26      	ldr	r3, [pc, #152]	; (484 <bt_bluetooth_read+0xf4>)
     3ec:	4798      	blx	r3
		    sysval.bluetooth_connected = 1;
     3ee:	2301      	movs	r3, #1
		    uart_print(0,"sim_bluetooth_read: connect!\n\r");
     3f0:	0020      	movs	r0, r4
     3f2:	4925      	ldr	r1, [pc, #148]	; (488 <bt_bluetooth_read+0xf8>)
		    sysval.bluetooth_connected = 1;
     3f4:	702b      	strb	r3, [r5, #0]
		uart_print(0,"sim_bluetooth_read: disconnect!\n\r");
     3f6:	4b1e      	ldr	r3, [pc, #120]	; (470 <bt_bluetooth_read+0xe0>)
     3f8:	4798      	blx	r3
     3fa:	e7dc      	b.n	3b6 <bt_bluetooth_read+0x26>
	} else if(strncasecmp(expect[1],sim_bufptr,strlen(expect[1])) == 0) {
     3fc:	686d      	ldr	r5, [r5, #4]
     3fe:	4b1d      	ldr	r3, [pc, #116]	; (474 <bt_bluetooth_read+0xe4>)
     400:	0028      	movs	r0, r5
     402:	4798      	blx	r3
     404:	0031      	movs	r1, r6
     406:	0002      	movs	r2, r0
     408:	0028      	movs	r0, r5
     40a:	47b8      	blx	r7
     40c:	1e05      	subs	r5, r0, #0
     40e:	d107      	bne.n	420 <bt_bluetooth_read+0x90>
		sim_rxflush();
     410:	4b1a      	ldr	r3, [pc, #104]	; (47c <bt_bluetooth_read+0xec>)
     412:	4798      	blx	r3
		sysval.bluetooth_connected = 0;
     414:	4b1a      	ldr	r3, [pc, #104]	; (480 <bt_bluetooth_read+0xf0>)
		uart_print(0,"sim_bluetooth_read: disconnect!\n\r");
     416:	491d      	ldr	r1, [pc, #116]	; (48c <bt_bluetooth_read+0xfc>)
		sysval.bluetooth_connected = 0;
     418:	33c2      	adds	r3, #194	; 0xc2
     41a:	701d      	strb	r5, [r3, #0]
		uart_print(0,"sim_bluetooth_read: disconnect!\n\r");
     41c:	0028      	movs	r0, r5
     41e:	e7ea      	b.n	3f6 <bt_bluetooth_read+0x66>
	if(sim_read(sim_rxbuf,"\r\n",7,maxlen) == 0) return NULL;
     420:	9b03      	ldr	r3, [sp, #12]
     422:	2207      	movs	r2, #7
     424:	491a      	ldr	r1, [pc, #104]	; (490 <bt_bluetooth_read+0x100>)
     426:	0020      	movs	r0, r4
     428:	4d1a      	ldr	r5, [pc, #104]	; (494 <bt_bluetooth_read+0x104>)
     42a:	47a8      	blx	r5
     42c:	2800      	cmp	r0, #0
     42e:	d0c2      	beq.n	3b6 <bt_bluetooth_read+0x26>
	found=sscanf(ptr,"%d,%d",&bt_ch,&bt_len);
     430:	ab06      	add	r3, sp, #24
     432:	aa05      	add	r2, sp, #20
     434:	4918      	ldr	r1, [pc, #96]	; (498 <bt_bluetooth_read+0x108>)
     436:	0020      	movs	r0, r4
     438:	4d18      	ldr	r5, [pc, #96]	; (49c <bt_bluetooth_read+0x10c>)
     43a:	47a8      	blx	r5
	if(found!=2) {
     43c:	2802      	cmp	r0, #2
     43e:	d1ba      	bne.n	3b6 <bt_bluetooth_read+0x26>
     440:	2300      	movs	r3, #0
     442:	0020      	movs	r0, r4
	while((c=*sim_bufptr) != '\r') {
     444:	7802      	ldrb	r2, [r0, #0]
     446:	2a0d      	cmp	r2, #13
     448:	d0b6      	beq.n	3b8 <bt_bluetooth_read+0x28>
		if(c==',') match++;
     44a:	2a2c      	cmp	r2, #44	; 0x2c
     44c:	d101      	bne.n	452 <bt_bluetooth_read+0xc2>
     44e:	3301      	adds	r3, #1
     450:	b2db      	uxtb	r3, r3
		sim_bufptr++;
     452:	3001      	adds	r0, #1
		if(match==2) break;
     454:	2b02      	cmp	r3, #2
     456:	d1f5      	bne.n	444 <bt_bluetooth_read+0xb4>
		sim_bufptr++;
     458:	0003      	movs	r3, r0
	while((c=*ptr) != '\r') {
     45a:	781a      	ldrb	r2, [r3, #0]
     45c:	2a0d      	cmp	r2, #13
     45e:	d0ab      	beq.n	3b8 <bt_bluetooth_read+0x28>
		ptr++;
     460:	3301      	adds	r3, #1
     462:	e7fa      	b.n	45a <bt_bluetooth_read+0xca>
     464:	00009d74 	.word	0x00009d74
     468:	00005101 	.word	0x00005101
     46c:	00009ee7 	.word	0x00009ee7
     470:	00007b99 	.word	0x00007b99
     474:	00008a3f 	.word	0x00008a3f
     478:	00008a4d 	.word	0x00008a4d
     47c:	00004fc1 	.word	0x00004fc1
     480:	20000a58 	.word	0x20000a58
     484:	00000345 	.word	0x00000345
     488:	00009eff 	.word	0x00009eff
     48c:	00009f1e 	.word	0x00009f1e
     490:	00009f82 	.word	0x00009f82
     494:	00005021 	.word	0x00005021
     498:	0000b008 	.word	0x0000b008
     49c:	000089ad 	.word	0x000089ad

000004a0 <bt_bluetooth_write>:

uint8_t bt_bluetooth_write(const char *msg, uint16_t size)
{
     4a0:	b5f0      	push	{r4, r5, r6, r7, lr}
	char sim_rxbuf[128], txbuf[32];
	uint8_t txlen;
	uint16_t oldidx=0,idx=0;
	
	// send line by line:
	while(idx < size) {
     4a2:	2400      	movs	r4, #0
	uint16_t oldidx=0,idx=0;
     4a4:	0025      	movs	r5, r4
{
     4a6:	b0ad      	sub	sp, #180	; 0xb4
     4a8:	9002      	str	r0, [sp, #8]
     4aa:	9103      	str	r1, [sp, #12]
	while(idx < size) {
     4ac:	9b03      	ldr	r3, [sp, #12]
     4ae:	429c      	cmp	r4, r3
     4b0:	d102      	bne.n	4b8 <bt_bluetooth_write+0x18>
			sim_read(sim_rxbuf,"SEND OK\r\n",50,sizeof(sim_rxbuf));
			oldidx=idx;
		}
	}
	return 1;
}
     4b2:	2001      	movs	r0, #1
     4b4:	b02d      	add	sp, #180	; 0xb4
     4b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     4b8:	1c63      	adds	r3, r4, #1
     4ba:	b29b      	uxth	r3, r3
     4bc:	9301      	str	r3, [sp, #4]
		if(c=='\n') {
     4be:	9b02      	ldr	r3, [sp, #8]
     4c0:	5d1f      	ldrb	r7, [r3, r4]
     4c2:	2f0a      	cmp	r7, #10
     4c4:	d125      	bne.n	512 <bt_bluetooth_write+0x72>
			txlen=sprintf(txbuf,"AT+BTSPPSEND=%d\r",idx-oldidx);
     4c6:	9b01      	ldr	r3, [sp, #4]
     4c8:	4913      	ldr	r1, [pc, #76]	; (518 <bt_bluetooth_write+0x78>)
     4ca:	1b5b      	subs	r3, r3, r5
     4cc:	001a      	movs	r2, r3
     4ce:	9300      	str	r3, [sp, #0]
     4d0:	a804      	add	r0, sp, #16
     4d2:	4b12      	ldr	r3, [pc, #72]	; (51c <bt_bluetooth_write+0x7c>)
     4d4:	4798      	blx	r3
			uart_print(0,"sim_bluetooth_write\n\r");
     4d6:	4b12      	ldr	r3, [pc, #72]	; (520 <bt_bluetooth_write+0x80>)
			txlen=sprintf(txbuf,"AT+BTSPPSEND=%d\r",idx-oldidx);
     4d8:	0006      	movs	r6, r0
			uart_print(0,"sim_bluetooth_write\n\r");
     4da:	4912      	ldr	r1, [pc, #72]	; (524 <bt_bluetooth_write+0x84>)
     4dc:	2000      	movs	r0, #0
     4de:	4798      	blx	r3
			sim_tx(txbuf,txlen);
     4e0:	21ff      	movs	r1, #255	; 0xff
     4e2:	a804      	add	r0, sp, #16
     4e4:	4031      	ands	r1, r6
     4e6:	4e10      	ldr	r6, [pc, #64]	; (528 <bt_bluetooth_write+0x88>)
     4e8:	47b0      	blx	r6
			sim_read(sim_rxbuf,"> ",10,sizeof(sim_rxbuf)); // read prompt
     4ea:	003a      	movs	r2, r7
     4ec:	2380      	movs	r3, #128	; 0x80
     4ee:	490f      	ldr	r1, [pc, #60]	; (52c <bt_bluetooth_write+0x8c>)
     4f0:	4f0f      	ldr	r7, [pc, #60]	; (530 <bt_bluetooth_write+0x90>)
     4f2:	a80c      	add	r0, sp, #48	; 0x30
     4f4:	47b8      	blx	r7
			sim_tx(&msg[oldidx],idx-oldidx);
     4f6:	9b02      	ldr	r3, [sp, #8]
     4f8:	9900      	ldr	r1, [sp, #0]
     4fa:	1958      	adds	r0, r3, r5
     4fc:	47b0      	blx	r6
			delay_ms(500);
     4fe:	20fa      	movs	r0, #250	; 0xfa
     500:	4b0c      	ldr	r3, [pc, #48]	; (534 <bt_bluetooth_write+0x94>)
     502:	0040      	lsls	r0, r0, #1
     504:	4798      	blx	r3
			sim_read(sim_rxbuf,"SEND OK\r\n",50,sizeof(sim_rxbuf));
     506:	2380      	movs	r3, #128	; 0x80
     508:	2232      	movs	r2, #50	; 0x32
     50a:	490b      	ldr	r1, [pc, #44]	; (538 <bt_bluetooth_write+0x98>)
     50c:	a80c      	add	r0, sp, #48	; 0x30
     50e:	47b8      	blx	r7
			oldidx=idx;
     510:	9d01      	ldr	r5, [sp, #4]
     512:	3401      	adds	r4, #1
     514:	e7ca      	b.n	4ac <bt_bluetooth_write+0xc>
     516:	46c0      	nop			; (mov r8, r8)
     518:	00009f40 	.word	0x00009f40
     51c:	00008969 	.word	0x00008969
     520:	00007b99 	.word	0x00007b99
     524:	00009f51 	.word	0x00009f51
     528:	0000525d 	.word	0x0000525d
     52c:	0000a53c 	.word	0x0000a53c
     530:	00005021 	.word	0x00005021
     534:	00007c05 	.word	0x00007c05
     538:	00009f67 	.word	0x00009f67

0000053c <bt_stop_bluetooth>:

void bt_stop_bluetooth(void)
{
     53c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uart_print(0,"sim_stop_bluetooth\n\r");
     53e:	4912      	ldr	r1, [pc, #72]	; (588 <bt_stop_bluetooth+0x4c>)
     540:	2000      	movs	r0, #0
     542:	4d12      	ldr	r5, [pc, #72]	; (58c <bt_stop_bluetooth+0x50>)
     544:	47a8      	blx	r5
	if(sysval.bluetooth_connected) {
     546:	4c12      	ldr	r4, [pc, #72]	; (590 <bt_stop_bluetooth+0x54>)
     548:	0023      	movs	r3, r4
     54a:	33c2      	adds	r3, #194	; 0xc2
     54c:	781b      	ldrb	r3, [r3, #0]
     54e:	2b00      	cmp	r3, #0
     550:	d003      	beq.n	55a <bt_stop_bluetooth+0x1e>
		bt_bluetooth_write("bye, (busy 15sec)\r\n",19);
     552:	2113      	movs	r1, #19
     554:	480f      	ldr	r0, [pc, #60]	; (594 <bt_stop_bluetooth+0x58>)
     556:	4b10      	ldr	r3, [pc, #64]	; (598 <bt_stop_bluetooth+0x5c>)
     558:	4798      	blx	r3
	}
	sysval.bluetooth_connected=0;
     55a:	0023      	movs	r3, r4
     55c:	2600      	movs	r6, #0
     55e:	33c2      	adds	r3, #194	; 0xc2
	sysval.bluetooth_status=bt_read_bluetooth_status();
     560:	4f0e      	ldr	r7, [pc, #56]	; (59c <bt_stop_bluetooth+0x60>)
	sysval.bluetooth_connected=0;
     562:	701e      	strb	r6, [r3, #0]
	sysval.bluetooth_status=bt_read_bluetooth_status();
     564:	47b8      	blx	r7
     566:	34c3      	adds	r4, #195	; 0xc3
     568:	b2c0      	uxtb	r0, r0
     56a:	7020      	strb	r0, [r4, #0]
	if(sysval.bluetooth_status==0) {
     56c:	42b0      	cmp	r0, r6
     56e:	d102      	bne.n	576 <bt_stop_bluetooth+0x3a>
		uart_print(0,"Bluetooth already off\n\r");
     570:	490b      	ldr	r1, [pc, #44]	; (5a0 <bt_stop_bluetooth+0x64>)
     572:	47a8      	blx	r5
		return;
	}
	bt_bluetooth_power_off();
	sysval.bluetooth_status=bt_read_bluetooth_status();
	uart_print(0,"Bluetooth status=%d\n\r",sysval.bluetooth_status);
}
     574:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	bt_bluetooth_power_off();
     576:	4b0b      	ldr	r3, [pc, #44]	; (5a4 <bt_stop_bluetooth+0x68>)
     578:	4798      	blx	r3
	sysval.bluetooth_status=bt_read_bluetooth_status();
     57a:	47b8      	blx	r7
	uart_print(0,"Bluetooth status=%d\n\r",sysval.bluetooth_status);
     57c:	490a      	ldr	r1, [pc, #40]	; (5a8 <bt_stop_bluetooth+0x6c>)
	sysval.bluetooth_status=bt_read_bluetooth_status();
     57e:	7020      	strb	r0, [r4, #0]
	uart_print(0,"Bluetooth status=%d\n\r",sysval.bluetooth_status);
     580:	b2c2      	uxtb	r2, r0
     582:	0030      	movs	r0, r6
     584:	47a8      	blx	r5
     586:	e7f5      	b.n	574 <bt_stop_bluetooth+0x38>
     588:	00009dd3 	.word	0x00009dd3
     58c:	00007b99 	.word	0x00007b99
     590:	20000a58 	.word	0x20000a58
     594:	00009f71 	.word	0x00009f71
     598:	000004a1 	.word	0x000004a1
     59c:	00000105 	.word	0x00000105
     5a0:	00009f85 	.word	0x00009f85
     5a4:	000001d9 	.word	0x000001d9
     5a8:	00009eac 	.word	0x00009eac

000005ac <cmd_sms>:
extern cmd_task_queue_t cmd_task_queue;

void cmd_sms(cmd_task_t *task)
{
    char response_msg[CMD_MAX_COMMAND_LEN];
    uint8_t next_state=task->state;
     5ac:	0003      	movs	r3, r0
{
     5ae:	b5f0      	push	{r4, r5, r6, r7, lr}
     5b0:	0004      	movs	r4, r0

    response_msg[0]=0;
     5b2:	2000      	movs	r0, #0
    uint8_t next_state=task->state;
     5b4:	332a      	adds	r3, #42	; 0x2a
{
     5b6:	b08d      	sub	sp, #52	; 0x34
    uint8_t next_state=task->state;
     5b8:	9301      	str	r3, [sp, #4]
     5ba:	781a      	ldrb	r2, [r3, #0]
    response_msg[0]=0;
     5bc:	ab02      	add	r3, sp, #8
     5be:	7018      	strb	r0, [r3, #0]
     5c0:	4b74      	ldr	r3, [pc, #464]	; (794 <cmd_sms+0x1e8>)

    switch(task->state) {
     5c2:	2a01      	cmp	r2, #1
     5c4:	d000      	beq.n	5c8 <cmd_sms+0x1c>
     5c6:	e0e2      	b.n	78e <cmd_sms+0x1e2>
        case CMD_TASK_STATE_START:
          uart_print(0,"CMD_TASK_STATE_START\n\r");
     5c8:	4973      	ldr	r1, [pc, #460]	; (798 <cmd_sms+0x1ec>)

          if(strncasecmp(task->cmd,"SOC?",4)==0) {
     5ca:	1c65      	adds	r5, r4, #1
          uart_print(0,"CMD_TASK_STATE_START\n\r");
     5cc:	4798      	blx	r3
          if(strncasecmp(task->cmd,"SOC?",4)==0) {
     5ce:	2204      	movs	r2, #4
     5d0:	4972      	ldr	r1, [pc, #456]	; (79c <cmd_sms+0x1f0>)
     5d2:	0028      	movs	r0, r5
     5d4:	4e72      	ldr	r6, [pc, #456]	; (7a0 <cmd_sms+0x1f4>)
     5d6:	47b0      	blx	r6
     5d8:	2800      	cmp	r0, #0
     5da:	d105      	bne.n	5e8 <cmd_sms+0x3c>
              task->cmd[0]=0; // no message, just the full SoC string
              task_add(TASK_SMS,task->cmd,task->arg1);
     5dc:	0029      	movs	r1, r5
              task->cmd[0]=0; // no message, just the full SoC string
     5de:	7060      	strb	r0, [r4, #1]
              task_add(TASK_SMS,task->cmd,task->arg1);
     5e0:	3429      	adds	r4, #41	; 0x29
     5e2:	7822      	ldrb	r2, [r4, #0]
          } else if(strlen(task->cmd) == 16 && task->cmd[0]=='*') { // *12345678901234# for real
              code_real(task->cmd, response_msg, CMD_MAX_COMMAND_LEN);
              task_add(TASK_SMS,response_msg,task->arg1);
              
          } else if(strncasecmp(task->cmd,"*1#",3)==0) {                  
              task_add(TASK_SMS," ",task->arg1); // id is already in the msg
     5e4:	3007      	adds	r0, #7
     5e6:	e010      	b.n	60a <cmd_sms+0x5e>
          } else if(strlen(task->cmd) == 11 && task->cmd[0]=='*') { // *123456789# for demo
     5e8:	0028      	movs	r0, r5
     5ea:	4b6e      	ldr	r3, [pc, #440]	; (7a4 <cmd_sms+0x1f8>)
     5ec:	4798      	blx	r3
     5ee:	280b      	cmp	r0, #11
     5f0:	d112      	bne.n	618 <cmd_sms+0x6c>
     5f2:	7863      	ldrb	r3, [r4, #1]
     5f4:	2b2a      	cmp	r3, #42	; 0x2a
     5f6:	d11a      	bne.n	62e <cmd_sms+0x82>
              code_demo(task->cmd, response_msg, CMD_MAX_COMMAND_LEN);
     5f8:	2228      	movs	r2, #40	; 0x28
     5fa:	a902      	add	r1, sp, #8
     5fc:	0028      	movs	r0, r5
     5fe:	4b6a      	ldr	r3, [pc, #424]	; (7a8 <cmd_sms+0x1fc>)
     600:	4798      	blx	r3
              task_add(TASK_SMS,response_msg,task->arg1);
     602:	3429      	adds	r4, #41	; 0x29
     604:	7822      	ldrb	r2, [r4, #0]
     606:	a902      	add	r1, sp, #8
     608:	2007      	movs	r0, #7
     60a:	4b68      	ldr	r3, [pc, #416]	; (7ac <cmd_sms+0x200>)
     60c:	4798      	blx	r3
        default:
          next_state = CMD_TASK_STATE_FINISHED;
          uart_print(0,"->CMD_TASK_STATE_FINISHED\n\r");
          break;
    }
    task->state = next_state;
     60e:	2300      	movs	r3, #0
     610:	9a01      	ldr	r2, [sp, #4]
     612:	7013      	strb	r3, [r2, #0]
    return;
}
     614:	b00d      	add	sp, #52	; 0x34
     616:	bdf0      	pop	{r4, r5, r6, r7, pc}
          } else if(strlen(task->cmd) == 16 && task->cmd[0]=='*') { // *12345678901234# for real
     618:	2810      	cmp	r0, #16
     61a:	d108      	bne.n	62e <cmd_sms+0x82>
     61c:	7863      	ldrb	r3, [r4, #1]
     61e:	2b2a      	cmp	r3, #42	; 0x2a
     620:	d105      	bne.n	62e <cmd_sms+0x82>
              code_real(task->cmd, response_msg, CMD_MAX_COMMAND_LEN);
     622:	2228      	movs	r2, #40	; 0x28
     624:	a902      	add	r1, sp, #8
     626:	0028      	movs	r0, r5
     628:	4b61      	ldr	r3, [pc, #388]	; (7b0 <cmd_sms+0x204>)
     62a:	4798      	blx	r3
     62c:	e7e9      	b.n	602 <cmd_sms+0x56>
          } else if(strncasecmp(task->cmd,"*1#",3)==0) {                  
     62e:	2203      	movs	r2, #3
     630:	4960      	ldr	r1, [pc, #384]	; (7b4 <cmd_sms+0x208>)
     632:	0028      	movs	r0, r5
     634:	47b0      	blx	r6
     636:	2800      	cmp	r0, #0
     638:	d103      	bne.n	642 <cmd_sms+0x96>
              task_add(TASK_SMS," ",task->arg1); // id is already in the msg
     63a:	3429      	adds	r4, #41	; 0x29
     63c:	7822      	ldrb	r2, [r4, #0]
     63e:	495e      	ldr	r1, [pc, #376]	; (7b8 <cmd_sms+0x20c>)
     640:	e7d0      	b.n	5e4 <cmd_sms+0x38>
          } else if(strncasecmp(task->cmd,"*2#",3)==0) {
     642:	2203      	movs	r2, #3
     644:	495d      	ldr	r1, [pc, #372]	; (7bc <cmd_sms+0x210>)
     646:	0028      	movs	r0, r5
     648:	47b0      	blx	r6
     64a:	2800      	cmp	r0, #0
     64c:	d104      	bne.n	658 <cmd_sms+0xac>
              read_print_rtc(false, response_msg, CMD_MAX_COMMAND_LEN);
     64e:	2228      	movs	r2, #40	; 0x28
     650:	a902      	add	r1, sp, #8
     652:	4b5b      	ldr	r3, [pc, #364]	; (7c0 <cmd_sms+0x214>)
     654:	4798      	blx	r3
     656:	e7d4      	b.n	602 <cmd_sms+0x56>
          } else if(strncasecmp(task->cmd,"LOAD=",5)==0) { // expect: 0 or 1
     658:	2205      	movs	r2, #5
     65a:	495a      	ldr	r1, [pc, #360]	; (7c4 <cmd_sms+0x218>)
     65c:	0028      	movs	r0, r5
     65e:	47b0      	blx	r6
     660:	1e07      	subs	r7, r0, #0
     662:	d10b      	bne.n	67c <cmd_sms+0xd0>
              task->cmd[6]=0;
     664:	71e0      	strb	r0, [r4, #7]
              state=atoi(bufptr);
     666:	4b58      	ldr	r3, [pc, #352]	; (7c8 <cmd_sms+0x21c>)
              char *bufptr=&task->cmd[5];
     668:	1da0      	adds	r0, r4, #6
              state=atoi(bufptr);
     66a:	4798      	blx	r3
              task_set_load(state);
     66c:	4b57      	ldr	r3, [pc, #348]	; (7cc <cmd_sms+0x220>)
     66e:	b2c0      	uxtb	r0, r0
     670:	4798      	blx	r3
              task->cmd[0]=0; // no message, just the full SoC string
     672:	7067      	strb	r7, [r4, #1]
              task_add(TASK_SMS,task->cmd,task->arg1);
     674:	3429      	adds	r4, #41	; 0x29
     676:	7822      	ldrb	r2, [r4, #0]
     678:	0029      	movs	r1, r5
     67a:	e7c5      	b.n	608 <cmd_sms+0x5c>
          } else if(strncasecmp(task->cmd,"apn=",4)==0) { // expect: APN
     67c:	2204      	movs	r2, #4
     67e:	4954      	ldr	r1, [pc, #336]	; (7d0 <cmd_sms+0x224>)
     680:	0028      	movs	r0, r5
     682:	47b0      	blx	r6
     684:	2800      	cmp	r0, #0
     686:	d116      	bne.n	6b6 <cmd_sms+0x10a>
              char *ptr=&task->cmd[4];
     688:	1d66      	adds	r6, r4, #5
     68a:	0035      	movs	r5, r6
              while((c=*ptr) != 0) {
     68c:	782f      	ldrb	r7, [r5, #0]
     68e:	2f00      	cmp	r7, #0
     690:	d008      	beq.n	6a4 <cmd_sms+0xf8>
                  if(isspace(c)) { *ptr=0; break; }
     692:	4b50      	ldr	r3, [pc, #320]	; (7d4 <cmd_sms+0x228>)
     694:	4798      	blx	r3
     696:	2208      	movs	r2, #8
     698:	19c7      	adds	r7, r0, r7
     69a:	787b      	ldrb	r3, [r7, #1]
     69c:	4213      	tst	r3, r2
     69e:	d008      	beq.n	6b2 <cmd_sms+0x106>
     6a0:	2300      	movs	r3, #0
     6a2:	702b      	strb	r3, [r5, #0]
              sim_eeprom_set_APN(&task->cmd[4]);
     6a4:	0030      	movs	r0, r6
     6a6:	4b4c      	ldr	r3, [pc, #304]	; (7d8 <cmd_sms+0x22c>)
              sim_eeprom_set_HOST(&task->cmd[5]);
     6a8:	4798      	blx	r3
              task_add(TASK_SMS,"OK",task->arg1);
     6aa:	3429      	adds	r4, #41	; 0x29
     6ac:	7822      	ldrb	r2, [r4, #0]
     6ae:	494b      	ldr	r1, [pc, #300]	; (7dc <cmd_sms+0x230>)
     6b0:	e7aa      	b.n	608 <cmd_sms+0x5c>
                  ptr++;
     6b2:	3501      	adds	r5, #1
     6b4:	e7ea      	b.n	68c <cmd_sms+0xe0>
          } else if(strncasecmp(task->cmd,"user=",5)==0) { // expect: user
     6b6:	2205      	movs	r2, #5
     6b8:	4949      	ldr	r1, [pc, #292]	; (7e0 <cmd_sms+0x234>)
     6ba:	0028      	movs	r0, r5
     6bc:	47b0      	blx	r6
     6be:	2800      	cmp	r0, #0
     6c0:	d112      	bne.n	6e8 <cmd_sms+0x13c>
              char *ptr=&task->cmd[5];
     6c2:	1da6      	adds	r6, r4, #6
     6c4:	0035      	movs	r5, r6
              while((c=*ptr) != 0) {
     6c6:	782f      	ldrb	r7, [r5, #0]
     6c8:	2f00      	cmp	r7, #0
     6ca:	d008      	beq.n	6de <cmd_sms+0x132>
                  if(isspace(c)) { *ptr=0; break; }
     6cc:	4b41      	ldr	r3, [pc, #260]	; (7d4 <cmd_sms+0x228>)
     6ce:	4798      	blx	r3
     6d0:	2208      	movs	r2, #8
     6d2:	19c7      	adds	r7, r0, r7
     6d4:	787b      	ldrb	r3, [r7, #1]
     6d6:	4213      	tst	r3, r2
     6d8:	d004      	beq.n	6e4 <cmd_sms+0x138>
     6da:	2300      	movs	r3, #0
     6dc:	702b      	strb	r3, [r5, #0]
              sim_eeprom_set_USER(&task->cmd[5]);
     6de:	0030      	movs	r0, r6
     6e0:	4b40      	ldr	r3, [pc, #256]	; (7e4 <cmd_sms+0x238>)
     6e2:	e7e1      	b.n	6a8 <cmd_sms+0xfc>
                  ptr++;
     6e4:	3501      	adds	r5, #1
     6e6:	e7ee      	b.n	6c6 <cmd_sms+0x11a>
          } else if(strncasecmp(task->cmd,"pwd=",4)==0) { // expect: pwd
     6e8:	2204      	movs	r2, #4
     6ea:	493f      	ldr	r1, [pc, #252]	; (7e8 <cmd_sms+0x23c>)
     6ec:	0028      	movs	r0, r5
     6ee:	47b0      	blx	r6
     6f0:	2800      	cmp	r0, #0
     6f2:	d112      	bne.n	71a <cmd_sms+0x16e>
              char *ptr=&task->cmd[4];
     6f4:	1d66      	adds	r6, r4, #5
     6f6:	0035      	movs	r5, r6
              while((c=*ptr) != 0) {
     6f8:	782f      	ldrb	r7, [r5, #0]
     6fa:	2f00      	cmp	r7, #0
     6fc:	d008      	beq.n	710 <cmd_sms+0x164>
                  if(isspace(c)) { *ptr=0; break; }
     6fe:	4b35      	ldr	r3, [pc, #212]	; (7d4 <cmd_sms+0x228>)
     700:	4798      	blx	r3
     702:	2208      	movs	r2, #8
     704:	19c7      	adds	r7, r0, r7
     706:	787b      	ldrb	r3, [r7, #1]
     708:	4213      	tst	r3, r2
     70a:	d004      	beq.n	716 <cmd_sms+0x16a>
     70c:	2300      	movs	r3, #0
     70e:	702b      	strb	r3, [r5, #0]
              sim_eeprom_set_PWD(&task->cmd[4]);
     710:	0030      	movs	r0, r6
     712:	4b36      	ldr	r3, [pc, #216]	; (7ec <cmd_sms+0x240>)
     714:	e7c8      	b.n	6a8 <cmd_sms+0xfc>
                  ptr++;
     716:	3501      	adds	r5, #1
     718:	e7ee      	b.n	6f8 <cmd_sms+0x14c>
          } else if(strncasecmp(task->cmd,"host=",5)==0) { // expect: hostname
     71a:	2205      	movs	r2, #5
     71c:	4934      	ldr	r1, [pc, #208]	; (7f0 <cmd_sms+0x244>)
     71e:	0028      	movs	r0, r5
     720:	47b0      	blx	r6
     722:	2800      	cmp	r0, #0
     724:	d112      	bne.n	74c <cmd_sms+0x1a0>
              char *ptr=&task->cmd[5];
     726:	1da6      	adds	r6, r4, #6
     728:	0035      	movs	r5, r6
              while((c=*ptr) != 0) {
     72a:	782f      	ldrb	r7, [r5, #0]
     72c:	2f00      	cmp	r7, #0
     72e:	d008      	beq.n	742 <cmd_sms+0x196>
                  if(isspace(c)) { *ptr=0; break; }
     730:	4b28      	ldr	r3, [pc, #160]	; (7d4 <cmd_sms+0x228>)
     732:	4798      	blx	r3
     734:	2208      	movs	r2, #8
     736:	19c7      	adds	r7, r0, r7
     738:	787b      	ldrb	r3, [r7, #1]
     73a:	4213      	tst	r3, r2
     73c:	d004      	beq.n	748 <cmd_sms+0x19c>
     73e:	2300      	movs	r3, #0
     740:	702b      	strb	r3, [r5, #0]
              sim_eeprom_set_HOST(&task->cmd[5]);
     742:	0030      	movs	r0, r6
     744:	4b2b      	ldr	r3, [pc, #172]	; (7f4 <cmd_sms+0x248>)
     746:	e7af      	b.n	6a8 <cmd_sms+0xfc>
                  ptr++;
     748:	3501      	adds	r5, #1
     74a:	e7ee      	b.n	72a <cmd_sms+0x17e>
          } else if(strncasecmp(task->cmd,"T_2G=",5)==0) { // expect: minutes
     74c:	2205      	movs	r2, #5
     74e:	492a      	ldr	r1, [pc, #168]	; (7f8 <cmd_sms+0x24c>)
     750:	0028      	movs	r0, r5
     752:	47b0      	blx	r6
     754:	2800      	cmp	r0, #0
     756:	d000      	beq.n	75a <cmd_sms+0x1ae>
     758:	e759      	b.n	60e <cmd_sms+0x62>
              for(i=5;i<strlen(task->cmd);i++) {
     75a:	2605      	movs	r6, #5
              char *bufptr=&task->cmd[5];
     75c:	1da7      	adds	r7, r4, #6
              for(i=5;i<strlen(task->cmd);i++) {
     75e:	0028      	movs	r0, r5
     760:	4b10      	ldr	r3, [pc, #64]	; (7a4 <cmd_sms+0x1f8>)
     762:	4798      	blx	r3
     764:	42b0      	cmp	r0, r6
     766:	d909      	bls.n	77c <cmd_sms+0x1d0>
                    if(!isdigit(task->cmd[i])) { task->cmd[i]=0; break; }
     768:	4b1a      	ldr	r3, [pc, #104]	; (7d4 <cmd_sms+0x228>)
     76a:	4798      	blx	r3
     76c:	2104      	movs	r1, #4
     76e:	19a2      	adds	r2, r4, r6
     770:	7853      	ldrb	r3, [r2, #1]
     772:	18c0      	adds	r0, r0, r3
     774:	7843      	ldrb	r3, [r0, #1]
     776:	400b      	ands	r3, r1
     778:	d107      	bne.n	78a <cmd_sms+0x1de>
     77a:	7053      	strb	r3, [r2, #1]
              tasks_eeprom_set_interval2G((uint16_t)atol(bufptr));
     77c:	0038      	movs	r0, r7
     77e:	4b1f      	ldr	r3, [pc, #124]	; (7fc <cmd_sms+0x250>)
     780:	4798      	blx	r3
     782:	4b1f      	ldr	r3, [pc, #124]	; (800 <STACK_SIZE>)
     784:	b280      	uxth	r0, r0
     786:	4798      	blx	r3
     788:	e78f      	b.n	6aa <cmd_sms+0xfe>
              for(i=5;i<strlen(task->cmd);i++) {
     78a:	3601      	adds	r6, #1
     78c:	e7e7      	b.n	75e <cmd_sms+0x1b2>
          uart_print(0,"->CMD_TASK_STATE_FINISHED\n\r");
     78e:	491d      	ldr	r1, [pc, #116]	; (804 <STACK_SIZE+0x4>)
     790:	4798      	blx	r3
          break;
     792:	e73c      	b.n	60e <cmd_sms+0x62>
     794:	00007b99 	.word	0x00007b99
     798:	00009fc0 	.word	0x00009fc0
     79c:	00009fd7 	.word	0x00009fd7
     7a0:	00008a4d 	.word	0x00008a4d
     7a4:	00008a3f 	.word	0x00008a3f
     7a8:	00000c49 	.word	0x00000c49
     7ac:	00006c7d 	.word	0x00006c7d
     7b0:	00000d8d 	.word	0x00000d8d
     7b4:	00009fdc 	.word	0x00009fdc
     7b8:	0000ae46 	.word	0x0000ae46
     7bc:	00009fe0 	.word	0x00009fe0
     7c0:	00000961 	.word	0x00000961
     7c4:	00009fe4 	.word	0x00009fe4
     7c8:	0000889d 	.word	0x0000889d
     7cc:	00006935 	.word	0x00006935
     7d0:	00009fea 	.word	0x00009fea
     7d4:	00008905 	.word	0x00008905
     7d8:	00006655 	.word	0x00006655
     7dc:	0000ae2e 	.word	0x0000ae2e
     7e0:	00009fef 	.word	0x00009fef
     7e4:	00006679 	.word	0x00006679
     7e8:	00009ff5 	.word	0x00009ff5
     7ec:	0000669d 	.word	0x0000669d
     7f0:	00009ffa 	.word	0x00009ffa
     7f4:	000066c1 	.word	0x000066c1
     7f8:	0000a000 	.word	0x0000a000
     7fc:	000088a9 	.word	0x000088a9
     800:	00007269 	.word	0x00007269
     804:	0000a006 	.word	0x0000a006

00000808 <cmd_task_add>:

int8_t cmd_task_add(const uint8_t task, const char *cmd, const uint8_t arg1)
{
     808:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  int8_t i;
  for(i=0;i<CMD_TASK_QUEUE_LEN;i++) {
    if(cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].id == CMD_TASK_IDLE) {
     80a:	4c1e      	ldr	r4, [pc, #120]	; (884 <cmd_task_add+0x7c>)
{
     80c:	0007      	movs	r7, r0
    if(cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].id == CMD_TASK_IDLE) {
     80e:	0023      	movs	r3, r4
     810:	2500      	movs	r5, #0
{
     812:	9201      	str	r2, [sp, #4]
    if(cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].id == CMD_TASK_IDLE) {
     814:	33b0      	adds	r3, #176	; 0xb0
     816:	781b      	ldrb	r3, [r3, #0]
     818:	2203      	movs	r2, #3
     81a:	1958      	adds	r0, r3, r5
     81c:	4010      	ands	r0, r2
     81e:	3229      	adds	r2, #41	; 0x29
     820:	4350      	muls	r0, r2
     822:	5d06      	ldrb	r6, [r0, r4]
     824:	2e00      	cmp	r6, #0
     826:	d122      	bne.n	86e <cmd_task_add+0x66>
      // queue entry is available
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].id = task;
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].state = CMD_TASK_STATE_START;
     828:	1823      	adds	r3, r4, r0
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].id = task;
     82a:	5507      	strb	r7, [r0, r4]
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].state = CMD_TASK_STATE_START;
     82c:	332a      	adds	r3, #42	; 0x2a
     82e:	3a2b      	subs	r2, #43	; 0x2b
      strncpy(cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd,cmd,
     830:	3001      	adds	r0, #1
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].state = CMD_TASK_STATE_START;
     832:	701a      	strb	r2, [r3, #0]
      strncpy(cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd,cmd,
     834:	1900      	adds	r0, r0, r4
     836:	2228      	movs	r2, #40	; 0x28
     838:	4b13      	ldr	r3, [pc, #76]	; (888 <cmd_task_add+0x80>)
     83a:	4798      	blx	r3
              CMD_MAX_COMMAND_LEN);
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd[CMD_MAX_COMMAND_LEN-1]=0;
     83c:	0023      	movs	r3, r4
     83e:	2203      	movs	r2, #3
     840:	33b0      	adds	r3, #176	; 0xb0
     842:	781b      	ldrb	r3, [r3, #0]
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].arg1 = arg1;
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].retries = 0;
      uart_print(0,"cmd_task_add[%d](%d)\n\r",i,task);
     844:	0030      	movs	r0, r6
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd[CMD_MAX_COMMAND_LEN-1]=0;
     846:	195b      	adds	r3, r3, r5
     848:	4013      	ands	r3, r2
     84a:	3229      	adds	r2, #41	; 0x29
     84c:	4353      	muls	r3, r2
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].arg1 = arg1;
     84e:	466a      	mov	r2, sp
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd[CMD_MAX_COMMAND_LEN-1]=0;
     850:	18e4      	adds	r4, r4, r3
     852:	0023      	movs	r3, r4
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].arg1 = arg1;
     854:	7912      	ldrb	r2, [r2, #4]
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd[CMD_MAX_COMMAND_LEN-1]=0;
     856:	3328      	adds	r3, #40	; 0x28
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].retries = 0;
     858:	342b      	adds	r4, #43	; 0x2b
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].arg1 = arg1;
     85a:	705a      	strb	r2, [r3, #1]
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].cmd[CMD_MAX_COMMAND_LEN-1]=0;
     85c:	701e      	strb	r6, [r3, #0]
      cmd_task_queue.task[((cmd_task_queue.current+i)&CMD_TASK_QUEUE_MASK)].retries = 0;
     85e:	7026      	strb	r6, [r4, #0]
      uart_print(0,"cmd_task_add[%d](%d)\n\r",i,task);
     860:	003b      	movs	r3, r7
     862:	002a      	movs	r2, r5
     864:	4909      	ldr	r1, [pc, #36]	; (88c <cmd_task_add+0x84>)
     866:	4c0a      	ldr	r4, [pc, #40]	; (890 <cmd_task_add+0x88>)
     868:	47a0      	blx	r4
      return 1; // ok
     86a:	2001      	movs	r0, #1
    }
  }
  uart_print(0,"cmd_task_add(%d) FAIL\n\r",task);
  return 0; // fail
}
     86c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
     86e:	3501      	adds	r5, #1
  for(i=0;i<CMD_TASK_QUEUE_LEN;i++) {
     870:	2d04      	cmp	r5, #4
     872:	d1d1      	bne.n	818 <cmd_task_add+0x10>
  uart_print(0,"cmd_task_add(%d) FAIL\n\r",task);
     874:	2000      	movs	r0, #0
     876:	003a      	movs	r2, r7
     878:	4906      	ldr	r1, [pc, #24]	; (894 <cmd_task_add+0x8c>)
     87a:	4b05      	ldr	r3, [pc, #20]	; (890 <cmd_task_add+0x88>)
     87c:	4798      	blx	r3
  return 0; // fail
     87e:	2000      	movs	r0, #0
     880:	e7f4      	b.n	86c <cmd_task_add+0x64>
     882:	46c0      	nop			; (mov r8, r8)
     884:	20000c14 	.word	0x20000c14
     888:	00008ab7 	.word	0x00008ab7
     88c:	0000a022 	.word	0x0000a022
     890:	00007b99 	.word	0x00007b99
     894:	0000a039 	.word	0x0000a039

00000898 <cmd_task_done>:

void cmd_task_done(void)
{
    //uart_print(0,"cmd_task_done %d\n\r",cmd_task_queue.task[cmd_task_queue.current].id);
    cmd_task_queue.task[cmd_task_queue.current].id = CMD_TASK_IDLE;
     898:	4b0b      	ldr	r3, [pc, #44]	; (8c8 <cmd_task_done+0x30>)
{
     89a:	b510      	push	{r4, lr}
    cmd_task_queue.task[cmd_task_queue.current].id = CMD_TASK_IDLE;
     89c:	001c      	movs	r4, r3
     89e:	202c      	movs	r0, #44	; 0x2c
     8a0:	2100      	movs	r1, #0
     8a2:	34b0      	adds	r4, #176	; 0xb0
     8a4:	7822      	ldrb	r2, [r4, #0]
     8a6:	4350      	muls	r0, r2
     8a8:	54c1      	strb	r1, [r0, r3]
    cmd_task_queue.task[cmd_task_queue.current].state = CMD_TASK_STATE_FINISHED;
     8aa:	181b      	adds	r3, r3, r0
     8ac:	0018      	movs	r0, r3
    cmd_task_queue.task[cmd_task_queue.current].cmd[0]=0;
     8ae:	7059      	strb	r1, [r3, #1]
    cmd_task_queue.task[cmd_task_queue.current].arg1 = 0;
    cmd_task_queue.task[cmd_task_queue.current].retries = 0;
     8b0:	332b      	adds	r3, #43	; 0x2b
     8b2:	7019      	strb	r1, [r3, #0]
    cmd_task_queue.current = (cmd_task_queue.current+1)&CMD_TASK_QUEUE_MASK; // point to next
     8b4:	2303      	movs	r3, #3
    cmd_task_queue.task[cmd_task_queue.current].state = CMD_TASK_STATE_FINISHED;
     8b6:	302a      	adds	r0, #42	; 0x2a
    cmd_task_queue.current = (cmd_task_queue.current+1)&CMD_TASK_QUEUE_MASK; // point to next
     8b8:	3201      	adds	r2, #1
    cmd_task_queue.task[cmd_task_queue.current].state = CMD_TASK_STATE_FINISHED;
     8ba:	7001      	strb	r1, [r0, #0]
    cmd_task_queue.current = (cmd_task_queue.current+1)&CMD_TASK_QUEUE_MASK; // point to next
     8bc:	401a      	ands	r2, r3
    cmd_task_queue.task[cmd_task_queue.current].arg1 = 0;
     8be:	3801      	subs	r0, #1
     8c0:	7001      	strb	r1, [r0, #0]
    cmd_task_queue.current = (cmd_task_queue.current+1)&CMD_TASK_QUEUE_MASK; // point to next
     8c2:	7022      	strb	r2, [r4, #0]
}
     8c4:	bd10      	pop	{r4, pc}
     8c6:	46c0      	nop			; (mov r8, r8)
     8c8:	20000c14 	.word	0x20000c14

000008cc <cmd_tasks>:

void cmd_tasks(void)
{
     8cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     8ce:	b672      	cpsid	i
    uint8_t tasklist;    
    __disable_irq();
    tasklist=sysval.cmd_tasklist;
    sysval.cmd_tasklist&=0x7f;
     8d0:	227f      	movs	r2, #127	; 0x7f
    tasklist=sysval.cmd_tasklist;
     8d2:	4916      	ldr	r1, [pc, #88]	; (92c <cmd_tasks+0x60>)
     8d4:	7ccb      	ldrb	r3, [r1, #19]
    sysval.cmd_tasklist&=0x7f;
     8d6:	401a      	ands	r2, r3
     8d8:	74ca      	strb	r2, [r1, #19]
  __ASM volatile ("cpsie i" : : : "memory");
     8da:	b662      	cpsie	i
    __enable_irq();

    if((tasklist&0x80)==0) return; // not yet allowed to run
     8dc:	b25b      	sxtb	r3, r3
     8de:	2b00      	cmp	r3, #0
     8e0:	da23      	bge.n	92a <cmd_tasks+0x5e>
    
    // task allowed to run
    uart_print(0,"cmd_task[%d]:\n\r",cmd_task_queue.task[cmd_task_queue.current].id);
     8e2:	4c13      	ldr	r4, [pc, #76]	; (930 <cmd_tasks+0x64>)
     8e4:	252c      	movs	r5, #44	; 0x2c
     8e6:	0026      	movs	r6, r4
     8e8:	36b0      	adds	r6, #176	; 0xb0
     8ea:	7833      	ldrb	r3, [r6, #0]
     8ec:	4911      	ldr	r1, [pc, #68]	; (934 <cmd_tasks+0x68>)
     8ee:	436b      	muls	r3, r5
     8f0:	2000      	movs	r0, #0
     8f2:	5d1a      	ldrb	r2, [r3, r4]
     8f4:	4f10      	ldr	r7, [pc, #64]	; (938 <cmd_tasks+0x6c>)
     8f6:	47b8      	blx	r7

    switch(cmd_task_queue.task[cmd_task_queue.current].id) {
     8f8:	7833      	ldrb	r3, [r6, #0]
     8fa:	436b      	muls	r3, r5
     8fc:	5ce3      	ldrb	r3, [r4, r3]
     8fe:	2b01      	cmp	r3, #1
     900:	d107      	bne.n	912 <cmd_tasks+0x46>
        case CMD_TASK_SMS:
          uart_print(0,"CMD_TASK_SMS\n\r");
     902:	2000      	movs	r0, #0
     904:	490d      	ldr	r1, [pc, #52]	; (93c <cmd_tasks+0x70>)
     906:	47b8      	blx	r7
          cmd_sms(&cmd_task_queue.task[cmd_task_queue.current]);
     908:	7830      	ldrb	r0, [r6, #0]
     90a:	4b0d      	ldr	r3, [pc, #52]	; (940 <cmd_tasks+0x74>)
     90c:	4368      	muls	r0, r5
     90e:	1900      	adds	r0, r0, r4
     910:	4798      	blx	r3
          break;
    }
    if(cmd_task_queue.task[cmd_task_queue.current].state == CMD_TASK_STATE_FINISHED) {
     912:	0023      	movs	r3, r4
     914:	33b0      	adds	r3, #176	; 0xb0
     916:	781a      	ldrb	r2, [r3, #0]
     918:	232c      	movs	r3, #44	; 0x2c
     91a:	4353      	muls	r3, r2
     91c:	18e4      	adds	r4, r4, r3
     91e:	342a      	adds	r4, #42	; 0x2a
     920:	7823      	ldrb	r3, [r4, #0]
     922:	2b00      	cmp	r3, #0
     924:	d101      	bne.n	92a <cmd_tasks+0x5e>
        cmd_task_done();
     926:	4b07      	ldr	r3, [pc, #28]	; (944 <cmd_tasks+0x78>)
     928:	4798      	blx	r3
    }
}
     92a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     92c:	20000a58 	.word	0x20000a58
     930:	20000c14 	.word	0x20000c14
     934:	0000a051 	.word	0x0000a051
     938:	00007b99 	.word	0x00007b99
     93c:	0000a061 	.word	0x0000a061
     940:	000005ad 	.word	0x000005ad
     944:	00000899 	.word	0x00000899

00000948 <cmd_init>:

void cmd_init(int8_t onoff)
{
     948:	b510      	push	{r4, lr}
    memset((void *)&cmd_task_queue,0,sizeof(cmd_task_queue_t));
     94a:	22b1      	movs	r2, #177	; 0xb1
     94c:	2100      	movs	r1, #0
     94e:	4802      	ldr	r0, [pc, #8]	; (958 <cmd_init+0x10>)
     950:	4b02      	ldr	r3, [pc, #8]	; (95c <cmd_init+0x14>)
     952:	4798      	blx	r3
}
     954:	bd10      	pop	{r4, pc}
     956:	46c0      	nop			; (mov r8, r8)
     958:	20000c14 	.word	0x20000c14
     95c:	00008957 	.word	0x00008957

00000960 <read_print_rtc>:


// returns -1 if passed alarm time already
// returns  >=0 if have still days credit left
int16_t read_print_rtc(bool do_print, char *log, uint8_t allowed_log_len)
{
     960:	b5f0      	push	{r4, r5, r6, r7, lr}
     962:	b099      	sub	sp, #100	; 0x64
    char buf[50];
    Time now,alarm;
    int16_t credit;
    uint8_t show_hours_left=0; // default show days left
    getTimeNow(&now);
     964:	4b38      	ldr	r3, [pc, #224]	; (a48 <read_print_rtc+0xe8>)
{
     966:	0007      	movs	r7, r0
    getTimeNow(&now);
     968:	a807      	add	r0, sp, #28
{
     96a:	9104      	str	r1, [sp, #16]
     96c:	9205      	str	r2, [sp, #20]
    getTimeNow(&now);
     96e:	4798      	blx	r3
    getAlarmTimeNow(&alarm);
     970:	a809      	add	r0, sp, #36	; 0x24
     972:	4b36      	ldr	r3, [pc, #216]	; (a4c <read_print_rtc+0xec>)
     974:	4798      	blx	r3
    
    credit = Days_left(&alarm,&now,show_hours_left,0);
     976:	2300      	movs	r3, #0
     978:	a907      	add	r1, sp, #28
     97a:	001a      	movs	r2, r3
     97c:	a809      	add	r0, sp, #36	; 0x24
     97e:	4e34      	ldr	r6, [pc, #208]	; (a50 <read_print_rtc+0xf0>)
     980:	47b0      	blx	r6
    uint8_t show_hours_left=0; // default show days left
     982:	2500      	movs	r5, #0
    credit = Days_left(&alarm,&now,show_hours_left,0);
     984:	0004      	movs	r4, r0
    if(credit<=0) {
     986:	42a8      	cmp	r0, r5
     988:	dc06      	bgt.n	998 <read_print_rtc+0x38>
        show_hours_left=1;
        credit = Days_left(&alarm,&now,show_hours_left,0);
     98a:	002b      	movs	r3, r5
     98c:	2201      	movs	r2, #1
     98e:	a907      	add	r1, sp, #28
     990:	a809      	add	r0, sp, #36	; 0x24
     992:	47b0      	blx	r6
     994:	0004      	movs	r4, r0
        show_hours_left=1;
     996:	3501      	adds	r5, #1
    }
    
    if(do_print) {
     998:	2f00      	cmp	r7, #0
     99a:	d03d      	beq.n	a18 <read_print_rtc+0xb8>
        sprintf(buf,"\n\r      YY-MM-DD hh:mm\n\r");
     99c:	492d      	ldr	r1, [pc, #180]	; (a54 <read_print_rtc+0xf4>)
     99e:	4b2e      	ldr	r3, [pc, #184]	; (a58 <read_print_rtc+0xf8>)
     9a0:	a80b      	add	r0, sp, #44	; 0x2c
     9a2:	4798      	blx	r3
        uart_puts_info(buf);
     9a4:	4e2d      	ldr	r6, [pc, #180]	; (a5c <read_print_rtc+0xfc>)
     9a6:	a80b      	add	r0, sp, #44	; 0x2c
     9a8:	47b0      	blx	r6
        sprintf(buf," time:%02d-%02d-%02d %02d:%02d\n\r",now.year,now.month,now.day,now.hour,now.minute);
     9aa:	2004      	movs	r0, #4
     9ac:	2301      	movs	r3, #1
     9ae:	2200      	movs	r2, #0
     9b0:	a907      	add	r1, sp, #28
     9b2:	5608      	ldrsb	r0, [r1, r0]
     9b4:	56cb      	ldrsb	r3, [r1, r3]
     9b6:	568a      	ldrsb	r2, [r1, r2]
     9b8:	9002      	str	r0, [sp, #8]
     9ba:	2003      	movs	r0, #3
     9bc:	5608      	ldrsb	r0, [r1, r0]
     9be:	4f28      	ldr	r7, [pc, #160]	; (a60 <read_print_rtc+0x100>)
     9c0:	9001      	str	r0, [sp, #4]
     9c2:	7889      	ldrb	r1, [r1, #2]
     9c4:	a80b      	add	r0, sp, #44	; 0x2c
     9c6:	b249      	sxtb	r1, r1
     9c8:	9100      	str	r1, [sp, #0]
     9ca:	4926      	ldr	r1, [pc, #152]	; (a64 <read_print_rtc+0x104>)
     9cc:	47b8      	blx	r7
        uart_puts_info(buf);
     9ce:	a80b      	add	r0, sp, #44	; 0x2c
     9d0:	47b0      	blx	r6
        sprintf(buf,"alarm:%02d-%02d-%02d %02d:%02d\n\r",alarm.year,alarm.month,alarm.day,alarm.hour,alarm.minute);
     9d2:	2004      	movs	r0, #4
     9d4:	2301      	movs	r3, #1
     9d6:	2200      	movs	r2, #0
     9d8:	a909      	add	r1, sp, #36	; 0x24
     9da:	5608      	ldrsb	r0, [r1, r0]
     9dc:	56cb      	ldrsb	r3, [r1, r3]
     9de:	568a      	ldrsb	r2, [r1, r2]
     9e0:	9002      	str	r0, [sp, #8]
     9e2:	2003      	movs	r0, #3
     9e4:	5608      	ldrsb	r0, [r1, r0]
     9e6:	9001      	str	r0, [sp, #4]
     9e8:	7889      	ldrb	r1, [r1, #2]
     9ea:	a80b      	add	r0, sp, #44	; 0x2c
     9ec:	b249      	sxtb	r1, r1
     9ee:	9100      	str	r1, [sp, #0]
     9f0:	491d      	ldr	r1, [pc, #116]	; (a68 <read_print_rtc+0x108>)
     9f2:	47b8      	blx	r7
        uart_puts_info(buf);
     9f4:	a80b      	add	r0, sp, #44	; 0x2c
     9f6:	47b0      	blx	r6
        sprintf(buf,"credit=%d %s left\n\r",credit,(show_hours_left ? "hours" : "days"));
     9f8:	4b1c      	ldr	r3, [pc, #112]	; (a6c <read_print_rtc+0x10c>)
     9fa:	2d00      	cmp	r5, #0
     9fc:	d100      	bne.n	a00 <read_print_rtc+0xa0>
     9fe:	4b1c      	ldr	r3, [pc, #112]	; (a70 <read_print_rtc+0x110>)
     a00:	491c      	ldr	r1, [pc, #112]	; (a74 <read_print_rtc+0x114>)
     a02:	0022      	movs	r2, r4
     a04:	a80b      	add	r0, sp, #44	; 0x2c
     a06:	4e16      	ldr	r6, [pc, #88]	; (a60 <read_print_rtc+0x100>)
     a08:	47b0      	blx	r6
        uart_puts_info(buf);
     a0a:	a80b      	add	r0, sp, #44	; 0x2c
     a0c:	4b13      	ldr	r3, [pc, #76]	; (a5c <read_print_rtc+0xfc>)
     a0e:	4798      	blx	r3

        oled_write_number_int(credit,show_hours_left);
     a10:	0029      	movs	r1, r5
     a12:	0020      	movs	r0, r4
     a14:	4b18      	ldr	r3, [pc, #96]	; (a78 <read_print_rtc+0x118>)
     a16:	4798      	blx	r3
    }
    if(allowed_log_len>=9) {
     a18:	9b05      	ldr	r3, [sp, #20]
     a1a:	2b08      	cmp	r3, #8
     a1c:	d907      	bls.n	a2e <read_print_rtc+0xce>
     a1e:	4b10      	ldr	r3, [pc, #64]	; (a60 <read_print_rtc+0x100>)
        if(show_hours_left) {
            sprintf(log,"[%dhrs]",credit);
     a20:	0022      	movs	r2, r4
     a22:	4916      	ldr	r1, [pc, #88]	; (a7c <read_print_rtc+0x11c>)
        if(show_hours_left) {
     a24:	2d00      	cmp	r5, #0
     a26:	d100      	bne.n	a2a <read_print_rtc+0xca>
        } else {
            sprintf(log,"[%dday]",credit);
     a28:	4915      	ldr	r1, [pc, #84]	; (a80 <read_print_rtc+0x120>)
     a2a:	9804      	ldr	r0, [sp, #16]
     a2c:	4798      	blx	r3
        }
    }
    if(credit<=0) {
     a2e:	2c00      	cmp	r4, #0
     a30:	dc06      	bgt.n	a40 <read_print_rtc+0xe0>
        credit = Days_left(&alarm,&now,0,1); // get credit for minutes left
     a32:	4c07      	ldr	r4, [pc, #28]	; (a50 <read_print_rtc+0xf0>)
     a34:	2301      	movs	r3, #1
     a36:	2200      	movs	r2, #0
     a38:	a907      	add	r1, sp, #28
     a3a:	a809      	add	r0, sp, #36	; 0x24
     a3c:	47a0      	blx	r4
     a3e:	0004      	movs	r4, r0
    }
    return credit;
}
     a40:	0020      	movs	r0, r4
     a42:	b019      	add	sp, #100	; 0x64
     a44:	bdf0      	pop	{r4, r5, r6, r7, pc}
     a46:	46c0      	nop			; (mov r8, r8)
     a48:	00003959 	.word	0x00003959
     a4c:	000039b1 	.word	0x000039b1
     a50:	00003a21 	.word	0x00003a21
     a54:	0000a07b 	.word	0x0000a07b
     a58:	00008a2f 	.word	0x00008a2f
     a5c:	00007b75 	.word	0x00007b75
     a60:	00008969 	.word	0x00008969
     a64:	0000a094 	.word	0x0000a094
     a68:	0000a0b5 	.word	0x0000a0b5
     a6c:	0000a070 	.word	0x0000a070
     a70:	0000a076 	.word	0x0000a076
     a74:	0000a0d6 	.word	0x0000a0d6
     a78:	00002135 	.word	0x00002135
     a7c:	0000a0ea 	.word	0x0000a0ea
     a80:	0000a0f2 	.word	0x0000a0f2

00000a84 <code_init>:
{
     a84:	b5f0      	push	{r4, r5, r6, r7, lr}
     a86:	b085      	sub	sp, #20
    if(onoff==0) return;
     a88:	2800      	cmp	r0, #0
     a8a:	d01b      	beq.n	ac4 <code_init+0x40>
    flash_read_eeprom_time(&eeprom_time);
     a8c:	4c22      	ldr	r4, [pc, #136]	; (b18 <code_init+0x94>)
     a8e:	4b23      	ldr	r3, [pc, #140]	; (b1c <code_init+0x98>)
     a90:	0020      	movs	r0, r4
     a92:	4798      	blx	r3
    if (eeprom_time.valid == false) {
     a94:	7826      	ldrb	r6, [r4, #0]
     a96:	4d22      	ldr	r5, [pc, #136]	; (b20 <code_init+0x9c>)
     a98:	4f22      	ldr	r7, [pc, #136]	; (b24 <code_init+0xa0>)
     a9a:	2e00      	cmp	r6, #0
     a9c:	d114      	bne.n	ac8 <code_init+0x44>
        uart_print(0,"eeprom empty: mosfet off\n\r");
     a9e:	4922      	ldr	r1, [pc, #136]	; (b28 <code_init+0xa4>)
     aa0:	0030      	movs	r0, r6
     aa2:	47a8      	blx	r5
        task_set_load(0);
     aa4:	0030      	movs	r0, r6
     aa6:	47b8      	blx	r7
        setTime(0,0,0);// set time (hour 0-23, minute 0-59, second 0-59)
     aa8:	0032      	movs	r2, r6
     aaa:	0031      	movs	r1, r6
     aac:	0030      	movs	r0, r6
     aae:	4b1f      	ldr	r3, [pc, #124]	; (b2c <code_init+0xa8>)
     ab0:	4798      	blx	r3
        setDate(1,1,1);// set date (day 1-31, month 1-12, year 0-99)
     ab2:	2201      	movs	r2, #1
     ab4:	4b1e      	ldr	r3, [pc, #120]	; (b30 <code_init+0xac>)
     ab6:	0011      	movs	r1, r2
     ab8:	0010      	movs	r0, r2
     aba:	4798      	blx	r3
        eeprom_time.seq=99;
     abc:	2363      	movs	r3, #99	; 0x63
     abe:	70e3      	strb	r3, [r4, #3]
                play_song_expired();
     ac0:	4b1c      	ldr	r3, [pc, #112]	; (b34 <code_init+0xb0>)
                play_song_success();
     ac2:	4798      	blx	r3
}
     ac4:	b005      	add	sp, #20
     ac6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uart_print(0,"eeprom ok: read values\n\r");
     ac8:	491b      	ldr	r1, [pc, #108]	; (b38 <code_init+0xb4>)
     aca:	2000      	movs	r0, #0
     acc:	47a8      	blx	r5
        uart_print(0,"(days=%d) (seq=%d)\n\r",eeprom_time.days,eeprom_time.seq);
     ace:	78e3      	ldrb	r3, [r4, #3]
     ad0:	7862      	ldrb	r2, [r4, #1]
     ad2:	491a      	ldr	r1, [pc, #104]	; (b3c <code_init+0xb8>)
     ad4:	2000      	movs	r0, #0
     ad6:	47a8      	blx	r5
        if(eeprom_time.days==0 && eeprom_time.minutes==0) {
     ad8:	7863      	ldrb	r3, [r4, #1]
     ada:	2b00      	cmp	r3, #0
     adc:	d108      	bne.n	af0 <code_init+0x6c>
     ade:	78a0      	ldrb	r0, [r4, #2]
     ae0:	2800      	cmp	r0, #0
     ae2:	d105      	bne.n	af0 <code_init+0x6c>
            uart_print(0,"free mode, no alarm: mosfet on\n\r");
     ae4:	4916      	ldr	r1, [pc, #88]	; (b40 <code_init+0xbc>)
     ae6:	47a8      	blx	r5
                task_set_load(1);
     ae8:	2001      	movs	r0, #1
     aea:	47b8      	blx	r7
                play_song_success();
     aec:	4b15      	ldr	r3, [pc, #84]	; (b44 <code_init+0xc0>)
     aee:	e7e8      	b.n	ac2 <code_init+0x3e>
            creditleft=read_print_rtc(true,log,0);
     af0:	2200      	movs	r2, #0
     af2:	a901      	add	r1, sp, #4
     af4:	2001      	movs	r0, #1
     af6:	4b14      	ldr	r3, [pc, #80]	; (b48 <code_init+0xc4>)
     af8:	4798      	blx	r3
            if(creditleft <= 0) { // passed the alarm time
     afa:	2800      	cmp	r0, #0
     afc:	dc05      	bgt.n	b0a <code_init+0x86>
                uart_print(0,"already expired, mosfet off\n\r");
     afe:	4913      	ldr	r1, [pc, #76]	; (b4c <code_init+0xc8>)
     b00:	2000      	movs	r0, #0
     b02:	47a8      	blx	r5
                task_set_load(0);
     b04:	2000      	movs	r0, #0
     b06:	47b8      	blx	r7
     b08:	e7da      	b.n	ac0 <code_init+0x3c>
                uart_print(0,"enable alarm, mosfet on\n\r");
     b0a:	4911      	ldr	r1, [pc, #68]	; (b50 <code_init+0xcc>)
     b0c:	2000      	movs	r0, #0
     b0e:	47a8      	blx	r5
                enableAlarm(RTC_MODE2_MASK_SEL_YYMMDDHHMMSS_Val);
     b10:	2006      	movs	r0, #6
     b12:	4b10      	ldr	r3, [pc, #64]	; (b54 <code_init+0xd0>)
     b14:	4798      	blx	r3
     b16:	e7e7      	b.n	ae8 <code_init+0x64>
     b18:	20000304 	.word	0x20000304
     b1c:	00001005 	.word	0x00001005
     b20:	00007b99 	.word	0x00007b99
     b24:	00006935 	.word	0x00006935
     b28:	0000a0fa 	.word	0x0000a0fa
     b2c:	00003c81 	.word	0x00003c81
     b30:	00003d0d 	.word	0x00003d0d
     b34:	00007485 	.word	0x00007485
     b38:	0000a115 	.word	0x0000a115
     b3c:	0000a12e 	.word	0x0000a12e
     b40:	0000a143 	.word	0x0000a143
     b44:	0000741d 	.word	0x0000741d
     b48:	00000961 	.word	0x00000961
     b4c:	0000a164 	.word	0x0000a164
     b50:	0000a182 	.word	0x0000a182
     b54:	00003e49 	.word	0x00003e49

00000b58 <generate_newalarm>:

void generate_newalarm(Time *newalarm, Time *now, Time *credit)
{
     b58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    Time alarm;
    int16_t oldcredit;
    getAlarmTimeNow(&alarm);
     b5a:	4b12      	ldr	r3, [pc, #72]	; (ba4 <generate_newalarm+0x4c>)
{
     b5c:	0005      	movs	r5, r0
    getAlarmTimeNow(&alarm);
     b5e:	4668      	mov	r0, sp
{
     b60:	000c      	movs	r4, r1
     b62:	0016      	movs	r6, r2
    getAlarmTimeNow(&alarm);
     b64:	4798      	blx	r3
    oldcredit = Days_left(&alarm,now,0,0); // are there days left?
     b66:	2300      	movs	r3, #0
     b68:	0021      	movs	r1, r4
     b6a:	001a      	movs	r2, r3
     b6c:	4668      	mov	r0, sp
     b6e:	4f0e      	ldr	r7, [pc, #56]	; (ba8 <generate_newalarm+0x50>)
     b70:	47b8      	blx	r7
    if(oldcredit<=0) {
     b72:	2800      	cmp	r0, #0
     b74:	dc0f      	bgt.n	b96 <generate_newalarm+0x3e>
        oldcredit = Days_left(&alarm,now,0,1); // maybe some minutes left?
     b76:	2301      	movs	r3, #1
     b78:	2200      	movs	r2, #0
     b7a:	0021      	movs	r1, r4
     b7c:	4668      	mov	r0, sp
     b7e:	47b8      	blx	r7
    }
    
    if(oldcredit < 0) {
     b80:	2800      	cmp	r0, #0
     b82:	da08      	bge.n	b96 <generate_newalarm+0x3e>
        // credit is expired; add credit to now
        uart_puts_info("add to now\n\r");
     b84:	4809      	ldr	r0, [pc, #36]	; (bac <generate_newalarm+0x54>)
     b86:	4b0a      	ldr	r3, [pc, #40]	; (bb0 <generate_newalarm+0x58>)
     b88:	4798      	blx	r3
        Time_add(newalarm, now, credit);
     b8a:	0032      	movs	r2, r6
     b8c:	0021      	movs	r1, r4
        } else {
        // credit not yet expired; add credit; move alarm forward
        uart_puts_info("add to alarm\n\r");
        Time_add(newalarm, &alarm, credit);
     b8e:	0028      	movs	r0, r5
     b90:	4b08      	ldr	r3, [pc, #32]	; (bb4 <generate_newalarm+0x5c>)
     b92:	4798      	blx	r3
    }
}
     b94:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        uart_puts_info("add to alarm\n\r");
     b96:	4808      	ldr	r0, [pc, #32]	; (bb8 <generate_newalarm+0x60>)
     b98:	4b05      	ldr	r3, [pc, #20]	; (bb0 <generate_newalarm+0x58>)
     b9a:	4798      	blx	r3
        Time_add(newalarm, &alarm, credit);
     b9c:	0032      	movs	r2, r6
     b9e:	4669      	mov	r1, sp
     ba0:	e7f5      	b.n	b8e <generate_newalarm+0x36>
     ba2:	46c0      	nop			; (mov r8, r8)
     ba4:	000039b1 	.word	0x000039b1
     ba8:	00003a21 	.word	0x00003a21
     bac:	0000a19c 	.word	0x0000a19c
     bb0:	00007b75 	.word	0x00007b75
     bb4:	00003b6d 	.word	0x00003b6d
     bb8:	0000a1a9 	.word	0x0000a1a9

00000bbc <code_alarm_triggered>:

void code_alarm_triggered(void)
{
     bbc:	b510      	push	{r4, lr}
    play_song_expired();
     bbe:	4b05      	ldr	r3, [pc, #20]	; (bd4 <code_alarm_triggered+0x18>)
     bc0:	4798      	blx	r3
    getTimeNow(&eeprom_time.now);    
     bc2:	4c05      	ldr	r4, [pc, #20]	; (bd8 <code_alarm_triggered+0x1c>)
     bc4:	4b05      	ldr	r3, [pc, #20]	; (bdc <code_alarm_triggered+0x20>)
     bc6:	1d20      	adds	r0, r4, #4
     bc8:	4798      	blx	r3
    flash_write_eeprom_time(&eeprom_time);
     bca:	0020      	movs	r0, r4
     bcc:	4b04      	ldr	r3, [pc, #16]	; (be0 <code_alarm_triggered+0x24>)
     bce:	4798      	blx	r3
}
     bd0:	bd10      	pop	{r4, pc}
     bd2:	46c0      	nop			; (mov r8, r8)
     bd4:	00007485 	.word	0x00007485
     bd8:	20000304 	.word	0x20000304
     bdc:	00003959 	.word	0x00003959
     be0:	00001195 	.word	0x00001195

00000be4 <code_daily_flash>:

void code_daily_flash(void)
{
     be4:	b510      	push	{r4, lr}
    getTimeNow(&eeprom_time.now);        
     be6:	4c04      	ldr	r4, [pc, #16]	; (bf8 <code_daily_flash+0x14>)
     be8:	4b04      	ldr	r3, [pc, #16]	; (bfc <code_daily_flash+0x18>)
     bea:	1d20      	adds	r0, r4, #4
     bec:	4798      	blx	r3
    flash_write_eeprom_time(&eeprom_time);
     bee:	0020      	movs	r0, r4
     bf0:	4b03      	ldr	r3, [pc, #12]	; (c00 <code_daily_flash+0x1c>)
     bf2:	4798      	blx	r3
}
     bf4:	bd10      	pop	{r4, pc}
     bf6:	46c0      	nop			; (mov r8, r8)
     bf8:	20000304 	.word	0x20000304
     bfc:	00003959 	.word	0x00003959
     c00:	00001195 	.word	0x00001195

00000c04 <code_run_update>:

void code_run_update(void)
{
     c04:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    char log[10];
    if(read_print_rtc(true,log,0) == 0) {         // 0 credit left? (last day)
     c06:	2200      	movs	r2, #0
     c08:	a901      	add	r1, sp, #4
     c0a:	4b02      	ldr	r3, [pc, #8]	; (c14 <code_run_update+0x10>)
     c0c:	2001      	movs	r0, #1
     c0e:	4798      	blx	r3
    }
}
     c10:	b005      	add	sp, #20
     c12:	bd00      	pop	{pc}
     c14:	00000961 	.word	0x00000961

00000c18 <get_myid>:
    // ATSAMD11 replies: 0xe1c74e77514d4b5331202020ff0b4631
    
    // most significant side seems to be more unique.
    
    volatile uint32_t *chip_ptr = (volatile uint32_t *)0x0080A00C; // word0 address
    return (*chip_ptr & 0x3fffffff); // mask 30bits
     c18:	4b02      	ldr	r3, [pc, #8]	; (c24 <get_myid+0xc>)
     c1a:	6818      	ldr	r0, [r3, #0]
     c1c:	0080      	lsls	r0, r0, #2
     c1e:	0880      	lsrs	r0, r0, #2
}
     c20:	4770      	bx	lr
     c22:	46c0      	nop			; (mov r8, r8)
     c24:	0080a00c 	.word	0x0080a00c

00000c28 <print_myid>:
    return (*chip_ptr & 0x3fffffff); // mask 30bits
     c28:	4b04      	ldr	r3, [pc, #16]	; (c3c <print_myid+0x14>)
void print_myid(void)
{
     c2a:	b510      	push	{r4, lr}
    return (*chip_ptr & 0x3fffffff); // mask 30bits
     c2c:	681a      	ldr	r2, [r3, #0]
    uint32_t chipval = get_myid();
    uart_print(0,"\n\r%09ld\n\r",chipval);
     c2e:	4904      	ldr	r1, [pc, #16]	; (c40 <print_myid+0x18>)
    return (*chip_ptr & 0x3fffffff); // mask 30bits
     c30:	0092      	lsls	r2, r2, #2
     c32:	0892      	lsrs	r2, r2, #2
    uart_print(0,"\n\r%09ld\n\r",chipval);
     c34:	2000      	movs	r0, #0
     c36:	4b03      	ldr	r3, [pc, #12]	; (c44 <print_myid+0x1c>)
     c38:	4798      	blx	r3
}
     c3a:	bd10      	pop	{r4, pc}
     c3c:	0080a00c 	.word	0x0080a00c
     c40:	0000a1b8 	.word	0x0000a1b8
     c44:	00007b99 	.word	0x00007b99

00000c48 <code_demo>:
void code_demo(char *rxbuf, char *log, uint8_t allowed_log_len) 
{
	unsigned long givencode;
	uint8_t givenminutes=0;
	uint8_t givendays=0;
	rxbuf[0]=' '; // strip '*'
     c48:	2320      	movs	r3, #32
{
     c4a:	b5f0      	push	{r4, r5, r6, r7, lr}
	rxbuf[0]=' '; // strip '*'
     c4c:	7003      	strb	r3, [r0, #0]
	rxbuf[10]=0;  // strip '#'
     c4e:	2300      	movs	r3, #0
{
     c50:	b08b      	sub	sp, #44	; 0x2c
	
    if(strncasecmp(&rxbuf[1],"123456789",9)==0) {
     c52:	1c47      	adds	r7, r0, #1
{
     c54:	0004      	movs	r4, r0
     c56:	9101      	str	r1, [sp, #4]
     c58:	9202      	str	r2, [sp, #8]
	rxbuf[10]=0;  // strip '#'
     c5a:	7283      	strb	r3, [r0, #10]
    if(strncasecmp(&rxbuf[1],"123456789",9)==0) {
     c5c:	2209      	movs	r2, #9
     c5e:	4937      	ldr	r1, [pc, #220]	; (d3c <code_demo+0xf4>)
     c60:	0038      	movs	r0, r7
     c62:	4e37      	ldr	r6, [pc, #220]	; (d40 <code_demo+0xf8>)
     c64:	47b0      	blx	r6
     c66:	2800      	cmp	r0, #0
     c68:	d009      	beq.n	c7e <code_demo+0x36>
	    givenminutes=3; // 3 minutes for demo
    } else if(strncasecmp(&rxbuf[1],"987654321",9)==0) {
     c6a:	2209      	movs	r2, #9
     c6c:	4935      	ldr	r1, [pc, #212]	; (d44 <code_demo+0xfc>)
     c6e:	0038      	movs	r0, r7
     c70:	47b0      	blx	r6
     c72:	2800      	cmp	r0, #0
     c74:	d05f      	beq.n	d36 <code_demo+0xee>
	    givendays=5; // 5 days for demo
    } else {
        play_song_error();
     c76:	4b34      	ldr	r3, [pc, #208]	; (d48 <code_demo+0x100>)
     c78:	4798      	blx	r3
	eeprom_time.minutes = givenminutes;	
	flash_write_eeprom_time(&eeprom_time);
	read_print_rtc(true,log,allowed_log_len);
	play_song_success();
    task_set_load(1);
}
     c7a:	b00b      	add	sp, #44	; 0x2c
     c7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t givendays=0;
     c7e:	0005      	movs	r5, r0
	    givenminutes=3; // 3 minutes for demo
     c80:	2703      	movs	r7, #3
	givencode = strtoul(rxbuf,NULL,10);
     c82:	220a      	movs	r2, #10
     c84:	2100      	movs	r1, #0
     c86:	0020      	movs	r0, r4
     c88:	4b30      	ldr	r3, [pc, #192]	; (d4c <code_demo+0x104>)
     c8a:	4798      	blx	r3
	uart_print(0," code=%lu (0x%lx):",givencode,givencode);
     c8c:	4930      	ldr	r1, [pc, #192]	; (d50 <code_demo+0x108>)
	givencode = strtoul(rxbuf,NULL,10);
     c8e:	0002      	movs	r2, r0
	uart_print(0," code=%lu (0x%lx):",givencode,givencode);
     c90:	0003      	movs	r3, r0
     c92:	4c30      	ldr	r4, [pc, #192]	; (d54 <code_demo+0x10c>)
     c94:	2000      	movs	r0, #0
     c96:	47a0      	blx	r4
	uart_puts_info("[setting alarm]");
     c98:	482f      	ldr	r0, [pc, #188]	; (d58 <code_demo+0x110>)
     c9a:	4b30      	ldr	r3, [pc, #192]	; (d5c <code_demo+0x114>)
     c9c:	4798      	blx	r3
	credit.year=0;
     c9e:	2300      	movs	r3, #0
     ca0:	ae06      	add	r6, sp, #24
     ca2:	7033      	strb	r3, [r6, #0]
	credit.month=0;
     ca4:	7073      	strb	r3, [r6, #1]
	credit.hour=0;
     ca6:	70f3      	strb	r3, [r6, #3]
	getTimeNow(&now);
     ca8:	a804      	add	r0, sp, #16
     caa:	4b2d      	ldr	r3, [pc, #180]	; (d60 <code_demo+0x118>)
	credit.day=givendays;
     cac:	70b5      	strb	r5, [r6, #2]
	credit.minute=givenminutes;
     cae:	7137      	strb	r7, [r6, #4]
	getTimeNow(&now);
     cb0:	4798      	blx	r3
    seconds_now=getSeconds();
     cb2:	4b2c      	ldr	r3, [pc, #176]	; (d64 <code_demo+0x11c>)
     cb4:	4798      	blx	r3
	generate_newalarm(&newalarm,&now,&credit);
     cb6:	ac08      	add	r4, sp, #32
    seconds_now=getSeconds();
     cb8:	9003      	str	r0, [sp, #12]
	generate_newalarm(&newalarm,&now,&credit);
     cba:	0032      	movs	r2, r6
     cbc:	a904      	add	r1, sp, #16
     cbe:	0020      	movs	r0, r4
     cc0:	4b29      	ldr	r3, [pc, #164]	; (d68 <code_demo+0x120>)
     cc2:	4798      	blx	r3
	setAlarmTime(newalarm.hour,newalarm.minute,seconds_now);
     cc4:	7921      	ldrb	r1, [r4, #4]
     cc6:	78e0      	ldrb	r0, [r4, #3]
     cc8:	9a03      	ldr	r2, [sp, #12]
     cca:	4b28      	ldr	r3, [pc, #160]	; (d6c <code_demo+0x124>)
     ccc:	4798      	blx	r3
	setAlarmDate(newalarm.day,newalarm.month,newalarm.year);
     cce:	7822      	ldrb	r2, [r4, #0]
     cd0:	7861      	ldrb	r1, [r4, #1]
     cd2:	78a0      	ldrb	r0, [r4, #2]
     cd4:	4b26      	ldr	r3, [pc, #152]	; (d70 <code_demo+0x128>)
     cd6:	4798      	blx	r3
	enableAlarm(RTC_MODE2_MASK_SEL_YYMMDDHHMMSS_Val);
     cd8:	2006      	movs	r0, #6
     cda:	4b26      	ldr	r3, [pc, #152]	; (d74 <code_demo+0x12c>)
     cdc:	4798      	blx	r3
	eeprom_time.alarm.hour   = newalarm.hour;
     cde:	78e3      	ldrb	r3, [r4, #3]
     ce0:	4825      	ldr	r0, [pc, #148]	; (d78 <code_demo+0x130>)
     ce2:	7303      	strb	r3, [r0, #12]
	eeprom_time.alarm.minute = newalarm.minute;
     ce4:	7923      	ldrb	r3, [r4, #4]
     ce6:	7343      	strb	r3, [r0, #13]
	eeprom_time.alarm.day    = newalarm.day;
     ce8:	78a3      	ldrb	r3, [r4, #2]
     cea:	72c3      	strb	r3, [r0, #11]
	eeprom_time.alarm.month  = newalarm.month;
     cec:	7863      	ldrb	r3, [r4, #1]
     cee:	7283      	strb	r3, [r0, #10]
	eeprom_time.alarm.year   = newalarm.year;
     cf0:	7823      	ldrb	r3, [r4, #0]
	eeprom_time.valid = true;
     cf2:	2401      	movs	r4, #1
	eeprom_time.alarm.year   = newalarm.year;
     cf4:	7243      	strb	r3, [r0, #9]
	eeprom_time.now.hour   = now.hour;
     cf6:	ab04      	add	r3, sp, #16
     cf8:	78db      	ldrb	r3, [r3, #3]
     cfa:	71c3      	strb	r3, [r0, #7]
	eeprom_time.now.minute = now.minute;
     cfc:	ab04      	add	r3, sp, #16
     cfe:	791b      	ldrb	r3, [r3, #4]
     d00:	7203      	strb	r3, [r0, #8]
	eeprom_time.now.day    = now.day;
     d02:	ab04      	add	r3, sp, #16
     d04:	789b      	ldrb	r3, [r3, #2]
     d06:	7183      	strb	r3, [r0, #6]
	eeprom_time.now.month  = now.month;
     d08:	ab04      	add	r3, sp, #16
     d0a:	785b      	ldrb	r3, [r3, #1]
	eeprom_time.valid = true;
     d0c:	7004      	strb	r4, [r0, #0]
	eeprom_time.now.month  = now.month;
     d0e:	7143      	strb	r3, [r0, #5]
	eeprom_time.now.year   = now.year;
     d10:	ab04      	add	r3, sp, #16
     d12:	781b      	ldrb	r3, [r3, #0]
	eeprom_time.seq   = 1;
     d14:	70c4      	strb	r4, [r0, #3]
	eeprom_time.now.year   = now.year;
     d16:	7103      	strb	r3, [r0, #4]
	flash_write_eeprom_time(&eeprom_time);
     d18:	4b18      	ldr	r3, [pc, #96]	; (d7c <code_demo+0x134>)
	eeprom_time.days  = givendays;
     d1a:	7045      	strb	r5, [r0, #1]
	eeprom_time.minutes = givenminutes;	
     d1c:	7087      	strb	r7, [r0, #2]
	flash_write_eeprom_time(&eeprom_time);
     d1e:	4798      	blx	r3
	read_print_rtc(true,log,allowed_log_len);
     d20:	9a02      	ldr	r2, [sp, #8]
     d22:	9901      	ldr	r1, [sp, #4]
     d24:	0020      	movs	r0, r4
     d26:	4b16      	ldr	r3, [pc, #88]	; (d80 <code_demo+0x138>)
     d28:	4798      	blx	r3
	play_song_success();
     d2a:	4b16      	ldr	r3, [pc, #88]	; (d84 <code_demo+0x13c>)
     d2c:	4798      	blx	r3
    task_set_load(1);
     d2e:	0020      	movs	r0, r4
     d30:	4b15      	ldr	r3, [pc, #84]	; (d88 <code_demo+0x140>)
     d32:	4798      	blx	r3
     d34:	e7a1      	b.n	c7a <code_demo+0x32>
	    givendays=5; // 5 days for demo
     d36:	2505      	movs	r5, #5
	uint8_t givenminutes=0;
     d38:	0007      	movs	r7, r0
     d3a:	e7a2      	b.n	c82 <code_demo+0x3a>
     d3c:	0000a1c2 	.word	0x0000a1c2
     d40:	00008a4d 	.word	0x00008a4d
     d44:	0000a1cc 	.word	0x0000a1cc
     d48:	000074ed 	.word	0x000074ed
     d4c:	00008d95 	.word	0x00008d95
     d50:	0000a1d6 	.word	0x0000a1d6
     d54:	00007b99 	.word	0x00007b99
     d58:	0000a1e9 	.word	0x0000a1e9
     d5c:	00007b75 	.word	0x00007b75
     d60:	00003959 	.word	0x00003959
     d64:	00003995 	.word	0x00003995
     d68:	00000b59 	.word	0x00000b59
     d6c:	00003d99 	.word	0x00003d99
     d70:	00003e25 	.word	0x00003e25
     d74:	00003e49 	.word	0x00003e49
     d78:	20000304 	.word	0x20000304
     d7c:	00001195 	.word	0x00001195
     d80:	00000961 	.word	0x00000961
     d84:	0000741d 	.word	0x0000741d
     d88:	00006935 	.word	0x00006935

00000d8c <code_real>:

int code_real(char *rxbuf, char *log, uint8_t allowed_log_len) // *12345678901234#
{
     d8c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t givenseq;
	uint16_t givendays,givendays_i;
	int8_t givendays_int8;
	//uint64_t givencode;
	char rxbuf_cpy[32];
	rxbuf[16]=0;  // strip '#'
     d8e:	2700      	movs	r7, #0
	strcpy(rxbuf_cpy,&rxbuf[1]); // skip '*'
				
	// decode the code:
	if(decode_rcode(rxbuf_cpy,&givenseq,&givenid,&givendays) > 0) {
     d90:	250a      	movs	r5, #10
     d92:	2609      	movs	r6, #9
{
     d94:	b095      	sub	sp, #84	; 0x54
     d96:	9102      	str	r1, [sp, #8]
	rxbuf[16]=0;  // strip '#'
     d98:	7407      	strb	r7, [r0, #16]
	strcpy(rxbuf_cpy,&rxbuf[1]); // skip '*'
     d9a:	1c41      	adds	r1, r0, #1
     d9c:	4b5e      	ldr	r3, [pc, #376]	; (f18 <code_real+0x18c>)
     d9e:	a80c      	add	r0, sp, #48	; 0x30
{
     da0:	9203      	str	r2, [sp, #12]
	strcpy(rxbuf_cpy,&rxbuf[1]); // skip '*'
     da2:	4798      	blx	r3
	if(decode_rcode(rxbuf_cpy,&givenseq,&givenid,&givendays) > 0) {
     da4:	ab02      	add	r3, sp, #8
     da6:	18f6      	adds	r6, r6, r3
     da8:	18ed      	adds	r5, r5, r3
     daa:	002b      	movs	r3, r5
     dac:	aa05      	add	r2, sp, #20
     dae:	0031      	movs	r1, r6
     db0:	a80c      	add	r0, sp, #48	; 0x30
     db2:	4c5a      	ldr	r4, [pc, #360]	; (f1c <code_real+0x190>)
     db4:	47a0      	blx	r4
     db6:	42b8      	cmp	r0, r7
     db8:	dc00      	bgt.n	dbc <code_real+0x30>
     dba:	e0a5      	b.n	f08 <code_real+0x17c>
    	uart_print(0," [seq=%d days=%d id=%ld]",givenseq,givendays,givenid);
     dbc:	9905      	ldr	r1, [sp, #20]
     dbe:	882b      	ldrh	r3, [r5, #0]
     dc0:	7832      	ldrb	r2, [r6, #0]
     dc2:	0038      	movs	r0, r7
     dc4:	9100      	str	r1, [sp, #0]
     dc6:	4c56      	ldr	r4, [pc, #344]	; (f20 <code_real+0x194>)
     dc8:	4956      	ldr	r1, [pc, #344]	; (f24 <code_real+0x198>)
     dca:	47a0      	blx	r4
        uart_print(0,"[eeprom seq=%d]",eeprom_time.seq);
     dcc:	4c56      	ldr	r4, [pc, #344]	; (f28 <code_real+0x19c>)
     dce:	0038      	movs	r0, r7
     dd0:	78e2      	ldrb	r2, [r4, #3]
     dd2:	4b53      	ldr	r3, [pc, #332]	; (f20 <code_real+0x194>)
     dd4:	4955      	ldr	r1, [pc, #340]	; (f2c <code_real+0x1a0>)
     dd6:	4798      	blx	r3
    return (*chip_ptr & 0x3fffffff); // mask 30bits
     dd8:	4b55      	ldr	r3, [pc, #340]	; (f30 <code_real+0x1a4>)
    	if(givenid == get_myid()) {
     dda:	9a05      	ldr	r2, [sp, #20]
    return (*chip_ptr & 0x3fffffff); // mask 30bits
     ddc:	681b      	ldr	r3, [r3, #0]
     dde:	4f55      	ldr	r7, [pc, #340]	; (f34 <code_real+0x1a8>)
     de0:	009b      	lsls	r3, r3, #2
     de2:	089b      	lsrs	r3, r3, #2
    	if(givenid == get_myid()) {
     de4:	429a      	cmp	r2, r3
     de6:	d000      	beq.n	dea <code_real+0x5e>
     de8:	e084      	b.n	ef4 <code_real+0x168>
        	uart_puts_info("[id match]");
     dea:	4853      	ldr	r0, [pc, #332]	; (f38 <code_real+0x1ac>)
     dec:	47b8      	blx	r7
        	if(givenseq > eeprom_time.seq || (givenseq==0 && eeprom_time.seq>95)) {
     dee:	78e3      	ldrb	r3, [r4, #3]
     df0:	7832      	ldrb	r2, [r6, #0]
     df2:	4293      	cmp	r3, r2
     df4:	d305      	bcc.n	e02 <code_real+0x76>
     df6:	2a00      	cmp	r2, #0
     df8:	d000      	beq.n	dfc <code_real+0x70>
     dfa:	e06d      	b.n	ed8 <code_real+0x14c>
     dfc:	2b5f      	cmp	r3, #95	; 0x5f
     dfe:	d800      	bhi.n	e02 <code_real+0x76>
     e00:	e06a      	b.n	ed8 <code_real+0x14c>
            	if(givendays > 0 && givendays < 1000) {
     e02:	882d      	ldrh	r5, [r5, #0]
     e04:	4a4d      	ldr	r2, [pc, #308]	; (f3c <code_real+0x1b0>)
     e06:	1e6b      	subs	r3, r5, #1
     e08:	b29b      	uxth	r3, r3
     e0a:	4293      	cmp	r3, r2
     e0c:	d85f      	bhi.n	ece <code_real+0x142>
                				
                	givendays_i=givendays;
                	while(givendays_i > 0) {
                    	getTimeNow(&now);
                    	uart_puts_info("[setting alarm]");
                    	credit.year=0;
     e0e:	2700      	movs	r7, #0
                    	getTimeNow(&now);
     e10:	ae06      	add	r6, sp, #24
     e12:	0030      	movs	r0, r6
     e14:	4b4a      	ldr	r3, [pc, #296]	; (f40 <code_real+0x1b4>)
     e16:	4798      	blx	r3
                    	uart_puts_info("[setting alarm]");
     e18:	4b46      	ldr	r3, [pc, #280]	; (f34 <code_real+0x1a8>)
     e1a:	484a      	ldr	r0, [pc, #296]	; (f44 <code_real+0x1b8>)
     e1c:	4798      	blx	r3
                    	credit.year=0;
     e1e:	aa08      	add	r2, sp, #32
     e20:	7017      	strb	r7, [r2, #0]
                    	credit.month=0;
     e22:	7057      	strb	r7, [r2, #1]
     e24:	1c2b      	adds	r3, r5, #0
     e26:	2d60      	cmp	r5, #96	; 0x60
     e28:	d900      	bls.n	e2c <code_real+0xa0>
     e2a:	2360      	movs	r3, #96	; 0x60
                    	if(givendays_i > 96) {givendays_int8=96;} else {givendays_int8=(int8_t)givendays_i;}
                    	givendays_i -= givendays_int8;
                    	credit.day=givendays_int8;
                    	credit.hour=0;
                    	credit.minute=0;
                    	generate_newalarm(&newalarm,&now,&credit);
     e2c:	ac0a      	add	r4, sp, #40	; 0x28
     e2e:	b29b      	uxth	r3, r3
                    	credit.day=givendays_int8;
     e30:	7093      	strb	r3, [r2, #2]
                    	givendays_i -= givendays_int8;
     e32:	1aed      	subs	r5, r5, r3
                    	generate_newalarm(&newalarm,&now,&credit);
     e34:	0031      	movs	r1, r6
     e36:	0020      	movs	r0, r4
     e38:	4b43      	ldr	r3, [pc, #268]	; (f48 <code_real+0x1bc>)
                    	credit.hour=0;
     e3a:	70d7      	strb	r7, [r2, #3]
                    	credit.minute=0;
     e3c:	7117      	strb	r7, [r2, #4]
                    	generate_newalarm(&newalarm,&now,&credit);
     e3e:	4798      	blx	r3
                    	setAlarmTime(newalarm.hour,newalarm.minute,0);
     e40:	7921      	ldrb	r1, [r4, #4]
     e42:	78e0      	ldrb	r0, [r4, #3]
     e44:	2200      	movs	r2, #0
     e46:	4b41      	ldr	r3, [pc, #260]	; (f4c <code_real+0x1c0>)
     e48:	4798      	blx	r3
                    	setAlarmDate(newalarm.day,newalarm.month,newalarm.year);
     e4a:	7822      	ldrb	r2, [r4, #0]
     e4c:	7861      	ldrb	r1, [r4, #1]
     e4e:	78a0      	ldrb	r0, [r4, #2]
     e50:	4b3f      	ldr	r3, [pc, #252]	; (f50 <code_real+0x1c4>)
     e52:	4798      	blx	r3
                    	enableAlarm(RTC_MODE2_MASK_SEL_YYMMDDHHMMSS_Val);
     e54:	2006      	movs	r0, #6
     e56:	4b3f      	ldr	r3, [pc, #252]	; (f54 <code_real+0x1c8>)
     e58:	4798      	blx	r3
                    	givendays_i -= givendays_int8;
     e5a:	b2ad      	uxth	r5, r5
                    	read_print_rtc(true,log,0);
     e5c:	2200      	movs	r2, #0
     e5e:	9902      	ldr	r1, [sp, #8]
     e60:	2001      	movs	r0, #1
     e62:	4b3d      	ldr	r3, [pc, #244]	; (f58 <code_real+0x1cc>)
     e64:	4798      	blx	r3
                	while(givendays_i > 0) {
     e66:	2d00      	cmp	r5, #0
     e68:	d1d3      	bne.n	e12 <code_real+0x86>
                	}
                				
                	eeprom_time.alarm.hour   = newalarm.hour;
     e6a:	78e2      	ldrb	r2, [r4, #3]
     e6c:	4b2e      	ldr	r3, [pc, #184]	; (f28 <code_real+0x19c>)
     e6e:	731a      	strb	r2, [r3, #12]
                	eeprom_time.alarm.minute = newalarm.minute;
     e70:	7922      	ldrb	r2, [r4, #4]
     e72:	735a      	strb	r2, [r3, #13]
                	eeprom_time.alarm.day    = newalarm.day;
     e74:	78a2      	ldrb	r2, [r4, #2]
     e76:	72da      	strb	r2, [r3, #11]
                	eeprom_time.alarm.month  = newalarm.month;
     e78:	7862      	ldrb	r2, [r4, #1]
     e7a:	729a      	strb	r2, [r3, #10]
                	eeprom_time.alarm.year   = newalarm.year;
     e7c:	7822      	ldrb	r2, [r4, #0]
     e7e:	725a      	strb	r2, [r3, #9]
                	eeprom_time.now.hour   = now.hour;
     e80:	78f2      	ldrb	r2, [r6, #3]
     e82:	71da      	strb	r2, [r3, #7]
                	eeprom_time.now.minute = now.minute;
     e84:	7932      	ldrb	r2, [r6, #4]
     e86:	721a      	strb	r2, [r3, #8]
                	eeprom_time.now.day    = now.day;
     e88:	78b2      	ldrb	r2, [r6, #2]
     e8a:	719a      	strb	r2, [r3, #6]
                	eeprom_time.now.month  = now.month;
     e8c:	7872      	ldrb	r2, [r6, #1]
     e8e:	715a      	strb	r2, [r3, #5]
                	eeprom_time.now.year   = now.year;
     e90:	7832      	ldrb	r2, [r6, #0]
     e92:	711a      	strb	r2, [r3, #4]
                } else {  // if givendays==0 stay on forever.
                	uart_puts_info("[disable alarm]");
                	disableAlarm();
            	}
            	eeprom_time.valid = true;
            	eeprom_time.seq   = givenseq;
     e94:	2309      	movs	r3, #9
     e96:	aa02      	add	r2, sp, #8
     e98:	189b      	adds	r3, r3, r2
            	eeprom_time.valid = true;
     e9a:	4823      	ldr	r0, [pc, #140]	; (f28 <code_real+0x19c>)
            	eeprom_time.seq   = givenseq;
     e9c:	781b      	ldrb	r3, [r3, #0]
            	eeprom_time.valid = true;
     e9e:	2501      	movs	r5, #1
            	eeprom_time.seq   = givenseq;
     ea0:	70c3      	strb	r3, [r0, #3]
            	eeprom_time.days  = givendays;
     ea2:	230a      	movs	r3, #10
            	eeprom_time.minutes = 0;            	
     ea4:	2400      	movs	r4, #0
            	eeprom_time.days  = givendays;
     ea6:	189b      	adds	r3, r3, r2
     ea8:	881b      	ldrh	r3, [r3, #0]
            	eeprom_time.valid = true;
     eaa:	7005      	strb	r5, [r0, #0]
            	eeprom_time.days  = givendays;
     eac:	7043      	strb	r3, [r0, #1]
            	flash_write_eeprom_time(&eeprom_time);
     eae:	4b2b      	ldr	r3, [pc, #172]	; (f5c <code_real+0x1d0>)
            	eeprom_time.minutes = 0;            	
     eb0:	7084      	strb	r4, [r0, #2]
            	flash_write_eeprom_time(&eeprom_time);
     eb2:	4798      	blx	r3
            	read_print_rtc(true,log,allowed_log_len);
     eb4:	9a03      	ldr	r2, [sp, #12]
     eb6:	9902      	ldr	r1, [sp, #8]
     eb8:	4b27      	ldr	r3, [pc, #156]	; (f58 <code_real+0x1cc>)
     eba:	0028      	movs	r0, r5
     ebc:	4798      	blx	r3
            	play_song_success();
     ebe:	4b28      	ldr	r3, [pc, #160]	; (f60 <code_real+0x1d4>)
     ec0:	4798      	blx	r3
                task_set_load(1);
     ec2:	0028      	movs	r0, r5
     ec4:	4b27      	ldr	r3, [pc, #156]	; (f64 <code_real+0x1d8>)
     ec6:	4798      	blx	r3
    int cmdstat=0;
     ec8:	0020      	movs	r0, r4
    	uart_puts_info("[decode error]");
        if(allowed_log_len>0) strcat(log,"[!decode]");
    	cmdstat=-1;
	}
    return cmdstat;
}
     eca:	b015      	add	sp, #84	; 0x54
     ecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                	uart_puts_info("[disable alarm]");
     ece:	4826      	ldr	r0, [pc, #152]	; (f68 <code_real+0x1dc>)
     ed0:	47b8      	blx	r7
                	disableAlarm();
     ed2:	4b26      	ldr	r3, [pc, #152]	; (f6c <code_real+0x1e0>)
     ed4:	4798      	blx	r3
     ed6:	e7dd      	b.n	e94 <code_real+0x108>
            	uart_puts_info("[already used]");
     ed8:	4825      	ldr	r0, [pc, #148]	; (f70 <code_real+0x1e4>)
     eda:	47b8      	blx	r7
                if(allowed_log_len>15) {                    
     edc:	9b03      	ldr	r3, [sp, #12]
     ede:	2b0f      	cmp	r3, #15
     ee0:	d802      	bhi.n	ee8 <code_real+0x15c>
    	cmdstat=-1;
     ee2:	2001      	movs	r0, #1
     ee4:	4240      	negs	r0, r0
    return cmdstat;
     ee6:	e7f0      	b.n	eca <code_real+0x13e>
                    sprintf(log,"[used,myseq=%d]",eeprom_time.seq);
     ee8:	78e2      	ldrb	r2, [r4, #3]
     eea:	4922      	ldr	r1, [pc, #136]	; (f74 <code_real+0x1e8>)
     eec:	9802      	ldr	r0, [sp, #8]
     eee:	4b22      	ldr	r3, [pc, #136]	; (f78 <code_real+0x1ec>)
     ef0:	4798      	blx	r3
     ef2:	e7f6      	b.n	ee2 <code_real+0x156>
        	uart_puts_info("[id not match]");
     ef4:	4821      	ldr	r0, [pc, #132]	; (f7c <code_real+0x1f0>)
     ef6:	47b8      	blx	r7
                if(allowed_log_len>0) strcat(log,"[!id]");
     ef8:	9b03      	ldr	r3, [sp, #12]
     efa:	4921      	ldr	r1, [pc, #132]	; (f80 <code_real+0x1f4>)
     efc:	2b00      	cmp	r3, #0
     efe:	d0f0      	beq.n	ee2 <code_real+0x156>
        if(allowed_log_len>0) strcat(log,"[!decode]");
     f00:	9802      	ldr	r0, [sp, #8]
     f02:	4b20      	ldr	r3, [pc, #128]	; (f84 <code_real+0x1f8>)
     f04:	4798      	blx	r3
     f06:	e7ec      	b.n	ee2 <code_real+0x156>
    	uart_puts_info("[decode error]");
     f08:	4b0a      	ldr	r3, [pc, #40]	; (f34 <code_real+0x1a8>)
     f0a:	481f      	ldr	r0, [pc, #124]	; (f88 <code_real+0x1fc>)
     f0c:	4798      	blx	r3
        if(allowed_log_len>0) strcat(log,"[!decode]");
     f0e:	9b03      	ldr	r3, [sp, #12]
     f10:	2b00      	cmp	r3, #0
     f12:	d0e6      	beq.n	ee2 <code_real+0x156>
     f14:	491d      	ldr	r1, [pc, #116]	; (f8c <code_real+0x200>)
     f16:	e7f3      	b.n	f00 <code_real+0x174>
     f18:	00008a2f 	.word	0x00008a2f
     f1c:	00007c65 	.word	0x00007c65
     f20:	00007b99 	.word	0x00007b99
     f24:	0000a1f9 	.word	0x0000a1f9
     f28:	20000304 	.word	0x20000304
     f2c:	0000a212 	.word	0x0000a212
     f30:	0080a00c 	.word	0x0080a00c
     f34:	00007b75 	.word	0x00007b75
     f38:	0000a222 	.word	0x0000a222
     f3c:	000003e6 	.word	0x000003e6
     f40:	00003959 	.word	0x00003959
     f44:	0000a1e9 	.word	0x0000a1e9
     f48:	00000b59 	.word	0x00000b59
     f4c:	00003d99 	.word	0x00003d99
     f50:	00003e25 	.word	0x00003e25
     f54:	00003e49 	.word	0x00003e49
     f58:	00000961 	.word	0x00000961
     f5c:	00001195 	.word	0x00001195
     f60:	0000741d 	.word	0x0000741d
     f64:	00006935 	.word	0x00006935
     f68:	0000a22d 	.word	0x0000a22d
     f6c:	00003e69 	.word	0x00003e69
     f70:	0000a23d 	.word	0x0000a23d
     f74:	0000a24c 	.word	0x0000a24c
     f78:	00008969 	.word	0x00008969
     f7c:	0000a25c 	.word	0x0000a25c
     f80:	0000a26b 	.word	0x0000a26b
     f84:	00008a01 	.word	0x00008a01
     f88:	0000a271 	.word	0x0000a271
     f8c:	0000a280 	.word	0x0000a280

00000f90 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     f90:	e7fe      	b.n	f90 <Dummy_Handler>
	...

00000f94 <Reset_Handler>:
        if (pSrc != pDest) {
     f94:	4811      	ldr	r0, [pc, #68]	; (fdc <Reset_Handler+0x48>)
     f96:	4912      	ldr	r1, [pc, #72]	; (fe0 <Reset_Handler+0x4c>)
{
     f98:	b570      	push	{r4, r5, r6, lr}
        if (pSrc != pDest) {
     f9a:	4288      	cmp	r0, r1
     f9c:	d004      	beq.n	fa8 <Reset_Handler+0x14>
     f9e:	2300      	movs	r3, #0
                for (; pDest < &_erelocate;) {
     fa0:	4c10      	ldr	r4, [pc, #64]	; (fe4 <Reset_Handler+0x50>)
     fa2:	18ca      	adds	r2, r1, r3
     fa4:	42a2      	cmp	r2, r4
     fa6:	d313      	bcc.n	fd0 <Reset_Handler+0x3c>
                *pDest++ = 0;
     fa8:	2100      	movs	r1, #0
     faa:	4b0f      	ldr	r3, [pc, #60]	; (fe8 <Reset_Handler+0x54>)
        for (pDest = &_szero; pDest < &_ezero;) {
     fac:	4a0f      	ldr	r2, [pc, #60]	; (fec <Reset_Handler+0x58>)
     fae:	4293      	cmp	r3, r2
     fb0:	d312      	bcc.n	fd8 <Reset_Handler+0x44>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     fb2:	21ff      	movs	r1, #255	; 0xff
     fb4:	4b0e      	ldr	r3, [pc, #56]	; (ff0 <Reset_Handler+0x5c>)
     fb6:	4a0f      	ldr	r2, [pc, #60]	; (ff4 <Reset_Handler+0x60>)
     fb8:	438b      	bics	r3, r1
     fba:	6093      	str	r3, [r2, #8]
        NVMCTRL->CTRLB.bit.MANW = 1;
     fbc:	2380      	movs	r3, #128	; 0x80
     fbe:	4a0e      	ldr	r2, [pc, #56]	; (ff8 <Reset_Handler+0x64>)
     fc0:	6851      	ldr	r1, [r2, #4]
     fc2:	430b      	orrs	r3, r1
     fc4:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     fc6:	4b0d      	ldr	r3, [pc, #52]	; (ffc <Reset_Handler+0x68>)
     fc8:	4798      	blx	r3
        main();
     fca:	4b0d      	ldr	r3, [pc, #52]	; (1000 <Reset_Handler+0x6c>)
     fcc:	4798      	blx	r3
     fce:	e7fe      	b.n	fce <Reset_Handler+0x3a>
                        *pDest++ = *pSrc++;
     fd0:	58c5      	ldr	r5, [r0, r3]
     fd2:	3304      	adds	r3, #4
     fd4:	6015      	str	r5, [r2, #0]
     fd6:	e7e4      	b.n	fa2 <Reset_Handler+0xe>
                *pDest++ = 0;
     fd8:	c302      	stmia	r3!, {r1}
     fda:	e7e8      	b.n	fae <Reset_Handler+0x1a>
     fdc:	0000bd10 	.word	0x0000bd10
     fe0:	20000000 	.word	0x20000000
     fe4:	200002e4 	.word	0x200002e4
     fe8:	200002e8 	.word	0x200002e8
     fec:	20000d60 	.word	0x20000d60
     ff0:	00000000 	.word	0x00000000
     ff4:	e000ed00 	.word	0xe000ed00
     ff8:	41004000 	.word	0x41004000
     ffc:	000088b5 	.word	0x000088b5
    1000:	00001a41 	.word	0x00001a41

00001004 <flash_read_eeprom_time>:
    // Read the content of "my_flash_store" into the "owner" variable
    flash_read((void *)&eeprom);
}

void flash_read_eeprom_time(Eeprom_time *data)
{
    1004:	b510      	push	{r4, lr}
    memcpy((void *)data, (const void *)&eeprom.eeprom_time, sizeof(Eeprom_time));
    1006:	220e      	movs	r2, #14
    1008:	4901      	ldr	r1, [pc, #4]	; (1010 <flash_read_eeprom_time+0xc>)
    100a:	4b02      	ldr	r3, [pc, #8]	; (1014 <flash_read_eeprom_time+0x10>)
    100c:	4798      	blx	r3
}
    100e:	bd10      	pop	{r4, pc}
    1010:	20000314 	.word	0x20000314
    1014:	00008945 	.word	0x00008945

00001018 <flash_read_eeprom_shs>:
void flash_read_eeprom_shs(Eeprom_shs *data)
{
    1018:	b510      	push	{r4, lr}
    memcpy((void *)data, (const void *)&eeprom.eeprom_shs, sizeof(Eeprom_shs));
    101a:	4903      	ldr	r1, [pc, #12]	; (1028 <flash_read_eeprom_shs+0x10>)
    101c:	2214      	movs	r2, #20
    101e:	3110      	adds	r1, #16
    1020:	4b02      	ldr	r3, [pc, #8]	; (102c <flash_read_eeprom_shs+0x14>)
    1022:	4798      	blx	r3
}
    1024:	bd10      	pop	{r4, pc}
    1026:	46c0      	nop			; (mov r8, r8)
    1028:	20000314 	.word	0x20000314
    102c:	00008945 	.word	0x00008945

00001030 <flash_read_eeprom_sim>:
void flash_read_eeprom_sim(Eeprom_sim *data)
{
    1030:	b510      	push	{r4, lr}
    memcpy((void *)data, (const void *)&eeprom.eeprom_sim, sizeof(Eeprom_sim));
    1032:	4903      	ldr	r1, [pc, #12]	; (1040 <flash_read_eeprom_sim+0x10>)
    1034:	2259      	movs	r2, #89	; 0x59
    1036:	3124      	adds	r1, #36	; 0x24
    1038:	4b02      	ldr	r3, [pc, #8]	; (1044 <flash_read_eeprom_sim+0x14>)
    103a:	4798      	blx	r3
}
    103c:	bd10      	pop	{r4, pc}
    103e:	46c0      	nop			; (mov r8, r8)
    1040:	20000314 	.word	0x20000314
    1044:	00008945 	.word	0x00008945

00001048 <flash_config>:
}


void flash_config(void) 
{
  PAGE_SIZE = pageSizes[NVMCTRL->PARAM.bit.PSZ]; // 64 bytes (SAMD11)
    1048:	490c      	ldr	r1, [pc, #48]	; (107c <flash_config+0x34>)
    104a:	4a0d      	ldr	r2, [pc, #52]	; (1080 <flash_config+0x38>)
    104c:	688b      	ldr	r3, [r1, #8]
    104e:	035b      	lsls	r3, r3, #13
    1050:	0f5b      	lsrs	r3, r3, #29
    1052:	009b      	lsls	r3, r3, #2
    1054:	589a      	ldr	r2, [r3, r2]
    1056:	4b0b      	ldr	r3, [pc, #44]	; (1084 <flash_config+0x3c>)
    1058:	601a      	str	r2, [r3, #0]
  PAGES = NVMCTRL->PARAM.bit.NVMP;               // 256 pages
    105a:	688b      	ldr	r3, [r1, #8]
    105c:	490a      	ldr	r1, [pc, #40]	; (1088 <flash_config+0x40>)
    105e:	b29b      	uxth	r3, r3
    1060:	600b      	str	r3, [r1, #0]
  MAX_FLASH = PAGE_SIZE * PAGES;                 // 16384
    1062:	4353      	muls	r3, r2
    1064:	4909      	ldr	r1, [pc, #36]	; (108c <flash_config+0x44>)
  ROW_SIZE = PAGE_SIZE * 4;                      // 256
    1066:	0092      	lsls	r2, r2, #2
  MAX_FLASH = PAGE_SIZE * PAGES;                 // 16384
    1068:	600b      	str	r3, [r1, #0]
  ROW_SIZE = PAGE_SIZE * 4;                      // 256
    106a:	4b09      	ldr	r3, [pc, #36]	; (1090 <flash_config+0x48>)
    106c:	601a      	str	r2, [r3, #0]
  FlashStorage(my_flash_addr,Eeprom);
    106e:	4a09      	ldr	r2, [pc, #36]	; (1094 <flash_config+0x4c>)
    1070:	4b09      	ldr	r3, [pc, #36]	; (1098 <flash_config+0x50>)
    1072:	601a      	str	r2, [r3, #0]
  flash_size = sizeof(Eeprom);
    1074:	2280      	movs	r2, #128	; 0x80
    1076:	4b09      	ldr	r3, [pc, #36]	; (109c <flash_config+0x54>)
    1078:	601a      	str	r2, [r3, #0]
}
    107a:	4770      	bx	lr
    107c:	41004000 	.word	0x41004000
    1080:	0000a300 	.word	0x0000a300
    1084:	200008c0 	.word	0x200008c0
    1088:	200008b8 	.word	0x200008b8
    108c:	200008b4 	.word	0x200008b4
    1090:	200008c4 	.word	0x200008c4
    1094:	0000a400 	.word	0x0000a400
    1098:	200008bc 	.word	0x200008bc
    109c:	200008c8 	.word	0x200008c8

000010a0 <flash_erase>:
  }
}

void flash_erase(const volatile void *flash_ptr)
{
	NVMCTRL->ADDR.reg = ((uint32_t)flash_ptr) / 2;
    10a0:	4b04      	ldr	r3, [pc, #16]	; (10b4 <flash_erase+0x14>)
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_ER;
    10a2:	4a05      	ldr	r2, [pc, #20]	; (10b8 <flash_erase+0x18>)
	NVMCTRL->ADDR.reg = ((uint32_t)flash_ptr) / 2;
    10a4:	0840      	lsrs	r0, r0, #1
    10a6:	61d8      	str	r0, [r3, #28]
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_ER;
    10a8:	801a      	strh	r2, [r3, #0]
	while (!NVMCTRL->INTFLAG.bit.READY) { }
    10aa:	7d1a      	ldrb	r2, [r3, #20]
    10ac:	07d2      	lsls	r2, r2, #31
    10ae:	d5fc      	bpl.n	10aa <flash_erase+0xa>
}
    10b0:	4770      	bx	lr
    10b2:	46c0      	nop			; (mov r8, r8)
    10b4:	41004000 	.word	0x41004000
    10b8:	ffffa502 	.word	0xffffa502

000010bc <flash_erase_sized>:

void flash_erase_sized(void)
{
    const volatile void *flash_ptr = flash_address;
    uint32_t size = flash_size;
    10bc:	4b08      	ldr	r3, [pc, #32]	; (10e0 <flash_erase_sized+0x24>)
{
    10be:	b570      	push	{r4, r5, r6, lr}
    uint32_t size = flash_size;
    10c0:	681d      	ldr	r5, [r3, #0]
    const uint8_t *ptr = (const uint8_t *)flash_ptr;
    10c2:	4b08      	ldr	r3, [pc, #32]	; (10e4 <flash_erase_sized+0x28>)
    10c4:	681c      	ldr	r4, [r3, #0]
    while (size > ROW_SIZE) {
    10c6:	4e08      	ldr	r6, [pc, #32]	; (10e8 <flash_erase_sized+0x2c>)
    10c8:	4b08      	ldr	r3, [pc, #32]	; (10ec <flash_erase_sized+0x30>)
    10ca:	6832      	ldr	r2, [r6, #0]
      flash_erase(ptr);
    10cc:	0020      	movs	r0, r4
    while (size > ROW_SIZE) {
    10ce:	4295      	cmp	r5, r2
    10d0:	d801      	bhi.n	10d6 <flash_erase_sized+0x1a>
      ptr += ROW_SIZE;
      size -= ROW_SIZE;
    }
    flash_erase(ptr);
    10d2:	4798      	blx	r3
}
    10d4:	bd70      	pop	{r4, r5, r6, pc}
      flash_erase(ptr);
    10d6:	4798      	blx	r3
      ptr += ROW_SIZE;
    10d8:	6833      	ldr	r3, [r6, #0]
    10da:	18e4      	adds	r4, r4, r3
      size -= ROW_SIZE;
    10dc:	1aed      	subs	r5, r5, r3
    10de:	e7f2      	b.n	10c6 <flash_erase_sized+0xa>
    10e0:	200008c8 	.word	0x200008c8
    10e4:	200008bc 	.word	0x200008bc
    10e8:	200008c4 	.word	0x200008c4
    10ec:	000010a1 	.word	0x000010a1

000010f0 <flash_write>:
{
    10f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  const volatile void *flash_ptr = flash_address;
    10f2:	4b1f      	ldr	r3, [pc, #124]	; (1170 <flash_write+0x80>)
{
    10f4:	0005      	movs	r5, r0
  const volatile void *flash_ptr = flash_address;
    10f6:	681e      	ldr	r6, [r3, #0]
  uint32_t size = flash_size;
    10f8:	4b1e      	ldr	r3, [pc, #120]	; (1174 <flash_write+0x84>)
    10fa:	681f      	ldr	r7, [r3, #0]
  flash_erase_sized();
    10fc:	4b1e      	ldr	r3, [pc, #120]	; (1178 <flash_write+0x88>)
    10fe:	4798      	blx	r3
  NVMCTRL->CTRLB.bit.MANW = 1;
    1100:	2180      	movs	r1, #128	; 0x80
    1102:	4a1e      	ldr	r2, [pc, #120]	; (117c <flash_write+0x8c>)
  size = (size + 3) / 4;
    1104:	1cfb      	adds	r3, r7, #3
  NVMCTRL->CTRLB.bit.MANW = 1;
    1106:	6850      	ldr	r0, [r2, #4]
  size = (size + 3) / 4;
    1108:	089b      	lsrs	r3, r3, #2
  NVMCTRL->CTRLB.bit.MANW = 1;
    110a:	4301      	orrs	r1, r0
    110c:	6051      	str	r1, [r2, #4]
  while (size) {
    110e:	2b00      	cmp	r3, #0
    1110:	d100      	bne.n	1114 <flash_write+0x24>
}
    1112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_PBC;
    1114:	491a      	ldr	r1, [pc, #104]	; (1180 <flash_write+0x90>)
    1116:	8011      	strh	r1, [r2, #0]
    while (NVMCTRL->INTFLAG.bit.READY == 0) { }
    1118:	7d11      	ldrb	r1, [r2, #20]
    111a:	07c9      	lsls	r1, r1, #31
    111c:	d5fc      	bpl.n	1118 <flash_write+0x28>
    for (i=0; i<(PAGE_SIZE/4) && size; i++) {
    111e:	4819      	ldr	r0, [pc, #100]	; (1184 <flash_write+0x94>)
    1120:	0019      	movs	r1, r3
    1122:	4684      	mov	ip, r0
    1124:	4667      	mov	r7, ip
    1126:	683f      	ldr	r7, [r7, #0]
    1128:	1a58      	subs	r0, r3, r1
    112a:	08bf      	lsrs	r7, r7, #2
    112c:	42b8      	cmp	r0, r7
    112e:	d201      	bcs.n	1134 <flash_write+0x44>
    1130:	2900      	cmp	r1, #0
    1132:	d106      	bne.n	1142 <flash_write+0x52>
    NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | NVMCTRL_CTRLA_CMD_WP;
    1134:	4b14      	ldr	r3, [pc, #80]	; (1188 <flash_write+0x98>)
    1136:	8013      	strh	r3, [r2, #0]
    while (NVMCTRL->INTFLAG.bit.READY == 0) { }
    1138:	7d13      	ldrb	r3, [r2, #20]
    113a:	07db      	lsls	r3, r3, #31
    113c:	d5fc      	bpl.n	1138 <flash_write+0x48>
    113e:	000b      	movs	r3, r1
    1140:	e7e5      	b.n	110e <flash_write+0x1e>
  res.u8[0] = d[0];
    1142:	27ff      	movs	r7, #255	; 0xff
    1144:	7828      	ldrb	r0, [r5, #0]
    1146:	43bc      	bics	r4, r7
    1148:	4304      	orrs	r4, r0
  res.u8[1] = d[1];
    114a:	4f10      	ldr	r7, [pc, #64]	; (118c <flash_write+0x9c>)
    114c:	7868      	ldrb	r0, [r5, #1]
    114e:	403c      	ands	r4, r7
    1150:	0200      	lsls	r0, r0, #8
    1152:	4304      	orrs	r4, r0
  res.u8[2] = d[2];
    1154:	480e      	ldr	r0, [pc, #56]	; (1190 <flash_write+0xa0>)
    1156:	78af      	ldrb	r7, [r5, #2]
    1158:	4020      	ands	r0, r4
  res.u8[3] = d[3];
    115a:	78ec      	ldrb	r4, [r5, #3]
  res.u8[2] = d[2];
    115c:	043f      	lsls	r7, r7, #16
  res.u8[3] = d[3];
    115e:	b280      	uxth	r0, r0
    1160:	0624      	lsls	r4, r4, #24
    1162:	4338      	orrs	r0, r7
    1164:	4304      	orrs	r4, r0
      *dst_addr = read_unaligned_uint32(src_addr);
    1166:	c610      	stmia	r6!, {r4}
	  src_addr += 4;
    1168:	3504      	adds	r5, #4
      size--;
    116a:	3901      	subs	r1, #1
    116c:	e7da      	b.n	1124 <flash_write+0x34>
    116e:	46c0      	nop			; (mov r8, r8)
    1170:	200008bc 	.word	0x200008bc
    1174:	200008c8 	.word	0x200008c8
    1178:	000010bd 	.word	0x000010bd
    117c:	41004000 	.word	0x41004000
    1180:	ffffa544 	.word	0xffffa544
    1184:	200008c0 	.word	0x200008c0
    1188:	ffffa504 	.word	0xffffa504
    118c:	ffff00ff 	.word	0xffff00ff
    1190:	ff00ffff 	.word	0xff00ffff

00001194 <flash_write_eeprom_time>:
{
    1194:	b570      	push	{r4, r5, r6, lr}
    1196:	0005      	movs	r5, r0
    uart_puts_info("[write flash time]");
    1198:	4b06      	ldr	r3, [pc, #24]	; (11b4 <flash_write_eeprom_time+0x20>)
    119a:	4807      	ldr	r0, [pc, #28]	; (11b8 <flash_write_eeprom_time+0x24>)
    119c:	4798      	blx	r3
    memcpy((void *)&eeprom.eeprom_time, (const void *)data, sizeof(Eeprom_time));
    119e:	4c07      	ldr	r4, [pc, #28]	; (11bc <flash_write_eeprom_time+0x28>)
    11a0:	0029      	movs	r1, r5
    11a2:	220e      	movs	r2, #14
    11a4:	0020      	movs	r0, r4
    11a6:	4b06      	ldr	r3, [pc, #24]	; (11c0 <flash_write_eeprom_time+0x2c>)
    11a8:	4798      	blx	r3
    flash_write((void *)&eeprom);
    11aa:	0020      	movs	r0, r4
    11ac:	4b05      	ldr	r3, [pc, #20]	; (11c4 <flash_write_eeprom_time+0x30>)
    11ae:	4798      	blx	r3
}
    11b0:	bd70      	pop	{r4, r5, r6, pc}
    11b2:	46c0      	nop			; (mov r8, r8)
    11b4:	00007b75 	.word	0x00007b75
    11b8:	0000a500 	.word	0x0000a500
    11bc:	20000314 	.word	0x20000314
    11c0:	00008945 	.word	0x00008945
    11c4:	000010f1 	.word	0x000010f1

000011c8 <flash_write_eeprom_shs>:
{
    11c8:	b570      	push	{r4, r5, r6, lr}
    uart_puts_info("[write flash shs]");
    11ca:	4b07      	ldr	r3, [pc, #28]	; (11e8 <flash_write_eeprom_shs+0x20>)
{
    11cc:	0005      	movs	r5, r0
    uart_puts_info("[write flash shs]");
    11ce:	4807      	ldr	r0, [pc, #28]	; (11ec <flash_write_eeprom_shs+0x24>)
    11d0:	4798      	blx	r3
    memcpy((void *)&eeprom.eeprom_shs, (const void *)data, sizeof(Eeprom_shs));
    11d2:	4c07      	ldr	r4, [pc, #28]	; (11f0 <flash_write_eeprom_shs+0x28>)
    11d4:	0029      	movs	r1, r5
    11d6:	0020      	movs	r0, r4
    11d8:	2214      	movs	r2, #20
    11da:	4b06      	ldr	r3, [pc, #24]	; (11f4 <flash_write_eeprom_shs+0x2c>)
    11dc:	3010      	adds	r0, #16
    11de:	4798      	blx	r3
    flash_write((void *)&eeprom);
    11e0:	0020      	movs	r0, r4
    11e2:	4b05      	ldr	r3, [pc, #20]	; (11f8 <flash_write_eeprom_shs+0x30>)
    11e4:	4798      	blx	r3
}
    11e6:	bd70      	pop	{r4, r5, r6, pc}
    11e8:	00007b75 	.word	0x00007b75
    11ec:	0000a513 	.word	0x0000a513
    11f0:	20000314 	.word	0x20000314
    11f4:	00008945 	.word	0x00008945
    11f8:	000010f1 	.word	0x000010f1

000011fc <flash_write_eeprom_sim>:
{
    11fc:	b570      	push	{r4, r5, r6, lr}
    uart_puts_info("[write flash sim]");
    11fe:	4b07      	ldr	r3, [pc, #28]	; (121c <flash_write_eeprom_sim+0x20>)
{
    1200:	0005      	movs	r5, r0
    uart_puts_info("[write flash sim]");
    1202:	4807      	ldr	r0, [pc, #28]	; (1220 <flash_write_eeprom_sim+0x24>)
    1204:	4798      	blx	r3
    memcpy((void *)&eeprom.eeprom_sim, (const void *)data, sizeof(Eeprom_sim));
    1206:	4c07      	ldr	r4, [pc, #28]	; (1224 <flash_write_eeprom_sim+0x28>)
    1208:	0029      	movs	r1, r5
    120a:	0020      	movs	r0, r4
    120c:	2259      	movs	r2, #89	; 0x59
    120e:	4b06      	ldr	r3, [pc, #24]	; (1228 <flash_write_eeprom_sim+0x2c>)
    1210:	3024      	adds	r0, #36	; 0x24
    1212:	4798      	blx	r3
    flash_write((void *)&eeprom);
    1214:	0020      	movs	r0, r4
    1216:	4b05      	ldr	r3, [pc, #20]	; (122c <flash_write_eeprom_sim+0x30>)
    1218:	4798      	blx	r3
}
    121a:	bd70      	pop	{r4, r5, r6, pc}
    121c:	00007b75 	.word	0x00007b75
    1220:	0000a525 	.word	0x0000a525
    1224:	20000314 	.word	0x20000314
    1228:	00008945 	.word	0x00008945
    122c:	000010f1 	.word	0x000010f1

00001230 <flash_read>:


void flash_read(void *data)
{
	const volatile void *flash_ptr = flash_address;
    1230:	4b03      	ldr	r3, [pc, #12]	; (1240 <flash_read+0x10>)
{
    1232:	b510      	push	{r4, lr}
	uint32_t size = flash_size;
	memcpy(data, (const void *)flash_ptr, size);
    1234:	6819      	ldr	r1, [r3, #0]
    1236:	4b03      	ldr	r3, [pc, #12]	; (1244 <flash_read+0x14>)
    1238:	681a      	ldr	r2, [r3, #0]
    123a:	4b03      	ldr	r3, [pc, #12]	; (1248 <flash_read+0x18>)
    123c:	4798      	blx	r3
}
    123e:	bd10      	pop	{r4, pc}
    1240:	200008bc 	.word	0x200008bc
    1244:	200008c8 	.word	0x200008c8
    1248:	00008945 	.word	0x00008945

0000124c <flash_init>:
{
    124c:	b510      	push	{r4, lr}
    flash_config();
    124e:	4b03      	ldr	r3, [pc, #12]	; (125c <flash_init+0x10>)
    1250:	4798      	blx	r3
    flash_read((void *)&eeprom);
    1252:	4803      	ldr	r0, [pc, #12]	; (1260 <flash_init+0x14>)
    1254:	4b03      	ldr	r3, [pc, #12]	; (1264 <flash_init+0x18>)
    1256:	4798      	blx	r3
}
    1258:	bd10      	pop	{r4, pc}
    125a:	46c0      	nop			; (mov r8, r8)
    125c:	00001049 	.word	0x00001049
    1260:	20000314 	.word	0x20000314
    1264:	00001231 	.word	0x00001231

00001268 <irrecv_get_irparams_rcvstate>:
volatile irparams_t irparams;
unsigned long myticks;

uint8_t irrecv_get_irparams_rcvstate(void)
{
    return irparams.rcvstate;
    1268:	4b01      	ldr	r3, [pc, #4]	; (1270 <irrecv_get_irparams_rcvstate+0x8>)
    126a:	7818      	ldrb	r0, [r3, #0]
    126c:	b2c0      	uxtb	r0, r0
}
    126e:	4770      	bx	lr
    1270:	200008cc 	.word	0x200008cc

00001274 <irrecv_reset>:

void irrecv_reset() {
    irparams.rcvstate = STATE_IDLE;
    1274:	2202      	movs	r2, #2
    1276:	4b03      	ldr	r3, [pc, #12]	; (1284 <irrecv_reset+0x10>)
    1278:	701a      	strb	r2, [r3, #0]
    irparams.rawlen = 0;    
    127a:	2200      	movs	r2, #0
    127c:	33ff      	adds	r3, #255	; 0xff
    127e:	775a      	strb	r2, [r3, #29]
}
    1280:	4770      	bx	lr
    1282:	46c0      	nop			; (mov r8, r8)
    1284:	200008cc 	.word	0x200008cc

00001288 <decodeNEC>:

// NECs have a repeat only 4 items long
long decodeNEC(decode_results *results) {
    1288:	b570      	push	{r4, r5, r6, lr}
	long data = 0;
	int offset = 1; // Skip first space
	// Initial mark
	if (!MATCH_MARK(results->rawbuf[offset], NEC_HDR_MARK)) {
    128a:	6885      	ldr	r5, [r0, #8]
long decodeNEC(decode_results *results) {
    128c:	0002      	movs	r2, r0
	if (!MATCH_MARK(results->rawbuf[offset], NEC_HDR_MARK)) {
    128e:	6869      	ldr	r1, [r5, #4]
        //uart_print(0,"bad hdr mark\r\n");
		return IRERR;
    1290:	2000      	movs	r0, #0
	if (!MATCH_MARK(results->rawbuf[offset], NEC_HDR_MARK)) {
    1292:	2987      	cmp	r1, #135	; 0x87
    1294:	d919      	bls.n	12ca <decodeNEC+0x42>
    1296:	6869      	ldr	r1, [r5, #4]
    1298:	29e4      	cmp	r1, #228	; 0xe4
    129a:	d816      	bhi.n	12ca <decodeNEC+0x42>
	}
	offset++;
	// Check for repeat
	if (irparams.rawlen == 4 &&
    129c:	4923      	ldr	r1, [pc, #140]	; (132c <decodeNEC+0xa4>)
    129e:	000c      	movs	r4, r1
    12a0:	34ff      	adds	r4, #255	; 0xff
    12a2:	7f64      	ldrb	r4, [r4, #29]
    12a4:	2c04      	cmp	r4, #4
    12a6:	d111      	bne.n	12cc <decodeNEC+0x44>
	MATCH_SPACE(results->rawbuf[offset], NEC_RPT_SPACE) &&
    12a8:	68ac      	ldr	r4, [r5, #8]
	if (irparams.rawlen == 4 &&
    12aa:	2c1f      	cmp	r4, #31
    12ac:	d90e      	bls.n	12cc <decodeNEC+0x44>
	MATCH_SPACE(results->rawbuf[offset], NEC_RPT_SPACE) &&
    12ae:	68ac      	ldr	r4, [r5, #8]
    12b0:	2c36      	cmp	r4, #54	; 0x36
    12b2:	d80b      	bhi.n	12cc <decodeNEC+0x44>
	MATCH_MARK(results->rawbuf[offset+1], NEC_BIT_MARK)) {
    12b4:	68ec      	ldr	r4, [r5, #12]
	MATCH_SPACE(results->rawbuf[offset], NEC_RPT_SPACE) &&
    12b6:	2c08      	cmp	r4, #8
    12b8:	d908      	bls.n	12cc <decodeNEC+0x44>
	MATCH_MARK(results->rawbuf[offset+1], NEC_BIT_MARK)) {
    12ba:	68ec      	ldr	r4, [r5, #12]
    12bc:	2c11      	cmp	r4, #17
    12be:	d805      	bhi.n	12cc <decodeNEC+0x44>
		results->bits = 0;
		results->value = REPEAT;
    12c0:	2301      	movs	r3, #1
		results->bits = 0;
    12c2:	6050      	str	r0, [r2, #4]
		results->value = REPEAT;
    12c4:	425b      	negs	r3, r3
		offset++;
	}
	// Success
	results->bits = NEC_BITS;
	results->value = data;
	return DECODED;
    12c6:	2001      	movs	r0, #1
	results->value = data;
    12c8:	6013      	str	r3, [r2, #0]
}
    12ca:	bd70      	pop	{r4, r5, r6, pc}
	if (irparams.rawlen < 2 * NEC_BITS + 4) {
    12cc:	31ff      	adds	r1, #255	; 0xff
    12ce:	7f49      	ldrb	r1, [r1, #29]
		return IRERR;
    12d0:	2000      	movs	r0, #0
	if (irparams.rawlen < 2 * NEC_BITS + 4) {
    12d2:	2943      	cmp	r1, #67	; 0x43
    12d4:	d9f9      	bls.n	12ca <decodeNEC+0x42>
	if (!MATCH_SPACE(results->rawbuf[offset], NEC_HDR_SPACE)) {
    12d6:	68a9      	ldr	r1, [r5, #8]
    12d8:	2941      	cmp	r1, #65	; 0x41
    12da:	d9f6      	bls.n	12ca <decodeNEC+0x42>
    12dc:	68a9      	ldr	r1, [r5, #8]
    12de:	296f      	cmp	r1, #111	; 0x6f
    12e0:	d8f3      	bhi.n	12ca <decodeNEC+0x42>
    12e2:	002c      	movs	r4, r5
    12e4:	0003      	movs	r3, r0
			data = (data << 1) | 1;
    12e6:	2601      	movs	r6, #1
    12e8:	350d      	adds	r5, #13
    12ea:	340c      	adds	r4, #12
    12ec:	35ff      	adds	r5, #255	; 0xff
		if (!MATCH_MARK(results->rawbuf[offset], NEC_BIT_MARK)) {
    12ee:	6821      	ldr	r1, [r4, #0]
    12f0:	2908      	cmp	r1, #8
    12f2:	d919      	bls.n	1328 <decodeNEC+0xa0>
    12f4:	6821      	ldr	r1, [r4, #0]
    12f6:	2911      	cmp	r1, #17
    12f8:	d816      	bhi.n	1328 <decodeNEC+0xa0>
		if (MATCH_SPACE(results->rawbuf[offset], NEC_ONE_SPACE)) {
    12fa:	6860      	ldr	r0, [r4, #4]
    12fc:	1d21      	adds	r1, r4, #4
    12fe:	2814      	cmp	r0, #20
    1300:	d90a      	bls.n	1318 <decodeNEC+0x90>
    1302:	6860      	ldr	r0, [r4, #4]
    1304:	2824      	cmp	r0, #36	; 0x24
    1306:	d807      	bhi.n	1318 <decodeNEC+0x90>
			data = (data << 1) | 1;
    1308:	005b      	lsls	r3, r3, #1
    130a:	4333      	orrs	r3, r6
    130c:	3408      	adds	r4, #8
	for (int i = 0; i < NEC_BITS; i++) {
    130e:	42ac      	cmp	r4, r5
    1310:	d1ed      	bne.n	12ee <decodeNEC+0x66>
	results->bits = NEC_BITS;
    1312:	2120      	movs	r1, #32
    1314:	6051      	str	r1, [r2, #4]
    1316:	e7d6      	b.n	12c6 <decodeNEC+0x3e>
		} else if (MATCH_SPACE(results->rawbuf[offset], NEC_ZERO_SPACE)) {
    1318:	6808      	ldr	r0, [r1, #0]
    131a:	2806      	cmp	r0, #6
    131c:	d904      	bls.n	1328 <decodeNEC+0xa0>
    131e:	6809      	ldr	r1, [r1, #0]
    1320:	290d      	cmp	r1, #13
    1322:	d801      	bhi.n	1328 <decodeNEC+0xa0>
			data <<= 1;
    1324:	005b      	lsls	r3, r3, #1
    1326:	e7f1      	b.n	130c <decodeNEC+0x84>
		return IRERR;
    1328:	2000      	movs	r0, #0
    132a:	e7ce      	b.n	12ca <decodeNEC+0x42>
    132c:	200008cc 	.word	0x200008cc

00001330 <irrecv_decode>:
// Returns 0 if no data ready, 1 if data ready.
// Results of decoding are stored in results
int irrecv_decode(decode_results *results) 
{
    long ret;
    results->rawbuf = irparams.rawbuf;
    1330:	4b0a      	ldr	r3, [pc, #40]	; (135c <irrecv_decode+0x2c>)
{
    1332:	b510      	push	{r4, lr}
    results->rawbuf = irparams.rawbuf;
    1334:	6083      	str	r3, [r0, #8]
    results->rawlen = irparams.rawlen;
    1336:	4b0a      	ldr	r3, [pc, #40]	; (1360 <irrecv_decode+0x30>)
    1338:	001a      	movs	r2, r3
    133a:	32ff      	adds	r2, #255	; 0xff
    133c:	7f52      	ldrb	r2, [r2, #29]
    133e:	60c2      	str	r2, [r0, #12]
    if(irparams.rcvstate != STATE_STOP) return IRERR;
    1340:	781a      	ldrb	r2, [r3, #0]
    1342:	2300      	movs	r3, #0
    1344:	2a05      	cmp	r2, #5
    1346:	d107      	bne.n	1358 <irrecv_decode+0x28>
    ret=decodeNEC(results);
    1348:	4b06      	ldr	r3, [pc, #24]	; (1364 <irrecv_decode+0x34>)
    134a:	4798      	blx	r3
    134c:	0004      	movs	r4, r0
    irrecv_reset();
    134e:	4b06      	ldr	r3, [pc, #24]	; (1368 <irrecv_decode+0x38>)
    1350:	4798      	blx	r3
    if(irparams.rcvstate != STATE_STOP) return IRERR;
    1352:	0023      	movs	r3, r4
    1354:	1e5c      	subs	r4, r3, #1
    1356:	41a3      	sbcs	r3, r4
    if(ret) return DECODED;
    else    return IRERR;
}
    1358:	0018      	movs	r0, r3
    135a:	bd10      	pop	{r4, pc}
    135c:	200008d0 	.word	0x200008d0
    1360:	200008cc 	.word	0x200008cc
    1364:	00001289 	.word	0x00001289
    1368:	00001275 	.word	0x00001275

0000136c <irrecv_convert>:

uint8_t irrecv_convert(uint32_t value)
{
	char ch,valid=0;
	
	switch(value) {
    136c:	4a6a      	ldr	r2, [pc, #424]	; (1518 <irrecv_convert+0x1ac>)
{
    136e:	b500      	push	{lr}
    1370:	0003      	movs	r3, r0
	switch(value) {
    1372:	4290      	cmp	r0, r2
    1374:	d100      	bne.n	1378 <irrecv_convert+0xc>
    1376:	e0ca      	b.n	150e <irrecv_convert+0x1a2>
    1378:	d900      	bls.n	137c <irrecv_convert+0x10>
    137a:	e065      	b.n	1448 <irrecv_convert+0xdc>
    137c:	4a67      	ldr	r2, [pc, #412]	; (151c <irrecv_convert+0x1b0>)
    137e:	4290      	cmp	r0, r2
    1380:	d05b      	beq.n	143a <irrecv_convert+0xce>
    1382:	d835      	bhi.n	13f0 <irrecv_convert+0x84>
    1384:	4a66      	ldr	r2, [pc, #408]	; (1520 <irrecv_convert+0x1b4>)
    1386:	4290      	cmp	r0, r2
    1388:	d100      	bne.n	138c <irrecv_convert+0x20>
    138a:	e0c2      	b.n	1512 <irrecv_convert+0x1a6>
    138c:	d817      	bhi.n	13be <irrecv_convert+0x52>
    138e:	4a65      	ldr	r2, [pc, #404]	; (1524 <irrecv_convert+0x1b8>)
    1390:	4290      	cmp	r0, r2
    1392:	d100      	bne.n	1396 <irrecv_convert+0x2a>
    1394:	e090      	b.n	14b8 <irrecv_convert+0x14c>
    1396:	d809      	bhi.n	13ac <irrecv_convert+0x40>
    1398:	4a63      	ldr	r2, [pc, #396]	; (1528 <irrecv_convert+0x1bc>)
    139a:	4290      	cmp	r0, r2
    139c:	d100      	bne.n	13a0 <irrecv_convert+0x34>
    139e:	e06b      	b.n	1478 <irrecv_convert+0x10c>
    13a0:	4a62      	ldr	r2, [pc, #392]	; (152c <irrecv_convert+0x1c0>)
    13a2:	4290      	cmp	r0, r2
    13a4:	d100      	bne.n	13a8 <irrecv_convert+0x3c>
    13a6:	e0ac      	b.n	1502 <irrecv_convert+0x196>
		ch='v'; break;
		
		case 0xFFFFFFFF: 
		ch='r'; break;
		
		default: ch='?';
    13a8:	203f      	movs	r0, #63	; 0x3f
    13aa:	e033      	b.n	1414 <irrecv_convert+0xa8>
	switch(value) {
    13ac:	4a60      	ldr	r2, [pc, #384]	; (1530 <irrecv_convert+0x1c4>)
    13ae:	4290      	cmp	r0, r2
    13b0:	d100      	bne.n	13b4 <irrecv_convert+0x48>
    13b2:	e0a2      	b.n	14fa <irrecv_convert+0x18e>
    13b4:	4a5f      	ldr	r2, [pc, #380]	; (1534 <irrecv_convert+0x1c8>)
    13b6:	4293      	cmp	r3, r2
    13b8:	d1f6      	bne.n	13a8 <irrecv_convert+0x3c>
		ch='*'; valid=1; break;
    13ba:	202a      	movs	r0, #42	; 0x2a
    13bc:	e015      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    13be:	4a5e      	ldr	r2, [pc, #376]	; (1538 <irrecv_convert+0x1cc>)
    13c0:	4290      	cmp	r0, r2
    13c2:	d100      	bne.n	13c6 <irrecv_convert+0x5a>
    13c4:	e0a3      	b.n	150e <irrecv_convert+0x1a2>
    13c6:	d808      	bhi.n	13da <irrecv_convert+0x6e>
    13c8:	4a5c      	ldr	r2, [pc, #368]	; (153c <irrecv_convert+0x1d0>)
    13ca:	4290      	cmp	r0, r2
    13cc:	d100      	bne.n	13d0 <irrecv_convert+0x64>
    13ce:	e07c      	b.n	14ca <irrecv_convert+0x15e>
    13d0:	4a5b      	ldr	r2, [pc, #364]	; (1540 <irrecv_convert+0x1d4>)
    13d2:	4293      	cmp	r3, r2
    13d4:	d1e8      	bne.n	13a8 <irrecv_convert+0x3c>
		ch='6'; valid=1; break;
    13d6:	2036      	movs	r0, #54	; 0x36
    13d8:	e007      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    13da:	4a5a      	ldr	r2, [pc, #360]	; (1544 <irrecv_convert+0x1d8>)
    13dc:	4290      	cmp	r0, r2
    13de:	d100      	bne.n	13e2 <irrecv_convert+0x76>
    13e0:	e091      	b.n	1506 <irrecv_convert+0x19a>
    13e2:	4a59      	ldr	r2, [pc, #356]	; (1548 <irrecv_convert+0x1dc>)
    13e4:	4290      	cmp	r0, r2
    13e6:	d1df      	bne.n	13a8 <irrecv_convert+0x3c>
		ch='2'; valid=1; break;
    13e8:	2032      	movs	r0, #50	; 0x32
		
		default: ch='?';
*/
	}
	if(valid==1) {
		return (0x80 | ch); // use bit 7 to identify valid
    13ea:	2380      	movs	r3, #128	; 0x80
    13ec:	4318      	orrs	r0, r3
    13ee:	e011      	b.n	1414 <irrecv_convert+0xa8>
	switch(value) {
    13f0:	4a56      	ldr	r2, [pc, #344]	; (154c <irrecv_convert+0x1e0>)
    13f2:	4290      	cmp	r0, r2
    13f4:	d100      	bne.n	13f8 <irrecv_convert+0x8c>
    13f6:	e082      	b.n	14fe <irrecv_convert+0x192>
    13f8:	d815      	bhi.n	1426 <irrecv_convert+0xba>
    13fa:	4a55      	ldr	r2, [pc, #340]	; (1550 <irrecv_convert+0x1e4>)
    13fc:	4290      	cmp	r0, r2
    13fe:	d100      	bne.n	1402 <irrecv_convert+0x96>
    1400:	e07d      	b.n	14fe <irrecv_convert+0x192>
    1402:	d808      	bhi.n	1416 <irrecv_convert+0xaa>
    1404:	4a53      	ldr	r2, [pc, #332]	; (1554 <irrecv_convert+0x1e8>)
    1406:	4290      	cmp	r0, r2
    1408:	d100      	bne.n	140c <irrecv_convert+0xa0>
    140a:	e06c      	b.n	14e6 <irrecv_convert+0x17a>
    140c:	4a52      	ldr	r2, [pc, #328]	; (1558 <irrecv_convert+0x1ec>)
		ch='v'; break;
    140e:	2076      	movs	r0, #118	; 0x76
	switch(value) {
    1410:	4293      	cmp	r3, r2
    1412:	d1c9      	bne.n	13a8 <irrecv_convert+0x3c>
	} else {
		return (uint8_t)ch;
	}
}
    1414:	bd00      	pop	{pc}
	switch(value) {
    1416:	4a51      	ldr	r2, [pc, #324]	; (155c <irrecv_convert+0x1f0>)
    1418:	4290      	cmp	r0, r2
    141a:	d076      	beq.n	150a <irrecv_convert+0x19e>
    141c:	4a50      	ldr	r2, [pc, #320]	; (1560 <irrecv_convert+0x1f4>)
    141e:	4290      	cmp	r0, r2
    1420:	d1c2      	bne.n	13a8 <irrecv_convert+0x3c>
		ch='0'; valid=1; break;
    1422:	2030      	movs	r0, #48	; 0x30
    1424:	e7e1      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    1426:	4a4f      	ldr	r2, [pc, #316]	; (1564 <irrecv_convert+0x1f8>)
    1428:	4290      	cmp	r0, r2
    142a:	d045      	beq.n	14b8 <irrecv_convert+0x14c>
    142c:	d807      	bhi.n	143e <irrecv_convert+0xd2>
    142e:	4a4e      	ldr	r2, [pc, #312]	; (1568 <irrecv_convert+0x1fc>)
    1430:	4290      	cmp	r0, r2
    1432:	d062      	beq.n	14fa <irrecv_convert+0x18e>
    1434:	4a4d      	ldr	r2, [pc, #308]	; (156c <irrecv_convert+0x200>)
    1436:	4290      	cmp	r0, r2
    1438:	d1b6      	bne.n	13a8 <irrecv_convert+0x3c>
		ch='^'; break;		
    143a:	205e      	movs	r0, #94	; 0x5e
    143c:	e7ea      	b.n	1414 <irrecv_convert+0xa8>
	switch(value) {
    143e:	4a4c      	ldr	r2, [pc, #304]	; (1570 <irrecv_convert+0x204>)
    1440:	4290      	cmp	r0, r2
    1442:	d062      	beq.n	150a <irrecv_convert+0x19e>
    1444:	4a4b      	ldr	r2, [pc, #300]	; (1574 <irrecv_convert+0x208>)
    1446:	e7e2      	b.n	140e <irrecv_convert+0xa2>
    1448:	4a4b      	ldr	r2, [pc, #300]	; (1578 <irrecv_convert+0x20c>)
    144a:	4290      	cmp	r0, r2
    144c:	d0b5      	beq.n	13ba <irrecv_convert+0x4e>
    144e:	d823      	bhi.n	1498 <irrecv_convert+0x12c>
    1450:	4a4a      	ldr	r2, [pc, #296]	; (157c <irrecv_convert+0x210>)
    1452:	4290      	cmp	r0, r2
    1454:	d047      	beq.n	14e6 <irrecv_convert+0x17a>
    1456:	d811      	bhi.n	147c <irrecv_convert+0x110>
    1458:	4a49      	ldr	r2, [pc, #292]	; (1580 <irrecv_convert+0x214>)
    145a:	4290      	cmp	r0, r2
    145c:	d035      	beq.n	14ca <irrecv_convert+0x15e>
    145e:	d804      	bhi.n	146a <irrecv_convert+0xfe>
    1460:	4a48      	ldr	r2, [pc, #288]	; (1584 <irrecv_convert+0x218>)
    1462:	4290      	cmp	r0, r2
    1464:	d0c0      	beq.n	13e8 <irrecv_convert+0x7c>
    1466:	4a48      	ldr	r2, [pc, #288]	; (1588 <irrecv_convert+0x21c>)
    1468:	e7a5      	b.n	13b6 <irrecv_convert+0x4a>
    146a:	4a48      	ldr	r2, [pc, #288]	; (158c <irrecv_convert+0x220>)
    146c:	4290      	cmp	r0, r2
    146e:	d0d8      	beq.n	1422 <irrecv_convert+0xb6>
    1470:	4a47      	ldr	r2, [pc, #284]	; (1590 <irrecv_convert+0x224>)
    1472:	4293      	cmp	r3, r2
    1474:	d000      	beq.n	1478 <irrecv_convert+0x10c>
    1476:	e797      	b.n	13a8 <irrecv_convert+0x3c>
		ch='1'; valid=1; break;
    1478:	2031      	movs	r0, #49	; 0x31
    147a:	e7b6      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    147c:	4a45      	ldr	r2, [pc, #276]	; (1594 <irrecv_convert+0x228>)
    147e:	4290      	cmp	r0, r2
    1480:	d03f      	beq.n	1502 <irrecv_convert+0x196>
    1482:	d804      	bhi.n	148e <irrecv_convert+0x122>
    1484:	4a44      	ldr	r2, [pc, #272]	; (1598 <irrecv_convert+0x22c>)
    1486:	4290      	cmp	r0, r2
    1488:	d03d      	beq.n	1506 <irrecv_convert+0x19a>
    148a:	4a44      	ldr	r2, [pc, #272]	; (159c <irrecv_convert+0x230>)
    148c:	e7a1      	b.n	13d2 <irrecv_convert+0x66>
    148e:	4a44      	ldr	r2, [pc, #272]	; (15a0 <irrecv_convert+0x234>)
    1490:	4290      	cmp	r0, r2
    1492:	d03e      	beq.n	1512 <irrecv_convert+0x1a6>
    1494:	4a43      	ldr	r2, [pc, #268]	; (15a4 <irrecv_convert+0x238>)
    1496:	e7ec      	b.n	1472 <irrecv_convert+0x106>
    1498:	4a43      	ldr	r2, [pc, #268]	; (15a8 <irrecv_convert+0x23c>)
    149a:	4290      	cmp	r0, r2
    149c:	d100      	bne.n	14a0 <irrecv_convert+0x134>
    149e:	e79a      	b.n	13d6 <irrecv_convert+0x6a>
    14a0:	d815      	bhi.n	14ce <irrecv_convert+0x162>
    14a2:	4a42      	ldr	r2, [pc, #264]	; (15ac <irrecv_convert+0x240>)
    14a4:	4290      	cmp	r0, r2
    14a6:	d034      	beq.n	1512 <irrecv_convert+0x1a6>
    14a8:	d808      	bhi.n	14bc <irrecv_convert+0x150>
    14aa:	4a41      	ldr	r2, [pc, #260]	; (15b0 <irrecv_convert+0x244>)
    14ac:	4290      	cmp	r0, r2
    14ae:	d028      	beq.n	1502 <irrecv_convert+0x196>
    14b0:	4a40      	ldr	r2, [pc, #256]	; (15b4 <irrecv_convert+0x248>)
    14b2:	4290      	cmp	r0, r2
    14b4:	d000      	beq.n	14b8 <irrecv_convert+0x14c>
    14b6:	e777      	b.n	13a8 <irrecv_convert+0x3c>
		ch='4'; valid=1; break;
    14b8:	2034      	movs	r0, #52	; 0x34
    14ba:	e796      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    14bc:	4a3e      	ldr	r2, [pc, #248]	; (15b8 <irrecv_convert+0x24c>)
    14be:	4290      	cmp	r0, r2
    14c0:	d021      	beq.n	1506 <irrecv_convert+0x19a>
    14c2:	4a3e      	ldr	r2, [pc, #248]	; (15bc <irrecv_convert+0x250>)
    14c4:	4290      	cmp	r0, r2
    14c6:	d000      	beq.n	14ca <irrecv_convert+0x15e>
    14c8:	e76e      	b.n	13a8 <irrecv_convert+0x3c>
		ch='9'; valid=1; break;
    14ca:	2039      	movs	r0, #57	; 0x39
    14cc:	e78d      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    14ce:	4a3c      	ldr	r2, [pc, #240]	; (15c0 <irrecv_convert+0x254>)
    14d0:	4290      	cmp	r0, r2
    14d2:	d014      	beq.n	14fe <irrecv_convert+0x192>
    14d4:	d809      	bhi.n	14ea <irrecv_convert+0x17e>
    14d6:	4a3b      	ldr	r2, [pc, #236]	; (15c4 <irrecv_convert+0x258>)
    14d8:	4290      	cmp	r0, r2
    14da:	d100      	bne.n	14de <irrecv_convert+0x172>
    14dc:	e784      	b.n	13e8 <irrecv_convert+0x7c>
    14de:	4a3a      	ldr	r2, [pc, #232]	; (15c8 <irrecv_convert+0x25c>)
    14e0:	4290      	cmp	r0, r2
    14e2:	d000      	beq.n	14e6 <irrecv_convert+0x17a>
    14e4:	e760      	b.n	13a8 <irrecv_convert+0x3c>
		ch='8'; valid=1; break;
    14e6:	2038      	movs	r0, #56	; 0x38
    14e8:	e77f      	b.n	13ea <irrecv_convert+0x7e>
	switch(value) {
    14ea:	4a38      	ldr	r2, [pc, #224]	; (15cc <irrecv_convert+0x260>)
    14ec:	4290      	cmp	r0, r2
    14ee:	d098      	beq.n	1422 <irrecv_convert+0xb6>
		ch='r'; break;
    14f0:	2072      	movs	r0, #114	; 0x72
	switch(value) {
    14f2:	3301      	adds	r3, #1
    14f4:	d100      	bne.n	14f8 <irrecv_convert+0x18c>
    14f6:	e78d      	b.n	1414 <irrecv_convert+0xa8>
    14f8:	e756      	b.n	13a8 <irrecv_convert+0x3c>
		ch='<'; break;		
    14fa:	203c      	movs	r0, #60	; 0x3c
    14fc:	e78a      	b.n	1414 <irrecv_convert+0xa8>
		ch='5'; valid=1; break;
    14fe:	2035      	movs	r0, #53	; 0x35
    1500:	e773      	b.n	13ea <irrecv_convert+0x7e>
		ch='7'; valid=1; break;
    1502:	2037      	movs	r0, #55	; 0x37
    1504:	e771      	b.n	13ea <irrecv_convert+0x7e>
		ch='#'; valid=1; break;		
    1506:	2023      	movs	r0, #35	; 0x23
    1508:	e76f      	b.n	13ea <irrecv_convert+0x7e>
		ch='!'; break;		
    150a:	2021      	movs	r0, #33	; 0x21
    150c:	e782      	b.n	1414 <irrecv_convert+0xa8>
		ch='>'; break;		
    150e:	203e      	movs	r0, #62	; 0x3e
    1510:	e780      	b.n	1414 <irrecv_convert+0xa8>
		ch='3'; valid=1; break;
    1512:	2033      	movs	r0, #51	; 0x33
    1514:	e769      	b.n	13ea <irrecv_convert+0x7e>
    1516:	46c0      	nop			; (mov r8, r8)
    1518:	00ff5aa5 	.word	0x00ff5aa5
    151c:	00fd8877 	.word	0x00fd8877
    1520:	00fd40bf 	.word	0x00fd40bf
    1524:	00fd20df 	.word	0x00fd20df
    1528:	00fd00ff 	.word	0x00fd00ff
    152c:	00fd10ef 	.word	0x00fd10ef
    1530:	00fd28d7 	.word	0x00fd28d7
    1534:	00fd30cf 	.word	0x00fd30cf
    1538:	00fd6897 	.word	0x00fd6897
    153c:	00fd50af 	.word	0x00fd50af
    1540:	00fd609f 	.word	0x00fd609f
    1544:	00fd708f 	.word	0x00fd708f
    1548:	00fd807f 	.word	0x00fd807f
    154c:	00ff02fd 	.word	0x00ff02fd
    1550:	00fda05f 	.word	0x00fda05f
    1554:	00fd906f 	.word	0x00fd906f
    1558:	00fd9867 	.word	0x00fd9867
    155c:	00fda857 	.word	0x00fda857
    1560:	00fdb04f 	.word	0x00fdb04f
    1564:	00ff22dd 	.word	0x00ff22dd
    1568:	00ff10ef 	.word	0x00ff10ef
    156c:	00ff18e7 	.word	0x00ff18e7
    1570:	00ff38c7 	.word	0x00ff38c7
    1574:	00ff4ab5 	.word	0x00ff4ab5
    1578:	10ed08f7 	.word	0x10ed08f7
    157c:	00ffa857 	.word	0x00ffa857
    1580:	00ff906f 	.word	0x00ff906f
    1584:	00ff629d 	.word	0x00ff629d
    1588:	00ff6897 	.word	0x00ff6897
    158c:	00ff9867 	.word	0x00ff9867
    1590:	00ffa25d 	.word	0x00ffa25d
    1594:	00ffe01f 	.word	0x00ffe01f
    1598:	00ffb04f 	.word	0x00ffb04f
    159c:	00ffc23d 	.word	0x00ffc23d
    15a0:	00ffe21d 	.word	0x00ffe21d
    15a4:	10ed00ff 	.word	0x10ed00ff
    15a8:	10ed609f 	.word	0x10ed609f
    15ac:	10ed40bf 	.word	0x10ed40bf
    15b0:	10ed10ef 	.word	0x10ed10ef
    15b4:	10ed20df 	.word	0x10ed20df
    15b8:	10ed48b7 	.word	0x10ed48b7
    15bc:	10ed50af 	.word	0x10ed50af
    15c0:	10eda05f 	.word	0x10eda05f
    15c4:	10ed807f 	.word	0x10ed807f
    15c8:	10ed906f 	.word	0x10ed906f
    15cc:	10edb04f 	.word	0x10edb04f

000015d0 <TC1_Handler>:

void TC1_Handler(void)
{
    15d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (TC1->COUNT16.INTFLAG.reg & TC_INTFLAG_MC(1)) {
    15d2:	4d2e      	ldr	r5, [pc, #184]	; (168c <TC1_Handler+0xbc>)
    15d4:	7bab      	ldrb	r3, [r5, #14]
    15d6:	06db      	lsls	r3, r3, #27
    15d8:	d53a      	bpl.n	1650 <TC1_Handler+0x80>
HAL_GPIO_PIN(SCC_SCL,   A, 9)

HAL_GPIO_PIN(OLED_SCL,  A, 23)
HAL_GPIO_PIN(OLED_SDA,  A, 22)

HAL_GPIO_PIN(RC_PIN,    A, 16)
    15da:	4b2d      	ldr	r3, [pc, #180]	; (1690 <TC1_Handler+0xc0>)
#if (MASTER_PCB_v32==0)
        //HAL_GPIO_LED_RED_write(irdata);
        HAL_GPIO_LED_RED_clr();
#endif
    
        myticks++;
    15dc:	4e2d      	ldr	r6, [pc, #180]	; (1694 <TC1_Handler+0xc4>)
    15de:	6a1a      	ldr	r2, [r3, #32]
    15e0:	2380      	movs	r3, #128	; 0x80
    15e2:	025b      	lsls	r3, r3, #9
    15e4:	401a      	ands	r2, r3
    15e6:	6833      	ldr	r3, [r6, #0]
    15e8:	1c5c      	adds	r4, r3, #1
        if (irparams.rawlen >= RAWBUF) {
    15ea:	4b2b      	ldr	r3, [pc, #172]	; (1698 <TC1_Handler+0xc8>)
        myticks++;
    15ec:	6034      	str	r4, [r6, #0]
        if (irparams.rawlen >= RAWBUF) {
    15ee:	0019      	movs	r1, r3
    15f0:	31ff      	adds	r1, #255	; 0xff
    15f2:	7f49      	ldrb	r1, [r1, #29]
    15f4:	2945      	cmp	r1, #69	; 0x45
    15f6:	d901      	bls.n	15fc <TC1_Handler+0x2c>
            // Buffer overflow
            irparams.rcvstate = STATE_STOP;
    15f8:	2105      	movs	r1, #5
    15fa:	7019      	strb	r1, [r3, #0]
        }
        switch(irparams.rcvstate) {
    15fc:	7818      	ldrb	r0, [r3, #0]
    15fe:	3802      	subs	r0, #2
    1600:	2803      	cmp	r0, #3
    1602:	d823      	bhi.n	164c <TC1_Handler+0x7c>
    1604:	f006 fcac 	bl	7f60 <__gnu_thumb1_case_uqi>
    1608:	35251202 	.word	0x35251202
          case STATE_IDLE: // In the middle of a gap
            if (irdata == MARK) {                
    160c:	2a00      	cmp	r2, #0
    160e:	d11d      	bne.n	164c <TC1_Handler+0x7c>
                // gap just ended, record duration and start recording transmission
                irparams.rawlen = 0;
    1610:	0018      	movs	r0, r3
    1612:	30ff      	adds	r0, #255	; 0xff
    1614:	7742      	strb	r2, [r0, #29]
                irparams.rawbuf[irparams.rawlen++] = myticks;
    1616:	7f41      	ldrb	r1, [r0, #29]
    1618:	b2c9      	uxtb	r1, r1
    161a:	1c4f      	adds	r7, r1, #1
    161c:	b2ff      	uxtb	r7, r7
    161e:	7747      	strb	r7, [r0, #29]
                irparams.rcvstate = STATE_SPACE;
            }
            break;
          case STATE_SPACE: // timing SPACE
            if (irdata == MARK) { // SPACE just ended, record it
                irparams.rawbuf[irparams.rawlen++] = myticks;
    1620:	0089      	lsls	r1, r1, #2
    1622:	1859      	adds	r1, r3, r1
    1624:	604c      	str	r4, [r1, #4]
                myticks = 0;
    1626:	6032      	str	r2, [r6, #0]
                irparams.rcvstate = STATE_MARK;
    1628:	3203      	adds	r2, #3
    162a:	e00e      	b.n	164a <TC1_Handler+0x7a>
            if (irdata == SPACE) {   // MARK ended, record time
    162c:	2a00      	cmp	r2, #0
    162e:	d00d      	beq.n	164c <TC1_Handler+0x7c>
                irparams.rawbuf[irparams.rawlen++] = myticks;
    1630:	0018      	movs	r0, r3
    1632:	30ff      	adds	r0, #255	; 0xff
    1634:	7f42      	ldrb	r2, [r0, #29]
    1636:	b2d2      	uxtb	r2, r2
    1638:	1c51      	adds	r1, r2, #1
    163a:	0092      	lsls	r2, r2, #2
    163c:	189a      	adds	r2, r3, r2
    163e:	b2c9      	uxtb	r1, r1
    1640:	7741      	strb	r1, [r0, #29]
    1642:	6054      	str	r4, [r2, #4]
                myticks = 0;
    1644:	2200      	movs	r2, #0
    1646:	6032      	str	r2, [r6, #0]
                irparams.rcvstate = STATE_SPACE;
    1648:	3204      	adds	r2, #4
                irparams.rcvstate = STATE_MARK;
    164a:	701a      	strb	r2, [r3, #0]
            if (irdata == MARK) { // reset gap timer                  
                myticks = 0;                
            }             
            break;
        }
        TC1->COUNT16.INTFLAG.reg = TC_INTFLAG_MC(1);
    164c:	2310      	movs	r3, #16
    164e:	73ab      	strb	r3, [r5, #14]
    }
}
    1650:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (irdata == MARK) { // SPACE just ended, record it
    1652:	2a00      	cmp	r2, #0
    1654:	d107      	bne.n	1666 <TC1_Handler+0x96>
                irparams.rawbuf[irparams.rawlen++] = myticks;
    1656:	001f      	movs	r7, r3
    1658:	37ff      	adds	r7, #255	; 0xff
    165a:	7f79      	ldrb	r1, [r7, #29]
    165c:	b2c9      	uxtb	r1, r1
    165e:	1c48      	adds	r0, r1, #1
    1660:	b2c0      	uxtb	r0, r0
    1662:	7778      	strb	r0, [r7, #29]
    1664:	e7dc      	b.n	1620 <TC1_Handler+0x50>
                if (myticks > GAP_TICKS) {
    1666:	22c8      	movs	r2, #200	; 0xc8
    1668:	00d2      	lsls	r2, r2, #3
    166a:	4294      	cmp	r4, r2
    166c:	d9ee      	bls.n	164c <TC1_Handler+0x7c>
                    irparams.rcvstate = STATE_STOP;                                        
    166e:	2205      	movs	r2, #5
    1670:	e7eb      	b.n	164a <TC1_Handler+0x7a>
            TC1->COUNT16.CTRLA.reg &= ~(TC_CTRLA_ENABLE);
    1672:	2102      	movs	r1, #2
    1674:	882b      	ldrh	r3, [r5, #0]
    1676:	438b      	bics	r3, r1

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    1678:	2180      	movs	r1, #128	; 0x80
    167a:	802b      	strh	r3, [r5, #0]
    167c:	4b07      	ldr	r3, [pc, #28]	; (169c <TC1_Handler+0xcc>)
    167e:	01c9      	lsls	r1, r1, #7
    1680:	67d9      	str	r1, [r3, #124]	; 0x7c
            if (irdata == MARK) { // reset gap timer                  
    1682:	2a00      	cmp	r2, #0
    1684:	d1e2      	bne.n	164c <TC1_Handler+0x7c>
                myticks = 0;                
    1686:	6032      	str	r2, [r6, #0]
    1688:	e7e0      	b.n	164c <TC1_Handler+0x7c>
    168a:	46c0      	nop			; (mov r8, r8)
    168c:	42002400 	.word	0x42002400
    1690:	41004400 	.word	0x41004400
    1694:	200009ec 	.word	0x200009ec
    1698:	200008cc 	.word	0x200008cc
    169c:	e000e104 	.word	0xe000e104

000016a0 <irrecv_init>:
        //NVIC_EnableIRQ(TC1_IRQn);
    }    
}

void irrecv_init(int8_t onoff)
{    
    16a0:	b570      	push	{r4, r5, r6, lr}
    16a2:	2580      	movs	r5, #128	; 0x80
    16a4:	2202      	movs	r2, #2
    16a6:	4c16      	ldr	r4, [pc, #88]	; (1700 <irrecv_init+0x60>)
    16a8:	4b16      	ldr	r3, [pc, #88]	; (1704 <irrecv_init+0x64>)
    16aa:	026d      	lsls	r5, r5, #9
    16ac:	6065      	str	r5, [r4, #4]
    16ae:	7819      	ldrb	r1, [r3, #0]
    16b0:	430a      	orrs	r2, r1
    16b2:	701a      	strb	r2, [r3, #0]
    16b4:	2204      	movs	r2, #4
    16b6:	7819      	ldrb	r1, [r3, #0]
    16b8:	4391      	bics	r1, r2
    16ba:	7019      	strb	r1, [r3, #0]
    16bc:	61a5      	str	r5, [r4, #24]
    16be:	7819      	ldrb	r1, [r3, #0]
    16c0:	430a      	orrs	r2, r1
    16c2:	701a      	strb	r2, [r3, #0]
    16c4:	4b10      	ldr	r3, [pc, #64]	; (1708 <irrecv_init+0x68>)
    if(onoff==0) {
    16c6:	2800      	cmp	r0, #0
    16c8:	d106      	bne.n	16d8 <irrecv_init+0x38>
        PM->APBCMASK.reg &= ~PM_APBCMASK_TC1;
    16ca:	6a1a      	ldr	r2, [r3, #32]
    16cc:	490f      	ldr	r1, [pc, #60]	; (170c <irrecv_init+0x6c>)
    16ce:	400a      	ands	r2, r1
    16d0:	621a      	str	r2, [r3, #32]
    HAL_GPIO_RC_PIN_in();
    HAL_GPIO_RC_PIN_pullup();
    timer1_init(onoff);
    irrecv_reset();
    16d2:	4b0f      	ldr	r3, [pc, #60]	; (1710 <irrecv_init+0x70>)
    16d4:	4798      	blx	r3
}
    16d6:	bd70      	pop	{r4, r5, r6, pc}
        PM->APBCMASK.reg |= PM_APBCMASK_TC1;
    16d8:	2280      	movs	r2, #128	; 0x80
    16da:	6a19      	ldr	r1, [r3, #32]
    16dc:	0092      	lsls	r2, r2, #2
    16de:	430a      	orrs	r2, r1
    16e0:	621a      	str	r2, [r3, #32]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(TC1_GCLK_ID) |
    16e2:	4a0c      	ldr	r2, [pc, #48]	; (1714 <irrecv_init+0x74>)
    16e4:	4b0c      	ldr	r3, [pc, #48]	; (1718 <irrecv_init+0x78>)
        TC1->COUNT16.CC[0].reg = 48; // 20kHz
    16e6:	2130      	movs	r1, #48	; 0x30
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(TC1_GCLK_ID) |
    16e8:	805a      	strh	r2, [r3, #2]
        TC1->COUNT16.CTRLA.reg = TC_CTRLA_MODE_COUNT16 | TC_CTRLA_WAVEGEN_MFRQ |
    16ea:	4b0c      	ldr	r3, [pc, #48]	; (171c <irrecv_init+0x7c>)
    16ec:	4a0c      	ldr	r2, [pc, #48]	; (1720 <irrecv_init+0x80>)
    16ee:	801a      	strh	r2, [r3, #0]
        TC1->COUNT16.COUNT.reg = 0;
    16f0:	2200      	movs	r2, #0
    16f2:	821a      	strh	r2, [r3, #16]
        TC1->COUNT16.CC[0].reg = 48; // 20kHz
    16f4:	8319      	strh	r1, [r3, #24]
        TC1->COUNT16.COUNT.reg = 0;
    16f6:	821a      	strh	r2, [r3, #16]
        TC1->COUNT16.INTENSET.reg = TC_INTENSET_MC(1);
    16f8:	3210      	adds	r2, #16
    16fa:	735a      	strb	r2, [r3, #13]
    16fc:	e7e9      	b.n	16d2 <irrecv_init+0x32>
    16fe:	46c0      	nop			; (mov r8, r8)
    1700:	41004400 	.word	0x41004400
    1704:	41004450 	.word	0x41004450
    1708:	40000400 	.word	0x40000400
    170c:	fffffdff 	.word	0xfffffdff
    1710:	00001275 	.word	0x00001275
    1714:	00004013 	.word	0x00004013
    1718:	40000c00 	.word	0x40000c00
    171c:	42002400 	.word	0x42002400
    1720:	00002320 	.word	0x00002320

00001724 <SYSCTRL_Handler>:

void all_init(int8_t onoff);

void SYSCTRL_Handler(void)
{
    if(SYSCTRL->INTFLAG.bit.BOD33DET) {
    1724:	4b05      	ldr	r3, [pc, #20]	; (173c <SYSCTRL_Handler+0x18>)
    1726:	689a      	ldr	r2, [r3, #8]
    1728:	0552      	lsls	r2, r2, #21
    172a:	d505      	bpl.n	1738 <SYSCTRL_Handler+0x14>
        bod33_tripped=1;//=SYSCTRL->INTFLAG.reg;
    172c:	2101      	movs	r1, #1
    172e:	4a04      	ldr	r2, [pc, #16]	; (1740 <SYSCTRL_Handler+0x1c>)
    1730:	7011      	strb	r1, [r2, #0]
        //bod33_det=SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_BOD33DET;
        SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33DET; // clear interrupt  
    1732:	2280      	movs	r2, #128	; 0x80
    1734:	00d2      	lsls	r2, r2, #3
    1736:	609a      	str	r2, [r3, #8]
        //HAL_GPIO_KEYPAD6_toggle();
    }    
}
    1738:	4770      	bx	lr
    173a:	46c0      	nop			; (mov r8, r8)
    173c:	40000800 	.word	0x40000800
    1740:	20000cc6 	.word	0x20000cc6

00001744 <print_prompt>:
        uart_print(0,">>> bod33 ok wakeup <<<\n\r");   
    }      
}

void print_prompt(void)
{
    1744:	b510      	push	{r4, lr}
    uart_puts("\n\rCMD> ");	
    1746:	4802      	ldr	r0, [pc, #8]	; (1750 <print_prompt+0xc>)
    1748:	4b02      	ldr	r3, [pc, #8]	; (1754 <print_prompt+0x10>)
    174a:	4798      	blx	r3
}
    174c:	bd10      	pop	{r4, pc}
    174e:	46c0      	nop			; (mov r8, r8)
    1750:	0000a537 	.word	0x0000a537
    1754:	00007b5d 	.word	0x00007b5d

00001758 <addchar>:

char addchar(char c)
{
	char buf[2]={0,0};
    1758:	2300      	movs	r3, #0
{
    175a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char buf[2]={0,0};
    175c:	af01      	add	r7, sp, #4
{
    175e:	0004      	movs	r4, r0
	char buf[2]={0,0};
    1760:	707b      	strb	r3, [r7, #1]
	buf[0]=c;
    1762:	7038      	strb	r0, [r7, #0]
	
	if(buf[0]=='*') {
    1764:	282a      	cmp	r0, #42	; 0x2a
    1766:	d108      	bne.n	177a <addchar+0x22>
		data_receive_idx=0;
    1768:	4a13      	ldr	r2, [pc, #76]	; (17b8 <addchar+0x60>)
    176a:	6013      	str	r3, [r2, #0]
	    play_song_error();
	    //data_receive_idx=0;
	    return ' ';
	}
	
	if(data_receive_idx>80) {
    176c:	4d12      	ldr	r5, [pc, #72]	; (17b8 <addchar+0x60>)
    176e:	682b      	ldr	r3, [r5, #0]
    1770:	2b50      	cmp	r3, #80	; 0x50
    1772:	dd16      	ble.n	17a2 <addchar+0x4a>
	    data_receive_idx=0;
    1774:	2300      	movs	r3, #0
    1776:	602b      	str	r3, [r5, #0]
    1778:	e010      	b.n	179c <addchar+0x44>
	} else if(buf[0]=='#' && rxbuf[0]=='*') {
    177a:	2823      	cmp	r0, #35	; 0x23
    177c:	d107      	bne.n	178e <addchar+0x36>
    177e:	4b0f      	ldr	r3, [pc, #60]	; (17bc <addchar+0x64>)
    1780:	781b      	ldrb	r3, [r3, #0]
    1782:	2b2a      	cmp	r3, #42	; 0x2a
    1784:	d103      	bne.n	178e <addchar+0x36>
	    usart_rx_ready=true;
    1786:	2201      	movs	r2, #1
    1788:	4b0b      	ldr	r3, [pc, #44]	; (17b8 <addchar+0x60>)
    178a:	711a      	strb	r2, [r3, #4]
    178c:	e7ee      	b.n	176c <addchar+0x14>
	} else if(!is_digit(buf[0])) {
    178e:	0020      	movs	r0, r4
    1790:	4b0b      	ldr	r3, [pc, #44]	; (17c0 <addchar+0x68>)
    1792:	4798      	blx	r3
    1794:	2800      	cmp	r0, #0
    1796:	d1e9      	bne.n	176c <addchar+0x14>
	    play_song_error();
    1798:	4b0a      	ldr	r3, [pc, #40]	; (17c4 <addchar+0x6c>)
    179a:	4798      	blx	r3
	    return ' ';
    179c:	2420      	movs	r4, #32
	play_toneC();	
	
	strcpy(&rxbuf[data_receive_idx],buf);
	data_receive_idx++;
	return c;
}
    179e:	0020      	movs	r0, r4
    17a0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	play_toneC();	
    17a2:	4b09      	ldr	r3, [pc, #36]	; (17c8 <addchar+0x70>)
    17a4:	4798      	blx	r3
	strcpy(&rxbuf[data_receive_idx],buf);
    17a6:	682e      	ldr	r6, [r5, #0]
    17a8:	4804      	ldr	r0, [pc, #16]	; (17bc <addchar+0x64>)
    17aa:	0039      	movs	r1, r7
    17ac:	1830      	adds	r0, r6, r0
    17ae:	4b07      	ldr	r3, [pc, #28]	; (17cc <addchar+0x74>)
	data_receive_idx++;
    17b0:	3601      	adds	r6, #1
	strcpy(&rxbuf[data_receive_idx],buf);
    17b2:	4798      	blx	r3
	data_receive_idx++;
    17b4:	602e      	str	r6, [r5, #0]
	return c;
    17b6:	e7f2      	b.n	179e <addchar+0x46>
    17b8:	20000394 	.word	0x20000394
    17bc:	200009f0 	.word	0x200009f0
    17c0:	00007c1d 	.word	0x00007c1d
    17c4:	000074ed 	.word	0x000074ed
    17c8:	00007555 	.word	0x00007555
    17cc:	00008a2f 	.word	0x00008a2f

000017d0 <unused_init>:
HAL_GPIO_PIN(SIM_UART_RX,   A, 11)

HAL_GPIO_PIN(SIM_CTS_PIN,   A, 3)
HAL_GPIO_PIN(SIM_STATUS_PIN,A, 5)

HAL_GPIO_PIN(DOORSW_PIN,A, 4)
    17d0:	4b2a      	ldr	r3, [pc, #168]	; (187c <unused_init+0xac>)

void unused_init(void)
{
    17d2:	b530      	push	{r4, r5, lr}
    17d4:	0019      	movs	r1, r3
    17d6:	2510      	movs	r5, #16
    17d8:	2202      	movs	r2, #2
    17da:	605d      	str	r5, [r3, #4]
    17dc:	3144      	adds	r1, #68	; 0x44
    17de:	7808      	ldrb	r0, [r1, #0]
    17e0:	4310      	orrs	r0, r2
    17e2:	7008      	strb	r0, [r1, #0]
    17e4:	2004      	movs	r0, #4
    17e6:	780c      	ldrb	r4, [r1, #0]
    17e8:	4384      	bics	r4, r0
    17ea:	700c      	strb	r4, [r1, #0]
    17ec:	619d      	str	r5, [r3, #24]
    17ee:	780c      	ldrb	r4, [r1, #0]
HAL_GPIO_PIN(EXT_UART_TX,A, 14)
HAL_GPIO_PIN(EXT_UART_RX,A, 15)
HAL_GPIO_PIN(KEYPAD1,A, 18)
    17f0:	001d      	movs	r5, r3
HAL_GPIO_PIN(DOORSW_PIN,A, 4)
    17f2:	4304      	orrs	r4, r0
    17f4:	700c      	strb	r4, [r1, #0]
HAL_GPIO_PIN(KEYPAD1,A, 18)
    17f6:	2480      	movs	r4, #128	; 0x80
    17f8:	02e4      	lsls	r4, r4, #11
    17fa:	609c      	str	r4, [r3, #8]
    17fc:	3552      	adds	r5, #82	; 0x52
    17fe:	7829      	ldrb	r1, [r5, #0]
HAL_GPIO_PIN(EXT_UART_TX,A, 14)
    1800:	3d04      	subs	r5, #4
HAL_GPIO_PIN(KEYPAD1,A, 18)
    1802:	4311      	orrs	r1, r2
    1804:	7129      	strb	r1, [r5, #4]
    1806:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(KEYPAD2,A, 19)
    1808:	2480      	movs	r4, #128	; 0x80
    180a:	0324      	lsls	r4, r4, #12
    180c:	609c      	str	r4, [r3, #8]
    180e:	7969      	ldrb	r1, [r5, #5]
    1810:	4311      	orrs	r1, r2
    1812:	7169      	strb	r1, [r5, #5]
    1814:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(KEYPAD3,A, 24)
    1816:	2480      	movs	r4, #128	; 0x80
    1818:	0464      	lsls	r4, r4, #17
    181a:	609c      	str	r4, [r3, #8]
    181c:	7aa9      	ldrb	r1, [r5, #10]
    181e:	4311      	orrs	r1, r2
    1820:	72a9      	strb	r1, [r5, #10]
    1822:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(KEYPAD4,A, 25)
    1824:	2480      	movs	r4, #128	; 0x80
    1826:	04a4      	lsls	r4, r4, #18
    1828:	609c      	str	r4, [r3, #8]
    182a:	7ae9      	ldrb	r1, [r5, #11]
    182c:	4311      	orrs	r1, r2
    182e:	72e9      	strb	r1, [r5, #11]
    1830:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(KEYPAD5,A, 27)
    1832:	2480      	movs	r4, #128	; 0x80
    1834:	0524      	lsls	r4, r4, #20
    1836:	609c      	str	r4, [r3, #8]
    1838:	7b69      	ldrb	r1, [r5, #13]
    183a:	4311      	orrs	r1, r2
    183c:	7369      	strb	r1, [r5, #13]
    183e:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(KEYPAD6,A, 28)
    1840:	2480      	movs	r4, #128	; 0x80
    1842:	0564      	lsls	r4, r4, #21
    1844:	609c      	str	r4, [r3, #8]
    1846:	7ba9      	ldrb	r1, [r5, #14]
    1848:	4311      	orrs	r1, r2
    184a:	73a9      	strb	r1, [r5, #14]
    184c:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(EXT_UART_TX,A, 14)
    184e:	2480      	movs	r4, #128	; 0x80
    1850:	01e4      	lsls	r4, r4, #7
    1852:	609c      	str	r4, [r3, #8]
    1854:	7829      	ldrb	r1, [r5, #0]
    1856:	4311      	orrs	r1, r2
    1858:	7029      	strb	r1, [r5, #0]
    185a:	615c      	str	r4, [r3, #20]
HAL_GPIO_PIN(EXT_UART_RX,A, 15)
    185c:	2480      	movs	r4, #128	; 0x80
    185e:	0019      	movs	r1, r3
    1860:	0224      	lsls	r4, r4, #8
    1862:	605c      	str	r4, [r3, #4]
    1864:	314f      	adds	r1, #79	; 0x4f
    1866:	780d      	ldrb	r5, [r1, #0]
    1868:	432a      	orrs	r2, r5
    186a:	700a      	strb	r2, [r1, #0]
    186c:	780a      	ldrb	r2, [r1, #0]
    186e:	4382      	bics	r2, r0
    1870:	700a      	strb	r2, [r1, #0]
    1872:	619c      	str	r4, [r3, #24]
    1874:	780b      	ldrb	r3, [r1, #0]
    1876:	4318      	orrs	r0, r3
    1878:	7008      	strb	r0, [r1, #0]
  
  HAL_GPIO_EXT_UART_TX_out();
  HAL_GPIO_EXT_UART_TX_clr();
  HAL_GPIO_EXT_UART_RX_in();
  HAL_GPIO_EXT_UART_RX_pullup();    
}
    187a:	bd30      	pop	{r4, r5, pc}
    187c:	41004400 	.word	0x41004400

00001880 <show_intro_text>:

void show_intro_text(void)
{    
    1880:	b510      	push	{r4, lr}
    uart_print(0,"Kamworks SHS Master\n\rVersion=%d.%02d\n\r",VERSION,SUBVERSION);
    1882:	2301      	movs	r3, #1
    1884:	4c15      	ldr	r4, [pc, #84]	; (18dc <show_intro_text+0x5c>)
    1886:	2207      	movs	r2, #7
    1888:	4915      	ldr	r1, [pc, #84]	; (18e0 <show_intro_text+0x60>)
    188a:	2000      	movs	r0, #0
    188c:	47a0      	blx	r4
    uart_print(0,"RCAUSE=0x%x\n\r",rcause);
    188e:	4b15      	ldr	r3, [pc, #84]	; (18e4 <show_intro_text+0x64>)
    1890:	4915      	ldr	r1, [pc, #84]	; (18e8 <show_intro_text+0x68>)
    1892:	781a      	ldrb	r2, [r3, #0]
    1894:	2000      	movs	r0, #0
    1896:	47a0      	blx	r4
#if (TESTING==1)
    uart_print(0,"TESTING\n\r");
    1898:	4914      	ldr	r1, [pc, #80]	; (18ec <show_intro_text+0x6c>)
    189a:	2000      	movs	r0, #0
    189c:	47a0      	blx	r4
#endif

    uart_print(0,"\n\rChipID:");
    189e:	4914      	ldr	r1, [pc, #80]	; (18f0 <show_intro_text+0x70>)
    18a0:	2000      	movs	r0, #0
    18a2:	47a0      	blx	r4
    print_myid();
    18a4:	4b13      	ldr	r3, [pc, #76]	; (18f4 <show_intro_text+0x74>)
    18a6:	4798      	blx	r3
  
    uart_print(0,"\nHelp: *code#\n\rcode=1: read id\n\rcode=2: remaining days\n\rcode=5: read RTC\n\r");
    18a8:	4913      	ldr	r1, [pc, #76]	; (18f8 <show_intro_text+0x78>)
    18aa:	2000      	movs	r0, #0
    18ac:	47a0      	blx	r4
    uart_print(0,"code=10: info OFF, code=11: info ON\n\r");
    18ae:	4913      	ldr	r1, [pc, #76]	; (18fc <show_intro_text+0x7c>)
    18b0:	2000      	movs	r0, #0
    18b2:	47a0      	blx	r4
    uart_print(0,"code=12: display subversion\n\r");
    18b4:	4912      	ldr	r1, [pc, #72]	; (1900 <show_intro_text+0x80>)
    18b6:	2000      	movs	r0, #0
    18b8:	47a0      	blx	r4
#if (TESTING==1)
    uart_print(0,"code=3: mosfet ON\n\rcode=4: mosfet OFF\n\r");
    18ba:	4912      	ldr	r1, [pc, #72]	; (1904 <show_intro_text+0x84>)
    18bc:	2000      	movs	r0, #0
    18be:	47a0      	blx	r4
    uart_print(0,"code=5yy: set Year\n\rcode=6mm: set Month\n\rcode=7dd: set Day\n\r");
    18c0:	4911      	ldr	r1, [pc, #68]	; (1908 <show_intro_text+0x88>)
    18c2:	2000      	movs	r0, #0
    18c4:	47a0      	blx	r4
    uart_print(0,"code=8hh: set Hour\n\rcode=9mm: set Minute\n\r");
    18c6:	4911      	ldr	r1, [pc, #68]	; (190c <show_intro_text+0x8c>)
    18c8:	2000      	movs	r0, #0
    18ca:	47a0      	blx	r4
    uart_print(0,"code=*123456789# : 3 minutes credit\r\n");
    18cc:	4910      	ldr	r1, [pc, #64]	; (1910 <show_intro_text+0x90>)
    18ce:	2000      	movs	r0, #0
    18d0:	47a0      	blx	r4
#endif
    uart_print(0,"else code is days credit (14 digits)\n\n\r");    
    18d2:	4910      	ldr	r1, [pc, #64]	; (1914 <show_intro_text+0x94>)
    18d4:	2000      	movs	r0, #0
    18d6:	47a0      	blx	r4
}
    18d8:	bd10      	pop	{r4, pc}
    18da:	46c0      	nop			; (mov r8, r8)
    18dc:	00007b99 	.word	0x00007b99
    18e0:	0000a53f 	.word	0x0000a53f
    18e4:	20000a54 	.word	0x20000a54
    18e8:	0000a566 	.word	0x0000a566
    18ec:	0000a574 	.word	0x0000a574
    18f0:	0000a57e 	.word	0x0000a57e
    18f4:	00000c29 	.word	0x00000c29
    18f8:	0000a588 	.word	0x0000a588
    18fc:	0000a5d3 	.word	0x0000a5d3
    1900:	0000a5f9 	.word	0x0000a5f9
    1904:	0000a617 	.word	0x0000a617
    1908:	0000a63f 	.word	0x0000a63f
    190c:	0000a67c 	.word	0x0000a67c
    1910:	0000a6a7 	.word	0x0000a6a7
    1914:	0000a6cd 	.word	0x0000a6cd

00001918 <all_init>:

void all_init(int8_t onoff)
{
    1918:	b570      	push	{r4, r5, r6, lr}
    bod33_tripped=0;
    191a:	2500      	movs	r5, #0
    191c:	4b1c      	ldr	r3, [pc, #112]	; (1990 <all_init+0x78>)
{
    191e:	0004      	movs	r4, r0
    bod33_tripped=0;
    1920:	701d      	strb	r5, [r3, #0]
    //rtc_init(onoff);
    if(onoff) {
    1922:	42a8      	cmp	r0, r5
    1924:	d00e      	beq.n	1944 <all_init+0x2c>
  __ASM volatile ("cpsid i" : : : "memory");
    1926:	b672      	cpsid	i
        __disable_irq();
        memset((void *)&sysval,0,sizeof(sysVals_t));        
    1928:	4e1a      	ldr	r6, [pc, #104]	; (1994 <all_init+0x7c>)
    192a:	0029      	movs	r1, r5
    192c:	22c4      	movs	r2, #196	; 0xc4
    192e:	481a      	ldr	r0, [pc, #104]	; (1998 <all_init+0x80>)
    1930:	47b0      	blx	r6
        memset((void *)&sysTime,0,sizeof(sysTime_t));
    1932:	2204      	movs	r2, #4
    1934:	0029      	movs	r1, r5
    1936:	4819      	ldr	r0, [pc, #100]	; (199c <all_init+0x84>)
    1938:	47b0      	blx	r6
  __ASM volatile ("cpsie i" : : : "memory");
    193a:	b662      	cpsie	i
        __enable_irq();        
        wdt_enable(5000,false);
    193c:	4818      	ldr	r0, [pc, #96]	; (19a0 <all_init+0x88>)
    193e:	0029      	movs	r1, r5
    1940:	4b18      	ldr	r3, [pc, #96]	; (19a4 <all_init+0x8c>)
    1942:	4798      	blx	r3
    }
    tone_init(onoff);
    1944:	0020      	movs	r0, r4
    1946:	4b18      	ldr	r3, [pc, #96]	; (19a8 <all_init+0x90>)
    1948:	4798      	blx	r3
    uart_init(onoff);
    194a:	0020      	movs	r0, r4
    194c:	4b17      	ldr	r3, [pc, #92]	; (19ac <all_init+0x94>)
    194e:	4798      	blx	r3
    i2c_init(onoff);
    1950:	0020      	movs	r0, r4
    1952:	4b17      	ldr	r3, [pc, #92]	; (19b0 <all_init+0x98>)
    1954:	4798      	blx	r3
    tasks_init(onoff);
    1956:	0020      	movs	r0, r4
    1958:	4b16      	ldr	r3, [pc, #88]	; (19b4 <all_init+0x9c>)
    195a:	4798      	blx	r3
#if (SYSTEM_MODULAR_DC==1 || SYSTEM_MODULAR_AC==1 || SYSTEM_MODULAR_PV==1)
    mod_init(onoff);
#endif
#if (SYSTEM_CCNEO_SCC==1) 
    scc_init(onoff);
    195c:	b2e0      	uxtb	r0, r4
    195e:	4b16      	ldr	r3, [pc, #88]	; (19b8 <all_init+0xa0>)
    1960:	4798      	blx	r3
#endif
    code_init(onoff);
    1962:	0020      	movs	r0, r4
    1964:	4b15      	ldr	r3, [pc, #84]	; (19bc <all_init+0xa4>)
    1966:	4798      	blx	r3
    irrecv_init(onoff);
    1968:	0020      	movs	r0, r4
    196a:	4b15      	ldr	r3, [pc, #84]	; (19c0 <all_init+0xa8>)
    196c:	4798      	blx	r3
    sim_init(onoff);
    196e:	0020      	movs	r0, r4
    1970:	4b14      	ldr	r3, [pc, #80]	; (19c4 <all_init+0xac>)
    1972:	4798      	blx	r3
    cmd_init(onoff);
    1974:	0020      	movs	r0, r4
    1976:	4b14      	ldr	r3, [pc, #80]	; (19c8 <all_init+0xb0>)
    1978:	4798      	blx	r3
    oled_init(onoff);
    197a:	0020      	movs	r0, r4
    197c:	4b13      	ldr	r3, [pc, #76]	; (19cc <all_init+0xb4>)
    197e:	4798      	blx	r3
    
    if(onoff) {
    1980:	2c00      	cmp	r4, #0
    1982:	d002      	beq.n	198a <all_init+0x72>
        show_intro_text();
    1984:	4b12      	ldr	r3, [pc, #72]	; (19d0 <all_init+0xb8>)
    1986:	4798      	blx	r3
    }
    if(onoff==0) {
        wdt_disable();
    }
}
    1988:	bd70      	pop	{r4, r5, r6, pc}
        wdt_disable();
    198a:	4b12      	ldr	r3, [pc, #72]	; (19d4 <all_init+0xbc>)
    198c:	4798      	blx	r3
    198e:	e7fb      	b.n	1988 <all_init+0x70>
    1990:	20000cc6 	.word	0x20000cc6
    1994:	00008957 	.word	0x00008957
    1998:	20000a58 	.word	0x20000a58
    199c:	20000c10 	.word	0x20000c10
    19a0:	00001388 	.word	0x00001388
    19a4:	00007d65 	.word	0x00007d65
    19a8:	00007605 	.word	0x00007605
    19ac:	00007a75 	.word	0x00007a75
    19b0:	00007705 	.word	0x00007705
    19b4:	00007181 	.word	0x00007181
    19b8:	00003fb9 	.word	0x00003fb9
    19bc:	00000a85 	.word	0x00000a85
    19c0:	000016a1 	.word	0x000016a1
    19c4:	000066e5 	.word	0x000066e5
    19c8:	00000949 	.word	0x00000949
    19cc:	00001fdd 	.word	0x00001fdd
    19d0:	00001881 	.word	0x00001881
    19d4:	00007eb1 	.word	0x00007eb1

000019d8 <check_bod>:
{
    19d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    19da:	b672      	cpsid	i
    bod33_tripped=0;   
    19dc:	2400      	movs	r4, #0
    bod33_trip=bod33_tripped;
    19de:	4b10      	ldr	r3, [pc, #64]	; (1a20 <check_bod+0x48>)
    19e0:	781a      	ldrb	r2, [r3, #0]
    bod33_tripped=0;   
    19e2:	701c      	strb	r4, [r3, #0]
    bod33_trip=bod33_tripped;
    19e4:	b2d2      	uxtb	r2, r2
  __ASM volatile ("cpsie i" : : : "memory");
    19e6:	b662      	cpsie	i
    if(bod33_trip) {
    19e8:	42a2      	cmp	r2, r4
    19ea:	d017      	beq.n	1a1c <check_bod+0x44>
        uart_print(0,">>> bod33_trip=%d SLEEP! <<<\n\r",bod33_trip);
    19ec:	0020      	movs	r0, r4
    19ee:	490d      	ldr	r1, [pc, #52]	; (1a24 <check_bod+0x4c>)
    19f0:	4e0d      	ldr	r6, [pc, #52]	; (1a28 <check_bod+0x50>)
    19f2:	47b0      	blx	r6
        all_init(0);
    19f4:	0020      	movs	r0, r4
    19f6:	4f0d      	ldr	r7, [pc, #52]	; (1a2c <check_bod+0x54>)
    19f8:	47b8      	blx	r7
            wdt_sleep(2000);            
    19fa:	20fa      	movs	r0, #250	; 0xfa
            wdt_wakeup=0;            
    19fc:	4b0c      	ldr	r3, [pc, #48]	; (1a30 <check_bod+0x58>)
            wdt_sleep(2000);            
    19fe:	00c0      	lsls	r0, r0, #3
            wdt_wakeup=0;            
    1a00:	701c      	strb	r4, [r3, #0]
            wdt_sleep(2000);            
    1a02:	4b0c      	ldr	r3, [pc, #48]	; (1a34 <check_bod+0x5c>)
    1a04:	4798      	blx	r3
            if((SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_BOD33DET) == 0) break;
    1a06:	4b0c      	ldr	r3, [pc, #48]	; (1a38 <check_bod+0x60>)
    1a08:	68dd      	ldr	r5, [r3, #12]
    1a0a:	2380      	movs	r3, #128	; 0x80
    1a0c:	00db      	lsls	r3, r3, #3
    1a0e:	401d      	ands	r5, r3
    1a10:	d1f3      	bne.n	19fa <check_bod+0x22>
        all_init(1);
    1a12:	2001      	movs	r0, #1
    1a14:	47b8      	blx	r7
        uart_print(0,">>> bod33 ok wakeup <<<\n\r");   
    1a16:	4909      	ldr	r1, [pc, #36]	; (1a3c <check_bod+0x64>)
    1a18:	0028      	movs	r0, r5
    1a1a:	47b0      	blx	r6
}
    1a1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1a1e:	46c0      	nop			; (mov r8, r8)
    1a20:	20000cc6 	.word	0x20000cc6
    1a24:	0000a6f5 	.word	0x0000a6f5
    1a28:	00007b99 	.word	0x00007b99
    1a2c:	00001919 	.word	0x00001919
    1a30:	20000cc5 	.word	0x20000cc5
    1a34:	00007eed 	.word	0x00007eed
    1a38:	40000800 	.word	0x40000800
    1a3c:	0000a714 	.word	0x0000a714

00001a40 <main>:

//-----------------------------------------------------------------------------
int main(void)
{   
    1a40:	b5f0      	push	{r4, r5, r6, r7, lr}
  decode_results results; // IR receiver results
  char ch='.'; 
  char log_rtc[1]; 
  rcause=PM->RCAUSE.reg;
    1a42:	4ba1      	ldr	r3, [pc, #644]	; (1cc8 <main+0x288>)
{   
    1a44:	b087      	sub	sp, #28
  rcause=PM->RCAUSE.reg;
    1a46:	781a      	ldrb	r2, [r3, #0]
    1a48:	4ba0      	ldr	r3, [pc, #640]	; (1ccc <main+0x28c>)

  delay_ms(100);
    1a4a:	2064      	movs	r0, #100	; 0x64
  rcause=PM->RCAUSE.reg;
    1a4c:	701a      	strb	r2, [r3, #0]
  delay_ms(100);
    1a4e:	4ba0      	ldr	r3, [pc, #640]	; (1cd0 <main+0x290>)
    1a50:	4798      	blx	r3
    PM->APBAMASK.reg |= PM_APBAMASK_GCLK;
    1a52:	2308      	movs	r3, #8
  rcause=PM->RCAUSE.reg;
    1a54:	4c9f      	ldr	r4, [pc, #636]	; (1cd4 <main+0x294>)
    SYSCTRL->OSC8M.bit.PRESC = 0;
    1a56:	49a0      	ldr	r1, [pc, #640]	; (1cd8 <main+0x298>)
    PM->APBAMASK.reg |= PM_APBAMASK_GCLK;
    1a58:	69a2      	ldr	r2, [r4, #24]
    1a5a:	4313      	orrs	r3, r2
    1a5c:	61a3      	str	r3, [r4, #24]
    SYSCTRL->OSC8M.bit.PRESC = 0;
    1a5e:	4b9f      	ldr	r3, [pc, #636]	; (1cdc <main+0x29c>)
    1a60:	6a1a      	ldr	r2, [r3, #32]
    1a62:	400a      	ands	r2, r1
    1a64:	621a      	str	r2, [r3, #32]
    SYSCTRL->BOD33.reg = 0; // disable to avoid spurious interrupts
    1a66:	2200      	movs	r2, #0
    SYSCTRL->BOD33.reg = SYSCTRL_BOD33_LEVEL(48) | SYSCTRL_BOD33_CEN | SYSCTRL_BOD33_MODE |
    1a68:	499d      	ldr	r1, [pc, #628]	; (1ce0 <main+0x2a0>)
    SYSCTRL->BOD33.reg = 0; // disable to avoid spurious interrupts
    1a6a:	635a      	str	r2, [r3, #52]	; 0x34
    SYSCTRL->BOD33.reg = SYSCTRL_BOD33_LEVEL(48) | SYSCTRL_BOD33_CEN | SYSCTRL_BOD33_MODE |
    1a6c:	6359      	str	r1, [r3, #52]	; 0x34
    bod33_tripped=0;
    1a6e:	499d      	ldr	r1, [pc, #628]	; (1ce4 <main+0x2a4>)
    1a70:	700a      	strb	r2, [r1, #0]
    wdt_wakeup=0;
    1a72:	499d      	ldr	r1, [pc, #628]	; (1ce8 <main+0x2a8>)
    1a74:	700a      	strb	r2, [r1, #0]
    SYSCTRL->BOD33.reg |= SYSCTRL_BOD33_ENABLE;
    1a76:	6b59      	ldr	r1, [r3, #52]	; 0x34
    1a78:	3202      	adds	r2, #2
    1a7a:	430a      	orrs	r2, r1
    1a7c:	635a      	str	r2, [r3, #52]	; 0x34
    while((SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_B33SRDY) == 0);
    1a7e:	2280      	movs	r2, #128	; 0x80
    1a80:	0112      	lsls	r2, r2, #4
    1a82:	68d9      	ldr	r1, [r3, #12]
    1a84:	4211      	tst	r1, r2
    1a86:	d0fc      	beq.n	1a82 <main+0x42>
    SYSCTRL->INTENSET.reg = SYSCTRL_INTENSET_BOD33DET;
    1a88:	2280      	movs	r2, #128	; 0x80
    1a8a:	00d2      	lsls	r2, r2, #3
    1a8c:	605a      	str	r2, [r3, #4]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    1a8e:	2202      	movs	r2, #2
    1a90:	4b96      	ldr	r3, [pc, #600]	; (1cec <main+0x2ac>)
    1a92:	601a      	str	r2, [r3, #0]
    asm volatile ("cpsie i");
    1a94:	b662      	cpsie	i
  
  // fixed pheripherals
  sys_init(1);
  rtc_initialize(); 
    1a96:	4b96      	ldr	r3, [pc, #600]	; (1cf0 <main+0x2b0>)
    1a98:	4798      	blx	r3
  wdt_init();
    1a9a:	4b96      	ldr	r3, [pc, #600]	; (1cf4 <main+0x2b4>)
    1a9c:	4798      	blx	r3
  unused_init();  
    1a9e:	4b96      	ldr	r3, [pc, #600]	; (1cf8 <main+0x2b8>)
    1aa0:	4798      	blx	r3
  flash_init();
    1aa2:	4b96      	ldr	r3, [pc, #600]	; (1cfc <main+0x2bc>)
    1aa4:	4798      	blx	r3
  
  // dynamic pheripherals
  all_init(1);
    1aa6:	4b96      	ldr	r3, [pc, #600]	; (1d00 <main+0x2c0>)
    1aa8:	2001      	movs	r0, #1
    1aaa:	4798      	blx	r3
  
  if(sim_available()) {
    1aac:	4b95      	ldr	r3, [pc, #596]	; (1d04 <main+0x2c4>)
    1aae:	4798      	blx	r3
    1ab0:	2800      	cmp	r0, #0
    1ab2:	d00c      	beq.n	1ace <main+0x8e>
      uart_print(0,"SIM available\n\r");
    1ab4:	4994      	ldr	r1, [pc, #592]	; (1d08 <main+0x2c8>)
    1ab6:	2000      	movs	r0, #0
    1ab8:	4b94      	ldr	r3, [pc, #592]	; (1d0c <main+0x2cc>)
    1aba:	4798      	blx	r3
      sim_task_add(SIM_TASK_WAIT,10,0); // wait 10 seconds
    1abc:	2200      	movs	r2, #0
    1abe:	210a      	movs	r1, #10
    1ac0:	2007      	movs	r0, #7
    1ac2:	4c93      	ldr	r4, [pc, #588]	; (1d10 <main+0x2d0>)
    1ac4:	47a0      	blx	r4
      sim_task_add(SIM_TASK_POWER,1,1); // power on
    1ac6:	2201      	movs	r2, #1
    1ac8:	0011      	movs	r1, r2
    1aca:	0010      	movs	r0, r2
    1acc:	47a0      	blx	r4
  }

  read_print_rtc(true,log_rtc,0);
    1ace:	4b91      	ldr	r3, [pc, #580]	; (1d14 <main+0x2d4>)
    1ad0:	2200      	movs	r2, #0
    1ad2:	a901      	add	r1, sp, #4
    1ad4:	2001      	movs	r0, #1
    1ad6:	4798      	blx	r3
  print_prompt();
    1ad8:	4b8f      	ldr	r3, [pc, #572]	; (1d18 <main+0x2d8>)
    1ada:	4798      	blx	r3
  
  while (1) {    
    wdt_reset();
    1adc:	4b8f      	ldr	r3, [pc, #572]	; (1d1c <main+0x2dc>)
    1ade:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
    1ae0:	b672      	cpsid	i

    __disable_irq();
    if(serial_rxflag) {
    1ae2:	4e8f      	ldr	r6, [pc, #572]	; (1d20 <main+0x2e0>)
    1ae4:	7973      	ldrb	r3, [r6, #5]
    1ae6:	2b00      	cmp	r3, #0
    1ae8:	d06c      	beq.n	1bc4 <main+0x184>
        serial_rxflag=false;	
    1aea:	2300      	movs	r3, #0
    1aec:	7173      	strb	r3, [r6, #5]
        ch=addchar(serial_rxbuf);
    1aee:	4b8d      	ldr	r3, [pc, #564]	; (1d24 <main+0x2e4>)
    1af0:	7818      	ldrb	r0, [r3, #0]
    1af2:	4b8d      	ldr	r3, [pc, #564]	; (1d28 <main+0x2e8>)
    1af4:	b2c0      	uxtb	r0, r0
    1af6:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
    1af8:	b662      	cpsie	i
        __enable_irq();
        uart_putc(ch);
    1afa:	4b8c      	ldr	r3, [pc, #560]	; (1d2c <main+0x2ec>)
    1afc:	4798      	blx	r3
    } else __enable_irq();
	//uart_print(0,"IRstate=%d\r\n",irrecv_get_irparams_rcvstate()); 
    if (irrecv_get_irparams_rcvstate() == STATE_STOP) {
    1afe:	4b8c      	ldr	r3, [pc, #560]	; (1d30 <main+0x2f0>)
    1b00:	4798      	blx	r3
    1b02:	2805      	cmp	r0, #5
    1b04:	d11a      	bne.n	1b3c <main+0xfc>
        if (irrecv_decode(&results) ) {
    1b06:	a802      	add	r0, sp, #8
    1b08:	4b8a      	ldr	r3, [pc, #552]	; (1d34 <main+0x2f4>)
    1b0a:	4798      	blx	r3
    1b0c:	2800      	cmp	r0, #0
    1b0e:	d015      	beq.n	1b3c <main+0xfc>
            ch = irrecv_convert(results.value);
    1b10:	9802      	ldr	r0, [sp, #8]
    1b12:	4b89      	ldr	r3, [pc, #548]	; (1d38 <main+0x2f8>)
    1b14:	4798      	blx	r3
    1b16:	0004      	movs	r4, r0
            if(ch&0x80) { ch &= 0x7f; addchar(ch); }				
    1b18:	0603      	lsls	r3, r0, #24
    1b1a:	d504      	bpl.n	1b26 <main+0xe6>
    1b1c:	237f      	movs	r3, #127	; 0x7f
    1b1e:	401c      	ands	r4, r3
    1b20:	0020      	movs	r0, r4
    1b22:	4b81      	ldr	r3, [pc, #516]	; (1d28 <main+0x2e8>)
    1b24:	4798      	blx	r3
            uart_putc(ch);
    1b26:	0020      	movs	r0, r4
    1b28:	4b80      	ldr	r3, [pc, #512]	; (1d2c <main+0x2ec>)
    1b2a:	4798      	blx	r3
            uart_print(0," [IR:%0lx:%c]",results.value,ch);
    1b2c:	0023      	movs	r3, r4
    1b2e:	9a02      	ldr	r2, [sp, #8]
    1b30:	4982      	ldr	r1, [pc, #520]	; (1d3c <main+0x2fc>)
    1b32:	2000      	movs	r0, #0
    1b34:	4c75      	ldr	r4, [pc, #468]	; (1d0c <main+0x2cc>)
    1b36:	47a0      	blx	r4
            print_prompt();
    1b38:	4b77      	ldr	r3, [pc, #476]	; (1d18 <main+0x2d8>)
    1b3a:	4798      	blx	r3
        }       
    }

    if(usart_rx_ready) {
    1b3c:	7933      	ldrb	r3, [r6, #4]
    1b3e:	2b00      	cmp	r3, #0
    1b40:	d020      	beq.n	1b84 <main+0x144>
        int cmdstat=0;
        int16_t creditleft;	
        uart_puts_info("\n\r");		
    1b42:	4b7f      	ldr	r3, [pc, #508]	; (1d40 <main+0x300>)
    1b44:	487f      	ldr	r0, [pc, #508]	; (1d44 <main+0x304>)
    1b46:	4798      	blx	r3
        if(strcmp(rxbuf,"*1#")==0) {
    1b48:	4c7f      	ldr	r4, [pc, #508]	; (1d48 <main+0x308>)
    1b4a:	4980      	ldr	r1, [pc, #512]	; (1d4c <main+0x30c>)
    1b4c:	0020      	movs	r0, r4
    1b4e:	4d80      	ldr	r5, [pc, #512]	; (1d50 <main+0x310>)
    1b50:	47a8      	blx	r5
            print_myid();		
    1b52:	4b80      	ldr	r3, [pc, #512]	; (1d54 <main+0x314>)
        if(strcmp(rxbuf,"*1#")==0) {
    1b54:	2800      	cmp	r0, #0
    1b56:	d00b      	beq.n	1b70 <main+0x130>
        } else if(strcmp(rxbuf,"*2#")==0) {
    1b58:	497f      	ldr	r1, [pc, #508]	; (1d58 <main+0x318>)
    1b5a:	0020      	movs	r0, r4
    1b5c:	47a8      	blx	r5
    1b5e:	1e02      	subs	r2, r0, #0
    1b60:	d135      	bne.n	1bce <main+0x18e>
            creditleft=read_print_rtc(true,log_rtc,0);
    1b62:	a901      	add	r1, sp, #4
    1b64:	2001      	movs	r0, #1
    1b66:	4b6b      	ldr	r3, [pc, #428]	; (1d14 <main+0x2d4>)
    1b68:	4798      	blx	r3
            if(creditleft<=0) {
    1b6a:	2800      	cmp	r0, #0
    1b6c:	dc2c      	bgt.n	1bc8 <main+0x188>
                play_song_expired();
    1b6e:	4b7b      	ldr	r3, [pc, #492]	; (1d5c <main+0x31c>)
    1b70:	4798      	blx	r3
            cmdstat = code_real(rxbuf,log_rtc,0);
        } else cmdstat=-1;

        if(cmdstat < 0) play_song_error();

        memset(rxbuf,0,RXBUF_SIZE);
    1b72:	4b7b      	ldr	r3, [pc, #492]	; (1d60 <main+0x320>)
    1b74:	2264      	movs	r2, #100	; 0x64
    1b76:	2100      	movs	r1, #0
    1b78:	0020      	movs	r0, r4
    1b7a:	4798      	blx	r3
        usart_rx_ready=false;		
    1b7c:	2300      	movs	r3, #0
    1b7e:	7133      	strb	r3, [r6, #4]
        print_prompt();
    1b80:	4b65      	ldr	r3, [pc, #404]	; (1d18 <main+0x2d8>)
    1b82:	4798      	blx	r3
    }
    if (alarmTriggered) {   // If the alarm has been triggered
    1b84:	79b3      	ldrb	r3, [r6, #6]
    1b86:	2b00      	cmp	r3, #0
    1b88:	d009      	beq.n	1b9e <main+0x15e>
        alarmTriggered=false;
    1b8a:	2400      	movs	r4, #0
        uart_puts_info("Alarm! mosfet OFF!\n\r");
    1b8c:	4875      	ldr	r0, [pc, #468]	; (1d64 <main+0x324>)
    1b8e:	4b6c      	ldr	r3, [pc, #432]	; (1d40 <main+0x300>)
        alarmTriggered=false;
    1b90:	71b4      	strb	r4, [r6, #6]
        uart_puts_info("Alarm! mosfet OFF!\n\r");
    1b92:	4798      	blx	r3
        code_alarm_triggered();
    1b94:	4b74      	ldr	r3, [pc, #464]	; (1d68 <main+0x328>)
    1b96:	4798      	blx	r3
        task_set_load(0);
    1b98:	0020      	movs	r0, r4
    1b9a:	4b74      	ldr	r3, [pc, #464]	; (1d6c <main+0x32c>)
    1b9c:	4798      	blx	r3
    }

    oled_update();
    1b9e:	4d74      	ldr	r5, [pc, #464]	; (1d70 <main+0x330>)
    1ba0:	47a8      	blx	r5
      check_bod();
    1ba2:	4c74      	ldr	r4, [pc, #464]	; (1d74 <main+0x334>)
    1ba4:	47a0      	blx	r4
    run_tasks();
    1ba6:	4b74      	ldr	r3, [pc, #464]	; (1d78 <main+0x338>)
    1ba8:	4798      	blx	r3
      check_bod();
    1baa:	47a0      	blx	r4
      
#if (SYSTEM_CCNEO_SCC==1) 
    scc_tasks();
    1bac:	4b73      	ldr	r3, [pc, #460]	; (1d7c <main+0x33c>)
    1bae:	4798      	blx	r3
#endif

      check_bod();
    1bb0:	47a0      	blx	r4
    oled_update();
    1bb2:	47a8      	blx	r5
      check_bod();
    1bb4:	47a0      	blx	r4
      
#if (SYSTEM_MODULAR_DC==1 || SYSTEM_MODULAR_AC==1 || SYSTEM_MODULAR_PV==1)
    mod_tasks();
#endif

    sim_tasks();
    1bb6:	4b72      	ldr	r3, [pc, #456]	; (1d80 <main+0x340>)
    1bb8:	4798      	blx	r3
      check_bod();
    1bba:	47a0      	blx	r4
    cmd_tasks();
    1bbc:	4b71      	ldr	r3, [pc, #452]	; (1d84 <main+0x344>)
    1bbe:	4798      	blx	r3
      check_bod();
    1bc0:	47a0      	blx	r4
    wdt_reset();
    1bc2:	e78b      	b.n	1adc <main+0x9c>
    1bc4:	b662      	cpsie	i
    1bc6:	e79a      	b.n	1afe <main+0xbe>
                play_nof_tones(creditleft);
    1bc8:	4b6f      	ldr	r3, [pc, #444]	; (1d88 <main+0x348>)
    1bca:	4798      	blx	r3
    1bcc:	e7d1      	b.n	1b72 <main+0x132>
        } else if(strcmp(rxbuf,"*3#")==0) {
    1bce:	496f      	ldr	r1, [pc, #444]	; (1d8c <main+0x34c>)
    1bd0:	0020      	movs	r0, r4
    1bd2:	47a8      	blx	r5
    1bd4:	2800      	cmp	r0, #0
    1bd6:	d103      	bne.n	1be0 <main+0x1a0>
            task_set_load(1);
    1bd8:	3001      	adds	r0, #1
            task_set_load(0);
    1bda:	4b64      	ldr	r3, [pc, #400]	; (1d6c <main+0x32c>)
            uart_set_print_info(true);				
    1bdc:	4798      	blx	r3
    1bde:	e7c8      	b.n	1b72 <main+0x132>
        } else if(strcmp(rxbuf,"*4#")==0) {
    1be0:	496b      	ldr	r1, [pc, #428]	; (1d90 <main+0x350>)
    1be2:	0020      	movs	r0, r4
    1be4:	47a8      	blx	r5
    1be6:	2800      	cmp	r0, #0
    1be8:	d0f7      	beq.n	1bda <main+0x19a>
        } else if(strcmp(rxbuf,"*5#")==0) {
    1bea:	496a      	ldr	r1, [pc, #424]	; (1d94 <main+0x354>)
    1bec:	0020      	movs	r0, r4
    1bee:	47a8      	blx	r5
    1bf0:	1e07      	subs	r7, r0, #0
    1bf2:	d114      	bne.n	1c1e <main+0x1de>
            if(!uart_get_print_info()) {
    1bf4:	4b68      	ldr	r3, [pc, #416]	; (1d98 <main+0x358>)
    1bf6:	4798      	blx	r3
    1bf8:	1e05      	subs	r5, r0, #0
    1bfa:	d10a      	bne.n	1c12 <main+0x1d2>
                uart_set_print_info(true);
    1bfc:	2001      	movs	r0, #1
    1bfe:	4f67      	ldr	r7, [pc, #412]	; (1d9c <main+0x35c>)
    1c00:	47b8      	blx	r7
                read_print_rtc(true,log_rtc,0);
    1c02:	002a      	movs	r2, r5
    1c04:	a901      	add	r1, sp, #4
    1c06:	4b43      	ldr	r3, [pc, #268]	; (1d14 <main+0x2d4>)
    1c08:	2001      	movs	r0, #1
    1c0a:	4798      	blx	r3
                uart_set_print_info(false);
    1c0c:	0028      	movs	r0, r5
    1c0e:	47b8      	blx	r7
    1c10:	e7af      	b.n	1b72 <main+0x132>
                read_print_rtc(true,log_rtc,0);
    1c12:	003a      	movs	r2, r7
    1c14:	a901      	add	r1, sp, #4
    1c16:	4b3f      	ldr	r3, [pc, #252]	; (1d14 <main+0x2d4>)
    1c18:	2001      	movs	r0, #1
    1c1a:	4798      	blx	r3
    1c1c:	e7a9      	b.n	1b72 <main+0x132>
        } else if(strcmp(rxbuf,"*10#")==0) {
    1c1e:	4960      	ldr	r1, [pc, #384]	; (1da0 <main+0x360>)
    1c20:	0020      	movs	r0, r4
    1c22:	47a8      	blx	r5
    1c24:	2800      	cmp	r0, #0
    1c26:	d101      	bne.n	1c2c <main+0x1ec>
            uart_set_print_info(true);				
    1c28:	4b5c      	ldr	r3, [pc, #368]	; (1d9c <main+0x35c>)
    1c2a:	e7d7      	b.n	1bdc <main+0x19c>
        } else if(strcmp(rxbuf,"*11#")==0) {
    1c2c:	495d      	ldr	r1, [pc, #372]	; (1da4 <main+0x364>)
    1c2e:	0020      	movs	r0, r4
    1c30:	47a8      	blx	r5
    1c32:	2800      	cmp	r0, #0
    1c34:	d101      	bne.n	1c3a <main+0x1fa>
            uart_set_print_info(true);				
    1c36:	3001      	adds	r0, #1
    1c38:	e7f6      	b.n	1c28 <main+0x1e8>
        } else if(strlen(rxbuf) == 5) { // *123#  (set date, time) // disable this command after debug!
    1c3a:	0020      	movs	r0, r4
    1c3c:	4b5a      	ldr	r3, [pc, #360]	; (1da8 <main+0x368>)
    1c3e:	4798      	blx	r3
    1c40:	2805      	cmp	r0, #5
    1c42:	d12d      	bne.n	1ca0 <main+0x260>
            rxbuf[0]=' '; // strip '*'
    1c44:	2320      	movs	r3, #32
    1c46:	7023      	strb	r3, [r4, #0]
            rxbuf[1]=' '; // strip opcode
    1c48:	2320      	movs	r3, #32
            rxbuf[4]=0;   // strip '#'
    1c4a:	2100      	movs	r1, #0
            char opcode = rxbuf[1];
    1c4c:	7865      	ldrb	r5, [r4, #1]
            givencode = strtoul(rxbuf,NULL,10);		
    1c4e:	220a      	movs	r2, #10
            rxbuf[1]=' '; // strip opcode
    1c50:	7063      	strb	r3, [r4, #1]
            givencode = strtoul(rxbuf,NULL,10);		
    1c52:	0020      	movs	r0, r4
    1c54:	4b55      	ldr	r3, [pc, #340]	; (1dac <main+0x36c>)
            rxbuf[4]=0;   // strip '#'
    1c56:	7121      	strb	r1, [r4, #4]
            givencode = strtoul(rxbuf,NULL,10);		
    1c58:	4798      	blx	r3
            if(opcode == '5') { // set year			
    1c5a:	2d35      	cmp	r5, #53	; 0x35
    1c5c:	d10c      	bne.n	1c78 <main+0x238>
            	setYear((uint8_t)givencode);
    1c5e:	4b54      	ldr	r3, [pc, #336]	; (1db0 <main+0x370>)
    1c60:	b2c0      	uxtb	r0, r0
                setMinutes((uint8_t)givencode);
    1c62:	4798      	blx	r3
            read_print_rtc(true,log_rtc,0);
    1c64:	a901      	add	r1, sp, #4
    1c66:	2200      	movs	r2, #0
    1c68:	4b2a      	ldr	r3, [pc, #168]	; (1d14 <main+0x2d4>)
    1c6a:	2001      	movs	r0, #1
    1c6c:	4798      	blx	r3
            uart_print(0,"Enter new credit code to write flash!\n\r");
    1c6e:	4951      	ldr	r1, [pc, #324]	; (1db4 <main+0x374>)
    1c70:	2000      	movs	r0, #0
    1c72:	4b26      	ldr	r3, [pc, #152]	; (1d0c <main+0x2cc>)
    1c74:	4798      	blx	r3
    1c76:	e77c      	b.n	1b72 <main+0x132>
            } else if(opcode == '6') { // set month
    1c78:	2d36      	cmp	r5, #54	; 0x36
    1c7a:	d102      	bne.n	1c82 <main+0x242>
                setMonth((uint8_t)givencode);
    1c7c:	b2c0      	uxtb	r0, r0
    1c7e:	4b4e      	ldr	r3, [pc, #312]	; (1db8 <main+0x378>)
    1c80:	e7ef      	b.n	1c62 <main+0x222>
            } else if(opcode == '7') { // set day
    1c82:	2d37      	cmp	r5, #55	; 0x37
    1c84:	d102      	bne.n	1c8c <main+0x24c>
                setDay((uint8_t)givencode);
    1c86:	b2c0      	uxtb	r0, r0
    1c88:	4b4c      	ldr	r3, [pc, #304]	; (1dbc <main+0x37c>)
    1c8a:	e7ea      	b.n	1c62 <main+0x222>
            } else if(opcode == '8') { // set hour
    1c8c:	2d38      	cmp	r5, #56	; 0x38
    1c8e:	d102      	bne.n	1c96 <main+0x256>
                setHours((uint8_t)givencode);
    1c90:	b2c0      	uxtb	r0, r0
    1c92:	4b4b      	ldr	r3, [pc, #300]	; (1dc0 <main+0x380>)
    1c94:	e7e5      	b.n	1c62 <main+0x222>
            } else if(opcode == '9') { // set minute
    1c96:	2d39      	cmp	r5, #57	; 0x39
    1c98:	d1e4      	bne.n	1c64 <main+0x224>
                setMinutes((uint8_t)givencode);
    1c9a:	b2c0      	uxtb	r0, r0
    1c9c:	4b49      	ldr	r3, [pc, #292]	; (1dc4 <main+0x384>)
    1c9e:	e7e0      	b.n	1c62 <main+0x222>
        } else if(strlen(rxbuf) == 11) { // *123456789# // for demo
    1ca0:	280b      	cmp	r0, #11
    1ca2:	d105      	bne.n	1cb0 <main+0x270>
            code_demo(rxbuf,log_rtc,0);
    1ca4:	2200      	movs	r2, #0
    1ca6:	a901      	add	r1, sp, #4
    1ca8:	0020      	movs	r0, r4
    1caa:	4b47      	ldr	r3, [pc, #284]	; (1dc8 <main+0x388>)
    1cac:	4798      	blx	r3
    1cae:	e760      	b.n	1b72 <main+0x132>
        } else if(strlen(rxbuf) == 16) { // *12345678901234#
    1cb0:	2810      	cmp	r0, #16
    1cb2:	d001      	beq.n	1cb8 <main+0x278>
        if(cmdstat < 0) play_song_error();
    1cb4:	4b45      	ldr	r3, [pc, #276]	; (1dcc <main+0x38c>)
    1cb6:	e75b      	b.n	1b70 <main+0x130>
            cmdstat = code_real(rxbuf,log_rtc,0);
    1cb8:	2200      	movs	r2, #0
    1cba:	a901      	add	r1, sp, #4
    1cbc:	0020      	movs	r0, r4
    1cbe:	4b44      	ldr	r3, [pc, #272]	; (1dd0 <main+0x390>)
    1cc0:	4798      	blx	r3
        if(cmdstat < 0) play_song_error();
    1cc2:	2800      	cmp	r0, #0
    1cc4:	dbf6      	blt.n	1cb4 <main+0x274>
    1cc6:	e754      	b.n	1b72 <main+0x132>
    1cc8:	40000438 	.word	0x40000438
    1ccc:	20000a54 	.word	0x20000a54
    1cd0:	00007c05 	.word	0x00007c05
    1cd4:	40000400 	.word	0x40000400
    1cd8:	fffffcff 	.word	0xfffffcff
    1cdc:	40000800 	.word	0x40000800
    1ce0:	00300354 	.word	0x00300354
    1ce4:	20000cc6 	.word	0x20000cc6
    1ce8:	20000cc5 	.word	0x20000cc5
    1cec:	e000e100 	.word	0xe000e100
    1cf0:	00003ee1 	.word	0x00003ee1
    1cf4:	00007f11 	.word	0x00007f11
    1cf8:	000017d1 	.word	0x000017d1
    1cfc:	0000124d 	.word	0x0000124d
    1d00:	00001919 	.word	0x00001919
    1d04:	000061e5 	.word	0x000061e5
    1d08:	0000a72e 	.word	0x0000a72e
    1d0c:	00007b99 	.word	0x00007b99
    1d10:	000063cd 	.word	0x000063cd
    1d14:	00000961 	.word	0x00000961
    1d18:	00001745 	.word	0x00001745
    1d1c:	00007d51 	.word	0x00007d51
    1d20:	20000394 	.word	0x20000394
    1d24:	20000c0f 	.word	0x20000c0f
    1d28:	00001759 	.word	0x00001759
    1d2c:	00007b49 	.word	0x00007b49
    1d30:	00001269 	.word	0x00001269
    1d34:	00001331 	.word	0x00001331
    1d38:	0000136d 	.word	0x0000136d
    1d3c:	0000a73e 	.word	0x0000a73e
    1d40:	00007b75 	.word	0x00007b75
    1d44:	0000a6f2 	.word	0x0000a6f2
    1d48:	200009f0 	.word	0x200009f0
    1d4c:	00009fdc 	.word	0x00009fdc
    1d50:	00008a1b 	.word	0x00008a1b
    1d54:	00000c29 	.word	0x00000c29
    1d58:	00009fe0 	.word	0x00009fe0
    1d5c:	00007485 	.word	0x00007485
    1d60:	00008957 	.word	0x00008957
    1d64:	0000a78a 	.word	0x0000a78a
    1d68:	00000bbd 	.word	0x00000bbd
    1d6c:	00006935 	.word	0x00006935
    1d70:	0000214d 	.word	0x0000214d
    1d74:	000019d9 	.word	0x000019d9
    1d78:	00006d41 	.word	0x00006d41
    1d7c:	00004df1 	.word	0x00004df1
    1d80:	00006491 	.word	0x00006491
    1d84:	000008cd 	.word	0x000008cd
    1d88:	000073e5 	.word	0x000073e5
    1d8c:	0000a74c 	.word	0x0000a74c
    1d90:	0000a750 	.word	0x0000a750
    1d94:	0000a754 	.word	0x0000a754
    1d98:	00007bdd 	.word	0x00007bdd
    1d9c:	00007be9 	.word	0x00007be9
    1da0:	0000a758 	.word	0x0000a758
    1da4:	0000a75d 	.word	0x0000a75d
    1da8:	00008a3f 	.word	0x00008a3f
    1dac:	00008d95 	.word	0x00008d95
    1db0:	00003cf1 	.word	0x00003cf1
    1db4:	0000a762 	.word	0x0000a762
    1db8:	00003ccd 	.word	0x00003ccd
    1dbc:	00003ca9 	.word	0x00003ca9
    1dc0:	00003c5d 	.word	0x00003c5d
    1dc4:	00003c39 	.word	0x00003c39
    1dc8:	00000c49 	.word	0x00000c49
    1dcc:	000074ed 	.word	0x000074ed
    1dd0:	00000d8d 	.word	0x00000d8d

00001dd4 <_sbrk>:
  }
  return 0;
}

// get rid of linker error when using linker flag --specs=nano.specs
void _sbrk(void) {}
    1dd4:	4770      	bx	lr
	...

00001dd8 <u8g2_gpio_and_delay_samd20>:
0x01, 0x01, 0x01, 0x09, 0x0d, 0x0b, 0x09, 0x08, 0x08, 0x2a, 0x1c, 0x08 };

	

uint8_t u8g2_gpio_and_delay_samd20(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
    1dd8:	b510      	push	{r4, lr}
    switch(msg) {
    1dda:	292d      	cmp	r1, #45	; 0x2d
    1ddc:	d809      	bhi.n	1df2 <u8g2_gpio_and_delay_samd20+0x1a>
    1dde:	292a      	cmp	r1, #42	; 0x2a
    1de0:	d20a      	bcs.n	1df8 <u8g2_gpio_and_delay_samd20+0x20>
    1de2:	2928      	cmp	r1, #40	; 0x28
    1de4:	d008      	beq.n	1df8 <u8g2_gpio_and_delay_samd20+0x20>
    1de6:	2929      	cmp	r1, #41	; 0x29
    1de8:	d008      	beq.n	1dfc <u8g2_gpio_and_delay_samd20+0x24>
       	case U8X8_MSG_GPIO_I2C_CLOCK: // do this in hw callback
       	    break;
       	case U8X8_MSG_GPIO_I2C_DATA: // do this in hw callback
       	    break;
       	default:
       	    u8x8_SetGPIOResult(u8x8, 1);
    1dea:	2301      	movs	r3, #1
    1dec:	3005      	adds	r0, #5
    1dee:	77c3      	strb	r3, [r0, #31]
       	    break;
    1df0:	e002      	b.n	1df8 <u8g2_gpio_and_delay_samd20+0x20>
    switch(msg) {
    1df2:	394c      	subs	r1, #76	; 0x4c
    1df4:	2901      	cmp	r1, #1
    1df6:	d8f8      	bhi.n	1dea <u8g2_gpio_and_delay_samd20+0x12>
    }
    return 1;
}
    1df8:	2001      	movs	r0, #1
    1dfa:	bd10      	pop	{r4, pc}
       	    delay_ms(arg_int);
    1dfc:	0010      	movs	r0, r2
    1dfe:	4b01      	ldr	r3, [pc, #4]	; (1e04 <u8g2_gpio_and_delay_samd20+0x2c>)
    1e00:	4798      	blx	r3
       	    break;
    1e02:	e7f9      	b.n	1df8 <u8g2_gpio_and_delay_samd20+0x20>
    1e04:	00007c05 	.word	0x00007c05

00001e08 <u8x8_byte_hw_i2c>:


uint8_t u8x8_byte_hw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
  //uint8_t *data;
  switch(msg)
    1e08:	3914      	subs	r1, #20
{
    1e0a:	b570      	push	{r4, r5, r6, lr}
    1e0c:	0005      	movs	r5, r0
  switch(msg)
    1e0e:	0008      	movs	r0, r1
    1e10:	290c      	cmp	r1, #12
    1e12:	d855      	bhi.n	1ec0 <u8x8_byte_hw_i2c+0xb8>
    1e14:	f006 f8a4 	bl	7f60 <__gnu_thumb1_case_uqi>
    1e18:	07545416 	.word	0x07545416
    1e1c:	54542b24 	.word	0x54542b24
    1e20:	54545454 	.word	0x54545454
    1e24:	16          	.byte	0x16
    1e25:	00          	.byte	0x00
  {
    case U8X8_MSG_BYTE_SEND: {
        oled_i2c_idx = 0;
    1e26:	2400      	movs	r4, #0
        oled_i2c_tx_done = false;
        oled_i2c_rx_done = false;
        if((oled_i2c_concat_idx+arg_int) >= OLED_I2C_BUF_SIZE) {
    1e28:	4e26      	ldr	r6, [pc, #152]	; (1ec4 <u8x8_byte_hw_i2c+0xbc>)
        oled_i2c_idx = 0;
    1e2a:	4927      	ldr	r1, [pc, #156]	; (1ec8 <u8x8_byte_hw_i2c+0xc0>)
        if((oled_i2c_concat_idx+arg_int) >= OLED_I2C_BUF_SIZE) {
    1e2c:	7830      	ldrb	r0, [r6, #0]
        oled_i2c_idx = 0;
    1e2e:	700c      	strb	r4, [r1, #0]
        oled_i2c_tx_done = false;
    1e30:	4926      	ldr	r1, [pc, #152]	; (1ecc <u8x8_byte_hw_i2c+0xc4>)
        if((oled_i2c_concat_idx+arg_int) >= OLED_I2C_BUF_SIZE) {
    1e32:	1885      	adds	r5, r0, r2
        oled_i2c_tx_done = false;
    1e34:	700c      	strb	r4, [r1, #0]
        oled_i2c_rx_done = false;
    1e36:	704c      	strb	r4, [r1, #1]
        if((oled_i2c_concat_idx+arg_int) >= OLED_I2C_BUF_SIZE) {
    1e38:	2d1f      	cmp	r5, #31
    1e3a:	dd05      	ble.n	1e48 <u8x8_byte_hw_i2c+0x40>
            uart_print(0,"oled I2C message too long!!\n\r");
    1e3c:	4924      	ldr	r1, [pc, #144]	; (1ed0 <u8x8_byte_hw_i2c+0xc8>)
    1e3e:	0020      	movs	r0, r4
    1e40:	4b24      	ldr	r3, [pc, #144]	; (1ed4 <u8x8_byte_hw_i2c+0xcc>)
    1e42:	4798      	blx	r3
        }
        if(ret==-1) {
            /*interrupts are cleared */
            SERCOM3->I2CM.INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
        }
      u8x8->i2c_started = 0;      
    1e44:	2001      	movs	r0, #1
    1e46:	e011      	b.n	1e6c <u8x8_byte_hw_i2c+0x64>
        memcpy((void *)&oled_i2c_tx_buf[oled_i2c_concat_idx],(void *)arg_ptr,arg_int);
    1e48:	4923      	ldr	r1, [pc, #140]	; (1ed8 <u8x8_byte_hw_i2c+0xd0>)
        oled_i2c_concat_idx+=arg_int;
    1e4a:	b2ed      	uxtb	r5, r5
        memcpy((void *)&oled_i2c_tx_buf[oled_i2c_concat_idx],(void *)arg_ptr,arg_int);
    1e4c:	1840      	adds	r0, r0, r1
    1e4e:	0019      	movs	r1, r3
    1e50:	4b22      	ldr	r3, [pc, #136]	; (1edc <u8x8_byte_hw_i2c+0xd4>)
    1e52:	4798      	blx	r3
        oled_i2c_nof_tx = oled_i2c_concat_idx;
    1e54:	4a22      	ldr	r2, [pc, #136]	; (1ee0 <u8x8_byte_hw_i2c+0xd8>)
        oled_i2c_nof_rx = 0;
    1e56:	4b23      	ldr	r3, [pc, #140]	; (1ee4 <u8x8_byte_hw_i2c+0xdc>)
        oled_i2c_concat_idx+=arg_int;
    1e58:	7035      	strb	r5, [r6, #0]
        oled_i2c_nof_tx = oled_i2c_concat_idx;
    1e5a:	7015      	strb	r5, [r2, #0]
        oled_i2c_nof_rx = 0;
    1e5c:	701c      	strb	r4, [r3, #0]
    1e5e:	e7f1      	b.n	1e44 <u8x8_byte_hw_i2c+0x3c>
      oled_i2c_concat_idx=0;  
    1e60:	2200      	movs	r2, #0
      u8x8->i2c_started = 1;
    1e62:	2001      	movs	r0, #1
      oled_i2c_concat_idx=0;  
    1e64:	4b17      	ldr	r3, [pc, #92]	; (1ec4 <u8x8_byte_hw_i2c+0xbc>)
      u8x8->i2c_started = 1;
    1e66:	3502      	adds	r5, #2
      oled_i2c_concat_idx=0;  
    1e68:	701a      	strb	r2, [r3, #0]
      u8x8->i2c_started = 1;
    1e6a:	77e8      	strb	r0, [r5, #31]
      break;
    default:
      return 0;
  }
  return 1;
}
    1e6c:	bd70      	pop	{r4, r5, r6, pc}
        SERCOM3->I2CM.INTENSET.reg = SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB;
    1e6e:	2303      	movs	r3, #3
    1e70:	4c1d      	ldr	r4, [pc, #116]	; (1ee8 <u8x8_byte_hw_i2c+0xe0>)
        SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    1e72:	4a1e      	ldr	r2, [pc, #120]	; (1eec <u8x8_byte_hw_i2c+0xe4>)
        SERCOM3->I2CM.INTENSET.reg = SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB;
    1e74:	7363      	strb	r3, [r4, #13]
        SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    1e76:	6863      	ldr	r3, [r4, #4]
    1e78:	4013      	ands	r3, r2
    1e7a:	6063      	str	r3, [r4, #4]
        while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY);
    1e7c:	8a23      	ldrh	r3, [r4, #16]
    1e7e:	0bdb      	lsrs	r3, r3, #15
    1e80:	d1fc      	bne.n	1e7c <u8x8_byte_hw_i2c+0x74>
        oled_i2c_timeout = OLED_I2C_TIMEOUT;
    1e82:	4e1b      	ldr	r6, [pc, #108]	; (1ef0 <u8x8_byte_hw_i2c+0xe8>)
    1e84:	3303      	adds	r3, #3
    1e86:	7033      	strb	r3, [r6, #0]
        SERCOM3->I2CM.ADDR.reg = (u8x8_GetI2CAddress(u8x8)) | 0;//(u8x8_GetI2CAddress(u8x8) << 1) | 0;
    1e88:	1c6b      	adds	r3, r5, #1
    1e8a:	7fdb      	ldrb	r3, [r3, #31]
    1e8c:	7523      	strb	r3, [r4, #20]
        while(!oled_i2c_tx_done) {
    1e8e:	4b0f      	ldr	r3, [pc, #60]	; (1ecc <u8x8_byte_hw_i2c+0xc4>)
    1e90:	781b      	ldrb	r3, [r3, #0]
    1e92:	2b00      	cmp	r3, #0
    1e94:	d003      	beq.n	1e9e <u8x8_byte_hw_i2c+0x96>
      u8x8->i2c_started = 0;      
    1e96:	2300      	movs	r3, #0
    1e98:	3502      	adds	r5, #2
    1e9a:	77eb      	strb	r3, [r5, #31]
    1e9c:	e7d2      	b.n	1e44 <u8x8_byte_hw_i2c+0x3c>
            delay_ms(1);
    1e9e:	4b15      	ldr	r3, [pc, #84]	; (1ef4 <u8x8_byte_hw_i2c+0xec>)
    1ea0:	2001      	movs	r0, #1
    1ea2:	4798      	blx	r3
            if(oled_i2c_timeout==0) {
    1ea4:	7833      	ldrb	r3, [r6, #0]
    1ea6:	2b00      	cmp	r3, #0
    1ea8:	d1f1      	bne.n	1e8e <u8x8_byte_hw_i2c+0x86>
                SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
    1eaa:	23c0      	movs	r3, #192	; 0xc0
    1eac:	6862      	ldr	r2, [r4, #4]
    1eae:	029b      	lsls	r3, r3, #10
    1eb0:	4313      	orrs	r3, r2
    1eb2:	6063      	str	r3, [r4, #4]
                while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY);
    1eb4:	8a23      	ldrh	r3, [r4, #16]
    1eb6:	0bdb      	lsrs	r3, r3, #15
    1eb8:	d1fc      	bne.n	1eb4 <u8x8_byte_hw_i2c+0xac>
            SERCOM3->I2CM.INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
    1eba:	2303      	movs	r3, #3
    1ebc:	7323      	strb	r3, [r4, #12]
    1ebe:	e7ea      	b.n	1e96 <u8x8_byte_hw_i2c+0x8e>
      return 0;
    1ec0:	2000      	movs	r0, #0
    1ec2:	e7d3      	b.n	1e6c <u8x8_byte_hw_i2c+0x64>
    1ec4:	20000d09 	.word	0x20000d09
    1ec8:	20000cc7 	.word	0x20000cc7
    1ecc:	2000039c 	.word	0x2000039c
    1ed0:	0000a7ef 	.word	0x0000a7ef
    1ed4:	00007b99 	.word	0x00007b99
    1ed8:	20000ce8 	.word	0x20000ce8
    1edc:	00008945 	.word	0x00008945
    1ee0:	20000d0a 	.word	0x20000d0a
    1ee4:	20000d08 	.word	0x20000d08
    1ee8:	42001400 	.word	0x42001400
    1eec:	fffbffff 	.word	0xfffbffff
    1ef0:	20000d0d 	.word	0x20000d0d
    1ef4:	00007c05 	.word	0x00007c05

00001ef8 <SERCOM3_Handler>:
{ 
    1ef8:	b510      	push	{r4, lr}
    if (SERCOM3->I2CM.INTFLAG.bit.MB) {
    1efa:	4b2f      	ldr	r3, [pc, #188]	; (1fb8 <SERCOM3_Handler+0xc0>)
    1efc:	7b9a      	ldrb	r2, [r3, #14]
    1efe:	07d2      	lsls	r2, r2, #31
    1f00:	d511      	bpl.n	1f26 <SERCOM3_Handler+0x2e>
        if (oled_i2c_idx == oled_i2c_nof_tx) {   
    1f02:	492e      	ldr	r1, [pc, #184]	; (1fbc <SERCOM3_Handler+0xc4>)
    1f04:	482e      	ldr	r0, [pc, #184]	; (1fc0 <SERCOM3_Handler+0xc8>)
    1f06:	780a      	ldrb	r2, [r1, #0]
    1f08:	7800      	ldrb	r0, [r0, #0]
    1f0a:	4290      	cmp	r0, r2
    1f0c:	d131      	bne.n	1f72 <SERCOM3_Handler+0x7a>
            SERCOM3->I2CM.CTRLB.bit.CMD = 0x3; 
    1f0e:	22c0      	movs	r2, #192	; 0xc0
    1f10:	6858      	ldr	r0, [r3, #4]
    1f12:	0292      	lsls	r2, r2, #10
    1f14:	4302      	orrs	r2, r0
    1f16:	605a      	str	r2, [r3, #4]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1f18:	8a1a      	ldrh	r2, [r3, #16]
    1f1a:	0bd2      	lsrs	r2, r2, #15
    1f1c:	d1fc      	bne.n	1f18 <SERCOM3_Handler+0x20>
            oled_i2c_tx_done = true; 
    1f1e:	2401      	movs	r4, #1
    1f20:	4828      	ldr	r0, [pc, #160]	; (1fc4 <SERCOM3_Handler+0xcc>)
            oled_i2c_idx = 0; 
    1f22:	700a      	strb	r2, [r1, #0]
            oled_i2c_tx_done = true; 
    1f24:	7004      	strb	r4, [r0, #0]
    if (SERCOM3->I2CM.INTFLAG.bit.SB) {
    1f26:	7b9a      	ldrb	r2, [r3, #14]
    1f28:	0792      	lsls	r2, r2, #30
    1f2a:	d521      	bpl.n	1f70 <SERCOM3_Handler+0x78>
        if (oled_i2c_idx == (oled_i2c_nof_rx-1)) { 
    1f2c:	4826      	ldr	r0, [pc, #152]	; (1fc8 <SERCOM3_Handler+0xd0>)
    1f2e:	4923      	ldr	r1, [pc, #140]	; (1fbc <SERCOM3_Handler+0xc4>)
    1f30:	7800      	ldrb	r0, [r0, #0]
    1f32:	780a      	ldrb	r2, [r1, #0]
    1f34:	3801      	subs	r0, #1
    1f36:	4282      	cmp	r2, r0
    1f38:	d124      	bne.n	1f84 <SERCOM3_Handler+0x8c>
            SERCOM3->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    1f3a:	2080      	movs	r0, #128	; 0x80
    1f3c:	685c      	ldr	r4, [r3, #4]
    1f3e:	02c0      	lsls	r0, r0, #11
    1f40:	4320      	orrs	r0, r4
    1f42:	6058      	str	r0, [r3, #4]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1f44:	8a18      	ldrh	r0, [r3, #16]
    1f46:	0bc0      	lsrs	r0, r0, #15
    1f48:	d1fc      	bne.n	1f44 <SERCOM3_Handler+0x4c>
            SERCOM3->I2CM.CTRLB.bit.CMD = 0x3;
    1f4a:	20c0      	movs	r0, #192	; 0xc0
    1f4c:	685c      	ldr	r4, [r3, #4]
    1f4e:	0280      	lsls	r0, r0, #10
    1f50:	4320      	orrs	r0, r4
    1f52:	6058      	str	r0, [r3, #4]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1f54:	8a18      	ldrh	r0, [r3, #16]
    1f56:	0bc0      	lsrs	r0, r0, #15
    1f58:	d1fc      	bne.n	1f54 <SERCOM3_Handler+0x5c>
            oled_i2c_rx_buf[oled_i2c_idx++] = SERCOM3->I2CM.DATA.reg; 
    1f5a:	1c50      	adds	r0, r2, #1
    1f5c:	7008      	strb	r0, [r1, #0]
    1f5e:	7e18      	ldrb	r0, [r3, #24]
    1f60:	491a      	ldr	r1, [pc, #104]	; (1fcc <SERCOM3_Handler+0xd4>)
    1f62:	5488      	strb	r0, [r1, r2]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1f64:	8a1a      	ldrh	r2, [r3, #16]
    1f66:	0bd2      	lsrs	r2, r2, #15
    1f68:	d1fc      	bne.n	1f64 <SERCOM3_Handler+0x6c>
            oled_i2c_rx_done = true;
    1f6a:	4b16      	ldr	r3, [pc, #88]	; (1fc4 <SERCOM3_Handler+0xcc>)
    1f6c:	3201      	adds	r2, #1
    1f6e:	705a      	strb	r2, [r3, #1]
}
    1f70:	bd10      	pop	{r4, pc}
            SERCOM3->I2CM.DATA.reg = oled_i2c_tx_buf[oled_i2c_idx++]; 
    1f72:	1c50      	adds	r0, r2, #1
    1f74:	7008      	strb	r0, [r1, #0]
    1f76:	4916      	ldr	r1, [pc, #88]	; (1fd0 <SERCOM3_Handler+0xd8>)
    1f78:	5c8a      	ldrb	r2, [r1, r2]
    1f7a:	761a      	strb	r2, [r3, #24]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY);
    1f7c:	8a1a      	ldrh	r2, [r3, #16]
    1f7e:	0bd2      	lsrs	r2, r2, #15
    1f80:	d1fc      	bne.n	1f7c <SERCOM3_Handler+0x84>
    1f82:	e7d0      	b.n	1f26 <SERCOM3_Handler+0x2e>
            SERCOM3->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT; 
    1f84:	6858      	ldr	r0, [r3, #4]
    1f86:	4c13      	ldr	r4, [pc, #76]	; (1fd4 <SERCOM3_Handler+0xdc>)
    1f88:	4020      	ands	r0, r4
    1f8a:	6058      	str	r0, [r3, #4]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1f8c:	8a18      	ldrh	r0, [r3, #16]
    1f8e:	0bc0      	lsrs	r0, r0, #15
    1f90:	d1fc      	bne.n	1f8c <SERCOM3_Handler+0x94>
            oled_i2c_rx_buf[oled_i2c_idx++] = SERCOM3->I2CM.DATA.reg; 
    1f92:	1c50      	adds	r0, r2, #1
    1f94:	7008      	strb	r0, [r1, #0]
    1f96:	7e18      	ldrb	r0, [r3, #24]
    1f98:	490c      	ldr	r1, [pc, #48]	; (1fcc <SERCOM3_Handler+0xd4>)
    1f9a:	5488      	strb	r0, [r1, r2]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1f9c:	8a1a      	ldrh	r2, [r3, #16]
    1f9e:	0bd2      	lsrs	r2, r2, #15
    1fa0:	d1fc      	bne.n	1f9c <SERCOM3_Handler+0xa4>
            SERCOM3->I2CM.CTRLB.bit.CMD = 0x2; 
    1fa2:	685a      	ldr	r2, [r3, #4]
    1fa4:	490c      	ldr	r1, [pc, #48]	; (1fd8 <SERCOM3_Handler+0xe0>)
    1fa6:	4011      	ands	r1, r2
    1fa8:	2280      	movs	r2, #128	; 0x80
    1faa:	0292      	lsls	r2, r2, #10
    1fac:	430a      	orrs	r2, r1
    1fae:	605a      	str	r2, [r3, #4]
            while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    1fb0:	8a1a      	ldrh	r2, [r3, #16]
    1fb2:	0bd2      	lsrs	r2, r2, #15
    1fb4:	d1fc      	bne.n	1fb0 <SERCOM3_Handler+0xb8>
    1fb6:	e7db      	b.n	1f70 <SERCOM3_Handler+0x78>
    1fb8:	42001400 	.word	0x42001400
    1fbc:	20000cc7 	.word	0x20000cc7
    1fc0:	20000d0a 	.word	0x20000d0a
    1fc4:	2000039c 	.word	0x2000039c
    1fc8:	20000d08 	.word	0x20000d08
    1fcc:	20000cc8 	.word	0x20000cc8
    1fd0:	20000ce8 	.word	0x20000ce8
    1fd4:	fffbffff 	.word	0xfffbffff
    1fd8:	fffcffff 	.word	0xfffcffff

00001fdc <oled_init>:
{
    1fdc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
HAL_GPIO_PIN(OLED_SDA,  A, 22)
    1fde:	2480      	movs	r4, #128	; 0x80
    1fe0:	9001      	str	r0, [sp, #4]
    1fe2:	2002      	movs	r0, #2
    1fe4:	4d41      	ldr	r5, [pc, #260]	; (20ec <oled_init+0x110>)
    1fe6:	4b42      	ldr	r3, [pc, #264]	; (20f0 <oled_init+0x114>)
    1fe8:	03e4      	lsls	r4, r4, #15
    1fea:	606c      	str	r4, [r5, #4]
    1fec:	781a      	ldrb	r2, [r3, #0]
    1fee:	260f      	movs	r6, #15
    1ff0:	4302      	orrs	r2, r0
    1ff2:	701a      	strb	r2, [r3, #0]
    1ff4:	2204      	movs	r2, #4
    1ff6:	7819      	ldrb	r1, [r3, #0]
HAL_GPIO_PIN(OLED_SCL,  A, 23)
    1ff8:	2780      	movs	r7, #128	; 0x80
HAL_GPIO_PIN(OLED_SDA,  A, 22)
    1ffa:	4391      	bics	r1, r2
    1ffc:	7019      	strb	r1, [r3, #0]
    1ffe:	61ac      	str	r4, [r5, #24]
    2000:	7819      	ldrb	r1, [r3, #0]
HAL_GPIO_PIN(OLED_SCL,  A, 23)
    2002:	043f      	lsls	r7, r7, #16
HAL_GPIO_PIN(OLED_SDA,  A, 22)
    2004:	4311      	orrs	r1, r2
    2006:	7019      	strb	r1, [r3, #0]
    2008:	2101      	movs	r1, #1
    200a:	781c      	ldrb	r4, [r3, #0]
    200c:	430c      	orrs	r4, r1
    200e:	701c      	strb	r4, [r3, #0]
    2010:	4c38      	ldr	r4, [pc, #224]	; (20f4 <oled_init+0x118>)
    2012:	7823      	ldrb	r3, [r4, #0]
    2014:	43b3      	bics	r3, r6
    2016:	4303      	orrs	r3, r0
    2018:	7023      	strb	r3, [r4, #0]
HAL_GPIO_PIN(OLED_SCL,  A, 23)
    201a:	4b37      	ldr	r3, [pc, #220]	; (20f8 <oled_init+0x11c>)
    201c:	606f      	str	r7, [r5, #4]
    201e:	781e      	ldrb	r6, [r3, #0]
    2020:	4330      	orrs	r0, r6
    2022:	7018      	strb	r0, [r3, #0]
    2024:	7818      	ldrb	r0, [r3, #0]
    2026:	260f      	movs	r6, #15
    2028:	4390      	bics	r0, r2
    202a:	7018      	strb	r0, [r3, #0]
    202c:	61af      	str	r7, [r5, #24]
    202e:	2520      	movs	r5, #32
    2030:	7818      	ldrb	r0, [r3, #0]
    2032:	4302      	orrs	r2, r0
    2034:	701a      	strb	r2, [r3, #0]
    2036:	781a      	ldrb	r2, [r3, #0]
    2038:	430a      	orrs	r2, r1
    203a:	701a      	strb	r2, [r3, #0]
    203c:	7823      	ldrb	r3, [r4, #0]
    203e:	401e      	ands	r6, r3
    2040:	432e      	orrs	r6, r5
    2042:	7026      	strb	r6, [r4, #0]
    if(onoff==0) {
    2044:	9b01      	ldr	r3, [sp, #4]
    2046:	4c2d      	ldr	r4, [pc, #180]	; (20fc <oled_init+0x120>)
    2048:	2b00      	cmp	r3, #0
    204a:	d107      	bne.n	205c <oled_init+0x80>
        u8g2_SetPowerSave(&u8g2,1);
    204c:	482c      	ldr	r0, [pc, #176]	; (2100 <oled_init+0x124>)
    204e:	4b2d      	ldr	r3, [pc, #180]	; (2104 <oled_init+0x128>)
    2050:	3004      	adds	r0, #4
    2052:	4798      	blx	r3
        PM->APBCMASK.reg &= ~PM_APBCMASK_SERCOM3;
    2054:	6a23      	ldr	r3, [r4, #32]
    2056:	43ab      	bics	r3, r5
    2058:	6223      	str	r3, [r4, #32]
}
    205a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        PM->APBCMASK.reg |= PM_APBCMASK_SERCOM3;
    205c:	6a23      	ldr	r3, [r4, #32]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM3_GCLK_ID_CORE) |
    205e:	4a2a      	ldr	r2, [pc, #168]	; (2108 <oled_init+0x12c>)
        PM->APBCMASK.reg |= PM_APBCMASK_SERCOM3;
    2060:	431d      	orrs	r5, r3
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM3_GCLK_ID_CORE) |
    2062:	4b2a      	ldr	r3, [pc, #168]	; (210c <oled_init+0x130>)
        PM->APBCMASK.reg |= PM_APBCMASK_SERCOM3;
    2064:	6225      	str	r5, [r4, #32]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM3_GCLK_ID_CORE) |
    2066:	805a      	strh	r2, [r3, #2]
        SERCOM3->I2CM.CTRLA.reg =// SERCOM_I2CM_CTRLA_LOWTOUT |
    2068:	2294      	movs	r2, #148	; 0x94
    206a:	4b29      	ldr	r3, [pc, #164]	; (2110 <oled_init+0x134>)
    206c:	601a      	str	r2, [r3, #0]
        SERCOM3->I2CM.CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN; 
    206e:	326c      	adds	r2, #108	; 0x6c
    2070:	605a      	str	r2, [r3, #4]
        while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    2072:	8a1a      	ldrh	r2, [r3, #16]
    2074:	0bd2      	lsrs	r2, r2, #15
    2076:	d1fc      	bne.n	2072 <oled_init+0x96>
        SERCOM3->I2CM.BAUD.reg = SERCOM_I2CM_BAUD_BAUD(11) | SERCOM_I2CM_BAUD_BAUDLOW(22); // ratio 1:2 //178kHz (measured)
    2078:	4a26      	ldr	r2, [pc, #152]	; (2114 <oled_init+0x138>)
    207a:	815a      	strh	r2, [r3, #10]
        while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    207c:	8a1a      	ldrh	r2, [r3, #16]
    207e:	0bd2      	lsrs	r2, r2, #15
    2080:	d1fc      	bne.n	207c <oled_init+0xa0>
        SERCOM3->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE; 
    2082:	6819      	ldr	r1, [r3, #0]
    2084:	3202      	adds	r2, #2
    2086:	430a      	orrs	r2, r1
    2088:	601a      	str	r2, [r3, #0]
        while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY);
    208a:	8a1a      	ldrh	r2, [r3, #16]
    208c:	0bd2      	lsrs	r2, r2, #15
    208e:	d1fc      	bne.n	208a <oled_init+0xae>
        SERCOM3->I2CM.STATUS.bit.BUSSTATE = 0x1; 
    2090:	2130      	movs	r1, #48	; 0x30
    2092:	8a1a      	ldrh	r2, [r3, #16]
    2094:	438a      	bics	r2, r1
    2096:	0011      	movs	r1, r2
    2098:	2210      	movs	r2, #16
    209a:	430a      	orrs	r2, r1
    209c:	821a      	strh	r2, [r3, #16]
        while(SERCOM3->I2CM.STATUS.bit.SYNCBUSY); 
    209e:	8a1c      	ldrh	r4, [r3, #16]
    20a0:	0be4      	lsrs	r4, r4, #15
    20a2:	d1fc      	bne.n	209e <oled_init+0xc2>
        SERCOM3->I2CM.INTENSET.reg = SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB; 
    20a4:	2203      	movs	r2, #3
    20a6:	735a      	strb	r2, [r3, #13]
    20a8:	2280      	movs	r2, #128	; 0x80
        u8g2_Setup_sh1106_i2c_128x64_noname_2(&u8g2,U8G2_R2,u8x8_byte_hw_i2c,u8g2_gpio_and_delay_samd20); // 180 degrees rotation
    20aa:	4d15      	ldr	r5, [pc, #84]	; (2100 <oled_init+0x124>)
    20ac:	4b1a      	ldr	r3, [pc, #104]	; (2118 <oled_init+0x13c>)
    20ae:	1d2e      	adds	r6, r5, #4
    20b0:	00d2      	lsls	r2, r2, #3
    20b2:	601a      	str	r2, [r3, #0]
    20b4:	4919      	ldr	r1, [pc, #100]	; (211c <oled_init+0x140>)
    20b6:	4a1a      	ldr	r2, [pc, #104]	; (2120 <oled_init+0x144>)
    20b8:	4b1a      	ldr	r3, [pc, #104]	; (2124 <oled_init+0x148>)
    20ba:	0030      	movs	r0, r6
    20bc:	4f1a      	ldr	r7, [pc, #104]	; (2128 <oled_init+0x14c>)
    20be:	47b8      	blx	r7
        u8g2_SetI2CAddress(&u8g2,0x78);
    20c0:	2378      	movs	r3, #120	; 0x78
    20c2:	3505      	adds	r5, #5
    20c4:	77eb      	strb	r3, [r5, #31]
        u8g2_InitDisplay(&u8g2);
    20c6:	0030      	movs	r0, r6
    20c8:	4b18      	ldr	r3, [pc, #96]	; (212c <oled_init+0x150>)
    20ca:	4798      	blx	r3
        u8g2_SetPowerSave(&u8g2,0);
    20cc:	4b0d      	ldr	r3, [pc, #52]	; (2104 <oled_init+0x128>)
    20ce:	0021      	movs	r1, r4
    20d0:	0030      	movs	r0, r6
    20d2:	4798      	blx	r3
        oled_credit_value=0;
    20d4:	4b16      	ldr	r3, [pc, #88]	; (2130 <oled_init+0x154>)
    20d6:	809c      	strh	r4, [r3, #4]
        oled_credit_value_blinking=0;
    20d8:	719c      	strb	r4, [r3, #6]
        oled_soc=0;
    20da:	71dc      	strb	r4, [r3, #7]
        oled_load=0;
    20dc:	721c      	strb	r4, [r3, #8]
        oled_update_idx=0;
    20de:	725c      	strb	r4, [r3, #9]
        oled_draw_battery=0;
    20e0:	729c      	strb	r4, [r3, #10]
        oled_draw_load=0;
    20e2:	72dc      	strb	r4, [r3, #11]
        oled_draw_errorsign=0;
    20e4:	731c      	strb	r4, [r3, #12]
        oled_draw_credit_value=0;
    20e6:	735c      	strb	r4, [r3, #13]
}
    20e8:	e7b7      	b.n	205a <oled_init+0x7e>
    20ea:	46c0      	nop			; (mov r8, r8)
    20ec:	41004400 	.word	0x41004400
    20f0:	41004456 	.word	0x41004456
    20f4:	4100443b 	.word	0x4100443b
    20f8:	41004457 	.word	0x41004457
    20fc:	40000400 	.word	0x40000400
    2100:	2000039c 	.word	0x2000039c
    2104:	00003797 	.word	0x00003797
    2108:	00004010 	.word	0x00004010
    210c:	40000c00 	.word	0x40000c00
    2110:	42001400 	.word	0x42001400
    2114:	0000160b 	.word	0x0000160b
    2118:	e000e100 	.word	0xe000e100
    211c:	0000a958 	.word	0x0000a958
    2120:	00001e09 	.word	0x00001e09
    2124:	00001dd9 	.word	0x00001dd9
    2128:	00002a2d 	.word	0x00002a2d
    212c:	00003789 	.word	0x00003789
    2130:	2000041c 	.word	0x2000041c

00002134 <oled_write_number_int>:
{
    2134:	4b04      	ldr	r3, [pc, #16]	; (2148 <oled_write_number_int+0x14>)
    if(value < 0) {
    2136:	2800      	cmp	r0, #0
    2138:	da03      	bge.n	2142 <oled_write_number_int+0xe>
        oled_credit_value=0;
    213a:	2200      	movs	r2, #0
    213c:	809a      	strh	r2, [r3, #4]
    oled_credit_value_blinking=blinking;
    213e:	7199      	strb	r1, [r3, #6]
}
    2140:	4770      	bx	lr
        oled_credit_value=value;
    2142:	8098      	strh	r0, [r3, #4]
    2144:	e7fb      	b.n	213e <oled_write_number_int+0xa>
    2146:	46c0      	nop			; (mov r8, r8)
    2148:	2000041c 	.word	0x2000041c

0000214c <oled_update>:
{
    214c:	b5f0      	push	{r4, r5, r6, r7, lr}
    214e:	b08d      	sub	sp, #52	; 0x34
  __ASM volatile ("cpsid i" : : : "memory");
    2150:	b672      	cpsid	i
    blink_toggle = sysTime.ms>500;
    2152:	4bae      	ldr	r3, [pc, #696]	; (240c <oled_update+0x2c0>)
    2154:	881b      	ldrh	r3, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
    2156:	b662      	cpsie	i
    if(oled_update_idx==0) {
    2158:	4cad      	ldr	r4, [pc, #692]	; (2410 <oled_update+0x2c4>)
    215a:	4dae      	ldr	r5, [pc, #696]	; (2414 <oled_update+0x2c8>)
    215c:	7a62      	ldrb	r2, [r4, #9]
    215e:	4eae      	ldr	r6, [pc, #696]	; (2418 <oled_update+0x2cc>)
    2160:	9204      	str	r2, [sp, #16]
    2162:	2a00      	cmp	r2, #0
    2164:	d000      	beq.n	2168 <oled_update+0x1c>
    2166:	e0a1      	b.n	22ac <oled_update+0x160>
    blink_toggle = sysTime.ms>500;
    2168:	27fa      	movs	r7, #250	; 0xfa
    216a:	007f      	lsls	r7, r7, #1
    216c:	429f      	cmp	r7, r3
    216e:	41bf      	sbcs	r7, r7
        u8g2_FirstPage(&u8g2);
    2170:	1d28      	adds	r0, r5, #4
    2172:	4baa      	ldr	r3, [pc, #680]	; (241c <oled_update+0x2d0>)
    2174:	4798      	blx	r3
    	oled_update_idx++;
    2176:	7a63      	ldrb	r3, [r4, #9]
    blink_toggle = sysTime.ms>500;
    2178:	427f      	negs	r7, r7
    	oled_update_idx++;
    217a:	3301      	adds	r3, #1
    217c:	7263      	strb	r3, [r4, #9]
        oled_soc = sysval.SoC/2;
    217e:	0033      	movs	r3, r6
    2180:	33ac      	adds	r3, #172	; 0xac
    2182:	781b      	ldrb	r3, [r3, #0]
    2184:	085b      	lsrs	r3, r3, #1
    2186:	71e3      	strb	r3, [r4, #7]
        oled_draw_load=1;
    2188:	2301      	movs	r3, #1
    218a:	72e3      	strb	r3, [r4, #11]
        iload_tmp += sysval.I_load;
    218c:	0033      	movs	r3, r6
    218e:	3394      	adds	r3, #148	; 0x94
    2190:	2000      	movs	r0, #0
    2192:	5e18      	ldrsh	r0, [r3, r0]
        if(iload_tmp > OLED_MAX_LOAD_CURR_cA) {
    2194:	23fa      	movs	r3, #250	; 0xfa
    2196:	009b      	lsls	r3, r3, #2
    2198:	4298      	cmp	r0, r3
    219a:	dc00      	bgt.n	219e <oled_update+0x52>
    219c:	e06d      	b.n	227a <oled_update+0x12e>
            oled_load = 39;
    219e:	2327      	movs	r3, #39	; 0x27
            oled_draw_load=blink_toggle;
    21a0:	72e7      	strb	r7, [r4, #11]
            oled_load = 39;
    21a2:	7223      	strb	r3, [r4, #8]
        if(oled_load > 39) oled_load=39;
    21a4:	7a23      	ldrb	r3, [r4, #8]
    21a6:	2b27      	cmp	r3, #39	; 0x27
    21a8:	d901      	bls.n	21ae <oled_update+0x62>
    21aa:	2327      	movs	r3, #39	; 0x27
    21ac:	7223      	strb	r3, [r4, #8]
        nof_mods=sysval.scc_nof_scc;
    21ae:	0033      	movs	r3, r6
    21b0:	332c      	adds	r3, #44	; 0x2c
    21b2:	781b      	ldrb	r3, [r3, #0]
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;
    21b4:	2003      	movs	r0, #3
        nof_mods=sysval.scc_nof_scc;
    21b6:	b25b      	sxtb	r3, r3
    21b8:	9302      	str	r3, [sp, #8]
        oled_draw_battery=1;        
    21ba:	2301      	movs	r3, #1
    21bc:	72a3      	strb	r3, [r4, #10]
            uint8_t tmp_battstate = (sysval.batt_state>>(i*2))&0x03;
    21be:	0033      	movs	r3, r6
    21c0:	33b7      	adds	r3, #183	; 0xb7
    21c2:	781b      	ldrb	r3, [r3, #0]
    21c4:	9307      	str	r3, [sp, #28]
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;
    21c6:	0033      	movs	r3, r6
    21c8:	33b8      	adds	r3, #184	; 0xb8
    21ca:	781b      	ldrb	r3, [r3, #0]
    21cc:	9303      	str	r3, [sp, #12]
            uint8_t tmp_loadstate = (sysval.load_state>>(i*2))&0x03;
    21ce:	0033      	movs	r3, r6
    21d0:	33b6      	adds	r3, #182	; 0xb6
    21d2:	781b      	ldrb	r3, [r3, #0]
    21d4:	9305      	str	r3, [sp, #20]
            if( (tmp_battstate==0x02 && tmp_sysstate!=0x03) || sysval.SoC<10 || 
    21d6:	0033      	movs	r3, r6
    21d8:	33ac      	adds	r3, #172	; 0xac
    21da:	781b      	ldrb	r3, [r3, #0]
                (tmp_loadstate==0x03 && tmp_sysstate!=0x03 && sysval.Vbatt < 1080) ) {
    21dc:	3690      	adds	r6, #144	; 0x90
            if( (tmp_battstate==0x02 && tmp_sysstate!=0x03) || sysval.SoC<10 || 
    21de:	469c      	mov	ip, r3
                (tmp_loadstate==0x03 && tmp_sysstate!=0x03 && sysval.Vbatt < 1080) ) {
    21e0:	2200      	movs	r2, #0
    21e2:	5eb3      	ldrsh	r3, [r6, r2]
    21e4:	4e8e      	ldr	r6, [pc, #568]	; (2420 <oled_update+0x2d4>)
    21e6:	9306      	str	r3, [sp, #24]
        for(i=0;i<nof_mods;i++) {
    21e8:	2300      	movs	r3, #0
    21ea:	9902      	ldr	r1, [sp, #8]
    21ec:	b25a      	sxtb	r2, r3
    21ee:	4291      	cmp	r1, r2
    21f0:	dd1a      	ble.n	2228 <oled_update+0xdc>
            uint8_t tmp_battstate = (sysval.batt_state>>(i*2))&0x03;
    21f2:	9907      	ldr	r1, [sp, #28]
    21f4:	005d      	lsls	r5, r3, #1
    21f6:	4129      	asrs	r1, r5
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;
    21f8:	9a03      	ldr	r2, [sp, #12]
            uint8_t tmp_loadstate = (sysval.load_state>>(i*2))&0x03;
    21fa:	9c05      	ldr	r4, [sp, #20]
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;
    21fc:	412a      	asrs	r2, r5
            uint8_t tmp_loadstate = (sysval.load_state>>(i*2))&0x03;
    21fe:	412c      	asrs	r4, r5
            uint8_t tmp_battstate = (sysval.batt_state>>(i*2))&0x03;
    2200:	000d      	movs	r5, r1
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;
    2202:	4002      	ands	r2, r0
            uint8_t tmp_loadstate = (sysval.load_state>>(i*2))&0x03;
    2204:	4004      	ands	r4, r0
            if( (tmp_battstate==0x02 && tmp_sysstate!=0x03) || sysval.SoC<10 || 
    2206:	4005      	ands	r5, r0
    2208:	2d02      	cmp	r5, #2
    220a:	d101      	bne.n	2210 <oled_update+0xc4>
    220c:	2a03      	cmp	r2, #3
    220e:	d109      	bne.n	2224 <oled_update+0xd8>
    2210:	4661      	mov	r1, ip
    2212:	2909      	cmp	r1, #9
    2214:	d906      	bls.n	2224 <oled_update+0xd8>
    2216:	2c03      	cmp	r4, #3
    2218:	d134      	bne.n	2284 <oled_update+0x138>
                (tmp_loadstate==0x03 && tmp_sysstate!=0x03 && sysval.Vbatt < 1080) ) {
    221a:	2a03      	cmp	r2, #3
    221c:	d032      	beq.n	2284 <oled_update+0x138>
    221e:	9a06      	ldr	r2, [sp, #24]
    2220:	42b2      	cmp	r2, r6
    2222:	dc2f      	bgt.n	2284 <oled_update+0x138>
                oled_draw_battery=blink_toggle; break;
    2224:	4b7a      	ldr	r3, [pc, #488]	; (2410 <oled_update+0x2c4>)
    2226:	729f      	strb	r7, [r3, #10]
        for(i=0;i<nof_mods;i++) {            
    2228:	2300      	movs	r3, #0
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;          
    222a:	2003      	movs	r0, #3
        for(i=0;i<nof_mods;i++) {            
    222c:	9902      	ldr	r1, [sp, #8]
    222e:	b25a      	sxtb	r2, r3
    2230:	4291      	cmp	r1, r2
    2232:	dd08      	ble.n	2246 <oled_update+0xfa>
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;          
    2234:	9903      	ldr	r1, [sp, #12]
    2236:	005a      	lsls	r2, r3, #1
    2238:	4111      	asrs	r1, r2
    223a:	000a      	movs	r2, r1
    223c:	3301      	adds	r3, #1
    223e:	4002      	ands	r2, r0
            if( tmp_sysstate==0x00 ) {
    2240:	d1f4      	bne.n	222c <oled_update+0xe0>
                oled_draw_battery=0; break;
    2242:	4b73      	ldr	r3, [pc, #460]	; (2410 <oled_update+0x2c4>)
    2244:	729a      	strb	r2, [r3, #10]
        oled_draw_errorsign=0;        
    2246:	2300      	movs	r3, #0
    2248:	4a71      	ldr	r2, [pc, #452]	; (2410 <oled_update+0x2c4>)
        for(i=0;i<nof_mods;i++) {
    224a:	001c      	movs	r4, r3
        oled_draw_errorsign=0;        
    224c:	7313      	strb	r3, [r2, #12]
                oled_draw_errorsign=blink_toggle;
    224e:	2201      	movs	r2, #1
            uint8_t tmp_loadstate = (sysval.load_state>>(i*2))&0x03;
    2250:	2503      	movs	r5, #3
                oled_draw_errorsign=blink_toggle;
    2252:	4694      	mov	ip, r2
            if( tmp_loadstate==0x03 && tmp_sysstate!=0x03 && sysval.Vbatt >= 1080) {
    2254:	4e72      	ldr	r6, [pc, #456]	; (2420 <oled_update+0x2d4>)
        for(i=0;i<nof_mods;i++) {
    2256:	9902      	ldr	r1, [sp, #8]
    2258:	b25a      	sxtb	r2, r3
    225a:	4291      	cmp	r1, r2
    225c:	dc14      	bgt.n	2288 <oled_update+0x13c>
    225e:	4b6c      	ldr	r3, [pc, #432]	; (2410 <oled_update+0x2c4>)
    2260:	2c00      	cmp	r4, #0
    2262:	d002      	beq.n	226a <oled_update+0x11e>
    2264:	466a      	mov	r2, sp
    2266:	7c12      	ldrb	r2, [r2, #16]
    2268:	731a      	strb	r2, [r3, #12]
        oled_draw_credit_value=1;                    
    226a:	2201      	movs	r2, #1
    226c:	735a      	strb	r2, [r3, #13]
        if(oled_credit_value_blinking) {
    226e:	799a      	ldrb	r2, [r3, #6]
    2270:	2a00      	cmp	r2, #0
    2272:	d000      	beq.n	2276 <oled_update+0x12a>
            oled_draw_credit_value=blink_toggle;            
    2274:	735f      	strb	r7, [r3, #13]
}
    2276:	b00d      	add	sp, #52	; 0x34
    2278:	bdf0      	pop	{r4, r5, r6, r7, pc}
            oled_load = (uint8_t)(iload_tmp/(OLED_MAX_LOAD_CURR_cA/40));
    227a:	2119      	movs	r1, #25
    227c:	4b69      	ldr	r3, [pc, #420]	; (2424 <oled_update+0x2d8>)
    227e:	4798      	blx	r3
    2280:	7220      	strb	r0, [r4, #8]
    2282:	e78f      	b.n	21a4 <oled_update+0x58>
    2284:	3301      	adds	r3, #1
    2286:	e7b0      	b.n	21ea <oled_update+0x9e>
            uint8_t tmp_loadstate = (sysval.load_state>>(i*2))&0x03;
    2288:	9a05      	ldr	r2, [sp, #20]
    228a:	0058      	lsls	r0, r3, #1
    228c:	4102      	asrs	r2, r0
            if( tmp_loadstate==0x03 && tmp_sysstate!=0x03 && sysval.Vbatt >= 1080) {
    228e:	402a      	ands	r2, r5
    2290:	2a03      	cmp	r2, #3
    2292:	d109      	bne.n	22a8 <oled_update+0x15c>
            uint8_t tmp_sysstate = (sysval.sys_state>>(i*2))&0x03;
    2294:	9903      	ldr	r1, [sp, #12]
    2296:	4101      	asrs	r1, r0
            if( tmp_loadstate==0x03 && tmp_sysstate!=0x03 && sysval.Vbatt >= 1080) {
    2298:	400a      	ands	r2, r1
    229a:	2a03      	cmp	r2, #3
    229c:	d004      	beq.n	22a8 <oled_update+0x15c>
    229e:	9a06      	ldr	r2, [sp, #24]
    22a0:	42b2      	cmp	r2, r6
    22a2:	dd01      	ble.n	22a8 <oled_update+0x15c>
                oled_draw_errorsign=blink_toggle;
    22a4:	4664      	mov	r4, ip
    22a6:	9704      	str	r7, [sp, #16]
    22a8:	3301      	adds	r3, #1
    22aa:	e7d4      	b.n	2256 <oled_update+0x10a>
        u8g2_SetFont(&u8g2,u8g2_font_9x15_mn);
    22ac:	1d2f      	adds	r7, r5, #4
    22ae:	4b5e      	ldr	r3, [pc, #376]	; (2428 <oled_update+0x2dc>)
    22b0:	495e      	ldr	r1, [pc, #376]	; (242c <oled_update+0x2e0>)
    22b2:	0038      	movs	r0, r7
    22b4:	4798      	blx	r3
        if(oled_draw_errorsign) {
    22b6:	7b23      	ldrb	r3, [r4, #12]
    22b8:	2b00      	cmp	r3, #0
    22ba:	d008      	beq.n	22ce <oled_update+0x182>
            u8g2_DrawXBM(&u8g2,100,0,icon_error_25x25_width,icon_error_25x25_height,icon_error_25x25_bits);
    22bc:	4b5c      	ldr	r3, [pc, #368]	; (2430 <oled_update+0x2e4>)
    22be:	0038      	movs	r0, r7
    22c0:	9301      	str	r3, [sp, #4]
    22c2:	2319      	movs	r3, #25
    22c4:	2200      	movs	r2, #0
    22c6:	9300      	str	r3, [sp, #0]
    22c8:	2164      	movs	r1, #100	; 0x64
    22ca:	4f5a      	ldr	r7, [pc, #360]	; (2434 <oled_update+0x2e8>)
    22cc:	47b8      	blx	r7
        if(sysval.I_charge > 10) { // 0.1 A
    22ce:	3692      	adds	r6, #146	; 0x92
    22d0:	2200      	movs	r2, #0
    22d2:	5eb3      	ldrsh	r3, [r6, r2]
    22d4:	2b0a      	cmp	r3, #10
    22d6:	dd09      	ble.n	22ec <oled_update+0x1a0>
            u8g2_DrawXBM(&u8g2,12,0,icon_charge_6x12_width,icon_charge_6x12_height,icon_charge_6x12_bits); // charging indicate
    22d8:	210c      	movs	r1, #12
    22da:	4b55      	ldr	r3, [pc, #340]	; (2430 <oled_update+0x2e4>)
    22dc:	1d28      	adds	r0, r5, #4
    22de:	3364      	adds	r3, #100	; 0x64
    22e0:	9301      	str	r3, [sp, #4]
    22e2:	9100      	str	r1, [sp, #0]
    22e4:	2306      	movs	r3, #6
    22e6:	2200      	movs	r2, #0
    22e8:	4e52      	ldr	r6, [pc, #328]	; (2434 <oled_update+0x2e8>)
    22ea:	47b0      	blx	r6
        if(oled_draw_battery) {                       
    22ec:	7aa3      	ldrb	r3, [r4, #10]
    22ee:	2b00      	cmp	r3, #0
    22f0:	d01c      	beq.n	232c <oled_update+0x1e0>
            u8g2_DrawBox  (&u8g2,10,13,8,3);      // solid pole of battery // was 10,13,10,3
    22f2:	2303      	movs	r3, #3
    22f4:	1d2e      	adds	r6, r5, #4
    22f6:	0030      	movs	r0, r6
    22f8:	9300      	str	r3, [sp, #0]
    22fa:	220d      	movs	r2, #13
    22fc:	3305      	adds	r3, #5
    22fe:	210a      	movs	r1, #10
    2300:	4f4d      	ldr	r7, [pc, #308]	; (2438 <oled_update+0x2ec>)
    2302:	47b8      	blx	r7
            u8g2_DrawFrame(&u8g2,0, 16, 28,63-16); // frame for battery	// was 0, 16, 30,63-16
    2304:	232f      	movs	r3, #47	; 0x2f
    2306:	0030      	movs	r0, r6
    2308:	9300      	str	r3, [sp, #0]
    230a:	2210      	movs	r2, #16
    230c:	3b13      	subs	r3, #19
    230e:	2100      	movs	r1, #0
    2310:	4f4a      	ldr	r7, [pc, #296]	; (243c <oled_update+0x2f0>)
    2312:	47b8      	blx	r7
            u8g2_DrawBox  (&u8g2,0, 16+(50-oled_soc),28,63-(50-oled_soc)); // solid box representing State Of Charge // was 0, 16+(50-oled_soc),30,63-(50-oled_soc)
    2314:	2242      	movs	r2, #66	; 0x42
    2316:	79e3      	ldrb	r3, [r4, #7]
    2318:	0030      	movs	r0, r6
    231a:	1ad2      	subs	r2, r2, r3
    231c:	330d      	adds	r3, #13
    231e:	b2db      	uxtb	r3, r3
    2320:	9300      	str	r3, [sp, #0]
    2322:	b2d2      	uxtb	r2, r2
    2324:	231c      	movs	r3, #28
    2326:	2100      	movs	r1, #0
    2328:	4e43      	ldr	r6, [pc, #268]	; (2438 <oled_update+0x2ec>)
    232a:	47b0      	blx	r6
        u8g2_DrawCircle(&u8g2,95,55,24,U8G2_DRAW_UPPER_LEFT | U8G2_DRAW_UPPER_RIGHT);
    232c:	2603      	movs	r6, #3
    232e:	3504      	adds	r5, #4
    2330:	4f43      	ldr	r7, [pc, #268]	; (2440 <oled_update+0x2f4>)
    2332:	9600      	str	r6, [sp, #0]
    2334:	2318      	movs	r3, #24
    2336:	2237      	movs	r2, #55	; 0x37
    2338:	215f      	movs	r1, #95	; 0x5f
    233a:	0028      	movs	r0, r5
    233c:	47b8      	blx	r7
        u8g2_DrawCircle(&u8g2,95,55,25,U8G2_DRAW_UPPER_LEFT | U8G2_DRAW_UPPER_RIGHT);
    233e:	9600      	str	r6, [sp, #0]
    2340:	2319      	movs	r3, #25
    2342:	2237      	movs	r2, #55	; 0x37
    2344:	215f      	movs	r1, #95	; 0x5f
    2346:	0028      	movs	r0, r5
    2348:	47b8      	blx	r7
        u8g2_DrawDisc(&u8g2,95,55,3,U8G2_DRAW_ALL);
    234a:	230f      	movs	r3, #15
    234c:	2237      	movs	r2, #55	; 0x37
    234e:	9300      	str	r3, [sp, #0]
    2350:	215f      	movs	r1, #95	; 0x5f
    2352:	0033      	movs	r3, r6
    2354:	0028      	movs	r0, r5
    2356:	4e3b      	ldr	r6, [pc, #236]	; (2444 <oled_update+0x2f8>)
    2358:	47b0      	blx	r6
        u8g2_DrawLine(&u8g2,95,28,95,33);
    235a:	2321      	movs	r3, #33	; 0x21
        u8g2_DrawLine(&u8g2,95-27,55,95-22,55);
    235c:	2637      	movs	r6, #55	; 0x37
        u8g2_DrawLine(&u8g2,95,28,95,33);
    235e:	9300      	str	r3, [sp, #0]
    2360:	333e      	adds	r3, #62	; 0x3e
    2362:	0019      	movs	r1, r3
    2364:	4f38      	ldr	r7, [pc, #224]	; (2448 <oled_update+0x2fc>)
    2366:	221c      	movs	r2, #28
    2368:	0028      	movs	r0, r5
    236a:	47b8      	blx	r7
        u8g2_DrawLine(&u8g2,95-27,55,95-22,55);
    236c:	2349      	movs	r3, #73	; 0x49
    236e:	0032      	movs	r2, r6
    2370:	2144      	movs	r1, #68	; 0x44
    2372:	0028      	movs	r0, r5
    2374:	9600      	str	r6, [sp, #0]
    2376:	47b8      	blx	r7
        u8g2_DrawLine(&u8g2,95+27,55,95+22,55);       
    2378:	2375      	movs	r3, #117	; 0x75
    237a:	9600      	str	r6, [sp, #0]
    237c:	0032      	movs	r2, r6
    237e:	217a      	movs	r1, #122	; 0x7a
    2380:	0028      	movs	r0, r5
    2382:	47b8      	blx	r7
        if(oled_draw_load) {
    2384:	7ae3      	ldrb	r3, [r4, #11]
    2386:	2b00      	cmp	r3, #0
    2388:	d009      	beq.n	239e <oled_update+0x252>
            u8g2_DrawLine(&u8g2,95,55,xload[oled_load],yload[oled_load]); // load indicator
    238a:	7a21      	ldrb	r1, [r4, #8]
    238c:	4a2f      	ldr	r2, [pc, #188]	; (244c <oled_update+0x300>)
    238e:	0028      	movs	r0, r5
    2390:	5c53      	ldrb	r3, [r2, r1]
    2392:	3228      	adds	r2, #40	; 0x28
    2394:	5c52      	ldrb	r2, [r2, r1]
    2396:	215f      	movs	r1, #95	; 0x5f
    2398:	9200      	str	r2, [sp, #0]
    239a:	0032      	movs	r2, r6
    239c:	47b8      	blx	r7
        u8g2_DrawXBM(&u8g2,45,0,icon_alarm_11x14_width,icon_alarm_11x14_height,icon_alarm_11x14_bits);
    239e:	4b24      	ldr	r3, [pc, #144]	; (2430 <oled_update+0x2e4>)
    23a0:	4d1c      	ldr	r5, [pc, #112]	; (2414 <oled_update+0x2c8>)
    23a2:	3370      	adds	r3, #112	; 0x70
    23a4:	9301      	str	r3, [sp, #4]
    23a6:	230e      	movs	r3, #14
    23a8:	1d2f      	adds	r7, r5, #4
    23aa:	9300      	str	r3, [sp, #0]
    23ac:	4e21      	ldr	r6, [pc, #132]	; (2434 <oled_update+0x2e8>)
    23ae:	3b03      	subs	r3, #3
    23b0:	2200      	movs	r2, #0
    23b2:	212d      	movs	r1, #45	; 0x2d
    23b4:	0038      	movs	r0, r7
    23b6:	47b0      	blx	r6
        if(oled_draw_credit_value) {		
    23b8:	7b63      	ldrb	r3, [r4, #13]
    23ba:	4e25      	ldr	r6, [pc, #148]	; (2450 <oled_update+0x304>)
    23bc:	2b00      	cmp	r3, #0
    23be:	d00b      	beq.n	23d8 <oled_update+0x28c>
            sprintf(buf, "%d",oled_credit_value);
    23c0:	2304      	movs	r3, #4
    23c2:	5ee2      	ldrsh	r2, [r4, r3]
    23c4:	0031      	movs	r1, r6
    23c6:	4b23      	ldr	r3, [pc, #140]	; (2454 <oled_update+0x308>)
    23c8:	a809      	add	r0, sp, #36	; 0x24
    23ca:	4798      	blx	r3
            u8g2_DrawStr(&u8g2,60,12,buf); // nr of days
    23cc:	0038      	movs	r0, r7
    23ce:	ab09      	add	r3, sp, #36	; 0x24
    23d0:	220c      	movs	r2, #12
    23d2:	213c      	movs	r1, #60	; 0x3c
    23d4:	4f20      	ldr	r7, [pc, #128]	; (2458 <oled_update+0x30c>)
    23d6:	47b8      	blx	r7
        sprintf(buf, "%d",sysval.scc_nof_scc);
    23d8:	4b0f      	ldr	r3, [pc, #60]	; (2418 <oled_update+0x2cc>)
    23da:	0031      	movs	r1, r6
    23dc:	332c      	adds	r3, #44	; 0x2c
    23de:	781a      	ldrb	r2, [r3, #0]
        u8g2_DrawStr(&u8g2,30,63,buf); // nr of SCCs
    23e0:	3504      	adds	r5, #4
        sprintf(buf, "%d",sysval.scc_nof_scc);
    23e2:	4b1c      	ldr	r3, [pc, #112]	; (2454 <oled_update+0x308>)
    23e4:	a809      	add	r0, sp, #36	; 0x24
    23e6:	4798      	blx	r3
        u8g2_DrawStr(&u8g2,30,63,buf); // nr of SCCs
    23e8:	ab09      	add	r3, sp, #36	; 0x24
    23ea:	223f      	movs	r2, #63	; 0x3f
    23ec:	211e      	movs	r1, #30
    23ee:	0028      	movs	r0, r5
    23f0:	4e19      	ldr	r6, [pc, #100]	; (2458 <oled_update+0x30c>)
    23f2:	47b0      	blx	r6
        if(u8g2_NextPage(&u8g2)) { oled_update_idx++; } else { oled_update_idx=0; }		
    23f4:	0028      	movs	r0, r5
    23f6:	4b19      	ldr	r3, [pc, #100]	; (245c <oled_update+0x310>)
    23f8:	4798      	blx	r3
    23fa:	2800      	cmp	r0, #0
    23fc:	d003      	beq.n	2406 <oled_update+0x2ba>
    23fe:	7a63      	ldrb	r3, [r4, #9]
    2400:	3301      	adds	r3, #1
    2402:	7263      	strb	r3, [r4, #9]
    2404:	e737      	b.n	2276 <oled_update+0x12a>
    2406:	7260      	strb	r0, [r4, #9]
}
    2408:	e735      	b.n	2276 <oled_update+0x12a>
    240a:	46c0      	nop			; (mov r8, r8)
    240c:	20000c10 	.word	0x20000c10
    2410:	2000041c 	.word	0x2000041c
    2414:	2000039c 	.word	0x2000039c
    2418:	20000a58 	.word	0x20000a58
    241c:	000026d9 	.word	0x000026d9
    2420:	00000437 	.word	0x00000437
    2424:	0000809d 	.word	0x0000809d
    2428:	00002fad 	.word	0x00002fad
    242c:	0000a80d 	.word	0x0000a80d
    2430:	20000000 	.word	0x20000000
    2434:	0000255d 	.word	0x0000255d
    2438:	00002575 	.word	0x00002575
    243c:	000025c9 	.word	0x000025c9
    2440:	000028d9 	.word	0x000028d9
    2444:	0000297d 	.word	0x0000297d
    2448:	0000316d 	.word	0x0000316d
    244c:	0000a79f 	.word	0x0000a79f
    2450:	00009d9b 	.word	0x00009d9b
    2454:	00008969 	.word	0x00008969
    2458:	00002f29 	.word	0x00002f29
    245c:	000026fd 	.word	0x000026fd

00002460 <u8g2_DrawHXBMP>:




void u8g2_DrawHXBMP(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, const uint8_t *b)
{
    2460:	b5f0      	push	{r4, r5, r6, r7, lr}
    2462:	b087      	sub	sp, #28
    2464:	9203      	str	r2, [sp, #12]
  uint8_t mask;
  uint8_t color = u8g2->draw_color;
    2466:	0002      	movs	r2, r0
  uint8_t ncolor = (color == 0 ? 1 : 0);
#ifdef U8G2_WITH_INTERSECTION
  if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
    2468:	18cb      	adds	r3, r1, r3
    246a:	b2db      	uxtb	r3, r3
  uint8_t color = u8g2->draw_color;
    246c:	327d      	adds	r2, #125	; 0x7d
    246e:	7812      	ldrb	r2, [r2, #0]
  if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
    2470:	9305      	str	r3, [sp, #20]
    2472:	9b03      	ldr	r3, [sp, #12]
  uint8_t color = u8g2->draw_color;
    2474:	9204      	str	r2, [sp, #16]
  if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
    2476:	3301      	adds	r3, #1
    2478:	b2db      	uxtb	r3, r3
    247a:	9300      	str	r3, [sp, #0]
    247c:	9a03      	ldr	r2, [sp, #12]
    247e:	9b05      	ldr	r3, [sp, #20]
    2480:	4f1b      	ldr	r7, [pc, #108]	; (24f0 <u8g2_DrawHXBMP+0x90>)
{
    2482:	0004      	movs	r4, r0
    2484:	000d      	movs	r5, r1
  if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
    2486:	47b8      	blx	r7
    2488:	2601      	movs	r6, #1
    248a:	2800      	cmp	r0, #0
    248c:	d11c      	bne.n	24c8 <u8g2_DrawHXBMP+0x68>
      b++;
    }
    len--;
  }
  u8g2->draw_color = color;
}
    248e:	b007      	add	sp, #28
    2490:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( u8x8_pgm_read(b) & mask ) {
    2492:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    2494:	781b      	ldrb	r3, [r3, #0]
    2496:	4233      	tst	r3, r6
    2498:	d01e      	beq.n	24d8 <u8g2_DrawHXBMP+0x78>
      u8g2->draw_color = color;
    249a:	466a      	mov	r2, sp
    249c:	0023      	movs	r3, r4
    249e:	7c12      	ldrb	r2, [r2, #16]
    24a0:	337d      	adds	r3, #125	; 0x7d
    24a2:	701a      	strb	r2, [r3, #0]
      u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    24a4:	2300      	movs	r3, #0
      u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    24a6:	9300      	str	r3, [sp, #0]
    24a8:	9a03      	ldr	r2, [sp, #12]
    24aa:	3301      	adds	r3, #1
    24ac:	0029      	movs	r1, r5
    24ae:	0020      	movs	r0, r4
    24b0:	4f10      	ldr	r7, [pc, #64]	; (24f4 <u8g2_DrawHXBMP+0x94>)
    24b2:	47b8      	blx	r7
    mask <<= 1;
    24b4:	0076      	lsls	r6, r6, #1
    x++;
    24b6:	3501      	adds	r5, #1
    mask <<= 1;
    24b8:	b2f6      	uxtb	r6, r6
    x++;
    24ba:	b2ed      	uxtb	r5, r5
    if ( mask == 0 )
    24bc:	2e00      	cmp	r6, #0
    24be:	d103      	bne.n	24c8 <u8g2_DrawHXBMP+0x68>
      b++;
    24c0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
      mask = 1;
    24c2:	3601      	adds	r6, #1
      b++;
    24c4:	3301      	adds	r3, #1
    24c6:	930c      	str	r3, [sp, #48]	; 0x30
  while(len > 0)
    24c8:	9b05      	ldr	r3, [sp, #20]
    24ca:	429d      	cmp	r5, r3
    24cc:	d1e1      	bne.n	2492 <u8g2_DrawHXBMP+0x32>
  u8g2->draw_color = color;
    24ce:	466b      	mov	r3, sp
    24d0:	7c1b      	ldrb	r3, [r3, #16]
    24d2:	347d      	adds	r4, #125	; 0x7d
    24d4:	7023      	strb	r3, [r4, #0]
    24d6:	e7da      	b.n	248e <u8g2_DrawHXBMP+0x2e>
    } else if( u8g2->bitmap_transparency == 0 ) {
    24d8:	0023      	movs	r3, r4
    24da:	337c      	adds	r3, #124	; 0x7c
    24dc:	781b      	ldrb	r3, [r3, #0]
    24de:	2b00      	cmp	r3, #0
    24e0:	d1e8      	bne.n	24b4 <u8g2_DrawHXBMP+0x54>
  uint8_t ncolor = (color == 0 ? 1 : 0);
    24e2:	9904      	ldr	r1, [sp, #16]
    24e4:	424a      	negs	r2, r1
    24e6:	4151      	adcs	r1, r2
      u8g2->draw_color = ncolor;
    24e8:	0022      	movs	r2, r4
    24ea:	327d      	adds	r2, #125	; 0x7d
    24ec:	7011      	strb	r1, [r2, #0]
    24ee:	e7da      	b.n	24a6 <u8g2_DrawHXBMP+0x46>
    24f0:	00003139 	.word	0x00003139
    24f4:	0000308f 	.word	0x0000308f

000024f8 <u8g2_DrawXBMP>:


void u8g2_DrawXBMP(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, const uint8_t *bitmap)
{
    24f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    24fa:	001e      	movs	r6, r3
    24fc:	0014      	movs	r4, r2
    24fe:	b087      	sub	sp, #28
    2500:	ab0c      	add	r3, sp, #48	; 0x30
    2502:	781b      	ldrb	r3, [r3, #0]
  u8g2_uint_t blen;
  blen = w;
  blen += 7;
  blen >>= 3;
#ifdef U8G2_WITH_INTERSECTION
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    2504:	4f13      	ldr	r7, [pc, #76]	; (2554 <u8g2_DrawXBMP+0x5c>)
    2506:	18d3      	adds	r3, r2, r3
    2508:	b2db      	uxtb	r3, r3
    250a:	9303      	str	r3, [sp, #12]
    250c:	9a03      	ldr	r2, [sp, #12]
    250e:	1873      	adds	r3, r6, r1
    2510:	9200      	str	r2, [sp, #0]
    2512:	b2db      	uxtb	r3, r3
    2514:	0022      	movs	r2, r4
{
    2516:	9004      	str	r0, [sp, #16]
    2518:	000d      	movs	r5, r1
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    251a:	47b8      	blx	r7
    251c:	2800      	cmp	r0, #0
    251e:	d006      	beq.n	252e <u8g2_DrawXBMP+0x36>
  blen += 7;
    2520:	1df3      	adds	r3, r6, #7
    2522:	b2db      	uxtb	r3, r3
#endif /* U8G2_WITH_INTERSECTION */
  
  while( h > 0 )
  {
    u8g2_DrawHXBMP(u8g2, x, y, w, bitmap);
    bitmap += blen;
    2524:	08db      	lsrs	r3, r3, #3
    2526:	9305      	str	r3, [sp, #20]
  while( h > 0 )
    2528:	9b03      	ldr	r3, [sp, #12]
    252a:	429c      	cmp	r4, r3
    252c:	d101      	bne.n	2532 <u8g2_DrawXBMP+0x3a>
    y++;
    h--;
  }
}
    252e:	b007      	add	sp, #28
    2530:	bdf0      	pop	{r4, r5, r6, r7, pc}
    u8g2_DrawHXBMP(u8g2, x, y, w, bitmap);
    2532:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    2534:	0022      	movs	r2, r4
    2536:	9300      	str	r3, [sp, #0]
    2538:	0029      	movs	r1, r5
    253a:	0033      	movs	r3, r6
    253c:	9804      	ldr	r0, [sp, #16]
    253e:	4f06      	ldr	r7, [pc, #24]	; (2558 <u8g2_DrawXBMP+0x60>)
    2540:	47b8      	blx	r7
    bitmap += blen;
    2542:	9a05      	ldr	r2, [sp, #20]
    2544:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    2546:	4694      	mov	ip, r2
    y++;
    2548:	3401      	adds	r4, #1
    bitmap += blen;
    254a:	4463      	add	r3, ip
    254c:	930d      	str	r3, [sp, #52]	; 0x34
    y++;
    254e:	b2e4      	uxtb	r4, r4
    2550:	e7ea      	b.n	2528 <u8g2_DrawXBMP+0x30>
    2552:	46c0      	nop			; (mov r8, r8)
    2554:	00003139 	.word	0x00003139
    2558:	00002461 	.word	0x00002461

0000255c <u8g2_DrawXBM>:
    255c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    255e:	ac06      	add	r4, sp, #24
    2560:	7824      	ldrb	r4, [r4, #0]
    2562:	9d07      	ldr	r5, [sp, #28]
    2564:	9400      	str	r4, [sp, #0]
    2566:	9501      	str	r5, [sp, #4]
    2568:	4c01      	ldr	r4, [pc, #4]	; (2570 <u8g2_DrawXBM+0x14>)
    256a:	47a0      	blx	r4
    256c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    256e:	46c0      	nop			; (mov r8, r8)
    2570:	000024f9 	.word	0x000024f9

00002574 <u8g2_DrawBox>:
/*
  draw a filled box
  restriction: does not work for w = 0 or h = 0
*/
void u8g2_DrawBox(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h)
{
    2574:	b5f0      	push	{r4, r5, r6, r7, lr}
    2576:	0014      	movs	r4, r2
    2578:	b085      	sub	sp, #20
    257a:	9303      	str	r3, [sp, #12]
    257c:	ab0a      	add	r3, sp, #40	; 0x28
    257e:	781b      	ldrb	r3, [r3, #0]
#ifdef U8G2_WITH_INTERSECTION
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    2580:	4f0f      	ldr	r7, [pc, #60]	; (25c0 <u8g2_DrawBox+0x4c>)
    2582:	18d3      	adds	r3, r2, r3
    2584:	b2db      	uxtb	r3, r3
    2586:	9302      	str	r3, [sp, #8]
    2588:	9b03      	ldr	r3, [sp, #12]
    258a:	9a02      	ldr	r2, [sp, #8]
    258c:	18cb      	adds	r3, r1, r3
    258e:	9200      	str	r2, [sp, #0]
    2590:	b2db      	uxtb	r3, r3
    2592:	0022      	movs	r2, r4
{
    2594:	0006      	movs	r6, r0
    2596:	000d      	movs	r5, r1
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    2598:	47b8      	blx	r7
    259a:	2800      	cmp	r0, #0
    259c:	d10b      	bne.n	25b6 <u8g2_DrawBox+0x42>
  { 
    u8g2_DrawHVLine(u8g2, x, y, w, 0);
    y++;    
    h--;
  }
}
    259e:	b005      	add	sp, #20
    25a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    u8g2_DrawHVLine(u8g2, x, y, w, 0);
    25a2:	2300      	movs	r3, #0
    25a4:	0022      	movs	r2, r4
    25a6:	9300      	str	r3, [sp, #0]
    25a8:	0029      	movs	r1, r5
    25aa:	9b03      	ldr	r3, [sp, #12]
    25ac:	0030      	movs	r0, r6
    25ae:	4f05      	ldr	r7, [pc, #20]	; (25c4 <u8g2_DrawBox+0x50>)
    25b0:	47b8      	blx	r7
    y++;    
    25b2:	3401      	adds	r4, #1
    25b4:	b2e4      	uxtb	r4, r4
  while( h != 0 )
    25b6:	9b02      	ldr	r3, [sp, #8]
    25b8:	42a3      	cmp	r3, r4
    25ba:	d1f2      	bne.n	25a2 <u8g2_DrawBox+0x2e>
    25bc:	e7ef      	b.n	259e <u8g2_DrawBox+0x2a>
    25be:	46c0      	nop			; (mov r8, r8)
    25c0:	00003139 	.word	0x00003139
    25c4:	0000308f 	.word	0x0000308f

000025c8 <u8g2_DrawFrame>:
  restriction: does not work for w = 0 or h = 0
  ToDo:
    pixel in the corners are drawn twice. This could be optimized.
*/
void u8g2_DrawFrame(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h)
{
    25c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    25ca:	000d      	movs	r5, r1
    25cc:	0016      	movs	r6, r2
    25ce:	b087      	sub	sp, #28
    25d0:	9302      	str	r3, [sp, #8]
    25d2:	ab0c      	add	r3, sp, #48	; 0x30
    25d4:	781b      	ldrb	r3, [r3, #0]
  u8g2_uint_t xtmp = x;
  
#ifdef U8G2_WITH_INTERSECTION
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    25d6:	4f1a      	ldr	r7, [pc, #104]	; (2640 <u8g2_DrawFrame+0x78>)
{
    25d8:	9303      	str	r3, [sp, #12]
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    25da:	9b02      	ldr	r3, [sp, #8]
{
    25dc:	0004      	movs	r4, r0
  if ( u8g2_IsIntersection(u8g2, x, y, x+w, y+h) == 0 ) 
    25de:	18c9      	adds	r1, r1, r3
    25e0:	b2cb      	uxtb	r3, r1
    25e2:	9304      	str	r3, [sp, #16]
    25e4:	9b03      	ldr	r3, [sp, #12]
    25e6:	0029      	movs	r1, r5
    25e8:	18d2      	adds	r2, r2, r3
    25ea:	b2d3      	uxtb	r3, r2
    25ec:	9305      	str	r3, [sp, #20]
    25ee:	9300      	str	r3, [sp, #0]
    25f0:	0032      	movs	r2, r6
    25f2:	9b04      	ldr	r3, [sp, #16]
    25f4:	47b8      	blx	r7
    25f6:	2800      	cmp	r0, #0
    25f8:	d020      	beq.n	263c <u8g2_DrawFrame+0x74>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  
  u8g2_DrawHVLine(u8g2, x, y, w, 0);
    25fa:	2300      	movs	r3, #0
    25fc:	4f11      	ldr	r7, [pc, #68]	; (2644 <u8g2_DrawFrame+0x7c>)
    25fe:	9300      	str	r3, [sp, #0]
    2600:	0032      	movs	r2, r6
    2602:	9b02      	ldr	r3, [sp, #8]
    2604:	0029      	movs	r1, r5
    2606:	0020      	movs	r0, r4
    2608:	47b8      	blx	r7
  u8g2_DrawHVLine(u8g2, x, y, h, 1);
    260a:	2301      	movs	r3, #1
    260c:	0032      	movs	r2, r6
    260e:	9300      	str	r3, [sp, #0]
    2610:	0029      	movs	r1, r5
    2612:	9b03      	ldr	r3, [sp, #12]
    2614:	0020      	movs	r0, r4
    2616:	47b8      	blx	r7
  x+=w;
  x--;
  u8g2_DrawHVLine(u8g2, x, y, h, 1);
    2618:	2301      	movs	r3, #1
  x--;
    261a:	9904      	ldr	r1, [sp, #16]
  u8g2_DrawHVLine(u8g2, x, y, h, 1);
    261c:	9300      	str	r3, [sp, #0]
  x--;
    261e:	3901      	subs	r1, #1
  u8g2_DrawHVLine(u8g2, x, y, h, 1);
    2620:	b2c9      	uxtb	r1, r1
    2622:	9b03      	ldr	r3, [sp, #12]
    2624:	0032      	movs	r2, r6
    2626:	0020      	movs	r0, r4
    2628:	47b8      	blx	r7
  y+=h;
  y--;
  u8g2_DrawHVLine(u8g2, xtmp, y, w, 0);
    262a:	2300      	movs	r3, #0
  y--;
    262c:	9a05      	ldr	r2, [sp, #20]
  u8g2_DrawHVLine(u8g2, xtmp, y, w, 0);
    262e:	9300      	str	r3, [sp, #0]
  y--;
    2630:	3a01      	subs	r2, #1
  u8g2_DrawHVLine(u8g2, xtmp, y, w, 0);
    2632:	b2d2      	uxtb	r2, r2
    2634:	9b02      	ldr	r3, [sp, #8]
    2636:	0029      	movs	r1, r5
    2638:	0020      	movs	r0, r4
    263a:	47b8      	blx	r7
}
    263c:	b007      	add	sp, #28
    263e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2640:	00003139 	.word	0x00003139
    2644:	0000308f 	.word	0x0000308f

00002648 <u8g2_send_buffer>:
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
  src_max = u8g2->tile_buf_height;
    2648:	0003      	movs	r3, r0
{
    264a:	b5f0      	push	{r4, r5, r6, r7, lr}
  src_max = u8g2->tile_buf_height;
    264c:	3338      	adds	r3, #56	; 0x38
    264e:	781b      	ldrb	r3, [r3, #0]
{
    2650:	b087      	sub	sp, #28
  src_max = u8g2->tile_buf_height;
    2652:	9304      	str	r3, [sp, #16]
  dest_row = u8g2->tile_curr_row;
    2654:	0003      	movs	r3, r0
{
    2656:	0005      	movs	r5, r0
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
    2658:	2600      	movs	r6, #0
  dest_row = u8g2->tile_curr_row;
    265a:	3339      	adds	r3, #57	; 0x39
    265c:	781f      	ldrb	r7, [r3, #0]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
    265e:	6803      	ldr	r3, [r0, #0]
    2660:	7c5b      	ldrb	r3, [r3, #17]
    2662:	9305      	str	r3, [sp, #20]
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    2664:	682b      	ldr	r3, [r5, #0]
  offset = src_tile_row;
    2666:	b2b0      	uxth	r0, r6
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    2668:	7c1b      	ldrb	r3, [r3, #16]
    266a:	b2f4      	uxtb	r4, r6
  offset *= 8;
    266c:	00d9      	lsls	r1, r3, #3
    266e:	4341      	muls	r1, r0
  ptr += offset;
    2670:	6b68      	ldr	r0, [r5, #52]	; 0x34
    2672:	b289      	uxth	r1, r1
    2674:	1841      	adds	r1, r0, r1
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
    2676:	193a      	adds	r2, r7, r4
    2678:	9403      	str	r4, [sp, #12]
    267a:	9100      	str	r1, [sp, #0]
    267c:	4c09      	ldr	r4, [pc, #36]	; (26a4 <u8g2_send_buffer+0x5c>)
    267e:	b2d2      	uxtb	r2, r2
    2680:	2100      	movs	r1, #0
    2682:	0028      	movs	r0, r5
    2684:	47a0      	blx	r4
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
    src_row++;
    dest_row++;
  } while( src_row < src_max && dest_row < dest_max );
    2686:	9c03      	ldr	r4, [sp, #12]
    2688:	9b04      	ldr	r3, [sp, #16]
    268a:	3401      	adds	r4, #1
    268c:	b2e4      	uxtb	r4, r4
    268e:	42a3      	cmp	r3, r4
    2690:	d905      	bls.n	269e <u8g2_send_buffer+0x56>
    2692:	3601      	adds	r6, #1
    2694:	19bb      	adds	r3, r7, r6
    2696:	9a05      	ldr	r2, [sp, #20]
    2698:	b2db      	uxtb	r3, r3
    269a:	429a      	cmp	r2, r3
    269c:	d8e2      	bhi.n	2664 <u8g2_send_buffer+0x1c>
}
    269e:	b007      	add	sp, #28
    26a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26a2:	46c0      	nop			; (mov r8, r8)
    26a4:	00003761 	.word	0x00003761

000026a8 <u8g2_ClearBuffer>:
{
    26a8:	b510      	push	{r4, lr}
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    26aa:	6803      	ldr	r3, [r0, #0]
  memset(u8g2->tile_buf_ptr, 0, cnt);
    26ac:	2100      	movs	r1, #0
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    26ae:	7c1a      	ldrb	r2, [r3, #16]
  cnt *= u8g2->tile_buf_height;
    26b0:	0003      	movs	r3, r0
    26b2:	3338      	adds	r3, #56	; 0x38
    26b4:	781b      	ldrb	r3, [r3, #0]
  memset(u8g2->tile_buf_ptr, 0, cnt);
    26b6:	6b40      	ldr	r0, [r0, #52]	; 0x34
  cnt *= 8;
    26b8:	00db      	lsls	r3, r3, #3
    26ba:	435a      	muls	r2, r3
  memset(u8g2->tile_buf_ptr, 0, cnt);
    26bc:	4b01      	ldr	r3, [pc, #4]	; (26c4 <u8g2_ClearBuffer+0x1c>)
    26be:	4798      	blx	r3
}
    26c0:	bd10      	pop	{r4, pc}
    26c2:	46c0      	nop			; (mov r8, r8)
    26c4:	00008957 	.word	0x00008957

000026c8 <u8g2_SetBufferCurrTileRow>:
}

/*============================================*/
void u8g2_SetBufferCurrTileRow(u8g2_t *u8g2, uint8_t row)
{
  u8g2->tile_curr_row = row;
    26c8:	0003      	movs	r3, r0
{
    26ca:	b510      	push	{r4, lr}
  u8g2->tile_curr_row = row;
    26cc:	3339      	adds	r3, #57	; 0x39
    26ce:	7019      	strb	r1, [r3, #0]
  u8g2->cb->update(u8g2);
    26d0:	6b03      	ldr	r3, [r0, #48]	; 0x30
    26d2:	681b      	ldr	r3, [r3, #0]
    26d4:	4798      	blx	r3
}
    26d6:	bd10      	pop	{r4, pc}

000026d8 <u8g2_FirstPage>:

void u8g2_FirstPage(u8g2_t *u8g2)
{
  if ( u8g2->is_auto_page_clear )
    26d8:	0003      	movs	r3, r0
{
    26da:	b510      	push	{r4, lr}
  if ( u8g2->is_auto_page_clear )
    26dc:	337e      	adds	r3, #126	; 0x7e
    26de:	781b      	ldrb	r3, [r3, #0]
{
    26e0:	0004      	movs	r4, r0
  if ( u8g2->is_auto_page_clear )
    26e2:	2b00      	cmp	r3, #0
    26e4:	d001      	beq.n	26ea <u8g2_FirstPage+0x12>
  {
    u8g2_ClearBuffer(u8g2);
    26e6:	4b03      	ldr	r3, [pc, #12]	; (26f4 <u8g2_FirstPage+0x1c>)
    26e8:	4798      	blx	r3
  }
  u8g2_SetBufferCurrTileRow(u8g2, 0);
    26ea:	2100      	movs	r1, #0
    26ec:	0020      	movs	r0, r4
    26ee:	4b02      	ldr	r3, [pc, #8]	; (26f8 <u8g2_FirstPage+0x20>)
    26f0:	4798      	blx	r3
}
    26f2:	bd10      	pop	{r4, pc}
    26f4:	000026a9 	.word	0x000026a9
    26f8:	000026c9 	.word	0x000026c9

000026fc <u8g2_NextPage>:

uint8_t u8g2_NextPage(u8g2_t *u8g2)
{
    26fc:	b570      	push	{r4, r5, r6, lr}
    26fe:	0004      	movs	r4, r0
  uint8_t row;
  u8g2_send_buffer(u8g2);
    2700:	4b0f      	ldr	r3, [pc, #60]	; (2740 <u8g2_NextPage+0x44>)
    2702:	4798      	blx	r3
  row = u8g2->tile_curr_row;
    2704:	0023      	movs	r3, r4
    2706:	3339      	adds	r3, #57	; 0x39
    2708:	781d      	ldrb	r5, [r3, #0]
  row += u8g2->tile_buf_height;
    270a:	3b01      	subs	r3, #1
    270c:	781b      	ldrb	r3, [r3, #0]
    270e:	18ed      	adds	r5, r5, r3
  if ( row >= u8g2_GetU8x8(u8g2)->display_info->tile_height )
    2710:	6823      	ldr	r3, [r4, #0]
  row += u8g2->tile_buf_height;
    2712:	b2ed      	uxtb	r5, r5
  if ( row >= u8g2_GetU8x8(u8g2)->display_info->tile_height )
    2714:	7c5b      	ldrb	r3, [r3, #17]
    2716:	42ab      	cmp	r3, r5
    2718:	d804      	bhi.n	2724 <u8g2_NextPage+0x28>
  {
    u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );
    271a:	0020      	movs	r0, r4
    271c:	4b09      	ldr	r3, [pc, #36]	; (2744 <u8g2_NextPage+0x48>)
    271e:	4798      	blx	r3
    return 0;
    2720:	2000      	movs	r0, #0
  {
    u8g2_ClearBuffer(u8g2);
  }
  u8g2_SetBufferCurrTileRow(u8g2, row);
  return 1;
}
    2722:	bd70      	pop	{r4, r5, r6, pc}
  if ( u8g2->is_auto_page_clear )
    2724:	0023      	movs	r3, r4
    2726:	337e      	adds	r3, #126	; 0x7e
    2728:	781b      	ldrb	r3, [r3, #0]
    272a:	2b00      	cmp	r3, #0
    272c:	d002      	beq.n	2734 <u8g2_NextPage+0x38>
    u8g2_ClearBuffer(u8g2);
    272e:	0020      	movs	r0, r4
    2730:	4b05      	ldr	r3, [pc, #20]	; (2748 <u8g2_NextPage+0x4c>)
    2732:	4798      	blx	r3
  u8g2_SetBufferCurrTileRow(u8g2, row);
    2734:	0020      	movs	r0, r4
    2736:	0029      	movs	r1, r5
    2738:	4b04      	ldr	r3, [pc, #16]	; (274c <u8g2_NextPage+0x50>)
    273a:	4798      	blx	r3
  return 1;
    273c:	2001      	movs	r0, #1
    273e:	e7f0      	b.n	2722 <u8g2_NextPage+0x26>
    2740:	00002649 	.word	0x00002649
    2744:	000037a5 	.word	0x000037a5
    2748:	000026a9 	.word	0x000026a9
    274c:	000026c9 	.word	0x000026c9

00002750 <u8g2_draw_circle_section>:
/* Circle */

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option) U8G2_NOINLINE;

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option)
{
    2750:	b5f0      	push	{r4, r5, r6, r7, lr}
    2752:	b085      	sub	sp, #20
    2754:	9301      	str	r3, [sp, #4]
    2756:	ab0a      	add	r3, sp, #40	; 0x28
    2758:	781b      	ldrb	r3, [r3, #0]
    275a:	0005      	movs	r5, r0
    275c:	9302      	str	r3, [sp, #8]
    275e:	ab0b      	add	r3, sp, #44	; 0x2c
    2760:	781b      	ldrb	r3, [r3, #0]
    2762:	000c      	movs	r4, r1
    2764:	0016      	movs	r6, r2
    2766:	9303      	str	r3, [sp, #12]
    /* upper right */
    if ( option & U8G2_DRAW_UPPER_RIGHT )
    2768:	07db      	lsls	r3, r3, #31
    276a:	d50f      	bpl.n	278c <u8g2_draw_circle_section+0x3c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 - y);
    276c:	9b02      	ldr	r3, [sp, #8]
    276e:	4f26      	ldr	r7, [pc, #152]	; (2808 <u8g2_draw_circle_section+0xb8>)
    2770:	1a9a      	subs	r2, r3, r2
    2772:	9b01      	ldr	r3, [sp, #4]
    2774:	b2d2      	uxtb	r2, r2
    2776:	1859      	adds	r1, r3, r1
    2778:	b2c9      	uxtb	r1, r1
    277a:	47b8      	blx	r7
      u8g2_DrawPixel(u8g2, x0 + y, y0 - x);
    277c:	9b02      	ldr	r3, [sp, #8]
    277e:	0028      	movs	r0, r5
    2780:	1b1a      	subs	r2, r3, r4
    2782:	9b01      	ldr	r3, [sp, #4]
    2784:	b2d2      	uxtb	r2, r2
    2786:	1999      	adds	r1, r3, r6
    2788:	b2c9      	uxtb	r1, r1
    278a:	47b8      	blx	r7
    }
    
    /* upper left */
    if ( option & U8G2_DRAW_UPPER_LEFT )
    278c:	9b03      	ldr	r3, [sp, #12]
    278e:	079b      	lsls	r3, r3, #30
    2790:	d510      	bpl.n	27b4 <u8g2_draw_circle_section+0x64>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 - y);
    2792:	9b02      	ldr	r3, [sp, #8]
    2794:	0028      	movs	r0, r5
    2796:	1b9a      	subs	r2, r3, r6
    2798:	9b01      	ldr	r3, [sp, #4]
    279a:	b2d2      	uxtb	r2, r2
    279c:	1b19      	subs	r1, r3, r4
    279e:	b2c9      	uxtb	r1, r1
    27a0:	4f19      	ldr	r7, [pc, #100]	; (2808 <u8g2_draw_circle_section+0xb8>)
    27a2:	47b8      	blx	r7
      u8g2_DrawPixel(u8g2, x0 - y, y0 - x);
    27a4:	9b02      	ldr	r3, [sp, #8]
    27a6:	0028      	movs	r0, r5
    27a8:	1b1a      	subs	r2, r3, r4
    27aa:	9b01      	ldr	r3, [sp, #4]
    27ac:	b2d2      	uxtb	r2, r2
    27ae:	1b99      	subs	r1, r3, r6
    27b0:	b2c9      	uxtb	r1, r1
    27b2:	47b8      	blx	r7
    }
    
    /* lower right */
    if ( option & U8G2_DRAW_LOWER_RIGHT )
    27b4:	9b03      	ldr	r3, [sp, #12]
    27b6:	071b      	lsls	r3, r3, #28
    27b8:	d510      	bpl.n	27dc <u8g2_draw_circle_section+0x8c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 + y);
    27ba:	9b02      	ldr	r3, [sp, #8]
    27bc:	0028      	movs	r0, r5
    27be:	199a      	adds	r2, r3, r6
    27c0:	9b01      	ldr	r3, [sp, #4]
    27c2:	b2d2      	uxtb	r2, r2
    27c4:	1919      	adds	r1, r3, r4
    27c6:	b2c9      	uxtb	r1, r1
    27c8:	4f0f      	ldr	r7, [pc, #60]	; (2808 <u8g2_draw_circle_section+0xb8>)
    27ca:	47b8      	blx	r7
      u8g2_DrawPixel(u8g2, x0 + y, y0 + x);
    27cc:	9b02      	ldr	r3, [sp, #8]
    27ce:	0028      	movs	r0, r5
    27d0:	18e2      	adds	r2, r4, r3
    27d2:	9b01      	ldr	r3, [sp, #4]
    27d4:	b2d2      	uxtb	r2, r2
    27d6:	1999      	adds	r1, r3, r6
    27d8:	b2c9      	uxtb	r1, r1
    27da:	47b8      	blx	r7
    }
    
    /* lower left */
    if ( option & U8G2_DRAW_LOWER_LEFT )
    27dc:	9b03      	ldr	r3, [sp, #12]
    27de:	075b      	lsls	r3, r3, #29
    27e0:	d510      	bpl.n	2804 <u8g2_draw_circle_section+0xb4>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 + y);
    27e2:	9b02      	ldr	r3, [sp, #8]
    27e4:	0028      	movs	r0, r5
    27e6:	199a      	adds	r2, r3, r6
    27e8:	9b01      	ldr	r3, [sp, #4]
    27ea:	b2d2      	uxtb	r2, r2
    27ec:	1b19      	subs	r1, r3, r4
    27ee:	b2c9      	uxtb	r1, r1
    27f0:	4f05      	ldr	r7, [pc, #20]	; (2808 <u8g2_draw_circle_section+0xb8>)
    27f2:	47b8      	blx	r7
      u8g2_DrawPixel(u8g2, x0 - y, y0 + x);
    27f4:	9b02      	ldr	r3, [sp, #8]
    27f6:	0028      	movs	r0, r5
    27f8:	18e4      	adds	r4, r4, r3
    27fa:	9b01      	ldr	r3, [sp, #4]
    27fc:	b2e2      	uxtb	r2, r4
    27fe:	1b9e      	subs	r6, r3, r6
    2800:	b2f1      	uxtb	r1, r6
    2802:	47b8      	blx	r7
    }
}
    2804:	b005      	add	sp, #20
    2806:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2808:	000030e1 	.word	0x000030e1

0000280c <u8g2_draw_disc_section>:
/* Disk */

static void u8g2_draw_disc_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option) U8G2_NOINLINE;

static void u8g2_draw_disc_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option)
{
    280c:	b5f0      	push	{r4, r5, r6, r7, lr}
    280e:	b085      	sub	sp, #20
    2810:	9301      	str	r3, [sp, #4]
    2812:	ab0a      	add	r3, sp, #40	; 0x28
    2814:	781b      	ldrb	r3, [r3, #0]
    2816:	0006      	movs	r6, r0
    2818:	9302      	str	r3, [sp, #8]
    281a:	ab0b      	add	r3, sp, #44	; 0x2c
    281c:	781b      	ldrb	r3, [r3, #0]
    281e:	000c      	movs	r4, r1
    2820:	0015      	movs	r5, r2
    2822:	9303      	str	r3, [sp, #12]
    /* upper right */
    if ( option & U8G2_DRAW_UPPER_RIGHT )
    2824:	07db      	lsls	r3, r3, #31
    2826:	d513      	bpl.n	2850 <u8g2_draw_disc_section+0x44>
    {
      u8g2_DrawVLine(u8g2, x0+x, y0-y, y+1);
    2828:	1c53      	adds	r3, r2, #1
    282a:	9901      	ldr	r1, [sp, #4]
    282c:	9a02      	ldr	r2, [sp, #8]
    282e:	1909      	adds	r1, r1, r4
    2830:	1b52      	subs	r2, r2, r5
    2832:	b2db      	uxtb	r3, r3
    2834:	b2d2      	uxtb	r2, r2
    2836:	b2c9      	uxtb	r1, r1
    2838:	4f26      	ldr	r7, [pc, #152]	; (28d4 <u8g2_draw_disc_section+0xc8>)
    283a:	47b8      	blx	r7
      u8g2_DrawVLine(u8g2, x0+y, y0-x, x+1);
    283c:	9a02      	ldr	r2, [sp, #8]
    283e:	9901      	ldr	r1, [sp, #4]
    2840:	1c63      	adds	r3, r4, #1
    2842:	1b12      	subs	r2, r2, r4
    2844:	1949      	adds	r1, r1, r5
    2846:	b2db      	uxtb	r3, r3
    2848:	b2d2      	uxtb	r2, r2
    284a:	b2c9      	uxtb	r1, r1
    284c:	0030      	movs	r0, r6
    284e:	47b8      	blx	r7
    }
    
    /* upper left */
    if ( option & U8G2_DRAW_UPPER_LEFT )
    2850:	9b03      	ldr	r3, [sp, #12]
    2852:	079b      	lsls	r3, r3, #30
    2854:	d514      	bpl.n	2880 <u8g2_draw_disc_section+0x74>
    {
      u8g2_DrawVLine(u8g2, x0-x, y0-y, y+1);
    2856:	9a02      	ldr	r2, [sp, #8]
    2858:	9901      	ldr	r1, [sp, #4]
    285a:	1c6b      	adds	r3, r5, #1
    285c:	1b52      	subs	r2, r2, r5
    285e:	1b09      	subs	r1, r1, r4
    2860:	b2db      	uxtb	r3, r3
    2862:	b2d2      	uxtb	r2, r2
    2864:	b2c9      	uxtb	r1, r1
    2866:	0030      	movs	r0, r6
    2868:	4f1a      	ldr	r7, [pc, #104]	; (28d4 <u8g2_draw_disc_section+0xc8>)
    286a:	47b8      	blx	r7
      u8g2_DrawVLine(u8g2, x0-y, y0-x, x+1);
    286c:	9a02      	ldr	r2, [sp, #8]
    286e:	9901      	ldr	r1, [sp, #4]
    2870:	1c63      	adds	r3, r4, #1
    2872:	1b12      	subs	r2, r2, r4
    2874:	1b49      	subs	r1, r1, r5
    2876:	b2db      	uxtb	r3, r3
    2878:	b2d2      	uxtb	r2, r2
    287a:	b2c9      	uxtb	r1, r1
    287c:	0030      	movs	r0, r6
    287e:	47b8      	blx	r7
    }
    
    /* lower right */
    if ( option & U8G2_DRAW_LOWER_RIGHT )
    2880:	9b03      	ldr	r3, [sp, #12]
    2882:	071b      	lsls	r3, r3, #28
    2884:	d510      	bpl.n	28a8 <u8g2_draw_disc_section+0x9c>
    {
      u8g2_DrawVLine(u8g2, x0+x, y0, y+1);
    2886:	9a01      	ldr	r2, [sp, #4]
    2888:	1c6b      	adds	r3, r5, #1
    288a:	1911      	adds	r1, r2, r4
    288c:	b2db      	uxtb	r3, r3
    288e:	b2c9      	uxtb	r1, r1
    2890:	9a02      	ldr	r2, [sp, #8]
    2892:	0030      	movs	r0, r6
    2894:	4f0f      	ldr	r7, [pc, #60]	; (28d4 <u8g2_draw_disc_section+0xc8>)
    2896:	47b8      	blx	r7
      u8g2_DrawVLine(u8g2, x0+y, y0, x+1);
    2898:	9a01      	ldr	r2, [sp, #4]
    289a:	1c63      	adds	r3, r4, #1
    289c:	1951      	adds	r1, r2, r5
    289e:	b2db      	uxtb	r3, r3
    28a0:	b2c9      	uxtb	r1, r1
    28a2:	9a02      	ldr	r2, [sp, #8]
    28a4:	0030      	movs	r0, r6
    28a6:	47b8      	blx	r7
    }
    
    /* lower left */
    if ( option & U8G2_DRAW_LOWER_LEFT )
    28a8:	9b03      	ldr	r3, [sp, #12]
    28aa:	075b      	lsls	r3, r3, #29
    28ac:	d510      	bpl.n	28d0 <u8g2_draw_disc_section+0xc4>
    {
      u8g2_DrawVLine(u8g2, x0-x, y0, y+1);
    28ae:	9a01      	ldr	r2, [sp, #4]
    28b0:	1c6b      	adds	r3, r5, #1
    28b2:	1b11      	subs	r1, r2, r4
    28b4:	b2db      	uxtb	r3, r3
    28b6:	b2c9      	uxtb	r1, r1
    28b8:	9a02      	ldr	r2, [sp, #8]
    28ba:	0030      	movs	r0, r6
    28bc:	4f05      	ldr	r7, [pc, #20]	; (28d4 <u8g2_draw_disc_section+0xc8>)
    28be:	47b8      	blx	r7
      u8g2_DrawVLine(u8g2, x0-y, y0, x+1);
    28c0:	9a01      	ldr	r2, [sp, #4]
    28c2:	3401      	adds	r4, #1
    28c4:	1b55      	subs	r5, r2, r5
    28c6:	b2e3      	uxtb	r3, r4
    28c8:	b2e9      	uxtb	r1, r5
    28ca:	9a02      	ldr	r2, [sp, #8]
    28cc:	0030      	movs	r0, r6
    28ce:	47b8      	blx	r7
    }
}
    28d0:	b005      	add	sp, #20
    28d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28d4:	000030a5 	.word	0x000030a5

000028d8 <u8g2_DrawCircle>:
{
    28d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    28da:	001c      	movs	r4, r3
    28dc:	b089      	sub	sp, #36	; 0x24
    28de:	9204      	str	r2, [sp, #16]
    28e0:	9005      	str	r0, [sp, #20]
    28e2:	ab0e      	add	r3, sp, #56	; 0x38
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    28e4:	9804      	ldr	r0, [sp, #16]
{
    28e6:	781b      	ldrb	r3, [r3, #0]
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    28e8:	9a04      	ldr	r2, [sp, #16]
    28ea:	3001      	adds	r0, #1
{
    28ec:	9307      	str	r3, [sp, #28]
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    28ee:	1820      	adds	r0, r4, r0
    28f0:	1c63      	adds	r3, r4, #1
    28f2:	18cb      	adds	r3, r1, r3
    28f4:	b2c0      	uxtb	r0, r0
{
    28f6:	9103      	str	r1, [sp, #12]
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    28f8:	1b12      	subs	r2, r2, r4
    28fa:	1b09      	subs	r1, r1, r4
    28fc:	9000      	str	r0, [sp, #0]
    28fe:	b2db      	uxtb	r3, r3
    2900:	b2d2      	uxtb	r2, r2
    2902:	b2c9      	uxtb	r1, r1
    2904:	9805      	ldr	r0, [sp, #20]
    2906:	4d1b      	ldr	r5, [pc, #108]	; (2974 <u8g2_DrawCircle+0x9c>)
    2908:	47a8      	blx	r5
    290a:	2800      	cmp	r0, #0
    290c:	d013      	beq.n	2936 <u8g2_DrawCircle+0x5e>
    ddF_y *= 2;
    290e:	0063      	lsls	r3, r4, #1
    2910:	425b      	negs	r3, r3
    2912:	b25b      	sxtb	r3, r3
    2914:	9306      	str	r3, [sp, #24]
    u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);
    2916:	9b07      	ldr	r3, [sp, #28]
    f -= rad;
    2918:	2501      	movs	r5, #1
    u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);
    291a:	9301      	str	r3, [sp, #4]
    291c:	9b04      	ldr	r3, [sp, #16]
    291e:	4e16      	ldr	r6, [pc, #88]	; (2978 <u8g2_DrawCircle+0xa0>)
    2920:	9300      	str	r3, [sp, #0]
    2922:	0022      	movs	r2, r4
    2924:	9b03      	ldr	r3, [sp, #12]
    2926:	2100      	movs	r1, #0
    2928:	9805      	ldr	r0, [sp, #20]
    292a:	47b0      	blx	r6
    x = 0;
    292c:	2600      	movs	r6, #0
    f -= rad;
    292e:	1b2d      	subs	r5, r5, r4
    2930:	b26d      	sxtb	r5, r5
    while ( x < y )
    2932:	42b4      	cmp	r4, r6
    2934:	d801      	bhi.n	293a <u8g2_DrawCircle+0x62>
}
    2936:	b009      	add	sp, #36	; 0x24
    2938:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (f >= 0) 
    293a:	2d00      	cmp	r5, #0
    293c:	db08      	blt.n	2950 <u8g2_DrawCircle+0x78>
        ddF_y += 2;
    293e:	9b06      	ldr	r3, [sp, #24]
        y--;
    2940:	3c01      	subs	r4, #1
        ddF_y += 2;
    2942:	3302      	adds	r3, #2
    2944:	b2db      	uxtb	r3, r3
    2946:	b25a      	sxtb	r2, r3
        f += ddF_y;
    2948:	195d      	adds	r5, r3, r5
        y--;
    294a:	b2e4      	uxtb	r4, r4
        ddF_y += 2;
    294c:	9206      	str	r2, [sp, #24]
        f += ddF_y;
    294e:	b26d      	sxtb	r5, r5
      x++;
    2950:	3601      	adds	r6, #1
    2952:	b2f6      	uxtb	r6, r6
      f += ddF_x;
    2954:	0073      	lsls	r3, r6, #1
    2956:	3301      	adds	r3, #1
    2958:	195d      	adds	r5, r3, r5
      u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);    
    295a:	9b07      	ldr	r3, [sp, #28]
    295c:	0022      	movs	r2, r4
    295e:	9301      	str	r3, [sp, #4]
    2960:	9b04      	ldr	r3, [sp, #16]
    2962:	0031      	movs	r1, r6
    2964:	9300      	str	r3, [sp, #0]
    2966:	9805      	ldr	r0, [sp, #20]
    2968:	9b03      	ldr	r3, [sp, #12]
    296a:	4f03      	ldr	r7, [pc, #12]	; (2978 <u8g2_DrawCircle+0xa0>)
      f += ddF_x;
    296c:	b26d      	sxtb	r5, r5
      u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);    
    296e:	47b8      	blx	r7
    2970:	e7df      	b.n	2932 <u8g2_DrawCircle+0x5a>
    2972:	46c0      	nop			; (mov r8, r8)
    2974:	00003139 	.word	0x00003139
    2978:	00002751 	.word	0x00002751

0000297c <u8g2_DrawDisc>:
    u8g2_draw_disc_section(u8g2, x, y, x0, y0, option);    
  }
}

void u8g2_DrawDisc(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
    297c:	b5f0      	push	{r4, r5, r6, r7, lr}
    297e:	001c      	movs	r4, r3
    2980:	b089      	sub	sp, #36	; 0x24
    2982:	9204      	str	r2, [sp, #16]
    2984:	9005      	str	r0, [sp, #20]
    2986:	ab0e      	add	r3, sp, #56	; 0x38
  /* check for bounding box */
#ifdef U8G2_WITH_INTERSECTION
  {
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    2988:	9804      	ldr	r0, [sp, #16]
{
    298a:	781b      	ldrb	r3, [r3, #0]
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    298c:	9a04      	ldr	r2, [sp, #16]
    298e:	3001      	adds	r0, #1
{
    2990:	9307      	str	r3, [sp, #28]
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    2992:	1820      	adds	r0, r4, r0
    2994:	1c63      	adds	r3, r4, #1
    2996:	18cb      	adds	r3, r1, r3
    2998:	b2c0      	uxtb	r0, r0
{
    299a:	9103      	str	r1, [sp, #12]
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
    299c:	1b12      	subs	r2, r2, r4
    299e:	1b09      	subs	r1, r1, r4
    29a0:	9000      	str	r0, [sp, #0]
    29a2:	b2db      	uxtb	r3, r3
    29a4:	b2d2      	uxtb	r2, r2
    29a6:	b2c9      	uxtb	r1, r1
    29a8:	9805      	ldr	r0, [sp, #20]
    29aa:	4d1b      	ldr	r5, [pc, #108]	; (2a18 <u8g2_DrawDisc+0x9c>)
    29ac:	47a8      	blx	r5
    29ae:	2800      	cmp	r0, #0
    29b0:	d013      	beq.n	29da <u8g2_DrawDisc+0x5e>
  ddF_y *= 2;
    29b2:	0063      	lsls	r3, r4, #1
    29b4:	425b      	negs	r3, r3
    29b6:	b25b      	sxtb	r3, r3
    29b8:	9306      	str	r3, [sp, #24]
  u8g2_draw_disc_section(u8g2, x, y, x0, y0, option);
    29ba:	9b07      	ldr	r3, [sp, #28]
  f -= rad;
    29bc:	2501      	movs	r5, #1
  u8g2_draw_disc_section(u8g2, x, y, x0, y0, option);
    29be:	9301      	str	r3, [sp, #4]
    29c0:	9b04      	ldr	r3, [sp, #16]
    29c2:	4e16      	ldr	r6, [pc, #88]	; (2a1c <u8g2_DrawDisc+0xa0>)
    29c4:	9300      	str	r3, [sp, #0]
    29c6:	0022      	movs	r2, r4
    29c8:	9b03      	ldr	r3, [sp, #12]
    29ca:	2100      	movs	r1, #0
    29cc:	9805      	ldr	r0, [sp, #20]
    29ce:	47b0      	blx	r6
  x = 0;
    29d0:	2600      	movs	r6, #0
  f -= rad;
    29d2:	1b2d      	subs	r5, r5, r4
    29d4:	b26d      	sxtb	r5, r5
  while ( x < y )
    29d6:	42b4      	cmp	r4, r6
    29d8:	d801      	bhi.n	29de <u8g2_DrawDisc+0x62>
  }
#endif /* U8G2_WITH_INTERSECTION */
  
  /* draw disc */
  u8g2_draw_disc(u8g2, x0, y0, rad, option);
}
    29da:	b009      	add	sp, #36	; 0x24
    29dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (f >= 0) 
    29de:	2d00      	cmp	r5, #0
    29e0:	db08      	blt.n	29f4 <u8g2_DrawDisc+0x78>
      ddF_y += 2;
    29e2:	9b06      	ldr	r3, [sp, #24]
      y--;
    29e4:	3c01      	subs	r4, #1
      ddF_y += 2;
    29e6:	3302      	adds	r3, #2
    29e8:	b2db      	uxtb	r3, r3
    29ea:	b25a      	sxtb	r2, r3
      f += ddF_y;
    29ec:	195d      	adds	r5, r3, r5
      y--;
    29ee:	b2e4      	uxtb	r4, r4
      ddF_y += 2;
    29f0:	9206      	str	r2, [sp, #24]
      f += ddF_y;
    29f2:	b26d      	sxtb	r5, r5
    x++;
    29f4:	3601      	adds	r6, #1
    29f6:	b2f6      	uxtb	r6, r6
    f += ddF_x;
    29f8:	0073      	lsls	r3, r6, #1
    29fa:	3301      	adds	r3, #1
    29fc:	195d      	adds	r5, r3, r5
    u8g2_draw_disc_section(u8g2, x, y, x0, y0, option);    
    29fe:	9b07      	ldr	r3, [sp, #28]
    2a00:	0022      	movs	r2, r4
    2a02:	9301      	str	r3, [sp, #4]
    2a04:	9b04      	ldr	r3, [sp, #16]
    2a06:	0031      	movs	r1, r6
    2a08:	9300      	str	r3, [sp, #0]
    2a0a:	9805      	ldr	r0, [sp, #20]
    2a0c:	9b03      	ldr	r3, [sp, #12]
    2a0e:	4f03      	ldr	r7, [pc, #12]	; (2a1c <u8g2_DrawDisc+0xa0>)
    f += ddF_x;
    2a10:	b26d      	sxtb	r5, r5
    u8g2_draw_disc_section(u8g2, x, y, x0, y0, option);    
    2a12:	47b8      	blx	r7
    2a14:	e7df      	b.n	29d6 <u8g2_DrawDisc+0x5a>
    2a16:	46c0      	nop			; (mov r8, r8)
    2a18:	00003139 	.word	0x00003139
    2a1c:	0000280d 	.word	0x0000280d

00002a20 <u8g2_m_16_8_2>:
}
*/
uint8_t *u8g2_m_16_8_2(uint8_t *page_cnt)
{
  static uint8_t buf[256];
  *page_cnt = 2;
    2a20:	2302      	movs	r3, #2
    2a22:	7003      	strb	r3, [r0, #0]
  return buf;
}
    2a24:	4800      	ldr	r0, [pc, #0]	; (2a28 <u8g2_m_16_8_2+0x8>)
    2a26:	4770      	bx	lr
    2a28:	2000042a 	.word	0x2000042a

00002a2c <u8g2_Setup_sh1106_i2c_128x64_noname_2>:
  buf = u8g2_m_16_8_1(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
}
/* sh1106 2 */
void u8g2_Setup_sh1106_i2c_128x64_noname_2(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    2a2c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    2a2e:	000e      	movs	r6, r1
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_sh1106_128x64_noname, u8x8_cad_ssd13xx_i2c, byte_cb, gpio_and_delay_cb);
    2a30:	9300      	str	r3, [sp, #0]
    2a32:	4909      	ldr	r1, [pc, #36]	; (2a58 <u8g2_Setup_sh1106_i2c_128x64_noname_2+0x2c>)
    2a34:	0013      	movs	r3, r2
    2a36:	4d09      	ldr	r5, [pc, #36]	; (2a5c <u8g2_Setup_sh1106_i2c_128x64_noname_2+0x30>)
    2a38:	4a09      	ldr	r2, [pc, #36]	; (2a60 <u8g2_Setup_sh1106_i2c_128x64_noname_2+0x34>)
{
    2a3a:	0004      	movs	r4, r0
  u8g2_SetupDisplay(u8g2, u8x8_d_sh1106_128x64_noname, u8x8_cad_ssd13xx_i2c, byte_cb, gpio_and_delay_cb);
    2a3c:	47a8      	blx	r5
  buf = u8g2_m_16_8_2(&tile_buf_height);
    2a3e:	250f      	movs	r5, #15
    2a40:	446d      	add	r5, sp
    2a42:	0028      	movs	r0, r5
    2a44:	4b07      	ldr	r3, [pc, #28]	; (2a64 <u8g2_Setup_sh1106_i2c_128x64_noname_2+0x38>)
    2a46:	4798      	blx	r3
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
    2a48:	782a      	ldrb	r2, [r5, #0]
  buf = u8g2_m_16_8_2(&tile_buf_height);
    2a4a:	0001      	movs	r1, r0
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
    2a4c:	9600      	str	r6, [sp, #0]
    2a4e:	0020      	movs	r0, r4
    2a50:	4b05      	ldr	r3, [pc, #20]	; (2a68 <u8g2_Setup_sh1106_i2c_128x64_noname_2+0x3c>)
    2a52:	4c06      	ldr	r4, [pc, #24]	; (2a6c <u8g2_Setup_sh1106_i2c_128x64_noname_2+0x40>)
    2a54:	47a0      	blx	r4
}
    2a56:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
    2a58:	00003899 	.word	0x00003899
    2a5c:	0000391d 	.word	0x0000391d
    2a60:	00003681 	.word	0x00003681
    2a64:	00002a21 	.word	0x00002a21
    2a68:	00003261 	.word	0x00003261
    2a6c:	00003509 	.word	0x00003509

00002a70 <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
    uint16_t pos;
    font += offset;
    2a70:	1841      	adds	r1, r0, r1
    pos = u8x8_pgm_read( font );
    2a72:	7808      	ldrb	r0, [r1, #0]
    font++;
    pos <<= 8;
    pos += u8x8_pgm_read( font);
    2a74:	784b      	ldrb	r3, [r1, #1]
    pos <<= 8;
    2a76:	0200      	lsls	r0, r0, #8
    pos += u8x8_pgm_read( font);
    2a78:	18c0      	adds	r0, r0, r3
    return pos;
    2a7a:	b280      	uxth	r0, r0
}
    2a7c:	4770      	bx	lr

00002a7e <u8g2_add_vector_y>:


#ifdef U8G2_WITH_FONT_ROTATION
static u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir) U8G2_NOINLINE;
static u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir)
{
    2a7e:	b520      	push	{r5, lr}
    2a80:	0005      	movs	r5, r0
  {
    case 0:
      dy += y;
      break;
    case 1:
      dy += x;
    2a82:	1840      	adds	r0, r0, r1
    2a84:	b2c0      	uxtb	r0, r0
  switch(dir)
    2a86:	2b01      	cmp	r3, #1
    2a88:	d009      	beq.n	2a9e <u8g2_add_vector_y+0x20>
      dy += y;
    2a8a:	18a8      	adds	r0, r5, r2
    2a8c:	b2c0      	uxtb	r0, r0
  switch(dir)
    2a8e:	2b00      	cmp	r3, #0
    2a90:	d005      	beq.n	2a9e <u8g2_add_vector_y+0x20>
      break;
    case 2:
      dy -= y;
    2a92:	1aaa      	subs	r2, r5, r2
    2a94:	b2d0      	uxtb	r0, r2
  switch(dir)
    2a96:	2b02      	cmp	r3, #2
    2a98:	d001      	beq.n	2a9e <u8g2_add_vector_y+0x20>
      break;
    default:
      dy -= x;
    2a9a:	1a68      	subs	r0, r5, r1
    2a9c:	b2c0      	uxtb	r0, r0
      break;      
  }
  return dy;
}
    2a9e:	bd20      	pop	{r5, pc}

00002aa0 <u8g2_add_vector_x>:

static u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir) U8G2_NOINLINE;
static u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir)
{
    2aa0:	b520      	push	{r5, lr}
  {
    case 0:
      dx += x;
      break;
    case 1:
      dx -= y;
    2aa2:	1a85      	subs	r5, r0, r2
    2aa4:	b2ed      	uxtb	r5, r5
  switch(dir)
    2aa6:	2b01      	cmp	r3, #1
    2aa8:	d009      	beq.n	2abe <u8g2_add_vector_x+0x1e>
      dx += x;
    2aaa:	1845      	adds	r5, r0, r1
    2aac:	b2ed      	uxtb	r5, r5
  switch(dir)
    2aae:	2b00      	cmp	r3, #0
    2ab0:	d005      	beq.n	2abe <u8g2_add_vector_x+0x1e>
      break;
    case 2:
      dx -= x;
    2ab2:	1a41      	subs	r1, r0, r1
    2ab4:	b2cd      	uxtb	r5, r1
  switch(dir)
    2ab6:	2b02      	cmp	r3, #2
    2ab8:	d001      	beq.n	2abe <u8g2_add_vector_x+0x1e>
      break;
    default:
      dx += y;
    2aba:	1880      	adds	r0, r0, r2
    2abc:	b2c5      	uxtb	r5, r0
      break;      
  }
  return dx;
}
    2abe:	0028      	movs	r0, r5
    2ac0:	bd20      	pop	{r5, pc}

00002ac2 <u8g2_font_calc_vref_font>:
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
  return 0;
}
    2ac2:	2000      	movs	r0, #0
    2ac4:	4770      	bx	lr
	...

00002ac8 <u8g2_read_font_info>:
{
    2ac8:	b570      	push	{r4, r5, r6, lr}
  return u8x8_pgm_read( font );  
    2aca:	780b      	ldrb	r3, [r1, #0]
{
    2acc:	000d      	movs	r5, r1
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
    2ace:	7003      	strb	r3, [r0, #0]
  return u8x8_pgm_read( font );  
    2ad0:	784b      	ldrb	r3, [r1, #1]
{
    2ad2:	0004      	movs	r4, r0
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
    2ad4:	7043      	strb	r3, [r0, #1]
  return u8x8_pgm_read( font );  
    2ad6:	788b      	ldrb	r3, [r1, #2]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
    2ad8:	7083      	strb	r3, [r0, #2]
  return u8x8_pgm_read( font );  
    2ada:	78cb      	ldrb	r3, [r1, #3]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
    2adc:	70c3      	strb	r3, [r0, #3]
  return u8x8_pgm_read( font );  
    2ade:	790b      	ldrb	r3, [r1, #4]
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
    2ae0:	7103      	strb	r3, [r0, #4]
  return u8x8_pgm_read( font );  
    2ae2:	794b      	ldrb	r3, [r1, #5]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
    2ae4:	7143      	strb	r3, [r0, #5]
  return u8x8_pgm_read( font );  
    2ae6:	798b      	ldrb	r3, [r1, #6]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
    2ae8:	7183      	strb	r3, [r0, #6]
  return u8x8_pgm_read( font );  
    2aea:	79cb      	ldrb	r3, [r1, #7]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
    2aec:	71c3      	strb	r3, [r0, #7]
  return u8x8_pgm_read( font );  
    2aee:	7a0b      	ldrb	r3, [r1, #8]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
    2af0:	7203      	strb	r3, [r0, #8]
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
    2af2:	7a4b      	ldrb	r3, [r1, #9]
    2af4:	7243      	strb	r3, [r0, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
    2af6:	7a8b      	ldrb	r3, [r1, #10]
    2af8:	7283      	strb	r3, [r0, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
    2afa:	7acb      	ldrb	r3, [r1, #11]
    2afc:	72c3      	strb	r3, [r0, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
    2afe:	7b0b      	ldrb	r3, [r1, #12]
    2b00:	7303      	strb	r3, [r0, #12]
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
    2b02:	7b4b      	ldrb	r3, [r1, #13]
    2b04:	7343      	strb	r3, [r0, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
    2b06:	7b8b      	ldrb	r3, [r1, #14]
    2b08:	7383      	strb	r3, [r0, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
    2b0a:	7bcb      	ldrb	r3, [r1, #15]
    2b0c:	73c3      	strb	r3, [r0, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
    2b0e:	7c0b      	ldrb	r3, [r1, #16]
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
    2b10:	4e07      	ldr	r6, [pc, #28]	; (2b30 <u8g2_read_font_info+0x68>)
  font_info->descent_para = u8g2_font_get_byte(font, 16);
    2b12:	7403      	strb	r3, [r0, #16]
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
    2b14:	2111      	movs	r1, #17
    2b16:	0028      	movs	r0, r5
    2b18:	47b0      	blx	r6
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
    2b1a:	2113      	movs	r1, #19
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
    2b1c:	8260      	strh	r0, [r4, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
    2b1e:	0028      	movs	r0, r5
    2b20:	47b0      	blx	r6
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
    2b22:	2115      	movs	r1, #21
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
    2b24:	82a0      	strh	r0, [r4, #20]
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
    2b26:	0028      	movs	r0, r5
    2b28:	47b0      	blx	r6
    2b2a:	82e0      	strh	r0, [r4, #22]
}
    2b2c:	bd70      	pop	{r4, r5, r6, pc}
    2b2e:	46c0      	nop			; (mov r8, r8)
    2b30:	00002a71 	.word	0x00002a71

00002b34 <u8g2_font_decode_get_unsigned_bits>:
{
    2b34:	b570      	push	{r4, r5, r6, lr}
  val = u8x8_pgm_read( f->decode_ptr );  
    2b36:	6804      	ldr	r4, [r0, #0]
  uint8_t bit_pos = f->decode_bit_pos;
    2b38:	7a86      	ldrb	r6, [r0, #10]
  val >>= bit_pos;
    2b3a:	7825      	ldrb	r5, [r4, #0]
  bit_pos_plus_cnt += cnt;
    2b3c:	1872      	adds	r2, r6, r1
  val >>= bit_pos;
    2b3e:	4135      	asrs	r5, r6
  bit_pos_plus_cnt += cnt;
    2b40:	b2d2      	uxtb	r2, r2
  val >>= bit_pos;
    2b42:	b2eb      	uxtb	r3, r5
  if ( bit_pos_plus_cnt >= 8 )
    2b44:	2a07      	cmp	r2, #7
    2b46:	d90a      	bls.n	2b5e <u8g2_font_decode_get_unsigned_bits+0x2a>
    f->decode_ptr++;
    2b48:	1c63      	adds	r3, r4, #1
    2b4a:	6003      	str	r3, [r0, #0]
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
    2b4c:	7863      	ldrb	r3, [r4, #1]
    s -= bit_pos;
    2b4e:	2408      	movs	r4, #8
    2b50:	1ba4      	subs	r4, r4, r6
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
    2b52:	b2e4      	uxtb	r4, r4
    2b54:	40a3      	lsls	r3, r4
    bit_pos_plus_cnt -= 8;
    2b56:	3a08      	subs	r2, #8
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
    2b58:	432b      	orrs	r3, r5
    2b5a:	b2db      	uxtb	r3, r3
    bit_pos_plus_cnt -= 8;
    2b5c:	b2d2      	uxtb	r2, r2
  f->decode_bit_pos = bit_pos_plus_cnt;
    2b5e:	7282      	strb	r2, [r0, #10]
  val &= (1U<<cnt)-1;
    2b60:	2001      	movs	r0, #1
    2b62:	4088      	lsls	r0, r1
    2b64:	3801      	subs	r0, #1
  return val;
    2b66:	4018      	ands	r0, r3
}
    2b68:	bd70      	pop	{r4, r5, r6, pc}
	...

00002b6c <u8g2_font_setup_decode>:
{
    2b6c:	b570      	push	{r4, r5, r6, lr}
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    2b6e:	0004      	movs	r4, r0
  decode->decode_bit_pos = 0;
    2b70:	2300      	movs	r3, #0
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    2b72:	3450      	adds	r4, #80	; 0x50
  decode->decode_ptr = glyph_data;
    2b74:	6501      	str	r1, [r0, #80]	; 0x50
  decode->decode_bit_pos = 0;
    2b76:	72a3      	strb	r3, [r4, #10]
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
    2b78:	0003      	movs	r3, r0
{
    2b7a:	0005      	movs	r5, r0
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
    2b7c:	3364      	adds	r3, #100	; 0x64
    2b7e:	4e09      	ldr	r6, [pc, #36]	; (2ba4 <u8g2_font_setup_decode+0x38>)
    2b80:	7819      	ldrb	r1, [r3, #0]
    2b82:	0020      	movs	r0, r4
    2b84:	47b0      	blx	r6
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
    2b86:	002b      	movs	r3, r5
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
    2b88:	7220      	strb	r0, [r4, #8]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
    2b8a:	3365      	adds	r3, #101	; 0x65
    2b8c:	7819      	ldrb	r1, [r3, #0]
    2b8e:	0020      	movs	r0, r4
    2b90:	47b0      	blx	r6
  decode->fg_color = u8g2->draw_color;
    2b92:	357d      	adds	r5, #125	; 0x7d
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
    2b94:	7260      	strb	r0, [r4, #9]
  decode->fg_color = u8g2->draw_color;
    2b96:	782b      	ldrb	r3, [r5, #0]
    2b98:	7323      	strb	r3, [r4, #12]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
    2b9a:	425a      	negs	r2, r3
    2b9c:	4153      	adcs	r3, r2
    2b9e:	7363      	strb	r3, [r4, #13]
}
    2ba0:	bd70      	pop	{r4, r5, r6, pc}
    2ba2:	46c0      	nop			; (mov r8, r8)
    2ba4:	00002b35 	.word	0x00002b35

00002ba8 <u8g2_font_decode_get_signed_bits>:
{
    2ba8:	b510      	push	{r4, lr}
    2baa:	000c      	movs	r4, r1
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
    2bac:	4b04      	ldr	r3, [pc, #16]	; (2bc0 <u8g2_font_decode_get_signed_bits+0x18>)
    2bae:	4798      	blx	r3
  d <<= cnt;
    2bb0:	2301      	movs	r3, #1
  cnt--;
    2bb2:	3c01      	subs	r4, #1
  d <<= cnt;
    2bb4:	b2e4      	uxtb	r4, r4
    2bb6:	40a3      	lsls	r3, r4
  v -= d;
    2bb8:	1ac0      	subs	r0, r0, r3
  return v;
    2bba:	b240      	sxtb	r0, r0
}
    2bbc:	bd10      	pop	{r4, pc}
    2bbe:	46c0      	nop			; (mov r8, r8)
    2bc0:	00002b35 	.word	0x00002b35

00002bc4 <u8g2_font_decode_len>:
  lx = decode->x;
    2bc4:	0003      	movs	r3, r0
{
    2bc6:	b5f0      	push	{r4, r5, r6, r7, lr}
    2bc8:	0004      	movs	r4, r0
    2bca:	000f      	movs	r7, r1
    2bcc:	b08d      	sub	sp, #52	; 0x34
    2bce:	920b      	str	r2, [sp, #44]	; 0x2c
  lx = decode->x;
    2bd0:	3350      	adds	r3, #80	; 0x50
    2bd2:	799a      	ldrb	r2, [r3, #6]
    2bd4:	9202      	str	r2, [sp, #8]
  ly = decode->y;
    2bd6:	79db      	ldrb	r3, [r3, #7]
    2bd8:	9305      	str	r3, [sp, #20]
    rem = decode->glyph_width;
    2bda:	0025      	movs	r5, r4
    2bdc:	3550      	adds	r5, #80	; 0x50
    2bde:	7a2b      	ldrb	r3, [r5, #8]
    rem -= lx;
    2be0:	9a02      	ldr	r2, [sp, #8]
    2be2:	1a9b      	subs	r3, r3, r2
    2be4:	b2db      	uxtb	r3, r3
    2be6:	9303      	str	r3, [sp, #12]
    2be8:	9a03      	ldr	r2, [sp, #12]
    2bea:	1c3b      	adds	r3, r7, #0
    2bec:	4297      	cmp	r7, r2
    2bee:	d901      	bls.n	2bf4 <u8g2_font_decode_len+0x30>
    2bf0:	466b      	mov	r3, sp
    2bf2:	7b1b      	ldrb	r3, [r3, #12]
    2bf4:	b2db      	uxtb	r3, r3
    2bf6:	9308      	str	r3, [sp, #32]
    y = decode->target_y;
    2bf8:	796b      	ldrb	r3, [r5, #5]
    x = decode->target_x;
    2bfa:	7928      	ldrb	r0, [r5, #4]
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
    2bfc:	2608      	movs	r6, #8
    y = decode->target_y;
    2bfe:	930a      	str	r3, [sp, #40]	; 0x28
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
    2c00:	466b      	mov	r3, sp
    2c02:	579e      	ldrsb	r6, [r3, r6]
    2c04:	7d1b      	ldrb	r3, [r3, #20]
    2c06:	0031      	movs	r1, r6
    2c08:	b25b      	sxtb	r3, r3
    2c0a:	9306      	str	r3, [sp, #24]
    2c0c:	7bab      	ldrb	r3, [r5, #14]
    2c0e:	9a06      	ldr	r2, [sp, #24]
    2c10:	9607      	str	r6, [sp, #28]
    2c12:	4e19      	ldr	r6, [pc, #100]	; (2c78 <u8g2_font_decode_len+0xb4>)
    2c14:	9304      	str	r3, [sp, #16]
    2c16:	47b0      	blx	r6
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
    2c18:	9b04      	ldr	r3, [sp, #16]
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
    2c1a:	9009      	str	r0, [sp, #36]	; 0x24
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
    2c1c:	9a06      	ldr	r2, [sp, #24]
    2c1e:	9907      	ldr	r1, [sp, #28]
    2c20:	980a      	ldr	r0, [sp, #40]	; 0x28
    2c22:	4e16      	ldr	r6, [pc, #88]	; (2c7c <u8g2_font_decode_len+0xb8>)
    2c24:	47b0      	blx	r6
    if ( is_foreground )
    2c26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
    2c28:	0002      	movs	r2, r0
    if ( is_foreground )
    2c2a:	2b00      	cmp	r3, #0
    2c2c:	d016      	beq.n	2c5c <u8g2_font_decode_len+0x98>
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
    2c2e:	7b29      	ldrb	r1, [r5, #12]
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
    2c30:	0023      	movs	r3, r4
    2c32:	337d      	adds	r3, #125	; 0x7d
    2c34:	7019      	strb	r1, [r3, #0]
      u8g2_DrawHVLine(u8g2, 
    2c36:	9b04      	ldr	r3, [sp, #16]
    2c38:	9909      	ldr	r1, [sp, #36]	; 0x24
    2c3a:	9300      	str	r3, [sp, #0]
    2c3c:	0020      	movs	r0, r4
    2c3e:	9b08      	ldr	r3, [sp, #32]
    2c40:	4d0f      	ldr	r5, [pc, #60]	; (2c80 <u8g2_font_decode_len+0xbc>)
    2c42:	47a8      	blx	r5
    if ( cnt < rem )
    2c44:	9b03      	ldr	r3, [sp, #12]
    2c46:	429f      	cmp	r7, r3
    2c48:	d30d      	bcc.n	2c66 <u8g2_font_decode_len+0xa2>
    cnt -= rem;
    2c4a:	1aff      	subs	r7, r7, r3
    ly++;
    2c4c:	9b05      	ldr	r3, [sp, #20]
    cnt -= rem;
    2c4e:	b2ff      	uxtb	r7, r7
    ly++;
    2c50:	3301      	adds	r3, #1
    2c52:	b2db      	uxtb	r3, r3
    2c54:	9305      	str	r3, [sp, #20]
    lx = 0;
    2c56:	2300      	movs	r3, #0
    2c58:	9302      	str	r3, [sp, #8]
    rem = decode->glyph_width;
    2c5a:	e7be      	b.n	2bda <u8g2_font_decode_len+0x16>
    else if ( decode->is_transparent == 0 )    
    2c5c:	7aeb      	ldrb	r3, [r5, #11]
    2c5e:	2b00      	cmp	r3, #0
    2c60:	d1f0      	bne.n	2c44 <u8g2_font_decode_len+0x80>
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
    2c62:	7b69      	ldrb	r1, [r5, #13]
    2c64:	e7e4      	b.n	2c30 <u8g2_font_decode_len+0x6c>
  lx += cnt;
    2c66:	9b02      	ldr	r3, [sp, #8]
  decode->x = lx;
    2c68:	3450      	adds	r4, #80	; 0x50
  lx += cnt;
    2c6a:	18fb      	adds	r3, r7, r3
  decode->x = lx;
    2c6c:	71a3      	strb	r3, [r4, #6]
  decode->y = ly;
    2c6e:	466b      	mov	r3, sp
    2c70:	7e1b      	ldrb	r3, [r3, #24]
    2c72:	71e3      	strb	r3, [r4, #7]
}
    2c74:	b00d      	add	sp, #52	; 0x34
    2c76:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2c78:	00002aa1 	.word	0x00002aa1
    2c7c:	00002a7f 	.word	0x00002a7f
    2c80:	0000308f 	.word	0x0000308f

00002c84 <u8g2_font_decode_glyph>:
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    2c84:	0003      	movs	r3, r0
{
    2c86:	b5f0      	push	{r4, r5, r6, r7, lr}
    2c88:	0004      	movs	r4, r0
    2c8a:	b08b      	sub	sp, #44	; 0x2c
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    2c8c:	3350      	adds	r3, #80	; 0x50
    2c8e:	9303      	str	r3, [sp, #12]
  u8g2_font_setup_decode(u8g2, glyph_data);
    2c90:	4b52      	ldr	r3, [pc, #328]	; (2ddc <u8g2_font_decode_glyph+0x158>)
    2c92:	4798      	blx	r3
  h = u8g2->font_decode.glyph_height;
    2c94:	0023      	movs	r3, r4
    2c96:	3359      	adds	r3, #89	; 0x59
    2c98:	781b      	ldrb	r3, [r3, #0]
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    2c9a:	4d51      	ldr	r5, [pc, #324]	; (2de0 <u8g2_font_decode_glyph+0x15c>)
  h = u8g2->font_decode.glyph_height;
    2c9c:	b25b      	sxtb	r3, r3
    2c9e:	9307      	str	r3, [sp, #28]
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    2ca0:	0023      	movs	r3, r4
    2ca2:	3366      	adds	r3, #102	; 0x66
    2ca4:	7819      	ldrb	r1, [r3, #0]
    2ca6:	9803      	ldr	r0, [sp, #12]
    2ca8:	47a8      	blx	r5
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    2caa:	0023      	movs	r3, r4
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    2cac:	9008      	str	r0, [sp, #32]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    2cae:	3367      	adds	r3, #103	; 0x67
    2cb0:	7819      	ldrb	r1, [r3, #0]
    2cb2:	9803      	ldr	r0, [sp, #12]
    2cb4:	47a8      	blx	r5
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    2cb6:	0023      	movs	r3, r4
    2cb8:	3368      	adds	r3, #104	; 0x68
    2cba:	7819      	ldrb	r1, [r3, #0]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    2cbc:	0006      	movs	r6, r0
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    2cbe:	9803      	ldr	r0, [sp, #12]
    2cc0:	47a8      	blx	r5
  if ( decode->glyph_width > 0 )
    2cc2:	9b03      	ldr	r3, [sp, #12]
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    2cc4:	9009      	str	r0, [sp, #36]	; 0x24
  if ( decode->glyph_width > 0 )
    2cc6:	7a1b      	ldrb	r3, [r3, #8]
    2cc8:	b25b      	sxtb	r3, r3
    2cca:	9304      	str	r3, [sp, #16]
    2ccc:	2b00      	cmp	r3, #0
    2cce:	dd5e      	ble.n	2d8e <u8g2_font_decode_glyph+0x10a>
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    2cd0:	466b      	mov	r3, sp
    2cd2:	7f1b      	ldrb	r3, [r3, #28]
    2cd4:	9908      	ldr	r1, [sp, #32]
    2cd6:	9305      	str	r3, [sp, #20]
    2cd8:	199e      	adds	r6, r3, r6
    2cda:	9b03      	ldr	r3, [sp, #12]
    2cdc:	4276      	negs	r6, r6
    2cde:	7b9b      	ldrb	r3, [r3, #14]
    2ce0:	b276      	sxtb	r6, r6
    2ce2:	9306      	str	r3, [sp, #24]
    2ce4:	9b03      	ldr	r3, [sp, #12]
    2ce6:	0032      	movs	r2, r6
    2ce8:	7918      	ldrb	r0, [r3, #4]
    2cea:	4d3e      	ldr	r5, [pc, #248]	; (2de4 <u8g2_font_decode_glyph+0x160>)
    2cec:	9b06      	ldr	r3, [sp, #24]
    2cee:	47a8      	blx	r5
    2cf0:	9b03      	ldr	r3, [sp, #12]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    2cf2:	0032      	movs	r2, r6
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    2cf4:	7118      	strb	r0, [r3, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    2cf6:	9908      	ldr	r1, [sp, #32]
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    2cf8:	0005      	movs	r5, r0
    2cfa:	0007      	movs	r7, r0
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    2cfc:	4e3a      	ldr	r6, [pc, #232]	; (2de8 <u8g2_font_decode_glyph+0x164>)
    2cfe:	7958      	ldrb	r0, [r3, #5]
    2d00:	9b06      	ldr	r3, [sp, #24]
    2d02:	47b0      	blx	r6
    2d04:	9b03      	ldr	r3, [sp, #12]
    2d06:	0002      	movs	r2, r0
    2d08:	7158      	strb	r0, [r3, #5]
      switch(decode->dir)
    2d0a:	9b06      	ldr	r3, [sp, #24]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    2d0c:	0001      	movs	r1, r0
      switch(decode->dir)
    2d0e:	2b03      	cmp	r3, #3
    2d10:	d861      	bhi.n	2dd6 <u8g2_font_decode_glyph+0x152>
    2d12:	0018      	movs	r0, r3
    2d14:	f005 f924 	bl	7f60 <__gnu_thumb1_case_uqi>
    2d18:	55483e02 	.word	0x55483e02
	    x1 += decode->glyph_width;
    2d1c:	9b04      	ldr	r3, [sp, #16]
	    y1 += h;
    2d1e:	9805      	ldr	r0, [sp, #20]
	    x1 += decode->glyph_width;
    2d20:	18ef      	adds	r7, r5, r3
	    y1 += h;
    2d22:	1881      	adds	r1, r0, r2
	    x1 += decode->glyph_width;
    2d24:	b2fb      	uxtb	r3, r7
	    y1 += h;
    2d26:	b2c9      	uxtb	r1, r1
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
    2d28:	9100      	str	r1, [sp, #0]
    2d2a:	0020      	movs	r0, r4
    2d2c:	0029      	movs	r1, r5
    2d2e:	4d2f      	ldr	r5, [pc, #188]	; (2dec <u8g2_font_decode_glyph+0x168>)
    2d30:	47a8      	blx	r5
    2d32:	2800      	cmp	r0, #0
    2d34:	d02b      	beq.n	2d8e <u8g2_font_decode_glyph+0x10a>
    decode->x = 0;
    2d36:	0023      	movs	r3, r4
    2d38:	2200      	movs	r2, #0
	u8g2_font_decode_len(u8g2, b, 1);
    2d3a:	2601      	movs	r6, #1
    decode->x = 0;
    2d3c:	3350      	adds	r3, #80	; 0x50
    2d3e:	719a      	strb	r2, [r3, #6]
    decode->y = 0;
    2d40:	71da      	strb	r2, [r3, #7]
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    2d42:	0023      	movs	r3, r4
    2d44:	3362      	adds	r3, #98	; 0x62
    2d46:	7819      	ldrb	r1, [r3, #0]
    2d48:	4d29      	ldr	r5, [pc, #164]	; (2df0 <u8g2_font_decode_glyph+0x16c>)
    2d4a:	9803      	ldr	r0, [sp, #12]
    2d4c:	47a8      	blx	r5
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    2d4e:	0023      	movs	r3, r4
    2d50:	3363      	adds	r3, #99	; 0x63
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    2d52:	0007      	movs	r7, r0
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    2d54:	7819      	ldrb	r1, [r3, #0]
    2d56:	9803      	ldr	r0, [sp, #12]
    2d58:	47a8      	blx	r5
    2d5a:	9004      	str	r0, [sp, #16]
	u8g2_font_decode_len(u8g2, a, 0);
    2d5c:	2200      	movs	r2, #0
    2d5e:	0039      	movs	r1, r7
    2d60:	0020      	movs	r0, r4
    2d62:	4d24      	ldr	r5, [pc, #144]	; (2df4 <u8g2_font_decode_glyph+0x170>)
    2d64:	47a8      	blx	r5
	u8g2_font_decode_len(u8g2, b, 1);
    2d66:	9904      	ldr	r1, [sp, #16]
    2d68:	0020      	movs	r0, r4
    2d6a:	0032      	movs	r2, r6
    2d6c:	47a8      	blx	r5
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
    2d6e:	0031      	movs	r1, r6
    2d70:	9803      	ldr	r0, [sp, #12]
    2d72:	4b1f      	ldr	r3, [pc, #124]	; (2df0 <u8g2_font_decode_glyph+0x16c>)
    2d74:	4798      	blx	r3
    2d76:	2800      	cmp	r0, #0
    2d78:	d1f0      	bne.n	2d5c <u8g2_font_decode_glyph+0xd8>
      if ( decode->y >= h )
    2d7a:	0023      	movs	r3, r4
    2d7c:	2207      	movs	r2, #7
    2d7e:	3350      	adds	r3, #80	; 0x50
    2d80:	569a      	ldrsb	r2, [r3, r2]
    2d82:	9907      	ldr	r1, [sp, #28]
    2d84:	428a      	cmp	r2, r1
    2d86:	dbdc      	blt.n	2d42 <u8g2_font_decode_glyph+0xbe>
    u8g2->draw_color = decode->fg_color;
    2d88:	7b1b      	ldrb	r3, [r3, #12]
    2d8a:	347d      	adds	r4, #125	; 0x7d
    2d8c:	7023      	strb	r3, [r4, #0]
}
    2d8e:	9809      	ldr	r0, [sp, #36]	; 0x24
    2d90:	b00b      	add	sp, #44	; 0x2c
    2d92:	bdf0      	pop	{r4, r5, r6, r7, pc}
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2d94:	9b05      	ldr	r3, [sp, #20]
	    y1 += decode->glyph_width;
    2d96:	9804      	ldr	r0, [sp, #16]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2d98:	1aed      	subs	r5, r5, r3
	    x1++;
    2d9a:	3701      	adds	r7, #1
	    y1 += decode->glyph_width;
    2d9c:	1811      	adds	r1, r2, r0
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2d9e:	3501      	adds	r5, #1
	    x1++;
    2da0:	b2fb      	uxtb	r3, r7
	    y1 += decode->glyph_width;
    2da2:	b2c9      	uxtb	r1, r1
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2da4:	b2ed      	uxtb	r5, r5
	    break;	  
    2da6:	e7bf      	b.n	2d28 <u8g2_font_decode_glyph+0xa4>
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2da8:	2201      	movs	r2, #1
    2daa:	9b04      	ldr	r3, [sp, #16]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dac:	9805      	ldr	r0, [sp, #20]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dae:	1ad5      	subs	r5, r2, r3
    2db0:	197d      	adds	r5, r7, r5
	    x1++;
    2db2:	18bf      	adds	r7, r7, r2
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2db4:	1a12      	subs	r2, r2, r0
    2db6:	188a      	adds	r2, r1, r2
	    y1++;
    2db8:	3101      	adds	r1, #1
	    x1++;
    2dba:	b2fb      	uxtb	r3, r7
	    y1++;
    2dbc:	b2c9      	uxtb	r1, r1
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dbe:	b2d2      	uxtb	r2, r2
    2dc0:	e7f0      	b.n	2da4 <u8g2_font_decode_glyph+0x120>
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dc2:	9a04      	ldr	r2, [sp, #16]
	    x1 += h;
    2dc4:	9b05      	ldr	r3, [sp, #20]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dc6:	1a8a      	subs	r2, r1, r2
	    x1 += h;
    2dc8:	195f      	adds	r7, r3, r5
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dca:	3201      	adds	r2, #1
	    y1++;
    2dcc:	3101      	adds	r1, #1
	    x1 += h;
    2dce:	b2fb      	uxtb	r3, r7
	    y1++;
    2dd0:	b2c9      	uxtb	r1, r1
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    2dd2:	b2d2      	uxtb	r2, r2
	    break;	  
    2dd4:	e7a8      	b.n	2d28 <u8g2_font_decode_glyph+0xa4>
      y1 = y0;
    2dd6:	0001      	movs	r1, r0
      x1 = x0;
    2dd8:	002b      	movs	r3, r5
    2dda:	e7a5      	b.n	2d28 <u8g2_font_decode_glyph+0xa4>
    2ddc:	00002b6d 	.word	0x00002b6d
    2de0:	00002ba9 	.word	0x00002ba9
    2de4:	00002aa1 	.word	0x00002aa1
    2de8:	00002a7f 	.word	0x00002a7f
    2dec:	00003139 	.word	0x00003139
    2df0:	00002b35 	.word	0x00002b35
    2df4:	00002bc5 	.word	0x00002bc5

00002df8 <u8g2_font_get_glyph_data>:
  font += U8G2_FONT_DATA_STRUCT_SIZE;
    2df8:	6c83      	ldr	r3, [r0, #72]	; 0x48
    2dfa:	3317      	adds	r3, #23
  if ( encoding <= 255 )
    2dfc:	29ff      	cmp	r1, #255	; 0xff
    2dfe:	d812      	bhi.n	2e26 <u8g2_font_get_glyph_data+0x2e>
    if ( encoding >= 'a' )
    2e00:	2960      	cmp	r1, #96	; 0x60
    2e02:	d90a      	bls.n	2e1a <u8g2_font_get_glyph_data+0x22>
      font += u8g2->font_info.start_pos_lower_a;
    2e04:	3074      	adds	r0, #116	; 0x74
      font += u8g2->font_info.start_pos_upper_A;
    2e06:	8802      	ldrh	r2, [r0, #0]
    2e08:	189b      	adds	r3, r3, r2
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    2e0a:	7858      	ldrb	r0, [r3, #1]
    2e0c:	2800      	cmp	r0, #0
    2e0e:	d003      	beq.n	2e18 <u8g2_font_get_glyph_data+0x20>
      if ( u8x8_pgm_read( font ) == encoding )
    2e10:	781a      	ldrb	r2, [r3, #0]
    2e12:	428a      	cmp	r2, r1
    2e14:	d105      	bne.n	2e22 <u8g2_font_get_glyph_data+0x2a>
	return font+2;	/* skip encoding and glyph size */
    2e16:	1c98      	adds	r0, r3, #2
}
    2e18:	4770      	bx	lr
    else if ( encoding >= 'A' )
    2e1a:	2940      	cmp	r1, #64	; 0x40
    2e1c:	d9f5      	bls.n	2e0a <u8g2_font_get_glyph_data+0x12>
      font += u8g2->font_info.start_pos_upper_A;
    2e1e:	3072      	adds	r0, #114	; 0x72
    2e20:	e7f1      	b.n	2e06 <u8g2_font_get_glyph_data+0xe>
      font += u8x8_pgm_read( font + 1 );
    2e22:	181b      	adds	r3, r3, r0
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    2e24:	e7f1      	b.n	2e0a <u8g2_font_get_glyph_data+0x12>
    font += u8g2->font_info.start_pos_unicode;
    2e26:	3076      	adds	r0, #118	; 0x76
    2e28:	8800      	ldrh	r0, [r0, #0]
    2e2a:	181b      	adds	r3, r3, r0
      e = u8x8_pgm_read( font );
    2e2c:	7818      	ldrb	r0, [r3, #0]
      e |= u8x8_pgm_read( font + 1 );
    2e2e:	785a      	ldrb	r2, [r3, #1]
      e <<= 8;
    2e30:	0200      	lsls	r0, r0, #8
      e |= u8x8_pgm_read( font + 1 );
    2e32:	4310      	orrs	r0, r2
      if ( e == 0 )
    2e34:	d0f0      	beq.n	2e18 <u8g2_font_get_glyph_data+0x20>
      if ( e == encoding )
    2e36:	4281      	cmp	r1, r0
    2e38:	d101      	bne.n	2e3e <u8g2_font_get_glyph_data+0x46>
	return font+3;	/* skip encoding and glyph size */
    2e3a:	1cd8      	adds	r0, r3, #3
    2e3c:	e7ec      	b.n	2e18 <u8g2_font_get_glyph_data+0x20>
      font += u8x8_pgm_read( font + 2 );
    2e3e:	789a      	ldrb	r2, [r3, #2]
    2e40:	189b      	adds	r3, r3, r2
      e = u8x8_pgm_read( font );
    2e42:	e7f3      	b.n	2e2c <u8g2_font_get_glyph_data+0x34>

00002e44 <u8g2_DrawGlyph>:
{
    2e44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e46:	001f      	movs	r7, r3
  switch(u8g2->font_decode.dir)
    2e48:	0003      	movs	r3, r0
    2e4a:	335e      	adds	r3, #94	; 0x5e
{
    2e4c:	0004      	movs	r4, r0
  switch(u8g2->font_decode.dir)
    2e4e:	7818      	ldrb	r0, [r3, #0]
{
    2e50:	000e      	movs	r6, r1
    2e52:	0015      	movs	r5, r2
  switch(u8g2->font_decode.dir)
    2e54:	2803      	cmp	r0, #3
    2e56:	d808      	bhi.n	2e6a <u8g2_DrawGlyph+0x26>
    2e58:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    2e5a:	f005 f881 	bl	7f60 <__gnu_thumb1_case_uqi>
    2e5e:	1502      	.short	0x1502
    2e60:	1e1a      	.short	0x1e1a
      y += u8g2->font_calc_vref(u8g2);
    2e62:	0020      	movs	r0, r4
    2e64:	4798      	blx	r3
    2e66:	182d      	adds	r5, r5, r0
      y -= u8g2->font_calc_vref(u8g2);
    2e68:	b2ed      	uxtb	r5, r5
  u8g2->font_decode.target_x = x;
    2e6a:	0023      	movs	r3, r4
    2e6c:	3354      	adds	r3, #84	; 0x54
    2e6e:	701e      	strb	r6, [r3, #0]
  u8g2->font_decode.target_y = y;
    2e70:	705d      	strb	r5, [r3, #1]
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
    2e72:	0039      	movs	r1, r7
    2e74:	0020      	movs	r0, r4
    2e76:	4b0b      	ldr	r3, [pc, #44]	; (2ea4 <u8g2_DrawGlyph+0x60>)
    2e78:	4798      	blx	r3
    2e7a:	1e01      	subs	r1, r0, #0
  if ( glyph_data != NULL )
    2e7c:	d003      	beq.n	2e86 <u8g2_DrawGlyph+0x42>
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
    2e7e:	0020      	movs	r0, r4
    2e80:	4b09      	ldr	r3, [pc, #36]	; (2ea8 <u8g2_DrawGlyph+0x64>)
    2e82:	4798      	blx	r3
    2e84:	b2c0      	uxtb	r0, r0
}
    2e86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      x -= u8g2->font_calc_vref(u8g2);
    2e88:	0020      	movs	r0, r4
    2e8a:	4798      	blx	r3
    2e8c:	1a36      	subs	r6, r6, r0
      x += u8g2->font_calc_vref(u8g2);
    2e8e:	b2f6      	uxtb	r6, r6
      break;
    2e90:	e7eb      	b.n	2e6a <u8g2_DrawGlyph+0x26>
      y -= u8g2->font_calc_vref(u8g2);
    2e92:	0020      	movs	r0, r4
    2e94:	4798      	blx	r3
    2e96:	1a2d      	subs	r5, r5, r0
    2e98:	e7e6      	b.n	2e68 <u8g2_DrawGlyph+0x24>
      x += u8g2->font_calc_vref(u8g2);
    2e9a:	0020      	movs	r0, r4
    2e9c:	4798      	blx	r3
    2e9e:	1836      	adds	r6, r6, r0
    2ea0:	e7f5      	b.n	2e8e <u8g2_DrawGlyph+0x4a>
    2ea2:	46c0      	nop			; (mov r8, r8)
    2ea4:	00002df9 	.word	0x00002df9
    2ea8:	00002c85 	.word	0x00002c85

00002eac <u8g2_draw_string>:
{
    2eac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2eae:	9301      	str	r3, [sp, #4]
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    2eb0:	4b19      	ldr	r3, [pc, #100]	; (2f18 <u8g2_draw_string+0x6c>)
{
    2eb2:	0006      	movs	r6, r0
    2eb4:	000c      	movs	r4, r1
    2eb6:	0015      	movs	r5, r2
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    2eb8:	4798      	blx	r3
  sum = 0;
    2eba:	2300      	movs	r3, #0
    2ebc:	9300      	str	r3, [sp, #0]
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    2ebe:	9b01      	ldr	r3, [sp, #4]
    2ec0:	0030      	movs	r0, r6
    2ec2:	7819      	ldrb	r1, [r3, #0]
    2ec4:	6873      	ldr	r3, [r6, #4]
    2ec6:	4798      	blx	r3
    if ( e == 0x0ffff )
    2ec8:	4a14      	ldr	r2, [pc, #80]	; (2f1c <u8g2_draw_string+0x70>)
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    2eca:	0003      	movs	r3, r0
    if ( e == 0x0ffff )
    2ecc:	4290      	cmp	r0, r2
    2ece:	d021      	beq.n	2f14 <u8g2_draw_string+0x68>
    str++;
    2ed0:	9a01      	ldr	r2, [sp, #4]
    2ed2:	3201      	adds	r2, #1
    2ed4:	9201      	str	r2, [sp, #4]
    if ( e != 0x0fffe )
    2ed6:	4a12      	ldr	r2, [pc, #72]	; (2f20 <u8g2_draw_string+0x74>)
    2ed8:	4290      	cmp	r0, r2
    2eda:	d0f0      	beq.n	2ebe <u8g2_draw_string+0x12>
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    2edc:	002a      	movs	r2, r5
    2ede:	0021      	movs	r1, r4
    2ee0:	0030      	movs	r0, r6
    2ee2:	4f10      	ldr	r7, [pc, #64]	; (2f24 <u8g2_draw_string+0x78>)
    2ee4:	47b8      	blx	r7
      switch(u8g2->font_decode.dir)
    2ee6:	0032      	movs	r2, r6
    2ee8:	325e      	adds	r2, #94	; 0x5e
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    2eea:	0003      	movs	r3, r0
      switch(u8g2->font_decode.dir)
    2eec:	7810      	ldrb	r0, [r2, #0]
    2eee:	2803      	cmp	r0, #3
    2ef0:	d805      	bhi.n	2efe <u8g2_draw_string+0x52>
    2ef2:	f005 f835 	bl	7f60 <__gnu_thumb1_case_uqi>
    2ef6:	0802      	.short	0x0802
    2ef8:	0d0b      	.short	0x0d0b
	  x += delta;
    2efa:	18e4      	adds	r4, r4, r3
	  x -= delta;
    2efc:	b2e4      	uxtb	r4, r4
      sum += delta;    
    2efe:	9a00      	ldr	r2, [sp, #0]
    2f00:	18d7      	adds	r7, r2, r3
    2f02:	b2fb      	uxtb	r3, r7
    2f04:	e7da      	b.n	2ebc <u8g2_draw_string+0x10>
	  y += delta;
    2f06:	18ed      	adds	r5, r5, r3
	  y -= delta;
    2f08:	b2ed      	uxtb	r5, r5
	  break;
    2f0a:	e7f8      	b.n	2efe <u8g2_draw_string+0x52>
	  x -= delta;
    2f0c:	1ae4      	subs	r4, r4, r3
    2f0e:	e7f5      	b.n	2efc <u8g2_draw_string+0x50>
	  y -= delta;
    2f10:	1aed      	subs	r5, r5, r3
    2f12:	e7f9      	b.n	2f08 <u8g2_draw_string+0x5c>
}
    2f14:	9800      	ldr	r0, [sp, #0]
    2f16:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    2f18:	00003555 	.word	0x00003555
    2f1c:	0000ffff 	.word	0x0000ffff
    2f20:	0000fffe 	.word	0x0000fffe
    2f24:	00002e45 	.word	0x00002e45

00002f28 <u8g2_DrawStr>:
{
    2f28:	b510      	push	{r4, lr}
  u8g2->u8x8.next_cb = u8x8_ascii_next;
    2f2a:	4c02      	ldr	r4, [pc, #8]	; (2f34 <u8g2_DrawStr+0xc>)
    2f2c:	6044      	str	r4, [r0, #4]
  return u8g2_draw_string(u8g2, x, y, str);
    2f2e:	4c02      	ldr	r4, [pc, #8]	; (2f38 <u8g2_DrawStr+0x10>)
    2f30:	47a0      	blx	r4
}
    2f32:	bd10      	pop	{r4, pc}
    2f34:	00003541 	.word	0x00003541
    2f38:	00002ead 	.word	0x00002ead

00002f3c <u8g2_UpdateRefHeight>:
  if ( u8g2->font == NULL )
    2f3c:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
    2f3e:	b570      	push	{r4, r5, r6, lr}
  if ( u8g2->font == NULL )
    2f40:	2b00      	cmp	r3, #0
    2f42:	d01d      	beq.n	2f80 <u8g2_UpdateRefHeight+0x44>
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    2f44:	0003      	movs	r3, r0
    2f46:	2600      	movs	r6, #0
    2f48:	0005      	movs	r5, r0
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    2f4a:	2401      	movs	r4, #1
    2f4c:	0002      	movs	r2, r0
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    2f4e:	336d      	adds	r3, #109	; 0x6d
    2f50:	579e      	ldrsb	r6, [r3, r6]
    2f52:	3579      	adds	r5, #121	; 0x79
    2f54:	702e      	strb	r6, [r5, #0]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    2f56:	571c      	ldrsb	r4, [r3, r4]
    2f58:	327a      	adds	r2, #122	; 0x7a
    2f5a:	7014      	strb	r4, [r2, #0]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
    2f5c:	330b      	adds	r3, #11
    2f5e:	781b      	ldrb	r3, [r3, #0]
    2f60:	2b00      	cmp	r3, #0
    2f62:	d00d      	beq.n	2f80 <u8g2_UpdateRefHeight+0x44>
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
    2f64:	2b01      	cmp	r3, #1
    2f66:	d10c      	bne.n	2f82 <u8g2_UpdateRefHeight+0x46>
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
    2f68:	0003      	movs	r3, r0
    2f6a:	336f      	adds	r3, #111	; 0x6f
    2f6c:	781b      	ldrb	r3, [r3, #0]
    2f6e:	b25b      	sxtb	r3, r3
    2f70:	429e      	cmp	r6, r3
    2f72:	da00      	bge.n	2f76 <u8g2_UpdateRefHeight+0x3a>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
    2f74:	702b      	strb	r3, [r5, #0]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
    2f76:	2370      	movs	r3, #112	; 0x70
    2f78:	56c3      	ldrsb	r3, [r0, r3]
    2f7a:	429c      	cmp	r4, r3
    2f7c:	dd00      	ble.n	2f80 <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
    2f7e:	7013      	strb	r3, [r2, #0]
}
    2f80:	bd70      	pop	{r4, r5, r6, pc}
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
    2f82:	0003      	movs	r3, r0
    2f84:	216c      	movs	r1, #108	; 0x6c
    2f86:	336a      	adds	r3, #106	; 0x6a
    2f88:	781b      	ldrb	r3, [r3, #0]
    2f8a:	5641      	ldrsb	r1, [r0, r1]
    2f8c:	b25b      	sxtb	r3, r3
    2f8e:	185b      	adds	r3, r3, r1
    2f90:	429e      	cmp	r6, r3
    2f92:	da00      	bge.n	2f96 <u8g2_UpdateRefHeight+0x5a>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
    2f94:	702b      	strb	r3, [r5, #0]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
    2f96:	428c      	cmp	r4, r1
    2f98:	ddf2      	ble.n	2f80 <u8g2_UpdateRefHeight+0x44>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
    2f9a:	7011      	strb	r1, [r2, #0]
    2f9c:	e7f0      	b.n	2f80 <u8g2_UpdateRefHeight+0x44>
	...

00002fa0 <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
    2fa0:	4b01      	ldr	r3, [pc, #4]	; (2fa8 <u8g2_SetFontPosBaseline+0x8>)
    2fa2:	64c3      	str	r3, [r0, #76]	; 0x4c
}
    2fa4:	4770      	bx	lr
    2fa6:	46c0      	nop			; (mov r8, r8)
    2fa8:	00002ac3 	.word	0x00002ac3

00002fac <u8g2_SetFont>:

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
  if ( u8g2->font != font )
    2fac:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
    2fae:	b510      	push	{r4, lr}
    2fb0:	0004      	movs	r4, r0
  if ( u8g2->font != font )
    2fb2:	428b      	cmp	r3, r1
    2fb4:	d006      	beq.n	2fc4 <u8g2_SetFont+0x18>
  {
#ifdef  __unix__
	u8g2->last_font_data = NULL;
	u8g2->last_unicode = 0x0ffff;
#endif 
    u8g2->font = font;
    2fb6:	6481      	str	r1, [r0, #72]	; 0x48
    u8g2_read_font_info(&(u8g2->font_info), font);
    2fb8:	4b03      	ldr	r3, [pc, #12]	; (2fc8 <u8g2_SetFont+0x1c>)
    2fba:	3060      	adds	r0, #96	; 0x60
    2fbc:	4798      	blx	r3
    u8g2_UpdateRefHeight(u8g2);
    2fbe:	0020      	movs	r0, r4
    2fc0:	4b02      	ldr	r3, [pc, #8]	; (2fcc <u8g2_SetFont+0x20>)
    2fc2:	4798      	blx	r3
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
    2fc4:	bd10      	pop	{r4, pc}
    2fc6:	46c0      	nop			; (mov r8, r8)
    2fc8:	00002ac9 	.word	0x00002ac9
    2fcc:	00002f3d 	.word	0x00002f3d

00002fd0 <u8g2_draw_hv_line_4dir>:

  This function will remove directions 2 and 3. Instead 0 and 1 are used.

*/
void u8g2_draw_hv_line_4dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    2fd0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2fd2:	0006      	movs	r6, r0
    2fd4:	ac06      	add	r4, sp, #24
    2fd6:	7824      	ldrb	r4, [r4, #0]
    2fd8:	363a      	adds	r6, #58	; 0x3a

  /* additional optimization for one pixel draw */
  /* requires about 60 bytes on the ATMega flash memory */
  /* 20% improvement for single pixel draw test in FPS.ino */
#ifdef U8G2_WITH_ONE_PIXEL_OPTIMIZATION
  if ( len == 1 )
    2fda:	2b01      	cmp	r3, #1
    2fdc:	d111      	bne.n	3002 <u8g2_draw_hv_line_4dir+0x32>
  {
    y -= u8g2->tile_curr_row*8;
    if ( x < u8g2->pixel_buf_width && y < u8g2->pixel_buf_height )
    2fde:	7835      	ldrb	r5, [r6, #0]
    2fe0:	428d      	cmp	r5, r1
    2fe2:	d93d      	bls.n	3060 <u8g2_draw_hv_line_4dir+0x90>
    y -= u8g2->tile_curr_row*8;
    2fe4:	0005      	movs	r5, r0
    2fe6:	3539      	adds	r5, #57	; 0x39
    2fe8:	782d      	ldrb	r5, [r5, #0]
    2fea:	00ed      	lsls	r5, r5, #3
    2fec:	1b52      	subs	r2, r2, r5
    if ( x < u8g2->pixel_buf_width && y < u8g2->pixel_buf_height )
    2fee:	0005      	movs	r5, r0
    2ff0:	353b      	adds	r5, #59	; 0x3b
    2ff2:	782d      	ldrb	r5, [r5, #0]
    y -= u8g2->tile_curr_row*8;
    2ff4:	b2d2      	uxtb	r2, r2
    if ( x < u8g2->pixel_buf_width && y < u8g2->pixel_buf_height )
    2ff6:	4295      	cmp	r5, r2
    2ff8:	d932      	bls.n	3060 <u8g2_draw_hv_line_4dir+0x90>
  u8g2->ll_hvline(u8g2, x, y, len, dir);
    2ffa:	9400      	str	r4, [sp, #0]
    2ffc:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    2ffe:	47a0      	blx	r4
    3000:	e02e      	b.n	3060 <u8g2_draw_hv_line_4dir+0x90>
      u8g2->ll_hvline(u8g2, x, y, len, dir);
    return;
  }
#endif
  
  if ( dir == 2 )
    3002:	2c02      	cmp	r4, #2
    3004:	d123      	bne.n	304e <u8g2_draw_hv_line_4dir+0x7e>
    3006:	3101      	adds	r1, #1
  {
    x -= len;
    x++;
    3008:	1ac9      	subs	r1, r1, r3
    300a:	b2c9      	uxtb	r1, r1
  else if ( dir == 3 )
  {
    y -= len;
    y++;
  }
  dir &= 1;  
    300c:	2501      	movs	r5, #1
    300e:	402c      	ands	r4, r5
  y -= u8g2->tile_curr_row*8;
    3010:	0005      	movs	r5, r0
    3012:	3539      	adds	r5, #57	; 0x39
    3014:	782d      	ldrb	r5, [r5, #0]
  w = u8g2->pixel_buf_width;		// this could be replaced by u8g2->u8x8.display_info->pixel_width
    3016:	7836      	ldrb	r6, [r6, #0]
  y -= u8g2->tile_curr_row*8;
    3018:	00ed      	lsls	r5, r5, #3
    301a:	1b52      	subs	r2, r2, r5
  h = u8g2->pixel_buf_height;		// this must be the real buffer height
    301c:	0005      	movs	r5, r0
    301e:	353b      	adds	r5, #59	; 0x3b
  y -= u8g2->tile_curr_row*8;
    3020:	b2d2      	uxtb	r2, r2
  h = u8g2->pixel_buf_height;		// this must be the real buffer height
    3022:	782d      	ldrb	r5, [r5, #0]
  if ( dir == 0 )
    3024:	2c00      	cmp	r4, #0
    3026:	d11c      	bne.n	3062 <u8g2_draw_hv_line_4dir+0x92>
    if ( y >= h )
    3028:	42aa      	cmp	r2, r5
    302a:	d219      	bcs.n	3060 <u8g2_draw_hv_line_4dir+0x90>
    a += len;
    302c:	18cb      	adds	r3, r1, r3
    302e:	b2db      	uxtb	r3, r3
  if ( a > b )
    3030:	4299      	cmp	r1, r3
    3032:	d913      	bls.n	305c <u8g2_draw_hv_line_4dir+0x8c>
    if ( a < d )
    3034:	42b1      	cmp	r1, r6
    3036:	d210      	bcs.n	305a <u8g2_draw_hv_line_4dir+0x8a>
      b--;
    3038:	1e73      	subs	r3, r6, #1
    303a:	b2db      	uxtb	r3, r3
  if ( b <= 0 )		// was b <= c, could be replaced with b == 0
    303c:	2b00      	cmp	r3, #0
    303e:	d00f      	beq.n	3060 <u8g2_draw_hv_line_4dir+0x90>
    len -= x;
    3040:	1c35      	adds	r5, r6, #0
    3042:	429e      	cmp	r6, r3
    3044:	d900      	bls.n	3048 <u8g2_draw_hv_line_4dir+0x78>
    3046:	1c1d      	adds	r5, r3, #0
    3048:	1a6b      	subs	r3, r5, r1
    len -= y;
    304a:	b2db      	uxtb	r3, r3
    304c:	e7d5      	b.n	2ffa <u8g2_draw_hv_line_4dir+0x2a>
  else if ( dir == 3 )
    304e:	2c03      	cmp	r4, #3
    3050:	d1dc      	bne.n	300c <u8g2_draw_hv_line_4dir+0x3c>
    3052:	3201      	adds	r2, #1
    y++;
    3054:	1ad2      	subs	r2, r2, r3
    3056:	b2d2      	uxtb	r2, r2
    3058:	e7d8      	b.n	300c <u8g2_draw_hv_line_4dir+0x3c>
      a = 0;
    305a:	0021      	movs	r1, r4
  if ( a >= d )
    305c:	428e      	cmp	r6, r1
    305e:	d8ed      	bhi.n	303c <u8g2_draw_hv_line_4dir+0x6c>
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
#else
  u8g2->ll_hvline(u8g2, x, y, len, dir);
  //u8g2_draw_low_level_hv_line(u8g2, x, y, len, dir);
#endif
}
    3060:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    if ( x >= w )
    3062:	42b1      	cmp	r1, r6
    3064:	d2fc      	bcs.n	3060 <u8g2_draw_hv_line_4dir+0x90>
    a += len;
    3066:	189b      	adds	r3, r3, r2
    3068:	b2db      	uxtb	r3, r3
  if ( a > b )
    306a:	429a      	cmp	r2, r3
    306c:	d90c      	bls.n	3088 <u8g2_draw_hv_line_4dir+0xb8>
    if ( a < d )
    306e:	42aa      	cmp	r2, r5
    3070:	d209      	bcs.n	3086 <u8g2_draw_hv_line_4dir+0xb6>
      b--;
    3072:	1e6b      	subs	r3, r5, #1
    3074:	b2db      	uxtb	r3, r3
  if ( b <= 0 )		// was b <= c, could be replaced with b == 0
    3076:	2b00      	cmp	r3, #0
    3078:	d0f2      	beq.n	3060 <u8g2_draw_hv_line_4dir+0x90>
    len -= y;
    307a:	1c2e      	adds	r6, r5, #0
    307c:	429d      	cmp	r5, r3
    307e:	d900      	bls.n	3082 <u8g2_draw_hv_line_4dir+0xb2>
    3080:	1c1e      	adds	r6, r3, #0
    3082:	1ab3      	subs	r3, r6, r2
    3084:	e7e1      	b.n	304a <u8g2_draw_hv_line_4dir+0x7a>
      a = 0;
    3086:	2200      	movs	r2, #0
  if ( a >= d )
    3088:	4295      	cmp	r5, r2
    308a:	d9e9      	bls.n	3060 <u8g2_draw_hv_line_4dir+0x90>
    308c:	e7f3      	b.n	3076 <u8g2_draw_hv_line_4dir+0xa6>

0000308e <u8g2_DrawHVLine>:
/*
  This is the toplevel function for the hv line draw procedures.
  This function should be called by the user.
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    308e:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3090:	ac06      	add	r4, sp, #24
    3092:	7825      	ldrb	r5, [r4, #0]
  
  
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  if ( len != 0 )
    3094:	2b00      	cmp	r3, #0
    3096:	d003      	beq.n	30a0 <u8g2_DrawHVLine+0x12>
    u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    3098:	6b04      	ldr	r4, [r0, #48]	; 0x30
    309a:	9500      	str	r5, [sp, #0]
    309c:	6864      	ldr	r4, [r4, #4]
    309e:	47a0      	blx	r4
}
    30a0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
	...

000030a4 <u8g2_DrawVLine>:
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 0);
}

void u8g2_DrawVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    30a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    30a6:	001f      	movs	r7, r3
    30a8:	0015      	movs	r5, r2
#ifdef U8G2_WITH_INTERSECTION
  if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
    30aa:	19d2      	adds	r2, r2, r7
{
    30ac:	b085      	sub	sp, #20
  if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
    30ae:	b2d2      	uxtb	r2, r2
    30b0:	1c4b      	adds	r3, r1, #1
    30b2:	9200      	str	r2, [sp, #0]
    30b4:	b2db      	uxtb	r3, r3
    30b6:	002a      	movs	r2, r5
    30b8:	4e07      	ldr	r6, [pc, #28]	; (30d8 <u8g2_DrawVLine+0x34>)
{
    30ba:	9003      	str	r0, [sp, #12]
    30bc:	000c      	movs	r4, r1
  if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
    30be:	47b0      	blx	r6
    30c0:	2800      	cmp	r0, #0
    30c2:	d007      	beq.n	30d4 <u8g2_DrawVLine+0x30>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
    30c4:	2301      	movs	r3, #1
    30c6:	0021      	movs	r1, r4
    30c8:	9300      	str	r3, [sp, #0]
    30ca:	002a      	movs	r2, r5
    30cc:	003b      	movs	r3, r7
    30ce:	9803      	ldr	r0, [sp, #12]
    30d0:	4c02      	ldr	r4, [pc, #8]	; (30dc <u8g2_DrawVLine+0x38>)
    30d2:	47a0      	blx	r4
}
    30d4:	b005      	add	sp, #20
    30d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    30d8:	00003139 	.word	0x00003139
    30dc:	0000308f 	.word	0x0000308f

000030e0 <u8g2_DrawPixel>:

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
    30e0:	0003      	movs	r3, r0
{
    30e2:	b513      	push	{r0, r1, r4, lr}
  if ( y < u8g2->user_y0 )
    30e4:	3343      	adds	r3, #67	; 0x43
    30e6:	781b      	ldrb	r3, [r3, #0]
    30e8:	4293      	cmp	r3, r2
    30ea:	d814      	bhi.n	3116 <u8g2_DrawPixel+0x36>
    return;
  if ( y >= u8g2->user_y1 )
    30ec:	0003      	movs	r3, r0
    30ee:	3344      	adds	r3, #68	; 0x44
    30f0:	781b      	ldrb	r3, [r3, #0]
    30f2:	4293      	cmp	r3, r2
    30f4:	d90f      	bls.n	3116 <u8g2_DrawPixel+0x36>
    return;
  if ( x < u8g2->user_x0 )
    30f6:	0003      	movs	r3, r0
    30f8:	3341      	adds	r3, #65	; 0x41
    30fa:	781b      	ldrb	r3, [r3, #0]
    30fc:	428b      	cmp	r3, r1
    30fe:	d80a      	bhi.n	3116 <u8g2_DrawPixel+0x36>
    return;
  if ( x >= u8g2->user_x1 )
    3100:	0003      	movs	r3, r0
    3102:	3342      	adds	r3, #66	; 0x42
    3104:	781b      	ldrb	r3, [r3, #0]
    3106:	428b      	cmp	r3, r1
    3108:	d905      	bls.n	3116 <u8g2_DrawPixel+0x36>
    u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    310a:	2400      	movs	r4, #0
    310c:	6b03      	ldr	r3, [r0, #48]	; 0x30
    310e:	9400      	str	r4, [sp, #0]
    3110:	685c      	ldr	r4, [r3, #4]
    3112:	2301      	movs	r3, #1
    3114:	47a0      	blx	r4
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
}
    3116:	bd13      	pop	{r0, r1, r4, pc}

00003118 <u8g2_is_intersection_decision_tree>:
  version with asymetric boundaries.
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
    3118:	b510      	push	{r4, lr}
    311a:	0004      	movs	r4, r0
  if ( v0 < a1 )		// v0 <= a1
    311c:	428a      	cmp	r2, r1
    311e:	d206      	bcs.n	312e <u8g2_is_intersection_decision_tree+0x16>
  {
    if ( v1 > a0 )	// v1 >= a0
    {
      return 1;
    3120:	2001      	movs	r0, #1
    if ( v1 > a0 )	// v1 >= a0
    3122:	42a3      	cmp	r3, r4
    3124:	d802      	bhi.n	312c <u8g2_is_intersection_decision_tree+0x14>
      return 1;
    3126:	4293      	cmp	r3, r2
    3128:	419b      	sbcs	r3, r3
    312a:	4258      	negs	r0, r3
    else
    {
      return 0;
    }
  }
}
    312c:	bd10      	pop	{r4, pc}
    if ( v1 > a0 )	// v1 >= a0
    312e:	4283      	cmp	r3, r0
    3130:	d8f9      	bhi.n	3126 <u8g2_is_intersection_decision_tree+0xe>
      return 0;
    3132:	2000      	movs	r0, #0
    3134:	e7fa      	b.n	312c <u8g2_is_intersection_decision_tree+0x14>
	...

00003138 <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
    3138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    313a:	000e      	movs	r6, r1
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    313c:	0001      	movs	r1, r0
{
    313e:	0004      	movs	r4, r0
    3140:	001f      	movs	r7, r3
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    3142:	3144      	adds	r1, #68	; 0x44
{
    3144:	ab06      	add	r3, sp, #24
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    3146:	3043      	adds	r0, #67	; 0x43
{
    3148:	781b      	ldrb	r3, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    314a:	7809      	ldrb	r1, [r1, #0]
    314c:	7800      	ldrb	r0, [r0, #0]
    314e:	4d06      	ldr	r5, [pc, #24]	; (3168 <u8g2_IsIntersection+0x30>)
    3150:	47a8      	blx	r5
    3152:	2800      	cmp	r0, #0
    3154:	d007      	beq.n	3166 <u8g2_IsIntersection+0x2e>
    return 0; 
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
    3156:	0023      	movs	r3, r4
    3158:	3441      	adds	r4, #65	; 0x41
    315a:	3342      	adds	r3, #66	; 0x42
    315c:	7819      	ldrb	r1, [r3, #0]
    315e:	7820      	ldrb	r0, [r4, #0]
    3160:	003b      	movs	r3, r7
    3162:	0032      	movs	r2, r6
    3164:	47a8      	blx	r5
}
    3166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3168:	00003119 	.word	0x00003119

0000316c <u8g2_DrawLine>:

#include "u8g2.h"


void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    316c:	b5f0      	push	{r4, r5, r6, r7, lr}
    316e:	001e      	movs	r6, r3
    3170:	b087      	sub	sp, #28
    3172:	ab0c      	add	r3, sp, #48	; 0x30

  uint8_t swapxy = 0;
  
  /* no intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    3174:	1a77      	subs	r7, r6, r1
{
    3176:	9005      	str	r0, [sp, #20]
    3178:	000c      	movs	r4, r1
    317a:	0015      	movs	r5, r2
    317c:	781b      	ldrb	r3, [r3, #0]
  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    317e:	b2ff      	uxtb	r7, r7
    3180:	42b1      	cmp	r1, r6
    3182:	d901      	bls.n	3188 <u8g2_DrawLine+0x1c>
    3184:	1b8f      	subs	r7, r1, r6
    3186:	b2ff      	uxtb	r7, r7
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    3188:	429d      	cmp	r5, r3
    318a:	d908      	bls.n	319e <u8g2_DrawLine+0x32>
    318c:	1aea      	subs	r2, r5, r3
    318e:	b2d2      	uxtb	r2, r2
    3190:	9201      	str	r2, [sp, #4]

  if ( dy > dx ) 
    3192:	4297      	cmp	r7, r2
    3194:	d324      	bcc.n	31e0 <u8g2_DrawLine+0x74>
    swapxy = 1;
    tmp = dx; dx =dy; dy = tmp;
    tmp = x1; x1 =y1; y1 = tmp;
    tmp = x2; x2 =y2; y2 = tmp;
  }
  if ( x1 > x2 ) 
    3196:	42b4      	cmp	r4, r6
    3198:	d848      	bhi.n	322c <u8g2_DrawLine+0xc0>
    319a:	2200      	movs	r2, #0
    319c:	e00e      	b.n	31bc <u8g2_DrawLine+0x50>
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    319e:	1b5a      	subs	r2, r3, r5
    31a0:	b2d2      	uxtb	r2, r2
    31a2:	9201      	str	r2, [sp, #4]
  if ( dy > dx ) 
    31a4:	4297      	cmp	r7, r2
    31a6:	d24c      	bcs.n	3242 <u8g2_DrawLine+0xd6>
    31a8:	003a      	movs	r2, r7
    31aa:	9f01      	ldr	r7, [sp, #4]
    31ac:	9201      	str	r2, [sp, #4]
    31ae:	0032      	movs	r2, r6
    31b0:	001e      	movs	r6, r3
    31b2:	0013      	movs	r3, r2
    31b4:	0022      	movs	r2, r4
    31b6:	002c      	movs	r4, r5
    31b8:	0015      	movs	r5, r2
    swapxy = 1;
    31ba:	2201      	movs	r2, #1
    31bc:	9202      	str	r2, [sp, #8]
  {
    tmp = x1; x1 =x2; x2 = tmp;
    tmp = y1; y1 =y2; y2 = tmp;
  }
  err = dx >> 1;
    31be:	087a      	lsrs	r2, r7, #1
    31c0:	b252      	sxtb	r2, r2
    31c2:	9203      	str	r2, [sp, #12]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    31c4:	2200      	movs	r2, #0
    31c6:	429d      	cmp	r5, r3
    31c8:	4152      	adcs	r2, r2
    31ca:	2301      	movs	r3, #1
    31cc:	4252      	negs	r2, r2
    31ce:	4313      	orrs	r3, r2
    31d0:	9304      	str	r3, [sp, #16]
  y = y1;

#ifndef  U8G2_16BIT
  if ( x2 == 255 )
    31d2:	2eff      	cmp	r6, #255	; 0xff
    31d4:	d100      	bne.n	31d8 <u8g2_DrawLine+0x6c>
    x2--;
    31d6:	3e01      	subs	r6, #1
#else
  if ( x2 == 0xffff )
    x2--;
#endif

  for( x = x1; x <= x2; x++ )
    31d8:	42a6      	cmp	r6, r4
    31da:	d20b      	bcs.n	31f4 <u8g2_DrawLine+0x88>
    {
      y += (u8g2_uint_t)ystep;
      err += (u8g2_uint_t)dx;
    }
  }
}
    31dc:	b007      	add	sp, #28
    31de:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( dy > dx ) 
    31e0:	003a      	movs	r2, r7
    31e2:	9f01      	ldr	r7, [sp, #4]
    31e4:	9201      	str	r2, [sp, #4]
    31e6:	002a      	movs	r2, r5
    31e8:	0035      	movs	r5, r6
    31ea:	0016      	movs	r6, r2
    31ec:	0022      	movs	r2, r4
    31ee:	001c      	movs	r4, r3
    31f0:	0013      	movs	r3, r2
    31f2:	e7e2      	b.n	31ba <u8g2_DrawLine+0x4e>
    if ( swapxy == 0 ) 
    31f4:	9a02      	ldr	r2, [sp, #8]
    31f6:	4b19      	ldr	r3, [pc, #100]	; (325c <u8g2_DrawLine+0xf0>)
    31f8:	2a00      	cmp	r2, #0
    31fa:	d114      	bne.n	3226 <u8g2_DrawLine+0xba>
      u8g2_DrawPixel(u8g2, x, y); 
    31fc:	002a      	movs	r2, r5
    31fe:	0021      	movs	r1, r4
      u8g2_DrawPixel(u8g2, y, x); 
    3200:	9805      	ldr	r0, [sp, #20]
    3202:	4798      	blx	r3
    err -= (uint8_t)dy;
    3204:	9b03      	ldr	r3, [sp, #12]
    3206:	9a01      	ldr	r2, [sp, #4]
    3208:	1a9b      	subs	r3, r3, r2
    320a:	b2db      	uxtb	r3, r3
    320c:	b25a      	sxtb	r2, r3
    320e:	9203      	str	r2, [sp, #12]
    if ( err < 0 ) 
    3210:	2a00      	cmp	r2, #0
    3212:	da05      	bge.n	3220 <u8g2_DrawLine+0xb4>
      y += (u8g2_uint_t)ystep;
    3214:	9a04      	ldr	r2, [sp, #16]
      err += (u8g2_uint_t)dx;
    3216:	19db      	adds	r3, r3, r7
      y += (u8g2_uint_t)ystep;
    3218:	18ad      	adds	r5, r5, r2
      err += (u8g2_uint_t)dx;
    321a:	b25b      	sxtb	r3, r3
      y += (u8g2_uint_t)ystep;
    321c:	b2ed      	uxtb	r5, r5
      err += (u8g2_uint_t)dx;
    321e:	9303      	str	r3, [sp, #12]
  for( x = x1; x <= x2; x++ )
    3220:	3401      	adds	r4, #1
    3222:	b2e4      	uxtb	r4, r4
    3224:	e7d8      	b.n	31d8 <u8g2_DrawLine+0x6c>
      u8g2_DrawPixel(u8g2, y, x); 
    3226:	0022      	movs	r2, r4
    3228:	0029      	movs	r1, r5
    322a:	e7e9      	b.n	3200 <u8g2_DrawLine+0x94>
  err = dx >> 1;
    322c:	001d      	movs	r5, r3
    322e:	0023      	movs	r3, r4
    3230:	0034      	movs	r4, r6
    3232:	001e      	movs	r6, r3
    3234:	2300      	movs	r3, #0
    3236:	087a      	lsrs	r2, r7, #1
    3238:	b252      	sxtb	r2, r2
    323a:	9302      	str	r3, [sp, #8]
    323c:	9203      	str	r2, [sp, #12]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    323e:	3301      	adds	r3, #1
    3240:	e7c6      	b.n	31d0 <u8g2_DrawLine+0x64>
  if ( x1 > x2 ) 
    3242:	42b4      	cmp	r4, r6
    3244:	d9a9      	bls.n	319a <u8g2_DrawLine+0x2e>
  err = dx >> 1;
    3246:	001d      	movs	r5, r3
    3248:	0023      	movs	r3, r4
    324a:	0034      	movs	r4, r6
    324c:	001e      	movs	r6, r3
    324e:	2300      	movs	r3, #0
    3250:	087a      	lsrs	r2, r7, #1
    3252:	b252      	sxtb	r2, r2
    3254:	9302      	str	r3, [sp, #8]
    3256:	9203      	str	r2, [sp, #12]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    3258:	3b01      	subs	r3, #1
    325a:	e7b9      	b.n	31d0 <u8g2_DrawLine+0x64>
    325c:	000030e1 	.word	0x000030e1

00003260 <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    3260:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3262:	ac08      	add	r4, sp, #32
    3264:	7824      	ldrb	r4, [r4, #0]
    3266:	9401      	str	r4, [sp, #4]
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
    3268:	2407      	movs	r4, #7
    326a:	4014      	ands	r4, r2
    326c:	46a4      	mov	ip, r4
  mask = 1;
  mask <<= bit_pos;
    326e:	2401      	movs	r4, #1
    3270:	4665      	mov	r5, ip
    3272:	40ac      	lsls	r4, r5

  or_mask = 0;
  xor_mask = 0;
  if ( u8g2->draw_color <= 1 )
    3274:	0005      	movs	r5, r0
    3276:	357d      	adds	r5, #125	; 0x7d
    3278:	782e      	ldrb	r6, [r5, #0]
  mask <<= bit_pos;
    327a:	b2e4      	uxtb	r4, r4
  or_mask = 0;
    327c:	2500      	movs	r5, #0
  if ( u8g2->draw_color <= 1 )
    327e:	2e01      	cmp	r6, #1
    3280:	d802      	bhi.n	3288 <u8g2_ll_hvline_vertical_top_lsb+0x28>
    or_mask  = mask;
    3282:	0025      	movs	r5, r4
  if ( u8g2->draw_color != 1 )
    3284:	2e01      	cmp	r6, #1
    3286:	d014      	beq.n	32b2 <u8g2_ll_hvline_vertical_top_lsb+0x52>
    xor_mask = mask;


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
  offset &= ~7;
    3288:	2707      	movs	r7, #7
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    328a:	6806      	ldr	r6, [r0, #0]
  offset &= ~7;
    328c:	43ba      	bics	r2, r7
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    328e:	7c36      	ldrb	r6, [r6, #16]
  ptr = u8g2->tile_buf_ptr;
  ptr += offset;
    3290:	4372      	muls	r2, r6
  ptr += x;
    3292:	1851      	adds	r1, r2, r1
    3294:	6b42      	ldr	r2, [r0, #52]	; 0x34
    3296:	1851      	adds	r1, r2, r1
  
  if ( dir == 0 )
    3298:	9a01      	ldr	r2, [sp, #4]
    329a:	2a00      	cmp	r2, #0
    329c:	d10b      	bne.n	32b6 <u8g2_ll_hvline_vertical_top_lsb+0x56>
  {
      do
      {
	*ptr |= or_mask;
    329e:	780a      	ldrb	r2, [r1, #0]
	*ptr ^= xor_mask;
	ptr++;
	len--;
    32a0:	3b01      	subs	r3, #1
	*ptr |= or_mask;
    32a2:	432a      	orrs	r2, r5
	*ptr ^= xor_mask;
    32a4:	4062      	eors	r2, r4
	len--;
    32a6:	b2db      	uxtb	r3, r3
	*ptr ^= xor_mask;
    32a8:	700a      	strb	r2, [r1, #0]
	ptr++;
    32aa:	3101      	adds	r1, #1
      } while( len != 0 );
    32ac:	2b00      	cmp	r3, #0
    32ae:	d1f6      	bne.n	329e <u8g2_ll_hvline_vertical_top_lsb+0x3e>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
    32b0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
  xor_mask = 0;
    32b2:	2400      	movs	r4, #0
    32b4:	e7e8      	b.n	3288 <u8g2_ll_hvline_vertical_top_lsb+0x28>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    32b6:	0002      	movs	r2, r0
	  xor_mask = 1;
    32b8:	2601      	movs	r6, #1
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    32ba:	323a      	adds	r2, #58	; 0x3a
    32bc:	9201      	str	r2, [sp, #4]
      *ptr |= or_mask;
    32be:	780a      	ldrb	r2, [r1, #0]
      len--;
    32c0:	3b01      	subs	r3, #1
      *ptr |= or_mask;
    32c2:	432a      	orrs	r2, r5
      *ptr ^= xor_mask;
    32c4:	4062      	eors	r2, r4
    32c6:	700a      	strb	r2, [r1, #0]
      bit_pos++;
    32c8:	4662      	mov	r2, ip
    32ca:	3201      	adds	r2, #1
      bit_pos &= 7;
    32cc:	403a      	ands	r2, r7
    32ce:	4694      	mov	ip, r2
      len--;
    32d0:	b2db      	uxtb	r3, r3
      if ( bit_pos == 0 )
    32d2:	2a00      	cmp	r2, #0
    32d4:	d10c      	bne.n	32f0 <u8g2_ll_hvline_vertical_top_lsb+0x90>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    32d6:	9a01      	ldr	r2, [sp, #4]
    32d8:	7812      	ldrb	r2, [r2, #0]
    32da:	1889      	adds	r1, r1, r2
	if ( u8g2->draw_color <= 1 )
    32dc:	0002      	movs	r2, r0
    32de:	327d      	adds	r2, #125	; 0x7d
    32e0:	7812      	ldrb	r2, [r2, #0]
    32e2:	2a01      	cmp	r2, #1
    32e4:	d802      	bhi.n	32ec <u8g2_ll_hvline_vertical_top_lsb+0x8c>
	  or_mask  = 1;
    32e6:	0035      	movs	r5, r6
	if ( u8g2->draw_color != 1 )
    32e8:	2a01      	cmp	r2, #1
    32ea:	d005      	beq.n	32f8 <u8g2_ll_hvline_vertical_top_lsb+0x98>
	  xor_mask = 1;
    32ec:	0034      	movs	r4, r6
    32ee:	e003      	b.n	32f8 <u8g2_ll_hvline_vertical_top_lsb+0x98>
	or_mask <<= 1;
    32f0:	006d      	lsls	r5, r5, #1
	xor_mask <<= 1;
    32f2:	0064      	lsls	r4, r4, #1
	or_mask <<= 1;
    32f4:	b2ed      	uxtb	r5, r5
	xor_mask <<= 1;
    32f6:	b2e4      	uxtb	r4, r4
    } while( len != 0 );
    32f8:	2b00      	cmp	r3, #0
    32fa:	d1e0      	bne.n	32be <u8g2_ll_hvline_vertical_top_lsb+0x5e>
    32fc:	e7d8      	b.n	32b0 <u8g2_ll_hvline_vertical_top_lsb+0x50>

000032fe <u8g2_update_dimension_common>:

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
    32fe:	0003      	movs	r3, r0
{
    3300:	b570      	push	{r4, r5, r6, lr}
  t = u8g2->tile_buf_height;
    3302:	3338      	adds	r3, #56	; 0x38
    3304:	781a      	ldrb	r2, [r3, #0]
  t *= 8;
    3306:	00d1      	lsls	r1, r2, #3
  u8g2->pixel_buf_height = t;
    3308:	70d9      	strb	r1, [r3, #3]
  
  t = u8g2_GetU8x8(u8g2)->display_info->tile_width;
    330a:	6804      	ldr	r4, [r0, #0]
    330c:	7c23      	ldrb	r3, [r4, #16]
    330e:	1c19      	adds	r1, r3, #0
    3310:	2b1f      	cmp	r3, #31
    3312:	d900      	bls.n	3316 <u8g2_update_dimension_common+0x18>
    3314:	211f      	movs	r1, #31
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
  u8g2->pixel_buf_width = t;
    3316:	0003      	movs	r3, r0
    3318:	b2c9      	uxtb	r1, r1
  t *= 8;
    331a:	00c9      	lsls	r1, r1, #3
  u8g2->pixel_buf_width = t;
    331c:	333a      	adds	r3, #58	; 0x3a
    331e:	7019      	strb	r1, [r3, #0]
  
  t = u8g2->tile_curr_row;
  t *= 8;
  u8g2->pixel_curr_row = t;
    3320:	0001      	movs	r1, r0
  t = u8g2->tile_curr_row;
    3322:	3b01      	subs	r3, #1
    3324:	781d      	ldrb	r5, [r3, #0]
  u8g2->pixel_curr_row = t;
    3326:	313c      	adds	r1, #60	; 0x3c
  t *= 8;
    3328:	00eb      	lsls	r3, r5, #3
    332a:	b2db      	uxtb	r3, r3
  u8g2->pixel_curr_row = t;
    332c:	700b      	strb	r3, [r1, #0]
  
  t = u8g2->tile_buf_height;
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > u8g2_GetU8x8(u8g2)->display_info->tile_height )
    332e:	7c61      	ldrb	r1, [r4, #17]
    3330:	1956      	adds	r6, r2, r5
    3332:	428e      	cmp	r6, r1
    3334:	dd01      	ble.n	333a <u8g2_update_dimension_common+0x3c>
    t = u8g2_GetU8x8(u8g2)->display_info->tile_height - u8g2->tile_curr_row;
    3336:	1b4a      	subs	r2, r1, r5
    3338:	b2d2      	uxtb	r2, r2
  t *= 8;
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    333a:	0001      	movs	r1, r0
  t *= 8;
    333c:	00d2      	lsls	r2, r2, #3
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    333e:	313d      	adds	r1, #61	; 0x3d
    3340:	700b      	strb	r3, [r1, #0]
  u8g2->buf_y1 = u8g2->buf_y0;
  u8g2->buf_y1 += t;
    3342:	189b      	adds	r3, r3, r2
    3344:	0002      	movs	r2, r0
    3346:	323e      	adds	r2, #62	; 0x3e
    3348:	7013      	strb	r3, [r2, #0]
  
#ifdef U8G2_16BIT
  u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_width;
  u8g2->height = u8g2_GetU8x8(u8g2)->display_info->pixel_height;
#else
  u8g2->width = 240;
    334a:	0003      	movs	r3, r0
    334c:	22f0      	movs	r2, #240	; 0xf0
    334e:	333f      	adds	r3, #63	; 0x3f
    3350:	701a      	strb	r2, [r3, #0]
  if ( u8g2_GetU8x8(u8g2)->display_info->pixel_width <= 240 )
    3352:	8aa2      	ldrh	r2, [r4, #20]
    3354:	2af0      	cmp	r2, #240	; 0xf0
    3356:	d800      	bhi.n	335a <u8g2_update_dimension_common+0x5c>
    u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_width;
    3358:	701a      	strb	r2, [r3, #0]
  u8g2->height = u8g2_GetU8x8(u8g2)->display_info->pixel_height;
    335a:	8ae3      	ldrh	r3, [r4, #22]
    335c:	3040      	adds	r0, #64	; 0x40
    335e:	7003      	strb	r3, [r0, #0]
#endif

}
    3360:	bd70      	pop	{r4, r5, r6, pc}
	...

00003364 <u8g2_update_dimension_r0>:

void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
    3364:	b510      	push	{r4, lr}
    3366:	0004      	movs	r4, r0
  u8g2_update_dimension_common(u8g2);
    3368:	4b09      	ldr	r3, [pc, #36]	; (3390 <u8g2_update_dimension_r0+0x2c>)
    336a:	4798      	blx	r3

  u8g2->user_x0 = 0;
    336c:	0023      	movs	r3, r4
    336e:	2200      	movs	r2, #0
    3370:	3341      	adds	r3, #65	; 0x41
    3372:	701a      	strb	r2, [r3, #0]
  u8g2->user_x1 = u8g2->pixel_buf_width;	/* pixel_buf_width replaced with width */
    3374:	0022      	movs	r2, r4
    3376:	323a      	adds	r2, #58	; 0x3a
    3378:	7812      	ldrb	r2, [r2, #0]
  
  u8g2->user_y0 = u8g2->buf_y0;
  u8g2->user_y1 = u8g2->buf_y1;
    337a:	3b03      	subs	r3, #3
  u8g2->user_x1 = u8g2->pixel_buf_width;	/* pixel_buf_width replaced with width */
    337c:	711a      	strb	r2, [r3, #4]
  u8g2->user_y0 = u8g2->buf_y0;
    337e:	0022      	movs	r2, r4
    3380:	323d      	adds	r2, #61	; 0x3d
    3382:	7812      	ldrb	r2, [r2, #0]
  u8g2->user_y1 = u8g2->buf_y1;
    3384:	3444      	adds	r4, #68	; 0x44
  u8g2->user_y0 = u8g2->buf_y0;
    3386:	715a      	strb	r2, [r3, #5]
  u8g2->user_y1 = u8g2->buf_y1;
    3388:	781b      	ldrb	r3, [r3, #0]
    338a:	7023      	strb	r3, [r4, #0]
  
//  printf("x0=%d x1=%d y0=%d y1=%d\n", 
//      u8g2->user_x0, u8g2->user_x1, u8g2->user_y0, u8g2->user_y1);
}
    338c:	bd10      	pop	{r4, pc}
    338e:	46c0      	nop			; (mov r8, r8)
    3390:	000032ff 	.word	0x000032ff

00003394 <u8g2_update_dimension_r1>:

void u8g2_update_dimension_r1(u8g2_t *u8g2)
{
    3394:	b510      	push	{r4, lr}
    3396:	0004      	movs	r4, r0
  u8g2_update_dimension_common(u8g2);
    3398:	4b0b      	ldr	r3, [pc, #44]	; (33c8 <u8g2_update_dimension_r1+0x34>)
    339a:	4798      	blx	r3
  
  u8g2->height = u8g2_GetU8x8(u8g2)->display_info->pixel_width;
    339c:	0021      	movs	r1, r4
    339e:	6822      	ldr	r2, [r4, #0]
    33a0:	3140      	adds	r1, #64	; 0x40
    33a2:	7d13      	ldrb	r3, [r2, #20]
    33a4:	700b      	strb	r3, [r1, #0]
  u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_height;
    33a6:	8ad1      	ldrh	r1, [r2, #22]
    33a8:	0022      	movs	r2, r4
    33aa:	323f      	adds	r2, #63	; 0x3f
    33ac:	7011      	strb	r1, [r2, #0]
  
  u8g2->user_x0 = u8g2->buf_y0;
    33ae:	0021      	movs	r1, r4
    33b0:	313d      	adds	r1, #61	; 0x3d
    33b2:	7809      	ldrb	r1, [r1, #0]
    33b4:	7091      	strb	r1, [r2, #2]
  u8g2->user_x1 = u8g2->buf_y1;
    33b6:	0021      	movs	r1, r4
    33b8:	313e      	adds	r1, #62	; 0x3e
    33ba:	7809      	ldrb	r1, [r1, #0]
  
  u8g2->user_y0 = 0;
  u8g2->user_y1 = u8g2->height;	/* pixel_buf_width replaced with height (which is the real pixel width) */
    33bc:	3444      	adds	r4, #68	; 0x44
  u8g2->user_x1 = u8g2->buf_y1;
    33be:	70d1      	strb	r1, [r2, #3]
  u8g2->user_y0 = 0;
    33c0:	2100      	movs	r1, #0
    33c2:	7111      	strb	r1, [r2, #4]
  u8g2->user_y1 = u8g2->height;	/* pixel_buf_width replaced with height (which is the real pixel width) */
    33c4:	7023      	strb	r3, [r4, #0]
  
  //printf("x0=%d x1=%d y0=%d y1=%d\n", 
   //   u8g2->user_x0, u8g2->user_x1, u8g2->user_y0, u8g2->user_y1);
}
    33c6:	bd10      	pop	{r4, pc}
    33c8:	000032ff 	.word	0x000032ff

000033cc <u8g2_update_dimension_r2>:

void u8g2_update_dimension_r2(u8g2_t *u8g2)
{
    33cc:	b510      	push	{r4, lr}
    33ce:	0004      	movs	r4, r0
  u8g2_update_dimension_common(u8g2);
    33d0:	4b0c      	ldr	r3, [pc, #48]	; (3404 <u8g2_update_dimension_r2+0x38>)
    33d2:	4798      	blx	r3

  u8g2->user_x0 = 0;
    33d4:	0023      	movs	r3, r4
    33d6:	2200      	movs	r2, #0
    33d8:	3341      	adds	r3, #65	; 0x41
    33da:	701a      	strb	r2, [r3, #0]
  u8g2->user_x1 = u8g2->width;	/* pixel_buf_width replaced with width */
    33dc:	0022      	movs	r2, r4
    33de:	323f      	adds	r2, #63	; 0x3f
    33e0:	7812      	ldrb	r2, [r2, #0]
  
  u8g2->user_y0 = u8g2->height - u8g2->buf_y1;
    33e2:	0021      	movs	r1, r4
  u8g2->user_x1 = u8g2->width;	/* pixel_buf_width replaced with width */
    33e4:	705a      	strb	r2, [r3, #1]
  u8g2->user_y0 = u8g2->height - u8g2->buf_y1;
    33e6:	0022      	movs	r2, r4
    33e8:	3b01      	subs	r3, #1
    33ea:	323e      	adds	r2, #62	; 0x3e
    33ec:	781b      	ldrb	r3, [r3, #0]
    33ee:	7812      	ldrb	r2, [r2, #0]
    33f0:	3143      	adds	r1, #67	; 0x43
    33f2:	1a9a      	subs	r2, r3, r2
    33f4:	700a      	strb	r2, [r1, #0]
  u8g2->user_y1 = u8g2->height - u8g2->buf_y0;
    33f6:	0022      	movs	r2, r4
    33f8:	323d      	adds	r2, #61	; 0x3d
    33fa:	7812      	ldrb	r2, [r2, #0]
    33fc:	3444      	adds	r4, #68	; 0x44
    33fe:	1a9b      	subs	r3, r3, r2
    3400:	7023      	strb	r3, [r4, #0]

//  printf("x0=%d x1=%d y0=%d y1=%d\n", 
//      u8g2->user_x0, u8g2->user_x1, u8g2->user_y0, u8g2->user_y1);
}
    3402:	bd10      	pop	{r4, pc}
    3404:	000032ff 	.word	0x000032ff

00003408 <u8g2_update_dimension_r3>:

void u8g2_update_dimension_r3(u8g2_t *u8g2)
{
    3408:	b510      	push	{r4, lr}
    340a:	0004      	movs	r4, r0
  u8g2_update_dimension_common(u8g2);
    340c:	4b0e      	ldr	r3, [pc, #56]	; (3448 <u8g2_update_dimension_r3+0x40>)
    340e:	4798      	blx	r3
  
  u8g2->height = u8g2_GetU8x8(u8g2)->display_info->pixel_width;
    3410:	0022      	movs	r2, r4
  u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_height;

  u8g2->user_x0 = u8g2->width - u8g2->buf_y1;
    3412:	0020      	movs	r0, r4
  u8g2->height = u8g2_GetU8x8(u8g2)->display_info->pixel_width;
    3414:	6823      	ldr	r3, [r4, #0]
    3416:	3240      	adds	r2, #64	; 0x40
    3418:	7d19      	ldrb	r1, [r3, #20]
  u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_height;
    341a:	3a01      	subs	r2, #1
  u8g2->height = u8g2_GetU8x8(u8g2)->display_info->pixel_width;
    341c:	7051      	strb	r1, [r2, #1]
  u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_height;
    341e:	7d9b      	ldrb	r3, [r3, #22]
  u8g2->user_x0 = u8g2->width - u8g2->buf_y1;
    3420:	3a01      	subs	r2, #1
  u8g2->width = u8g2_GetU8x8(u8g2)->display_info->pixel_height;
    3422:	7053      	strb	r3, [r2, #1]
  u8g2->user_x0 = u8g2->width - u8g2->buf_y1;
    3424:	7812      	ldrb	r2, [r2, #0]
    3426:	3041      	adds	r0, #65	; 0x41
    3428:	1a9a      	subs	r2, r3, r2
    342a:	7002      	strb	r2, [r0, #0]
  u8g2->user_x1 = u8g2->width - u8g2->buf_y0;
    342c:	0022      	movs	r2, r4
    342e:	323d      	adds	r2, #61	; 0x3d
    3430:	7812      	ldrb	r2, [r2, #0]
    3432:	1a9b      	subs	r3, r3, r2
    3434:	0022      	movs	r2, r4
    3436:	3242      	adds	r2, #66	; 0x42
    3438:	7013      	strb	r3, [r2, #0]
  
  u8g2->user_y0 = 0;
    343a:	0023      	movs	r3, r4
    343c:	2200      	movs	r2, #0
    343e:	3343      	adds	r3, #67	; 0x43
  u8g2->user_y1 = u8g2->height;	/* pixel_buf_width replaced with height (pixel_width) */
    3440:	3444      	adds	r4, #68	; 0x44
  u8g2->user_y0 = 0;
    3442:	701a      	strb	r2, [r3, #0]
  u8g2->user_y1 = u8g2->height;	/* pixel_buf_width replaced with height (pixel_width) */
    3444:	7021      	strb	r1, [r4, #0]

//  printf("x0=%d x1=%d y0=%d y1=%d\n", 
//      u8g2->user_x0, u8g2->user_x1, u8g2->user_y0, u8g2->user_y1);
}
    3446:	bd10      	pop	{r4, pc}
    3448:	000032ff 	.word	0x000032ff

0000344c <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_4dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    344c:	b513      	push	{r0, r1, r4, lr}
    344e:	ac04      	add	r4, sp, #16
    3450:	7824      	ldrb	r4, [r4, #0]
  u8g2_draw_hv_line_4dir(u8g2, x, y, len, dir);
    3452:	9400      	str	r4, [sp, #0]
    3454:	4c01      	ldr	r4, [pc, #4]	; (345c <u8g2_draw_l90_r0+0x10>)
    3456:	47a0      	blx	r4
}
    3458:	bd13      	pop	{r0, r1, r4, pc}
    345a:	46c0      	nop			; (mov r8, r8)
    345c:	00002fd1 	.word	0x00002fd1

00003460 <u8g2_draw_l90_mirrorr_r0>:

void u8g2_draw_l90_mirrorr_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    3460:	b573      	push	{r0, r1, r4, r5, r6, lr}
    3462:	ac06      	add	r4, sp, #24
    3464:	7825      	ldrb	r5, [r4, #0]
  u8g2_uint_t xx;
  xx = u8g2->width;
    3466:	0004      	movs	r4, r0
    3468:	343f      	adds	r4, #63	; 0x3f
    346a:	7824      	ldrb	r4, [r4, #0]
  xx -= x;
    346c:	1a64      	subs	r4, r4, r1
    346e:	b2e4      	uxtb	r4, r4
  {
    xx -= len;
  }
  else
  {
    xx--;
    3470:	1e61      	subs	r1, r4, #1
    3472:	b2c9      	uxtb	r1, r1
  if ( (dir & 1) == 0 )
    3474:	07ee      	lsls	r6, r5, #31
    3476:	d401      	bmi.n	347c <u8g2_draw_l90_mirrorr_r0+0x1c>
    xx -= len;
    3478:	1ae4      	subs	r4, r4, r3
    347a:	b2e1      	uxtb	r1, r4
  }
  u8g2_draw_hv_line_4dir(u8g2, xx, y, len, dir);
    347c:	9500      	str	r5, [sp, #0]
    347e:	4c01      	ldr	r4, [pc, #4]	; (3484 <u8g2_draw_l90_mirrorr_r0+0x24>)
    3480:	47a0      	blx	r4
}
    3482:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    3484:	00002fd1 	.word	0x00002fd1

00003488 <u8g2_draw_l90_r1>:



void u8g2_draw_l90_r1(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    3488:	b573      	push	{r0, r1, r4, r5, r6, lr}
    348a:	000e      	movs	r6, r1
    348c:	a906      	add	r1, sp, #24
    348e:	780d      	ldrb	r5, [r1, #0]
  u8g2_uint_t xx, yy;
  
  yy = x;
  
  xx = u8g2->height;
    3490:	0001      	movs	r1, r0
    3492:	3140      	adds	r1, #64	; 0x40
    3494:	780c      	ldrb	r4, [r1, #0]
  xx -= y;
  xx--;
    3496:	43d1      	mvns	r1, r2
  
  dir ++;
  dir &= 3;
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    3498:	2203      	movs	r2, #3
  dir ++;
    349a:	3501      	adds	r5, #1
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    349c:	402a      	ands	r2, r5
  xx--;
    349e:	1861      	adds	r1, r4, r1
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    34a0:	9200      	str	r2, [sp, #0]
    34a2:	b2c9      	uxtb	r1, r1
    34a4:	0032      	movs	r2, r6
    34a6:	4c01      	ldr	r4, [pc, #4]	; (34ac <u8g2_draw_l90_r1+0x24>)
    34a8:	47a0      	blx	r4
}
    34aa:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    34ac:	00002fd1 	.word	0x00002fd1

000034b0 <u8g2_draw_l90_r2>:

void u8g2_draw_l90_r2(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    34b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    34b2:	ac06      	add	r4, sp, #24
    34b4:	7825      	ldrb	r5, [r4, #0]
  u8g2_uint_t xx, yy;

  yy = u8g2->height;
    34b6:	0004      	movs	r4, r0
  yy -= y;
  yy--;
  
  xx = u8g2->width;
  xx -= x;
  xx--;
    34b8:	43c9      	mvns	r1, r1
  yy = u8g2->height;
    34ba:	3440      	adds	r4, #64	; 0x40
    34bc:	7826      	ldrb	r6, [r4, #0]
  xx = u8g2->width;
    34be:	3c01      	subs	r4, #1
    34c0:	7824      	ldrb	r4, [r4, #0]
  yy--;
    34c2:	43d2      	mvns	r2, r2
  xx--;
    34c4:	1861      	adds	r1, r4, r1
  
  dir +=2;
  dir &= 3;
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    34c6:	2403      	movs	r4, #3
  dir +=2;
    34c8:	3502      	adds	r5, #2
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    34ca:	402c      	ands	r4, r5
  yy--;
    34cc:	18b2      	adds	r2, r6, r2
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    34ce:	9400      	str	r4, [sp, #0]
    34d0:	b2d2      	uxtb	r2, r2
    34d2:	b2c9      	uxtb	r1, r1
    34d4:	4c01      	ldr	r4, [pc, #4]	; (34dc <u8g2_draw_l90_r2+0x2c>)
    34d6:	47a0      	blx	r4
}
    34d8:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    34da:	46c0      	nop			; (mov r8, r8)
    34dc:	00002fd1 	.word	0x00002fd1

000034e0 <u8g2_draw_l90_r3>:

void u8g2_draw_l90_r3(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    34e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    34e2:	0015      	movs	r5, r2
    34e4:	aa06      	add	r2, sp, #24
    34e6:	7814      	ldrb	r4, [r2, #0]
  u8g2_uint_t xx, yy;

  xx = y;
  
  yy = u8g2->width;
    34e8:	0002      	movs	r2, r0
  yy -= x;
  yy--;
    34ea:	43c9      	mvns	r1, r1
  yy = u8g2->width;
    34ec:	323f      	adds	r2, #63	; 0x3f
    34ee:	7812      	ldrb	r2, [r2, #0]
  
  dir +=3;
    34f0:	3403      	adds	r4, #3
  yy--;
    34f2:	1852      	adds	r2, r2, r1
  dir &= 3;
  u8g2_draw_hv_line_4dir(u8g2, xx, yy, len, dir);
    34f4:	2103      	movs	r1, #3
    34f6:	400c      	ands	r4, r1
    34f8:	9400      	str	r4, [sp, #0]
    34fa:	0029      	movs	r1, r5
    34fc:	b2d2      	uxtb	r2, r2
    34fe:	4c01      	ldr	r4, [pc, #4]	; (3504 <u8g2_draw_l90_r3+0x24>)
    3500:	47a0      	blx	r4
}
    3502:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    3504:	00002fd1 	.word	0x00002fd1

00003508 <u8g2_SetupBuffer>:
{
    3508:	b570      	push	{r4, r5, r6, lr}
    350a:	0004      	movs	r4, r0
  u8g2->ll_hvline = ll_hvline_cb;
    350c:	62e3      	str	r3, [r4, #44]	; 0x2c
  u8g2->tile_buf_height = tile_buf_height;
    350e:	0023      	movs	r3, r4
  u8g2->font = NULL;
    3510:	2500      	movs	r5, #0
  u8g2->tile_buf_height = tile_buf_height;
    3512:	3338      	adds	r3, #56	; 0x38
  u8g2->font = NULL;
    3514:	64a5      	str	r5, [r4, #72]	; 0x48
  u8g2->tile_buf_ptr = buf;
    3516:	6361      	str	r1, [r4, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
    3518:	701a      	strb	r2, [r3, #0]
  u8g2->draw_color = 1;
    351a:	0022      	movs	r2, r4
  u8g2->tile_curr_row = 0;
    351c:	705d      	strb	r5, [r3, #1]
  u8g2->draw_color = 1;
    351e:	2301      	movs	r3, #1
{
    3520:	9804      	ldr	r0, [sp, #16]
  u8g2->draw_color = 1;
    3522:	327d      	adds	r2, #125	; 0x7d
    3524:	7013      	strb	r3, [r2, #0]
  u8g2->is_auto_page_clear = 1;
    3526:	7053      	strb	r3, [r2, #1]
  u8g2->cb->update(u8g2);
    3528:	6803      	ldr	r3, [r0, #0]
  u8g2->cb = u8g2_cb;
    352a:	6320      	str	r0, [r4, #48]	; 0x30
  u8g2->cb->update(u8g2);
    352c:	0020      	movs	r0, r4
    352e:	4798      	blx	r3
  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    3530:	0020      	movs	r0, r4
    3532:	4b02      	ldr	r3, [pc, #8]	; (353c <u8g2_SetupBuffer+0x34>)
  u8g2->font_decode.dir = 0;
    3534:	345e      	adds	r4, #94	; 0x5e
  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    3536:	4798      	blx	r3
  u8g2->font_decode.dir = 0;
    3538:	7025      	strb	r5, [r4, #0]
}
    353a:	bd70      	pop	{r4, r5, r6, pc}
    353c:	00002fa1 	.word	0x00002fa1

00003540 <u8x8_ascii_next>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
}

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    3540:	2900      	cmp	r1, #0
    3542:	d002      	beq.n	354a <u8x8_ascii_next+0xa>
    return 0x0ffff;	/* end of string detected*/
  return b;
    3544:	b288      	uxth	r0, r1
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    3546:	290a      	cmp	r1, #10
    3548:	d100      	bne.n	354c <u8x8_ascii_next+0xc>
    return 0x0ffff;	/* end of string detected*/
    354a:	4801      	ldr	r0, [pc, #4]	; (3550 <u8x8_ascii_next+0x10>)
}
    354c:	4770      	bx	lr
    354e:	46c0      	nop			; (mov r8, r8)
    3550:	0000ffff 	.word	0x0000ffff

00003554 <u8x8_utf8_init>:
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
    3554:	2300      	movs	r3, #0
    3556:	3004      	adds	r0, #4
    3558:	77c3      	strb	r3, [r0, #31]
}
    355a:	4770      	bx	lr

0000355c <u8x8_byte_SendBytes>:
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
}

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    355c:	b510      	push	{r4, lr}
    355e:	0013      	movs	r3, r2
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
    3560:	6904      	ldr	r4, [r0, #16]
    3562:	000a      	movs	r2, r1
    3564:	2117      	movs	r1, #23
    3566:	47a0      	blx	r4
}
    3568:	bd10      	pop	{r4, pc}
	...

0000356c <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
    356c:	b507      	push	{r0, r1, r2, lr}
    356e:	466b      	mov	r3, sp
    3570:	1dda      	adds	r2, r3, #7
    3572:	7011      	strb	r1, [r2, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
    3574:	4b01      	ldr	r3, [pc, #4]	; (357c <u8x8_byte_SendByte+0x10>)
    3576:	2101      	movs	r1, #1
    3578:	4798      	blx	r3
}
    357a:	bd0e      	pop	{r1, r2, r3, pc}
    357c:	0000355d 	.word	0x0000355d

00003580 <u8x8_byte_StartTransfer>:

uint8_t u8x8_byte_StartTransfer(u8x8_t *u8x8)
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_START_TRANSFER, 0, NULL);
    3580:	2300      	movs	r3, #0
{
    3582:	b510      	push	{r4, lr}
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_START_TRANSFER, 0, NULL);
    3584:	001a      	movs	r2, r3
    3586:	6904      	ldr	r4, [r0, #16]
    3588:	2118      	movs	r1, #24
    358a:	47a0      	blx	r4
}
    358c:	bd10      	pop	{r4, pc}

0000358e <u8x8_byte_EndTransfer>:

uint8_t u8x8_byte_EndTransfer(u8x8_t *u8x8)
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_END_TRANSFER, 0, NULL);
    358e:	2300      	movs	r3, #0
{
    3590:	b510      	push	{r4, lr}
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_END_TRANSFER, 0, NULL);
    3592:	001a      	movs	r2, r3
    3594:	6904      	ldr	r4, [r0, #16]
    3596:	2119      	movs	r1, #25
    3598:	47a0      	blx	r4
}
    359a:	bd10      	pop	{r4, pc}

0000359c <u8x8_i2c_data_transfer>:
/* U8X8_MSG_BYTE_START_TRANSFER starts i2c transfer, U8X8_MSG_BYTE_END_TRANSFER stops transfer */
/* After transfer start, a full byte indicates command or data mode */

static void u8x8_i2c_data_transfer(u8x8_t *u8x8, uint8_t arg_int, void *arg_ptr) U8X8_NOINLINE;
static void u8x8_i2c_data_transfer(u8x8_t *u8x8, uint8_t arg_int, void *arg_ptr)
{
    359c:	b570      	push	{r4, r5, r6, lr}
    359e:	0004      	movs	r4, r0
    35a0:	0016      	movs	r6, r2
    35a2:	000d      	movs	r5, r1
    u8x8_byte_StartTransfer(u8x8);    
    35a4:	4b07      	ldr	r3, [pc, #28]	; (35c4 <u8x8_i2c_data_transfer+0x28>)
    35a6:	4798      	blx	r3
    u8x8_byte_SendByte(u8x8, 0x040);
    35a8:	2140      	movs	r1, #64	; 0x40
    35aa:	0020      	movs	r0, r4
    35ac:	4b06      	ldr	r3, [pc, #24]	; (35c8 <u8x8_i2c_data_transfer+0x2c>)
    35ae:	4798      	blx	r3
    u8x8->byte_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, arg_int, arg_ptr);
    35b0:	0033      	movs	r3, r6
    35b2:	002a      	movs	r2, r5
    35b4:	2117      	movs	r1, #23
    35b6:	6925      	ldr	r5, [r4, #16]
    35b8:	0020      	movs	r0, r4
    35ba:	47a8      	blx	r5
    u8x8_byte_EndTransfer(u8x8);
    35bc:	0020      	movs	r0, r4
    35be:	4b03      	ldr	r3, [pc, #12]	; (35cc <u8x8_i2c_data_transfer+0x30>)
    35c0:	4798      	blx	r3
}
    35c2:	bd70      	pop	{r4, r5, r6, pc}
    35c4:	00003581 	.word	0x00003581
    35c8:	0000356d 	.word	0x0000356d
    35cc:	0000358f 	.word	0x0000358f

000035d0 <u8x8_cad_SendCmd>:
{
    35d0:	b510      	push	{r4, lr}
    35d2:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
    35d4:	68c4      	ldr	r4, [r0, #12]
    35d6:	2300      	movs	r3, #0
    35d8:	2115      	movs	r1, #21
    35da:	47a0      	blx	r4
}
    35dc:	bd10      	pop	{r4, pc}

000035de <u8x8_cad_SendArg>:
{
    35de:	b510      	push	{r4, lr}
    35e0:	000a      	movs	r2, r1
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
    35e2:	68c4      	ldr	r4, [r0, #12]
    35e4:	2300      	movs	r3, #0
    35e6:	2116      	movs	r1, #22
    35e8:	47a0      	blx	r4
}
    35ea:	bd10      	pop	{r4, pc}

000035ec <u8x8_cad_SendData>:
{
    35ec:	b510      	push	{r4, lr}
    35ee:	0013      	movs	r3, r2
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
    35f0:	68c4      	ldr	r4, [r0, #12]
    35f2:	000a      	movs	r2, r1
    35f4:	2117      	movs	r1, #23
    35f6:	47a0      	blx	r4
}
    35f8:	bd10      	pop	{r4, pc}

000035fa <u8x8_cad_StartTransfer>:
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    35fa:	2300      	movs	r3, #0
{
    35fc:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    35fe:	001a      	movs	r2, r3
    3600:	68c4      	ldr	r4, [r0, #12]
    3602:	2118      	movs	r1, #24
    3604:	47a0      	blx	r4
}
    3606:	bd10      	pop	{r4, pc}

00003608 <u8x8_cad_EndTransfer>:
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    3608:	2300      	movs	r3, #0
{
    360a:	b510      	push	{r4, lr}
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    360c:	001a      	movs	r2, r3
    360e:	68c4      	ldr	r4, [r0, #12]
    3610:	2119      	movs	r1, #25
    3612:	47a0      	blx	r4
}
    3614:	bd10      	pop	{r4, pc}
	...

00003618 <u8x8_cad_SendSequence>:
{
    3618:	b573      	push	{r0, r1, r4, r5, r6, lr}
    361a:	0005      	movs	r5, r0
    361c:	000c      	movs	r4, r1
    cmd = *data;
    361e:	7821      	ldrb	r1, [r4, #0]
    switch( cmd )
    3620:	2917      	cmp	r1, #23
    3622:	d018      	beq.n	3656 <u8x8_cad_SendSequence+0x3e>
    3624:	d802      	bhi.n	362c <u8x8_cad_SendSequence+0x14>
    3626:	2915      	cmp	r1, #21
    3628:	d20c      	bcs.n	3644 <u8x8_cad_SendSequence+0x2c>
}
    362a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    switch( cmd )
    362c:	2919      	cmp	r1, #25
    362e:	d91b      	bls.n	3668 <u8x8_cad_SendSequence+0x50>
    3630:	29fe      	cmp	r1, #254	; 0xfe
    3632:	d1fa      	bne.n	362a <u8x8_cad_SendSequence+0x12>
	  v = *data;
    3634:	466b      	mov	r3, sp
    3636:	7862      	ldrb	r2, [r4, #1]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    3638:	2129      	movs	r1, #41	; 0x29
	  v = *data;
    363a:	71da      	strb	r2, [r3, #7]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    363c:	0028      	movs	r0, r5
    363e:	4b0e      	ldr	r3, [pc, #56]	; (3678 <u8x8_cad_SendSequence+0x60>)
    3640:	4798      	blx	r3
    3642:	e006      	b.n	3652 <u8x8_cad_SendSequence+0x3a>
	  v = *data;
    3644:	466b      	mov	r3, sp
    3646:	7862      	ldrb	r2, [r4, #1]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    3648:	0028      	movs	r0, r5
	  v = *data;
    364a:	71da      	strb	r2, [r3, #7]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    364c:	68ee      	ldr	r6, [r5, #12]
    364e:	2300      	movs	r3, #0
    3650:	47b0      	blx	r6
	  data++;
    3652:	3402      	adds	r4, #2
	  break;
    3654:	e7e3      	b.n	361e <u8x8_cad_SendSequence+0x6>
	  v = *data;
    3656:	466b      	mov	r3, sp
    3658:	1dda      	adds	r2, r3, #7
    365a:	7863      	ldrb	r3, [r4, #1]
	  u8x8_cad_SendData(u8x8, 1, &v);
    365c:	2101      	movs	r1, #1
	  v = *data;
    365e:	7013      	strb	r3, [r2, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
    3660:	0028      	movs	r0, r5
    3662:	4b06      	ldr	r3, [pc, #24]	; (367c <u8x8_cad_SendSequence+0x64>)
    3664:	4798      	blx	r3
    3666:	e7f4      	b.n	3652 <u8x8_cad_SendSequence+0x3a>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    3668:	2300      	movs	r3, #0
    366a:	0028      	movs	r0, r5
    366c:	001a      	movs	r2, r3
    366e:	68ee      	ldr	r6, [r5, #12]
    data++;
    3670:	3401      	adds	r4, #1
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    3672:	47b0      	blx	r6
	  break;
    3674:	e7d3      	b.n	361e <u8x8_cad_SendSequence+0x6>
    3676:	46c0      	nop			; (mov r8, r8)
    3678:	000038e5 	.word	0x000038e5
    367c:	000035ed 	.word	0x000035ed

00003680 <u8x8_cad_ssd13xx_i2c>:

uint8_t u8x8_cad_ssd13xx_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
  uint8_t *p;
  switch(msg)
    3680:	3914      	subs	r1, #20
{
    3682:	b570      	push	{r4, r5, r6, lr}
    3684:	0004      	movs	r4, r0
    3686:	0015      	movs	r5, r2
    case U8X8_MSG_CAD_START_TRANSFER:
    case U8X8_MSG_CAD_END_TRANSFER:
      /* cad transfer commands are ignored */
      break;
    default:
      return 0;
    3688:	2000      	movs	r0, #0
  switch(msg)
    368a:	2905      	cmp	r1, #5
    368c:	d81c      	bhi.n	36c8 <u8x8_cad_ssd13xx_i2c+0x48>
    368e:	0008      	movs	r0, r1
    3690:	f004 fc66 	bl	7f60 <__gnu_thumb1_case_uqi>
    3694:	030c0c22 	.word	0x030c0c22
    3698:	1919      	.short	0x1919
    369a:	001e      	movs	r6, r3
    369c:	4b14      	ldr	r3, [pc, #80]	; (36f0 <u8x8_cad_ssd13xx_i2c+0x70>)
	u8x8_i2c_data_transfer(u8x8, 24, p);
    369e:	0032      	movs	r2, r6
       while( arg_int > 24 )
    36a0:	2d18      	cmp	r5, #24
    36a2:	d812      	bhi.n	36ca <u8x8_cad_ssd13xx_i2c+0x4a>
      u8x8_i2c_data_transfer(u8x8, arg_int, p);
    36a4:	0029      	movs	r1, r5
    36a6:	0020      	movs	r0, r4
    36a8:	4798      	blx	r3
    36aa:	e00c      	b.n	36c6 <u8x8_cad_ssd13xx_i2c+0x46>
      u8x8_byte_StartTransfer(u8x8);
    36ac:	4b11      	ldr	r3, [pc, #68]	; (36f4 <u8x8_cad_ssd13xx_i2c+0x74>)
    36ae:	0020      	movs	r0, r4
    36b0:	4798      	blx	r3
      u8x8_byte_SendByte(u8x8, 0x000);
    36b2:	2100      	movs	r1, #0
    36b4:	4e10      	ldr	r6, [pc, #64]	; (36f8 <u8x8_cad_ssd13xx_i2c+0x78>)
    36b6:	0020      	movs	r0, r4
    36b8:	47b0      	blx	r6
      u8x8_byte_SendByte(u8x8, arg_int);
    36ba:	0029      	movs	r1, r5
    36bc:	0020      	movs	r0, r4
    36be:	47b0      	blx	r6
      u8x8_byte_EndTransfer(u8x8);      
    36c0:	0020      	movs	r0, r4
    36c2:	4b0e      	ldr	r3, [pc, #56]	; (36fc <u8x8_cad_ssd13xx_i2c+0x7c>)
    36c4:	4798      	blx	r3
  }
  return 1;
    36c6:	2001      	movs	r0, #1
}
    36c8:	bd70      	pop	{r4, r5, r6, pc}
	u8x8_i2c_data_transfer(u8x8, 24, p);
    36ca:	2118      	movs	r1, #24
    36cc:	0020      	movs	r0, r4
	arg_int-=24;
    36ce:	3d18      	subs	r5, #24
	u8x8_i2c_data_transfer(u8x8, 24, p);
    36d0:	4798      	blx	r3
	arg_int-=24;
    36d2:	b2ed      	uxtb	r5, r5
	p+=24;
    36d4:	3618      	adds	r6, #24
    36d6:	e7e1      	b.n	369c <u8x8_cad_ssd13xx_i2c+0x1c>
      if ( u8x8->i2c_address == 255 )
    36d8:	1c62      	adds	r2, r4, #1
    36da:	7fd1      	ldrb	r1, [r2, #31]
    36dc:	29ff      	cmp	r1, #255	; 0xff
    36de:	d101      	bne.n	36e4 <u8x8_cad_ssd13xx_i2c+0x64>
	u8x8->i2c_address = 0x078;
    36e0:	3987      	subs	r1, #135	; 0x87
    36e2:	77d1      	strb	r1, [r2, #31]
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    36e4:	6926      	ldr	r6, [r4, #16]
    36e6:	002a      	movs	r2, r5
    36e8:	2114      	movs	r1, #20
    36ea:	0020      	movs	r0, r4
    36ec:	47b0      	blx	r6
    36ee:	e7eb      	b.n	36c8 <u8x8_cad_ssd13xx_i2c+0x48>
    36f0:	0000359d 	.word	0x0000359d
    36f4:	00003581 	.word	0x00003581
    36f8:	0000356d 	.word	0x0000356d
    36fc:	0000358f 	.word	0x0000358f

00003700 <u8x8_d_helper_display_setup_memory>:
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
      /* 1) set display info struct */
      u8x8->display_info = display_info;
    3700:	6001      	str	r1, [r0, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
    3702:	7c8b      	ldrb	r3, [r1, #18]
    3704:	7783      	strb	r3, [r0, #30]
}
    3706:	4770      	bx	lr

00003708 <u8x8_d_helper_display_init>:
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
    3708:	2300      	movs	r3, #0
{
    370a:	b570      	push	{r4, r5, r6, lr}
      u8x8_gpio_Init(u8x8);
    370c:	001a      	movs	r2, r3
    370e:	2128      	movs	r1, #40	; 0x28
    3710:	6945      	ldr	r5, [r0, #20]
{
    3712:	0004      	movs	r4, r0
      u8x8_gpio_Init(u8x8);
    3714:	47a8      	blx	r5
      u8x8_cad_Init(u8x8);
    3716:	2300      	movs	r3, #0
    3718:	68e5      	ldr	r5, [r4, #12]
    371a:	001a      	movs	r2, r3
    371c:	2114      	movs	r1, #20
    371e:	0020      	movs	r0, r4
    3720:	47a8      	blx	r5

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
    3722:	4d0e      	ldr	r5, [pc, #56]	; (375c <u8x8_d_helper_display_init+0x54>)
    3724:	0020      	movs	r0, r4
    3726:	2201      	movs	r2, #1
    3728:	214b      	movs	r1, #75	; 0x4b
    372a:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    372c:	6823      	ldr	r3, [r4, #0]
    372e:	0020      	movs	r0, r4
    3730:	791a      	ldrb	r2, [r3, #4]
    3732:	2129      	movs	r1, #41	; 0x29
    3734:	47a8      	blx	r5
      u8x8_gpio_SetReset(u8x8, 0);
    3736:	0020      	movs	r0, r4
    3738:	2200      	movs	r2, #0
    373a:	214b      	movs	r1, #75	; 0x4b
    373c:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    373e:	6823      	ldr	r3, [r4, #0]
    3740:	0020      	movs	r0, r4
    3742:	791a      	ldrb	r2, [r3, #4]
    3744:	2129      	movs	r1, #41	; 0x29
    3746:	47a8      	blx	r5
      u8x8_gpio_SetReset(u8x8, 1);
    3748:	0020      	movs	r0, r4
    374a:	2201      	movs	r2, #1
    374c:	214b      	movs	r1, #75	; 0x4b
    374e:	47a8      	blx	r5
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    3750:	6823      	ldr	r3, [r4, #0]
    3752:	2129      	movs	r1, #41	; 0x29
    3754:	795a      	ldrb	r2, [r3, #5]
    3756:	0020      	movs	r0, r4
    3758:	47a8      	blx	r5
}    
    375a:	bd70      	pop	{r4, r5, r6, pc}
    375c:	000038e5 	.word	0x000038e5

00003760 <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    3760:	b513      	push	{r0, r1, r4, lr}
  u8x8_tile_t tile;
  tile.x_pos = x;
    3762:	466c      	mov	r4, sp
  tile.y_pos = y;
  tile.cnt = cnt;
    3764:	7123      	strb	r3, [r4, #4]
  tile.tile_ptr = tile_ptr;
    3766:	9b04      	ldr	r3, [sp, #16]
  tile.x_pos = x;
    3768:	7161      	strb	r1, [r4, #5]
  tile.y_pos = y;
    376a:	71a2      	strb	r2, [r4, #6]
  tile.tile_ptr = tile_ptr;
    376c:	9300      	str	r3, [sp, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    376e:	6884      	ldr	r4, [r0, #8]
    3770:	466b      	mov	r3, sp
    3772:	2201      	movs	r2, #1
    3774:	210f      	movs	r1, #15
    3776:	47a0      	blx	r4
}
    3778:	bd16      	pop	{r1, r2, r4, pc}

0000377a <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    377a:	2300      	movs	r3, #0
{
    377c:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    377e:	001a      	movs	r2, r3
    3780:	6884      	ldr	r4, [r0, #8]
    3782:	2109      	movs	r1, #9
    3784:	47a0      	blx	r4
}
    3786:	bd10      	pop	{r4, pc}

00003788 <u8x8_InitDisplay>:

void u8x8_InitDisplay(u8x8_t *u8x8)
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);  
    3788:	2300      	movs	r3, #0
{
    378a:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);  
    378c:	001a      	movs	r2, r3
    378e:	6884      	ldr	r4, [r0, #8]
    3790:	210a      	movs	r1, #10
    3792:	47a0      	blx	r4
}
    3794:	bd10      	pop	{r4, pc}

00003796 <u8x8_SetPowerSave>:

void u8x8_SetPowerSave(u8x8_t *u8x8, uint8_t is_enable)
{
    3796:	b510      	push	{r4, lr}
    3798:	000a      	movs	r2, r1
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_POWER_SAVE, is_enable, NULL);  
    379a:	6884      	ldr	r4, [r0, #8]
    379c:	2300      	movs	r3, #0
    379e:	210b      	movs	r1, #11
    37a0:	47a0      	blx	r4
}
    37a2:	bd10      	pop	{r4, pc}

000037a4 <u8x8_RefreshDisplay>:
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
}

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    37a4:	2300      	movs	r3, #0
{
    37a6:	b510      	push	{r4, lr}
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    37a8:	001a      	movs	r2, r3
    37aa:	6884      	ldr	r4, [r0, #8]
    37ac:	2110      	movs	r1, #16
    37ae:	47a0      	blx	r4
}
    37b0:	bd10      	pop	{r4, pc}
	...

000037b4 <u8x8_d_ssd1306_sh1106_generic>:
  U8X8_END()             			/* end of sequence */
};


static uint8_t u8x8_d_ssd1306_sh1106_generic(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    37b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint8_t x, c;
  uint8_t *ptr;
  switch(msg)
    37b6:	390b      	subs	r1, #11
{
    37b8:	0004      	movs	r4, r0
    37ba:	0015      	movs	r5, r2
    37bc:	001e      	movs	r6, r3
  switch(msg)
    37be:	0008      	movs	r0, r1
    37c0:	2904      	cmp	r1, #4
    37c2:	d858      	bhi.n	3876 <u8x8_d_ssd1306_sh1106_generic+0xc2>
    37c4:	f004 fbcc 	bl	7f60 <__gnu_thumb1_case_uqi>
    37c8:	1e0d5703 	.word	0x1e0d5703
    37cc:	2d          	.byte	0x2d
    37cd:	00          	.byte	0x00
    37ce:	492b      	ldr	r1, [pc, #172]	; (387c <u8x8_d_ssd1306_sh1106_generic+0xc8>)
    37d0:	4b2b      	ldr	r3, [pc, #172]	; (3880 <u8x8_d_ssd1306_sh1106_generic+0xcc>)
      u8x8_d_helper_display_init(u8x8);
      u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_init_seq);    
      break;
    */
    case U8X8_MSG_DISPLAY_SET_POWER_SAVE:
      if ( arg_int == 0 )
    37d2:	2a00      	cmp	r2, #0
    37d4:	d103      	bne.n	37de <u8x8_d_ssd1306_sh1106_generic+0x2a>
	u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_powersave0_seq);
      else
	u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_powersave1_seq);
    37d6:	0020      	movs	r0, r4
    37d8:	4798      	blx	r3
      u8x8_cad_EndTransfer(u8x8);
      break;
    default:
      return 0;
  }
  return 1;
    37da:	2001      	movs	r0, #1
}
    37dc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_powersave1_seq);
    37de:	3105      	adds	r1, #5
    37e0:	e7f9      	b.n	37d6 <u8x8_d_ssd1306_sh1106_generic+0x22>
    37e2:	4926      	ldr	r1, [pc, #152]	; (387c <u8x8_d_ssd1306_sh1106_generic+0xc8>)
    37e4:	4b26      	ldr	r3, [pc, #152]	; (3880 <u8x8_d_ssd1306_sh1106_generic+0xcc>)
      if ( arg_int == 0 )
    37e6:	2a00      	cmp	r2, #0
    37e8:	d106      	bne.n	37f8 <u8x8_d_ssd1306_sh1106_generic+0x44>
	u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_flip0_seq);
    37ea:	310a      	adds	r1, #10
    37ec:	0020      	movs	r0, r4
    37ee:	4798      	blx	r3
	u8x8->x_offset = u8x8->display_info->default_x_offset;
    37f0:	6823      	ldr	r3, [r4, #0]
    37f2:	7c9b      	ldrb	r3, [r3, #18]
	u8x8->x_offset = u8x8->display_info->flipmode_x_offset;
    37f4:	77a3      	strb	r3, [r4, #30]
    37f6:	e7f0      	b.n	37da <u8x8_d_ssd1306_sh1106_generic+0x26>
	u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_flip1_seq);
    37f8:	3111      	adds	r1, #17
    37fa:	0020      	movs	r0, r4
    37fc:	4798      	blx	r3
	u8x8->x_offset = u8x8->display_info->flipmode_x_offset;
    37fe:	6823      	ldr	r3, [r4, #0]
    3800:	7cdb      	ldrb	r3, [r3, #19]
    3802:	e7f7      	b.n	37f4 <u8x8_d_ssd1306_sh1106_generic+0x40>
      u8x8_cad_StartTransfer(u8x8);
    3804:	4b1f      	ldr	r3, [pc, #124]	; (3884 <u8x8_d_ssd1306_sh1106_generic+0xd0>)
    3806:	0020      	movs	r0, r4
    3808:	4798      	blx	r3
      u8x8_cad_SendCmd(u8x8, 0x081 );
    380a:	2181      	movs	r1, #129	; 0x81
    380c:	4b1e      	ldr	r3, [pc, #120]	; (3888 <u8x8_d_ssd1306_sh1106_generic+0xd4>)
    380e:	0020      	movs	r0, r4
    3810:	4798      	blx	r3
      u8x8_cad_SendArg(u8x8, arg_int );	/* ssd1306 has range from 0 to 255 */
    3812:	0029      	movs	r1, r5
    3814:	0020      	movs	r0, r4
    3816:	4b1d      	ldr	r3, [pc, #116]	; (388c <u8x8_d_ssd1306_sh1106_generic+0xd8>)
    3818:	4798      	blx	r3
      u8x8_cad_EndTransfer(u8x8);
    381a:	0020      	movs	r0, r4
    381c:	4b1c      	ldr	r3, [pc, #112]	; (3890 <u8x8_d_ssd1306_sh1106_generic+0xdc>)
    381e:	4798      	blx	r3
    3820:	e7db      	b.n	37da <u8x8_d_ssd1306_sh1106_generic+0x26>
      u8x8_cad_StartTransfer(u8x8);
    3822:	4b18      	ldr	r3, [pc, #96]	; (3884 <u8x8_d_ssd1306_sh1106_generic+0xd0>)
    3824:	0020      	movs	r0, r4
    3826:	4798      	blx	r3
      x = ((u8x8_tile_t *)arg_ptr)->x_pos;    
    3828:	7971      	ldrb	r1, [r6, #5]
      x += u8x8->x_offset;
    382a:	7fa3      	ldrb	r3, [r4, #30]
      x *= 8;
    382c:	00c9      	lsls	r1, r1, #3
      x += u8x8->x_offset;
    382e:	18c9      	adds	r1, r1, r3
    3830:	b2cb      	uxtb	r3, r1
      u8x8_cad_SendCmd(u8x8, 0x040 );	/* set line offset to 0 */
    3832:	4f15      	ldr	r7, [pc, #84]	; (3888 <u8x8_d_ssd1306_sh1106_generic+0xd4>)
    3834:	2140      	movs	r1, #64	; 0x40
    3836:	0020      	movs	r0, r4
      x += u8x8->x_offset;
    3838:	9301      	str	r3, [sp, #4]
      u8x8_cad_SendCmd(u8x8, 0x040 );	/* set line offset to 0 */
    383a:	47b8      	blx	r7
      u8x8_cad_SendCmd(u8x8, 0x010 | (x>>4) );
    383c:	2110      	movs	r1, #16
    383e:	9b01      	ldr	r3, [sp, #4]
    3840:	0020      	movs	r0, r4
    3842:	091b      	lsrs	r3, r3, #4
    3844:	4319      	orrs	r1, r3
    3846:	47b8      	blx	r7
      u8x8_cad_SendArg(u8x8, 0x000 | ((x&15)));					/* probably wrong, should be SendCmd */
    3848:	210f      	movs	r1, #15
    384a:	9b01      	ldr	r3, [sp, #4]
    384c:	0020      	movs	r0, r4
    384e:	4019      	ands	r1, r3
    3850:	4f0e      	ldr	r7, [pc, #56]	; (388c <u8x8_d_ssd1306_sh1106_generic+0xd8>)
    3852:	47b8      	blx	r7
      u8x8_cad_SendArg(u8x8, 0x0b0 | (((u8x8_tile_t *)arg_ptr)->y_pos));	/* probably wrong, should be SendCmd */
    3854:	23b0      	movs	r3, #176	; 0xb0
    3856:	79b1      	ldrb	r1, [r6, #6]
    3858:	0020      	movs	r0, r4
    385a:	4319      	orrs	r1, r3
    385c:	47b8      	blx	r7
	u8x8_cad_SendData(u8x8, c*8, ptr); 	/* note: SendData can not handle more than 255 bytes */
    385e:	7931      	ldrb	r1, [r6, #4]
	arg_int--;
    3860:	3d01      	subs	r5, #1
	u8x8_cad_SendData(u8x8, c*8, ptr); 	/* note: SendData can not handle more than 255 bytes */
    3862:	00c9      	lsls	r1, r1, #3
    3864:	b2c9      	uxtb	r1, r1
    3866:	6832      	ldr	r2, [r6, #0]
    3868:	0020      	movs	r0, r4
    386a:	4b0a      	ldr	r3, [pc, #40]	; (3894 <u8x8_d_ssd1306_sh1106_generic+0xe0>)
	arg_int--;
    386c:	b2ed      	uxtb	r5, r5
	u8x8_cad_SendData(u8x8, c*8, ptr); 	/* note: SendData can not handle more than 255 bytes */
    386e:	4798      	blx	r3
      } while( arg_int > 0 );
    3870:	2d00      	cmp	r5, #0
    3872:	d1f4      	bne.n	385e <u8x8_d_ssd1306_sh1106_generic+0xaa>
    3874:	e7d1      	b.n	381a <u8x8_d_ssd1306_sh1106_generic+0x66>
      return 0;
    3876:	2000      	movs	r0, #0
    3878:	e7b0      	b.n	37dc <u8x8_d_ssd1306_sh1106_generic+0x28>
    387a:	46c0      	nop			; (mov r8, r8)
    387c:	0000a970 	.word	0x0000a970
    3880:	00003619 	.word	0x00003619
    3884:	000035fb 	.word	0x000035fb
    3888:	000035d1 	.word	0x000035d1
    388c:	000035df 	.word	0x000035df
    3890:	00003609 	.word	0x00003609
    3894:	000035ed 	.word	0x000035ed

00003898 <u8x8_d_sh1106_128x64_noname>:
  /* pixel_width = */ 128,
  /* pixel_height = */ 64
};

uint8_t u8x8_d_sh1106_128x64_noname(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    3898:	b570      	push	{r4, r5, r6, lr}
  if ( u8x8_d_ssd1306_sh1106_generic(u8x8, msg, arg_int, arg_ptr) != 0 )
    389a:	4e0c      	ldr	r6, [pc, #48]	; (38cc <u8x8_d_sh1106_128x64_noname+0x34>)
{
    389c:	0004      	movs	r4, r0
    389e:	000d      	movs	r5, r1
  if ( u8x8_d_ssd1306_sh1106_generic(u8x8, msg, arg_int, arg_ptr) != 0 )
    38a0:	47b0      	blx	r6
    38a2:	2800      	cmp	r0, #0
    38a4:	d10b      	bne.n	38be <u8x8_d_sh1106_128x64_noname+0x26>
    return 1;
  
  switch(msg)
    38a6:	2d09      	cmp	r5, #9
    38a8:	d00b      	beq.n	38c2 <u8x8_d_sh1106_128x64_noname+0x2a>
    38aa:	2d0a      	cmp	r5, #10
    38ac:	d108      	bne.n	38c0 <u8x8_d_sh1106_128x64_noname+0x28>
  {
    case U8X8_MSG_DISPLAY_INIT:
      u8x8_d_helper_display_init(u8x8);
    38ae:	0020      	movs	r0, r4
    38b0:	4b07      	ldr	r3, [pc, #28]	; (38d0 <u8x8_d_sh1106_128x64_noname+0x38>)
    38b2:	4798      	blx	r3
      /* maybe use a better init sequence */
      /* https://www.mikrocontroller.net/topic/431371 */
      /* the new sequence is added in the winstar constructor (see below), this is kept untouched */
      u8x8_cad_SendSequence(u8x8, u8x8_d_ssd1306_128x64_noname_init_seq);    
    38b4:	0020      	movs	r0, r4
    38b6:	4907      	ldr	r1, [pc, #28]	; (38d4 <u8x8_d_sh1106_128x64_noname+0x3c>)
    38b8:	4b07      	ldr	r3, [pc, #28]	; (38d8 <u8x8_d_sh1106_128x64_noname+0x40>)
    38ba:	3118      	adds	r1, #24
      break;
    case U8X8_MSG_DISPLAY_SETUP_MEMORY:
      u8x8_d_helper_display_setup_memory(u8x8, &u8x8_sh1106_128x64_noname_display_info);
    38bc:	4798      	blx	r3
    return 1;
    38be:	2001      	movs	r0, #1
    default:
      return 0;
  }
  return 1;
    
}
    38c0:	bd70      	pop	{r4, r5, r6, pc}
      u8x8_d_helper_display_setup_memory(u8x8, &u8x8_sh1106_128x64_noname_display_info);
    38c2:	4906      	ldr	r1, [pc, #24]	; (38dc <u8x8_d_sh1106_128x64_noname+0x44>)
    38c4:	0020      	movs	r0, r4
    38c6:	3154      	adds	r1, #84	; 0x54
    38c8:	4b05      	ldr	r3, [pc, #20]	; (38e0 <u8x8_d_sh1106_128x64_noname+0x48>)
    38ca:	e7f7      	b.n	38bc <u8x8_d_sh1106_128x64_noname+0x24>
    38cc:	000037b5 	.word	0x000037b5
    38d0:	00003709 	.word	0x00003709
    38d4:	0000a970 	.word	0x0000a970
    38d8:	00003619 	.word	0x00003619
    38dc:	0000a9f0 	.word	0x0000a9f0
    38e0:	00003701 	.word	0x00003701

000038e4 <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    38e4:	b510      	push	{r4, lr}
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    38e6:	2300      	movs	r3, #0
    38e8:	6944      	ldr	r4, [r0, #20]
    38ea:	47a0      	blx	r4
}
    38ec:	bd10      	pop	{r4, pc}

000038ee <u8x8_dummy_cb>:

uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
}
    38ee:	2000      	movs	r0, #0
    38f0:	4770      	bx	lr
	...

000038f4 <u8x8_SetupDefaults>:
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    u8x8->display_info = NULL;
    38f4:	2300      	movs	r3, #0
    u8x8->display_cb = u8x8_dummy_cb;
    38f6:	4a08      	ldr	r2, [pc, #32]	; (3918 <u8x8_SetupDefaults+0x24>)
    u8x8->cad_cb = u8x8_dummy_cb;
    u8x8->byte_cb = u8x8_dummy_cb;
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    u8x8->is_font_inverse_mode = 0;
    38f8:	77c3      	strb	r3, [r0, #31]
    u8x8->display_cb = u8x8_dummy_cb;
    38fa:	6082      	str	r2, [r0, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    38fc:	60c2      	str	r2, [r0, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    38fe:	6102      	str	r2, [r0, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    3900:	6142      	str	r2, [r0, #20]
    u8x8->device_address = 0;
    3902:	1cc2      	adds	r2, r0, #3
    u8x8->display_info = NULL;
    3904:	6003      	str	r3, [r0, #0]
    u8x8->device_address = 0;
    3906:	77d3      	strb	r3, [r2, #31]
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    3908:	1d02      	adds	r2, r0, #4
    390a:	77d3      	strb	r3, [r2, #31]
    u8x8->i2c_address = 255;
    390c:	1c42      	adds	r2, r0, #1
    390e:	33ff      	adds	r3, #255	; 0xff
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    3910:	3006      	adds	r0, #6
    u8x8->i2c_address = 255;
    3912:	77d3      	strb	r3, [r2, #31]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    3914:	77c3      	strb	r3, [r0, #31]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    3916:	4770      	bx	lr
    3918:	000038ef 	.word	0x000038ef

0000391c <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    391c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    391e:	0004      	movs	r4, r0
    3920:	000f      	movs	r7, r1
    3922:	0016      	movs	r6, r2
    3924:	001d      	movs	r5, r3
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    3926:	4b05      	ldr	r3, [pc, #20]	; (393c <u8x8_Setup+0x20>)
    3928:	4798      	blx	r3

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
  u8x8->cad_cb = cad_cb;
  u8x8->byte_cb = byte_cb;
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    392a:	9b06      	ldr	r3, [sp, #24]
  u8x8->display_cb = display_cb;
    392c:	60a7      	str	r7, [r4, #8]
  u8x8->cad_cb = cad_cb;
    392e:	60e6      	str	r6, [r4, #12]
  u8x8->byte_cb = byte_cb;
    3930:	6125      	str	r5, [r4, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    3932:	6163      	str	r3, [r4, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    3934:	0020      	movs	r0, r4
    3936:	4b02      	ldr	r3, [pc, #8]	; (3940 <u8x8_Setup+0x24>)
    3938:	4798      	blx	r3
}
    393a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    393c:	000038f5 	.word	0x000038f5
    3940:	0000377b 	.word	0x0000377b

00003944 <RTC_Handler>:

extern volatile bool alarmTriggered;

void RTC_Handler(void)
{
    alarmTriggered = true;
    3944:	2301      	movs	r3, #1
    3946:	4a02      	ldr	r2, [pc, #8]	; (3950 <RTC_Handler+0xc>)
    3948:	7013      	strb	r3, [r2, #0]
    RTC->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_ALARM0; // must clear flag at end
    394a:	4a02      	ldr	r2, [pc, #8]	; (3954 <RTC_Handler+0x10>)
    394c:	7213      	strb	r3, [r2, #8]
}
    394e:	4770      	bx	lr
    3950:	2000039a 	.word	0x2000039a
    3954:	40001400 	.word	0x40001400

00003958 <getTimeNow>:
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
}

/* Synchronise the CLOCK register for reading*/
inline void RTCreadRequest() {
    RTC->MODE2.READREQ.reg = RTC_READREQ_RREQ;
    3958:	4b0c      	ldr	r3, [pc, #48]	; (398c <getTimeNow+0x34>)
    395a:	4a0d      	ldr	r2, [pc, #52]	; (3990 <getTimeNow+0x38>)
    395c:	805a      	strh	r2, [r3, #2]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    395e:	7a9a      	ldrb	r2, [r3, #10]
    3960:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3962:	d1fc      	bne.n	395e <getTimeNow+0x6>

void getTimeNow(Time *now)
{
    RTCreadRequest();
    
    now->year   = (int8_t)RTC->MODE2.CLOCK.bit.YEAR;
    3964:	691a      	ldr	r2, [r3, #16]
    3966:	0e92      	lsrs	r2, r2, #26
    3968:	7002      	strb	r2, [r0, #0]
    now->month  = (int8_t)RTC->MODE2.CLOCK.bit.MONTH;
    396a:	691a      	ldr	r2, [r3, #16]
    396c:	0192      	lsls	r2, r2, #6
    396e:	0f12      	lsrs	r2, r2, #28
    3970:	7042      	strb	r2, [r0, #1]
    now->day    = (int8_t)RTC->MODE2.CLOCK.bit.DAY;
    3972:	691a      	ldr	r2, [r3, #16]
    3974:	0292      	lsls	r2, r2, #10
    3976:	0ed2      	lsrs	r2, r2, #27
    3978:	7082      	strb	r2, [r0, #2]
    now->hour   = (int8_t)RTC->MODE2.CLOCK.bit.HOUR;
    397a:	691a      	ldr	r2, [r3, #16]
    397c:	03d2      	lsls	r2, r2, #15
    397e:	0ed2      	lsrs	r2, r2, #27
    3980:	70c2      	strb	r2, [r0, #3]
    now->minute = (int8_t)RTC->MODE2.CLOCK.bit.MINUTE;
    3982:	691b      	ldr	r3, [r3, #16]
    3984:	051b      	lsls	r3, r3, #20
    3986:	0e9b      	lsrs	r3, r3, #26
    3988:	7103      	strb	r3, [r0, #4]
}
    398a:	4770      	bx	lr
    398c:	40001400 	.word	0x40001400
    3990:	ffff8000 	.word	0xffff8000

00003994 <getSeconds>:
    RTC->MODE2.READREQ.reg = RTC_READREQ_RREQ;
    3994:	4b04      	ldr	r3, [pc, #16]	; (39a8 <getSeconds+0x14>)
    3996:	4a05      	ldr	r2, [pc, #20]	; (39ac <getSeconds+0x18>)
    3998:	805a      	strh	r2, [r3, #2]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    399a:	7a9a      	ldrb	r2, [r3, #10]
    399c:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    399e:	d1fc      	bne.n	399a <getSeconds+0x6>

uint8_t getSeconds()
{
    RTCreadRequest();
    return RTC->MODE2.CLOCK.bit.SECOND;
    39a0:	6918      	ldr	r0, [r3, #16]
    39a2:	0680      	lsls	r0, r0, #26
    39a4:	0e80      	lsrs	r0, r0, #26
}
    39a6:	4770      	bx	lr
    39a8:	40001400 	.word	0x40001400
    39ac:	ffff8000 	.word	0xffff8000

000039b0 <getAlarmTimeNow>:
    return RTC->MODE2.Mode2Alarm[0].ALARM.bit.YEAR;
}

void getAlarmTimeNow(Time *date)
{    
    date->year   = (int8_t)RTC->MODE2.Mode2Alarm[0].ALARM.bit.YEAR;
    39b0:	4b0a      	ldr	r3, [pc, #40]	; (39dc <getAlarmTimeNow+0x2c>)
    39b2:	699a      	ldr	r2, [r3, #24]
    39b4:	0e92      	lsrs	r2, r2, #26
    39b6:	7002      	strb	r2, [r0, #0]
    date->month  = (int8_t)RTC->MODE2.Mode2Alarm[0].ALARM.bit.MONTH;
    39b8:	699a      	ldr	r2, [r3, #24]
    39ba:	0192      	lsls	r2, r2, #6
    39bc:	0f12      	lsrs	r2, r2, #28
    39be:	7042      	strb	r2, [r0, #1]
    date->day    = (int8_t)RTC->MODE2.Mode2Alarm[0].ALARM.bit.DAY;
    39c0:	699a      	ldr	r2, [r3, #24]
    39c2:	0292      	lsls	r2, r2, #10
    39c4:	0ed2      	lsrs	r2, r2, #27
    39c6:	7082      	strb	r2, [r0, #2]
    date->hour   = (int8_t)RTC->MODE2.Mode2Alarm[0].ALARM.bit.HOUR;
    39c8:	699a      	ldr	r2, [r3, #24]
    39ca:	03d2      	lsls	r2, r2, #15
    39cc:	0ed2      	lsrs	r2, r2, #27
    39ce:	70c2      	strb	r2, [r0, #3]
    date->minute = (int8_t)RTC->MODE2.Mode2Alarm[0].ALARM.bit.MINUTE;
    39d0:	699b      	ldr	r3, [r3, #24]
    39d2:	051b      	lsls	r3, r3, #20
    39d4:	0e9b      	lsrs	r3, r3, #26
    39d6:	7103      	strb	r3, [r0, #4]
}
    39d8:	4770      	bx	lr
    39da:	46c0      	nop			; (mov r8, r8)
    39dc:	40001400 	.word	0x40001400

000039e0 <get_days_in_month>:

int8_t get_days_in_month(Time *d)
{
    39e0:	2201      	movs	r2, #1
    if((d->year&0x3) == 0) { // leap year
    39e2:	7801      	ldrb	r1, [r0, #0]
{
    39e4:	0003      	movs	r3, r0
    39e6:	5682      	ldrsb	r2, [r0, r2]
        if(d->month==2) return 29; // february
    39e8:	201d      	movs	r0, #29
    if((d->year&0x3) == 0) { // leap year
    39ea:	0789      	lsls	r1, r1, #30
    39ec:	d000      	beq.n	39f0 <get_days_in_month+0x10>
        } else {
        if(d->month==2) return 28; // february
    39ee:	201c      	movs	r0, #28
    39f0:	2a02      	cmp	r2, #2
    39f2:	d00a      	beq.n	3a0a <get_days_in_month+0x2a>
    39f4:	785b      	ldrb	r3, [r3, #1]
        case 8: // august
        case 10: // october
        case 12: // december
        return 31;
    }
    return 30;
    39f6:	201e      	movs	r0, #30
    39f8:	2b0c      	cmp	r3, #12
    39fa:	d806      	bhi.n	3a0a <get_days_in_month+0x2a>
    39fc:	381d      	subs	r0, #29
    39fe:	4098      	lsls	r0, r3
    3a00:	4b02      	ldr	r3, [pc, #8]	; (3a0c <get_days_in_month+0x2c>)
    3a02:	4018      	ands	r0, r3
        return 31;
    3a04:	1e43      	subs	r3, r0, #1
    3a06:	4198      	sbcs	r0, r3
    3a08:	301e      	adds	r0, #30
}
    3a0a:	4770      	bx	lr
    3a0c:	000015aa 	.word	0x000015aa

00003a10 <get_days_in_year>:

int16_t get_days_in_year(Time *d)
{
    if((d->year&0x3) == 0) { // leap year
    3a10:	2303      	movs	r3, #3
    3a12:	7800      	ldrb	r0, [r0, #0]
    3a14:	4018      	ands	r0, r3
        return 366;
        } else {
        return 365;
    3a16:	4243      	negs	r3, r0
    3a18:	4158      	adcs	r0, r3
    3a1a:	306e      	adds	r0, #110	; 0x6e
    3a1c:	30ff      	adds	r0, #255	; 0xff
    }
}
    3a1e:	4770      	bx	lr

00003a20 <Days_left>:

int16_t Days_left(Time *a, Time *b, uint8_t want_hours_left, uint8_t want_minutes_left)
{
    3a20:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a22:	b08b      	sub	sp, #44	; 0x2c
    3a24:	9306      	str	r3, [sp, #24]
    int32_t days_year_a=0;
    int32_t days_year_b=0;
    int32_t minutes_delta;
    Time tmp;

    tmp.year = a->year;
    3a26:	2300      	movs	r3, #0
    3a28:	56c3      	ldrsb	r3, [r0, r3]
    3a2a:	ae08      	add	r6, sp, #32
    3a2c:	9302      	str	r3, [sp, #8]
    3a2e:	466b      	mov	r3, sp
    3a30:	7a1b      	ldrb	r3, [r3, #8]
{
    3a32:	0005      	movs	r5, r0
    tmp.year = a->year;
    3a34:	7033      	strb	r3, [r6, #0]
    for(i=2;i <= a->month;i++) {
    3a36:	2301      	movs	r3, #1
    int32_t d,minutes_a=0;
    3a38:	2700      	movs	r7, #0
    for(i=2;i <= a->month;i++) {
    3a3a:	2402      	movs	r4, #2
{
    3a3c:	9101      	str	r1, [sp, #4]
    3a3e:	9205      	str	r2, [sp, #20]
    for(i=2;i <= a->month;i++) {
    3a40:	56c3      	ldrsb	r3, [r0, r3]
    3a42:	9303      	str	r3, [sp, #12]
    3a44:	9b03      	ldr	r3, [sp, #12]
    3a46:	429c      	cmp	r4, r3
    3a48:	dd4c      	ble.n	3ae4 <Days_left+0xc4>
        tmp.month = i-1;
        d = get_days_in_month(&tmp);        
        minutes_a += (d * 1440);
    }
    minutes_a += (a->day * 1440);
    3a4a:	2002      	movs	r0, #2
    3a4c:	23b4      	movs	r3, #180	; 0xb4
    3a4e:	5628      	ldrsb	r0, [r5, r0]
    3a50:	00db      	lsls	r3, r3, #3
    3a52:	4358      	muls	r0, r3
    minutes_a += (a->hour * 60);
    3a54:	2203      	movs	r2, #3
    minutes_a += (a->day * 1440);
    3a56:	19c0      	adds	r0, r0, r7
    minutes_a += (a->hour * 60);
    3a58:	273c      	movs	r7, #60	; 0x3c
    3a5a:	56aa      	ldrsb	r2, [r5, r2]
    int32_t minutes_b=0;
    3a5c:	2600      	movs	r6, #0
    minutes_a += (a->hour * 60);
    3a5e:	4357      	muls	r7, r2
    3a60:	183f      	adds	r7, r7, r0
    minutes_a += a->minute;
    3a62:	2004      	movs	r0, #4

    tmp.year  = b->year;
    3a64:	9a01      	ldr	r2, [sp, #4]
    minutes_a += a->minute;
    3a66:	5628      	ldrsb	r0, [r5, r0]
    tmp.year  = b->year;
    3a68:	7812      	ldrb	r2, [r2, #0]
    for(i=2;i <= b->month;i++) {
    3a6a:	2402      	movs	r4, #2
    tmp.year  = b->year;
    3a6c:	b252      	sxtb	r2, r2
    3a6e:	9203      	str	r2, [sp, #12]
    3a70:	466a      	mov	r2, sp
    3a72:	7b12      	ldrb	r2, [r2, #12]
    3a74:	ad08      	add	r5, sp, #32
    3a76:	702a      	strb	r2, [r5, #0]
    for(i=2;i <= b->month;i++) {
    3a78:	9a01      	ldr	r2, [sp, #4]
    minutes_a += a->minute;
    3a7a:	19c7      	adds	r7, r0, r7
    for(i=2;i <= b->month;i++) {
    3a7c:	7852      	ldrb	r2, [r2, #1]
        tmp.month = i-1;
        d = get_days_in_month(&tmp);        
        minutes_b += (d * 1440);
    3a7e:	9307      	str	r3, [sp, #28]
    for(i=2;i <= b->month;i++) {
    3a80:	b252      	sxtb	r2, r2
    3a82:	9204      	str	r2, [sp, #16]
    3a84:	9b04      	ldr	r3, [sp, #16]
    3a86:	429c      	cmp	r4, r3
    3a88:	dd39      	ble.n	3afe <Days_left+0xde>
    }
    minutes_b += (b->day * 1440);
    3a8a:	20b4      	movs	r0, #180	; 0xb4
    3a8c:	9b01      	ldr	r3, [sp, #4]
    3a8e:	00c0      	lsls	r0, r0, #3
    3a90:	789b      	ldrb	r3, [r3, #2]
    int32_t days_year_a=0;
    3a92:	2400      	movs	r4, #0
    minutes_b += (b->day * 1440);
    3a94:	b25b      	sxtb	r3, r3
    3a96:	4358      	muls	r0, r3
    3a98:	1980      	adds	r0, r0, r6
    minutes_b += (b->hour * 60);
    3a9a:	263c      	movs	r6, #60	; 0x3c
    3a9c:	9b01      	ldr	r3, [sp, #4]
    minutes_b += b->minute;

    minutes_delta = minutes_a - minutes_b;    

    for(i=2;i <= a->year; i++) {
    3a9e:	2502      	movs	r5, #2
    minutes_b += (b->hour * 60);
    3aa0:	78db      	ldrb	r3, [r3, #3]
    3aa2:	b25b      	sxtb	r3, r3
    3aa4:	435e      	muls	r6, r3
    3aa6:	1836      	adds	r6, r6, r0
    minutes_b += b->minute;
    3aa8:	2004      	movs	r0, #4
    3aaa:	9b01      	ldr	r3, [sp, #4]
    3aac:	5618      	ldrsb	r0, [r3, r0]
    3aae:	1986      	adds	r6, r0, r6
    minutes_delta = minutes_a - minutes_b;    
    3ab0:	1bbb      	subs	r3, r7, r6
        tmp.year = i-1;
        days_year_a += get_days_in_year(&tmp);
    3ab2:	4e2a      	ldr	r6, [pc, #168]	; (3b5c <Days_left+0x13c>)
    minutes_delta = minutes_a - minutes_b;    
    3ab4:	9301      	str	r3, [sp, #4]
    for(i=2;i <= a->year; i++) {
    3ab6:	9b02      	ldr	r3, [sp, #8]
    3ab8:	429d      	cmp	r5, r3
    3aba:	dd2c      	ble.n	3b16 <Days_left+0xf6>
    3abc:	2600      	movs	r6, #0
    3abe:	2502      	movs	r5, #2
    }
    for(i=2;i <= b->year; i++) {
        tmp.year = i-1;
        days_year_b += get_days_in_year(&tmp);
    3ac0:	4f26      	ldr	r7, [pc, #152]	; (3b5c <Days_left+0x13c>)
    for(i=2;i <= b->year; i++) {
    3ac2:	9b03      	ldr	r3, [sp, #12]
    3ac4:	429d      	cmp	r5, r3
    3ac6:	dd30      	ble.n	3b2a <Days_left+0x10a>
    }    
    minutes_delta += (days_year_a-days_year_b)*1440;    
    3ac8:	21b4      	movs	r1, #180	; 0xb4
    3aca:	1ba0      	subs	r0, r4, r6
    3acc:	00c9      	lsls	r1, r1, #3
    3ace:	4348      	muls	r0, r1
    if(minutes_delta < 0) return -1;    
    3ad0:	9b01      	ldr	r3, [sp, #4]
    3ad2:	18c0      	adds	r0, r0, r3
    3ad4:	d43e      	bmi.n	3b54 <Days_left+0x134>

    if(want_hours_left) {
    3ad6:	9b05      	ldr	r3, [sp, #20]
    3ad8:	2b00      	cmp	r3, #0
    3ada:	d030      	beq.n	3b3e <Days_left+0x11e>
        return (int16_t)(minutes_delta/60); // return hours
    3adc:	213c      	movs	r1, #60	; 0x3c
            return 0x7fff;
        } else {
            return (int16_t)minutes_delta; // return minutes
        }
    } else {
        return (int16_t)(minutes_delta/1440); // return days
    3ade:	4b20      	ldr	r3, [pc, #128]	; (3b60 <Days_left+0x140>)
    3ae0:	4798      	blx	r3
    3ae2:	e033      	b.n	3b4c <Days_left+0x12c>
    3ae4:	b2e4      	uxtb	r4, r4
        tmp.month = i-1;
    3ae6:	1e63      	subs	r3, r4, #1
    3ae8:	7073      	strb	r3, [r6, #1]
        d = get_days_in_month(&tmp);        
    3aea:	0030      	movs	r0, r6
    3aec:	4b1d      	ldr	r3, [pc, #116]	; (3b64 <Days_left+0x144>)
    3aee:	4798      	blx	r3
        minutes_a += (d * 1440);
    3af0:	23b4      	movs	r3, #180	; 0xb4
    3af2:	00db      	lsls	r3, r3, #3
    3af4:	4358      	muls	r0, r3
    for(i=2;i <= a->month;i++) {
    3af6:	3401      	adds	r4, #1
        minutes_a += (d * 1440);
    3af8:	183f      	adds	r7, r7, r0
    for(i=2;i <= a->month;i++) {
    3afa:	b264      	sxtb	r4, r4
    3afc:	e7a2      	b.n	3a44 <Days_left+0x24>
    3afe:	b2e4      	uxtb	r4, r4
        tmp.month = i-1;
    3b00:	1e63      	subs	r3, r4, #1
    3b02:	706b      	strb	r3, [r5, #1]
        d = get_days_in_month(&tmp);        
    3b04:	0028      	movs	r0, r5
    3b06:	4b17      	ldr	r3, [pc, #92]	; (3b64 <Days_left+0x144>)
    3b08:	4798      	blx	r3
        minutes_b += (d * 1440);
    3b0a:	9b07      	ldr	r3, [sp, #28]
    for(i=2;i <= b->month;i++) {
    3b0c:	3401      	adds	r4, #1
        minutes_b += (d * 1440);
    3b0e:	4358      	muls	r0, r3
    for(i=2;i <= b->month;i++) {
    3b10:	b264      	sxtb	r4, r4
        minutes_b += (d * 1440);
    3b12:	1836      	adds	r6, r6, r0
    3b14:	e7b6      	b.n	3a84 <Days_left+0x64>
        tmp.year = i-1;
    3b16:	aa08      	add	r2, sp, #32
    3b18:	b2ed      	uxtb	r5, r5
    3b1a:	1e6b      	subs	r3, r5, #1
        days_year_a += get_days_in_year(&tmp);
    3b1c:	0010      	movs	r0, r2
        tmp.year = i-1;
    3b1e:	7013      	strb	r3, [r2, #0]
        days_year_a += get_days_in_year(&tmp);
    3b20:	47b0      	blx	r6
    for(i=2;i <= a->year; i++) {
    3b22:	3501      	adds	r5, #1
        days_year_a += get_days_in_year(&tmp);
    3b24:	1824      	adds	r4, r4, r0
    for(i=2;i <= a->year; i++) {
    3b26:	b26d      	sxtb	r5, r5
    3b28:	e7c5      	b.n	3ab6 <Days_left+0x96>
        tmp.year = i-1;
    3b2a:	aa08      	add	r2, sp, #32
    3b2c:	b2ed      	uxtb	r5, r5
    3b2e:	1e6b      	subs	r3, r5, #1
        days_year_b += get_days_in_year(&tmp);
    3b30:	0010      	movs	r0, r2
        tmp.year = i-1;
    3b32:	7013      	strb	r3, [r2, #0]
        days_year_b += get_days_in_year(&tmp);
    3b34:	47b8      	blx	r7
    for(i=2;i <= b->year; i++) {
    3b36:	3501      	adds	r5, #1
        days_year_b += get_days_in_year(&tmp);
    3b38:	1836      	adds	r6, r6, r0
    for(i=2;i <= b->year; i++) {
    3b3a:	b26d      	sxtb	r5, r5
    3b3c:	e7c1      	b.n	3ac2 <Days_left+0xa2>
    } else if(want_minutes_left) {
    3b3e:	9b06      	ldr	r3, [sp, #24]
    3b40:	2b00      	cmp	r3, #0
    3b42:	d0cc      	beq.n	3ade <Days_left+0xbe>
        if(minutes_delta > 0x7fff) {
    3b44:	4a08      	ldr	r2, [pc, #32]	; (3b68 <Days_left+0x148>)
            return 0x7fff;
    3b46:	0013      	movs	r3, r2
        if(minutes_delta > 0x7fff) {
    3b48:	4290      	cmp	r0, r2
    3b4a:	dc00      	bgt.n	3b4e <Days_left+0x12e>
        return (int16_t)(minutes_delta/1440); // return days
    3b4c:	b203      	sxth	r3, r0
    }
}
    3b4e:	0018      	movs	r0, r3
    3b50:	b00b      	add	sp, #44	; 0x2c
    3b52:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(minutes_delta < 0) return -1;    
    3b54:	2301      	movs	r3, #1
    3b56:	425b      	negs	r3, r3
    3b58:	e7f9      	b.n	3b4e <Days_left+0x12e>
    3b5a:	46c0      	nop			; (mov r8, r8)
    3b5c:	00003a11 	.word	0x00003a11
    3b60:	0000809d 	.word	0x0000809d
    3b64:	000039e1 	.word	0x000039e1
    3b68:	00007fff 	.word	0x00007fff

00003b6c <Time_add>:


void Time_add(Time *sum, Time *now, Time *credit)
{
    3b6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int8_t days_in_month;
    sum->minute = 0;
    3b6e:	2300      	movs	r3, #0
{
    3b70:	0015      	movs	r5, r2
    3b72:	0004      	movs	r4, r0
    3b74:	000e      	movs	r6, r1
    sum->minute = 0;
    3b76:	7103      	strb	r3, [r0, #4]
    sum->hour = 0;
    3b78:	70c3      	strb	r3, [r0, #3]
    sum->day = 0;
    3b7a:	7083      	strb	r3, [r0, #2]

    sum->year  = now->year  + credit->year;
    3b7c:	7812      	ldrb	r2, [r2, #0]
    3b7e:	780b      	ldrb	r3, [r1, #0]
    3b80:	189b      	adds	r3, r3, r2
    3b82:	7003      	strb	r3, [r0, #0]
    sum->month = now->month + credit->month;
    3b84:	784b      	ldrb	r3, [r1, #1]
    3b86:	786a      	ldrb	r2, [r5, #1]
    3b88:	189b      	adds	r3, r3, r2
    while(sum->month > 12) {
        sum->year++; sum->month-=12;        
    3b8a:	7063      	strb	r3, [r4, #1]
    while(sum->month > 12) {
    3b8c:	2301      	movs	r3, #1
    3b8e:	56e3      	ldrsb	r3, [r4, r3]
    3b90:	2b0c      	cmp	r3, #12
    3b92:	dc1f      	bgt.n	3bd4 <Time_add+0x68>
    }
    sum->minute += now->minute + credit->minute;
    3b94:	7933      	ldrb	r3, [r6, #4]
    3b96:	792a      	ldrb	r2, [r5, #4]
    3b98:	189b      	adds	r3, r3, r2
    3b9a:	7123      	strb	r3, [r4, #4]
    while(sum->minute > 59) {
    3b9c:	2104      	movs	r1, #4
    3b9e:	5661      	ldrsb	r1, [r4, r1]
    3ba0:	78e2      	ldrb	r2, [r4, #3]
    3ba2:	293b      	cmp	r1, #59	; 0x3b
    3ba4:	dc1b      	bgt.n	3bde <Time_add+0x72>
        sum->hour++; sum->minute-=60;        
    }
    sum->hour   += now->hour   + credit->hour;
    3ba6:	78f3      	ldrb	r3, [r6, #3]
    3ba8:	78e9      	ldrb	r1, [r5, #3]
    3baa:	185b      	adds	r3, r3, r1
    3bac:	189b      	adds	r3, r3, r2
    while(sum->hour > 23) {
        sum->day++; sum->hour-=24;        
    3bae:	70e3      	strb	r3, [r4, #3]
    while(sum->hour > 23) {
    3bb0:	2303      	movs	r3, #3
    3bb2:	56e3      	ldrsb	r3, [r4, r3]
    3bb4:	78a7      	ldrb	r7, [r4, #2]
    3bb6:	2b17      	cmp	r3, #23
    3bb8:	dc16      	bgt.n	3be8 <Time_add+0x7c>
    }
    days_in_month = get_days_in_month(sum);    
    3bba:	4b16      	ldr	r3, [pc, #88]	; (3c14 <Time_add+0xa8>)
    3bbc:	0020      	movs	r0, r4
    3bbe:	4798      	blx	r3

    sum->day    += now->day    + credit->day;    
    3bc0:	78b3      	ldrb	r3, [r6, #2]
    3bc2:	78aa      	ldrb	r2, [r5, #2]
    3bc4:	189b      	adds	r3, r3, r2
    3bc6:	19df      	adds	r7, r3, r7
    3bc8:	70a7      	strb	r7, [r4, #2]

    while(sum->day > days_in_month) {
    3bca:	2302      	movs	r3, #2
    3bcc:	56e3      	ldrsb	r3, [r4, r3]
    3bce:	4298      	cmp	r0, r3
    3bd0:	db0e      	blt.n	3bf0 <Time_add+0x84>
        sum->day-=days_in_month;
        sum->month++; if(sum->month > 12) { sum->year++; sum->month-=12; }
        days_in_month = get_days_in_month(sum);        
    }
}
    3bd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        sum->year++; sum->month-=12;        
    3bd4:	7822      	ldrb	r2, [r4, #0]
    3bd6:	3b0c      	subs	r3, #12
    3bd8:	3201      	adds	r2, #1
    3bda:	7022      	strb	r2, [r4, #0]
    3bdc:	e7d5      	b.n	3b8a <Time_add+0x1e>
        sum->hour++; sum->minute-=60;        
    3bde:	3201      	adds	r2, #1
    3be0:	393c      	subs	r1, #60	; 0x3c
    3be2:	70e2      	strb	r2, [r4, #3]
    3be4:	7121      	strb	r1, [r4, #4]
    3be6:	e7d9      	b.n	3b9c <Time_add+0x30>
        sum->day++; sum->hour-=24;        
    3be8:	3701      	adds	r7, #1
    3bea:	70a7      	strb	r7, [r4, #2]
    3bec:	3b18      	subs	r3, #24
    3bee:	e7de      	b.n	3bae <Time_add+0x42>
        sum->day-=days_in_month;
    3bf0:	1a1b      	subs	r3, r3, r0
    3bf2:	70a3      	strb	r3, [r4, #2]
        sum->month++; if(sum->month > 12) { sum->year++; sum->month-=12; }
    3bf4:	7863      	ldrb	r3, [r4, #1]
    3bf6:	1c5a      	adds	r2, r3, #1
    3bf8:	b252      	sxtb	r2, r2
    3bfa:	7062      	strb	r2, [r4, #1]
    3bfc:	2a0c      	cmp	r2, #12
    3bfe:	dd04      	ble.n	3c0a <Time_add+0x9e>
    3c00:	7822      	ldrb	r2, [r4, #0]
    3c02:	3b0b      	subs	r3, #11
    3c04:	3201      	adds	r2, #1
    3c06:	7022      	strb	r2, [r4, #0]
    3c08:	7063      	strb	r3, [r4, #1]
        days_in_month = get_days_in_month(sum);        
    3c0a:	0020      	movs	r0, r4
    3c0c:	4b01      	ldr	r3, [pc, #4]	; (3c14 <Time_add+0xa8>)
    3c0e:	4798      	blx	r3
    3c10:	e7db      	b.n	3bca <Time_add+0x5e>
    3c12:	46c0      	nop			; (mov r8, r8)
    3c14:	000039e1 	.word	0x000039e1

00003c18 <setSeconds>:

/*
 * Set Functions
 */
void setSeconds(uint8_t seconds)
{
    3c18:	b510      	push	{r4, lr}
    RTC->MODE2.CLOCK.bit.SECOND = seconds;
    3c1a:	243f      	movs	r4, #63	; 0x3f
    3c1c:	4b05      	ldr	r3, [pc, #20]	; (3c34 <setSeconds+0x1c>)
    3c1e:	0001      	movs	r1, r0
    3c20:	691a      	ldr	r2, [r3, #16]
    3c22:	4021      	ands	r1, r4
    3c24:	43a2      	bics	r2, r4
    3c26:	0010      	movs	r0, r2
    3c28:	4308      	orrs	r0, r1
    3c2a:	6118      	str	r0, [r3, #16]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3c2c:	7a9a      	ldrb	r2, [r3, #10]
    3c2e:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3c30:	d1fc      	bne.n	3c2c <setSeconds+0x14>
}
    3c32:	bd10      	pop	{r4, pc}
    3c34:	40001400 	.word	0x40001400

00003c38 <setMinutes>:

void setMinutes(uint8_t minutes)
{
    RTC->MODE2.CLOCK.bit.MINUTE = minutes;
    3c38:	213f      	movs	r1, #63	; 0x3f
    3c3a:	4b06      	ldr	r3, [pc, #24]	; (3c54 <setMinutes+0x1c>)
    3c3c:	4001      	ands	r1, r0
    3c3e:	691a      	ldr	r2, [r3, #16]
    3c40:	4805      	ldr	r0, [pc, #20]	; (3c58 <setMinutes+0x20>)
    3c42:	0189      	lsls	r1, r1, #6
    3c44:	4010      	ands	r0, r2
    3c46:	4308      	orrs	r0, r1
    3c48:	6118      	str	r0, [r3, #16]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3c4a:	7a9a      	ldrb	r2, [r3, #10]
    3c4c:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3c4e:	d1fc      	bne.n	3c4a <setMinutes+0x12>
}
    3c50:	4770      	bx	lr
    3c52:	46c0      	nop			; (mov r8, r8)
    3c54:	40001400 	.word	0x40001400
    3c58:	fffff03f 	.word	0xfffff03f

00003c5c <setHours>:

void setHours(uint8_t hours)
{
    RTC->MODE2.CLOCK.bit.HOUR = hours;
    3c5c:	211f      	movs	r1, #31
    3c5e:	4b06      	ldr	r3, [pc, #24]	; (3c78 <setHours+0x1c>)
    3c60:	4001      	ands	r1, r0
    3c62:	691a      	ldr	r2, [r3, #16]
    3c64:	4805      	ldr	r0, [pc, #20]	; (3c7c <setHours+0x20>)
    3c66:	0309      	lsls	r1, r1, #12
    3c68:	4010      	ands	r0, r2
    3c6a:	4308      	orrs	r0, r1
    3c6c:	6118      	str	r0, [r3, #16]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3c6e:	7a9a      	ldrb	r2, [r3, #10]
    3c70:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3c72:	d1fc      	bne.n	3c6e <setHours+0x12>
}
    3c74:	4770      	bx	lr
    3c76:	46c0      	nop			; (mov r8, r8)
    3c78:	40001400 	.word	0x40001400
    3c7c:	fffe0fff 	.word	0xfffe0fff

00003c80 <setTime>:

void setTime(uint8_t hours, uint8_t minutes, uint8_t seconds)
{
    3c80:	b570      	push	{r4, r5, r6, lr}
    3c82:	000d      	movs	r5, r1
    3c84:	0004      	movs	r4, r0
    setSeconds(seconds);
    3c86:	4b05      	ldr	r3, [pc, #20]	; (3c9c <setTime+0x1c>)
    3c88:	0010      	movs	r0, r2
    3c8a:	4798      	blx	r3
    setMinutes(minutes);
    3c8c:	0028      	movs	r0, r5
    3c8e:	4b04      	ldr	r3, [pc, #16]	; (3ca0 <setTime+0x20>)
    3c90:	4798      	blx	r3
    setHours(hours);
    3c92:	0020      	movs	r0, r4
    3c94:	4b03      	ldr	r3, [pc, #12]	; (3ca4 <setTime+0x24>)
    3c96:	4798      	blx	r3
}
    3c98:	bd70      	pop	{r4, r5, r6, pc}
    3c9a:	46c0      	nop			; (mov r8, r8)
    3c9c:	00003c19 	.word	0x00003c19
    3ca0:	00003c39 	.word	0x00003c39
    3ca4:	00003c5d 	.word	0x00003c5d

00003ca8 <setDay>:

void setDay(uint8_t day)
{
    RTC->MODE2.CLOCK.bit.DAY = day;
    3ca8:	211f      	movs	r1, #31
    3caa:	4b06      	ldr	r3, [pc, #24]	; (3cc4 <setDay+0x1c>)
    3cac:	4001      	ands	r1, r0
    3cae:	691a      	ldr	r2, [r3, #16]
    3cb0:	4805      	ldr	r0, [pc, #20]	; (3cc8 <setDay+0x20>)
    3cb2:	0449      	lsls	r1, r1, #17
    3cb4:	4010      	ands	r0, r2
    3cb6:	4308      	orrs	r0, r1
    3cb8:	6118      	str	r0, [r3, #16]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3cba:	7a9a      	ldrb	r2, [r3, #10]
    3cbc:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3cbe:	d1fc      	bne.n	3cba <setDay+0x12>
}
    3cc0:	4770      	bx	lr
    3cc2:	46c0      	nop			; (mov r8, r8)
    3cc4:	40001400 	.word	0x40001400
    3cc8:	ffc1ffff 	.word	0xffc1ffff

00003ccc <setMonth>:

void setMonth(uint8_t month)
{
    RTC->MODE2.CLOCK.bit.MONTH = month;
    3ccc:	210f      	movs	r1, #15
    3cce:	4b06      	ldr	r3, [pc, #24]	; (3ce8 <setMonth+0x1c>)
    3cd0:	4001      	ands	r1, r0
    3cd2:	691a      	ldr	r2, [r3, #16]
    3cd4:	4805      	ldr	r0, [pc, #20]	; (3cec <setMonth+0x20>)
    3cd6:	0589      	lsls	r1, r1, #22
    3cd8:	4010      	ands	r0, r2
    3cda:	4308      	orrs	r0, r1
    3cdc:	6118      	str	r0, [r3, #16]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3cde:	7a9a      	ldrb	r2, [r3, #10]
    3ce0:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3ce2:	d1fc      	bne.n	3cde <setMonth+0x12>
}
    3ce4:	4770      	bx	lr
    3ce6:	46c0      	nop			; (mov r8, r8)
    3ce8:	40001400 	.word	0x40001400
    3cec:	fc3fffff 	.word	0xfc3fffff

00003cf0 <setYear>:

void setYear(uint8_t year)
{
    RTC->MODE2.CLOCK.bit.YEAR = year;
    3cf0:	4a05      	ldr	r2, [pc, #20]	; (3d08 <setYear+0x18>)
    3cf2:	0681      	lsls	r1, r0, #26
    3cf4:	6913      	ldr	r3, [r2, #16]
    3cf6:	0198      	lsls	r0, r3, #6
    3cf8:	0980      	lsrs	r0, r0, #6
    3cfa:	4308      	orrs	r0, r1
    3cfc:	6110      	str	r0, [r2, #16]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3cfe:	7a93      	ldrb	r3, [r2, #10]
    3d00:	09db      	lsrs	r3, r3, #7
    while (RTCisSyncing());
    3d02:	d1fc      	bne.n	3cfe <setYear+0xe>
}
    3d04:	4770      	bx	lr
    3d06:	46c0      	nop			; (mov r8, r8)
    3d08:	40001400 	.word	0x40001400

00003d0c <setDate>:

void setDate(uint8_t day, uint8_t month, uint8_t year)
{
    3d0c:	b570      	push	{r4, r5, r6, lr}
    3d0e:	000d      	movs	r5, r1
    3d10:	0014      	movs	r4, r2
    setDay(day);
    3d12:	4b04      	ldr	r3, [pc, #16]	; (3d24 <setDate+0x18>)
    3d14:	4798      	blx	r3
    setMonth(month);
    3d16:	0028      	movs	r0, r5
    3d18:	4b03      	ldr	r3, [pc, #12]	; (3d28 <setDate+0x1c>)
    3d1a:	4798      	blx	r3
    setYear(year);
    3d1c:	0020      	movs	r0, r4
    3d1e:	4b03      	ldr	r3, [pc, #12]	; (3d2c <setDate+0x20>)
    3d20:	4798      	blx	r3
}
    3d22:	bd70      	pop	{r4, r5, r6, pc}
    3d24:	00003ca9 	.word	0x00003ca9
    3d28:	00003ccd 	.word	0x00003ccd
    3d2c:	00003cf1 	.word	0x00003cf1

00003d30 <setAlarmSeconds>:

void setAlarmSeconds(uint8_t seconds)
{
    3d30:	b510      	push	{r4, lr}
    RTC->MODE2.Mode2Alarm[0].ALARM.bit.SECOND = seconds;
    3d32:	243f      	movs	r4, #63	; 0x3f
    3d34:	4b05      	ldr	r3, [pc, #20]	; (3d4c <setAlarmSeconds+0x1c>)
    3d36:	0001      	movs	r1, r0
    3d38:	699a      	ldr	r2, [r3, #24]
    3d3a:	4021      	ands	r1, r4
    3d3c:	43a2      	bics	r2, r4
    3d3e:	0010      	movs	r0, r2
    3d40:	4308      	orrs	r0, r1
    3d42:	6198      	str	r0, [r3, #24]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3d44:	7a9a      	ldrb	r2, [r3, #10]
    3d46:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3d48:	d1fc      	bne.n	3d44 <setAlarmSeconds+0x14>
}
    3d4a:	bd10      	pop	{r4, pc}
    3d4c:	40001400 	.word	0x40001400

00003d50 <setAlarmMinutes>:

void setAlarmMinutes(uint8_t minutes)
{
    RTC->MODE2.Mode2Alarm[0].ALARM.bit.MINUTE = minutes;
    3d50:	213f      	movs	r1, #63	; 0x3f
    3d52:	4b06      	ldr	r3, [pc, #24]	; (3d6c <setAlarmMinutes+0x1c>)
    3d54:	4001      	ands	r1, r0
    3d56:	699a      	ldr	r2, [r3, #24]
    3d58:	4805      	ldr	r0, [pc, #20]	; (3d70 <setAlarmMinutes+0x20>)
    3d5a:	0189      	lsls	r1, r1, #6
    3d5c:	4010      	ands	r0, r2
    3d5e:	4308      	orrs	r0, r1
    3d60:	6198      	str	r0, [r3, #24]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3d62:	7a9a      	ldrb	r2, [r3, #10]
    3d64:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3d66:	d1fc      	bne.n	3d62 <setAlarmMinutes+0x12>
}
    3d68:	4770      	bx	lr
    3d6a:	46c0      	nop			; (mov r8, r8)
    3d6c:	40001400 	.word	0x40001400
    3d70:	fffff03f 	.word	0xfffff03f

00003d74 <setAlarmHours>:

void setAlarmHours(uint8_t hours)
{
    RTC->MODE2.Mode2Alarm[0].ALARM.bit.HOUR = hours;
    3d74:	211f      	movs	r1, #31
    3d76:	4b06      	ldr	r3, [pc, #24]	; (3d90 <setAlarmHours+0x1c>)
    3d78:	4001      	ands	r1, r0
    3d7a:	699a      	ldr	r2, [r3, #24]
    3d7c:	4805      	ldr	r0, [pc, #20]	; (3d94 <setAlarmHours+0x20>)
    3d7e:	0309      	lsls	r1, r1, #12
    3d80:	4010      	ands	r0, r2
    3d82:	4308      	orrs	r0, r1
    3d84:	6198      	str	r0, [r3, #24]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3d86:	7a9a      	ldrb	r2, [r3, #10]
    3d88:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3d8a:	d1fc      	bne.n	3d86 <setAlarmHours+0x12>
}
    3d8c:	4770      	bx	lr
    3d8e:	46c0      	nop			; (mov r8, r8)
    3d90:	40001400 	.word	0x40001400
    3d94:	fffe0fff 	.word	0xfffe0fff

00003d98 <setAlarmTime>:

void setAlarmTime(uint8_t hours, uint8_t minutes, uint8_t seconds)
{
    3d98:	b570      	push	{r4, r5, r6, lr}
    3d9a:	000d      	movs	r5, r1
    3d9c:	0004      	movs	r4, r0
    setAlarmSeconds(seconds);
    3d9e:	4b05      	ldr	r3, [pc, #20]	; (3db4 <setAlarmTime+0x1c>)
    3da0:	0010      	movs	r0, r2
    3da2:	4798      	blx	r3
    setAlarmMinutes(minutes);
    3da4:	0028      	movs	r0, r5
    3da6:	4b04      	ldr	r3, [pc, #16]	; (3db8 <setAlarmTime+0x20>)
    3da8:	4798      	blx	r3
    setAlarmHours(hours);
    3daa:	0020      	movs	r0, r4
    3dac:	4b03      	ldr	r3, [pc, #12]	; (3dbc <setAlarmTime+0x24>)
    3dae:	4798      	blx	r3
}
    3db0:	bd70      	pop	{r4, r5, r6, pc}
    3db2:	46c0      	nop			; (mov r8, r8)
    3db4:	00003d31 	.word	0x00003d31
    3db8:	00003d51 	.word	0x00003d51
    3dbc:	00003d75 	.word	0x00003d75

00003dc0 <setAlarmDay>:

void setAlarmDay(uint8_t day)
{
    RTC->MODE2.Mode2Alarm[0].ALARM.bit.DAY = day;
    3dc0:	211f      	movs	r1, #31
    3dc2:	4b06      	ldr	r3, [pc, #24]	; (3ddc <setAlarmDay+0x1c>)
    3dc4:	4001      	ands	r1, r0
    3dc6:	699a      	ldr	r2, [r3, #24]
    3dc8:	4805      	ldr	r0, [pc, #20]	; (3de0 <setAlarmDay+0x20>)
    3dca:	0449      	lsls	r1, r1, #17
    3dcc:	4010      	ands	r0, r2
    3dce:	4308      	orrs	r0, r1
    3dd0:	6198      	str	r0, [r3, #24]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3dd2:	7a9a      	ldrb	r2, [r3, #10]
    3dd4:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3dd6:	d1fc      	bne.n	3dd2 <setAlarmDay+0x12>
}
    3dd8:	4770      	bx	lr
    3dda:	46c0      	nop			; (mov r8, r8)
    3ddc:	40001400 	.word	0x40001400
    3de0:	ffc1ffff 	.word	0xffc1ffff

00003de4 <setAlarmMonth>:

void setAlarmMonth(uint8_t month)
{
    RTC->MODE2.Mode2Alarm[0].ALARM.bit.MONTH = month;
    3de4:	210f      	movs	r1, #15
    3de6:	4b06      	ldr	r3, [pc, #24]	; (3e00 <setAlarmMonth+0x1c>)
    3de8:	4001      	ands	r1, r0
    3dea:	699a      	ldr	r2, [r3, #24]
    3dec:	4805      	ldr	r0, [pc, #20]	; (3e04 <setAlarmMonth+0x20>)
    3dee:	0589      	lsls	r1, r1, #22
    3df0:	4010      	ands	r0, r2
    3df2:	4308      	orrs	r0, r1
    3df4:	6198      	str	r0, [r3, #24]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3df6:	7a9a      	ldrb	r2, [r3, #10]
    3df8:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3dfa:	d1fc      	bne.n	3df6 <setAlarmMonth+0x12>
}
    3dfc:	4770      	bx	lr
    3dfe:	46c0      	nop			; (mov r8, r8)
    3e00:	40001400 	.word	0x40001400
    3e04:	fc3fffff 	.word	0xfc3fffff

00003e08 <setAlarmYear>:

void setAlarmYear(uint8_t year)
{
    RTC->MODE2.Mode2Alarm[0].ALARM.bit.YEAR = year;
    3e08:	4a05      	ldr	r2, [pc, #20]	; (3e20 <setAlarmYear+0x18>)
    3e0a:	0681      	lsls	r1, r0, #26
    3e0c:	6993      	ldr	r3, [r2, #24]
    3e0e:	0198      	lsls	r0, r3, #6
    3e10:	0980      	lsrs	r0, r0, #6
    3e12:	4308      	orrs	r0, r1
    3e14:	6190      	str	r0, [r2, #24]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3e16:	7a93      	ldrb	r3, [r2, #10]
    3e18:	09db      	lsrs	r3, r3, #7
    while (RTCisSyncing());
    3e1a:	d1fc      	bne.n	3e16 <setAlarmYear+0xe>
}
    3e1c:	4770      	bx	lr
    3e1e:	46c0      	nop			; (mov r8, r8)
    3e20:	40001400 	.word	0x40001400

00003e24 <setAlarmDate>:

void setAlarmDate(uint8_t day, uint8_t month, uint8_t year)
{
    3e24:	b570      	push	{r4, r5, r6, lr}
    3e26:	000d      	movs	r5, r1
    3e28:	0014      	movs	r4, r2
    setAlarmDay(day);
    3e2a:	4b04      	ldr	r3, [pc, #16]	; (3e3c <setAlarmDate+0x18>)
    3e2c:	4798      	blx	r3
    setAlarmMonth(month);
    3e2e:	0028      	movs	r0, r5
    3e30:	4b03      	ldr	r3, [pc, #12]	; (3e40 <setAlarmDate+0x1c>)
    3e32:	4798      	blx	r3
    setAlarmYear(year);
    3e34:	0020      	movs	r0, r4
    3e36:	4b03      	ldr	r3, [pc, #12]	; (3e44 <setAlarmDate+0x20>)
    3e38:	4798      	blx	r3
}
    3e3a:	bd70      	pop	{r4, r5, r6, pc}
    3e3c:	00003dc1 	.word	0x00003dc1
    3e40:	00003de5 	.word	0x00003de5
    3e44:	00003e09 	.word	0x00003e09

00003e48 <enableAlarm>:
      MATCH_YYMMDDHHMMSS = RTC_MODE2_MASK_SEL_YYMMDDHHMMSS_Val  // Once, on a specific date and a specific time
  };
  */

void enableAlarm(uint8_t match)
{
    3e48:	b510      	push	{r4, lr}
    RTC->MODE2.Mode2Alarm[0].MASK.bit.SEL = match;
    3e4a:	2407      	movs	r4, #7
    3e4c:	4b05      	ldr	r3, [pc, #20]	; (3e64 <enableAlarm+0x1c>)
    3e4e:	0001      	movs	r1, r0
    3e50:	7f1a      	ldrb	r2, [r3, #28]
    3e52:	4021      	ands	r1, r4
    3e54:	43a2      	bics	r2, r4
    3e56:	0010      	movs	r0, r2
    3e58:	4308      	orrs	r0, r1
    3e5a:	7718      	strb	r0, [r3, #28]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3e5c:	7a9a      	ldrb	r2, [r3, #10]
    3e5e:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3e60:	d1fc      	bne.n	3e5c <enableAlarm+0x14>
}
    3e62:	bd10      	pop	{r4, pc}
    3e64:	40001400 	.word	0x40001400

00003e68 <disableAlarm>:

void disableAlarm()
{
    RTC->MODE2.Mode2Alarm[0].MASK.bit.SEL = 0x00;
    3e68:	2107      	movs	r1, #7
    3e6a:	4b04      	ldr	r3, [pc, #16]	; (3e7c <disableAlarm+0x14>)
    3e6c:	7f1a      	ldrb	r2, [r3, #28]
    3e6e:	438a      	bics	r2, r1
    3e70:	771a      	strb	r2, [r3, #28]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3e72:	7a9a      	ldrb	r2, [r3, #10]
    3e74:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3e76:	d1fc      	bne.n	3e72 <disableAlarm+0xa>
}
    3e78:	4770      	bx	lr
    3e7a:	46c0      	nop			; (mov r8, r8)
    3e7c:	40001400 	.word	0x40001400

00003e80 <RTCdisable>:

void RTCdisable()
{
    RTC->MODE2.CTRL.reg &= ~RTC_MODE2_CTRL_ENABLE; // disable RTC
    3e80:	2102      	movs	r1, #2
    3e82:	4b04      	ldr	r3, [pc, #16]	; (3e94 <RTCdisable+0x14>)
    3e84:	881a      	ldrh	r2, [r3, #0]
    3e86:	438a      	bics	r2, r1
    3e88:	801a      	strh	r2, [r3, #0]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3e8a:	7a9a      	ldrb	r2, [r3, #10]
    3e8c:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3e8e:	d1fc      	bne.n	3e8a <RTCdisable+0xa>
}
    3e90:	4770      	bx	lr
    3e92:	46c0      	nop			; (mov r8, r8)
    3e94:	40001400 	.word	0x40001400

00003e98 <RTCenable>:

void RTCenable()
{
    RTC->MODE2.CTRL.reg |= RTC_MODE2_CTRL_ENABLE; // enable RTC
    3e98:	2202      	movs	r2, #2
    3e9a:	4b04      	ldr	r3, [pc, #16]	; (3eac <RTCenable+0x14>)
    3e9c:	8819      	ldrh	r1, [r3, #0]
    3e9e:	430a      	orrs	r2, r1
    3ea0:	801a      	strh	r2, [r3, #0]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3ea2:	7a9a      	ldrb	r2, [r3, #10]
    3ea4:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3ea6:	d1fc      	bne.n	3ea2 <RTCenable+0xa>
}
    3ea8:	4770      	bx	lr
    3eaa:	46c0      	nop			; (mov r8, r8)
    3eac:	40001400 	.word	0x40001400

00003eb0 <RTCreset>:

void RTCreset()
{
    RTC->MODE2.CTRL.reg |= RTC_MODE2_CTRL_SWRST; // software reset
    3eb0:	2201      	movs	r2, #1
    3eb2:	4b04      	ldr	r3, [pc, #16]	; (3ec4 <RTCreset+0x14>)
    3eb4:	8819      	ldrh	r1, [r3, #0]
    3eb6:	430a      	orrs	r2, r1
    3eb8:	801a      	strh	r2, [r3, #0]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3eba:	7a9a      	ldrb	r2, [r3, #10]
    3ebc:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3ebe:	d1fc      	bne.n	3eba <RTCreset+0xa>
}
    3ec0:	4770      	bx	lr
    3ec2:	46c0      	nop			; (mov r8, r8)
    3ec4:	40001400 	.word	0x40001400

00003ec8 <RTCresetRemove>:
void RTCresetRemove()
{
    RTC->MODE2.CTRL.reg &= ~RTC_MODE2_CTRL_SWRST; // software reset remove
    3ec8:	2101      	movs	r1, #1
    3eca:	4b04      	ldr	r3, [pc, #16]	; (3edc <RTCresetRemove+0x14>)
    3ecc:	881a      	ldrh	r2, [r3, #0]
    3ece:	438a      	bics	r2, r1
    3ed0:	801a      	strh	r2, [r3, #0]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3ed2:	7a9a      	ldrb	r2, [r3, #10]
    3ed4:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3ed6:	d1fc      	bne.n	3ed2 <RTCresetRemove+0xa>
}
    3ed8:	4770      	bx	lr
    3eda:	46c0      	nop			; (mov r8, r8)
    3edc:	40001400 	.word	0x40001400

00003ee0 <rtc_initialize>:
}

void rtc_initialize(void)
{
    uint16_t tmp_reg = 0;
    PM->APBAMASK.reg |= PM_APBAMASK_RTC; // turn on digital interface clock
    3ee0:	2320      	movs	r3, #32
{
    3ee2:	b510      	push	{r4, lr}
    PM->APBAMASK.reg |= PM_APBAMASK_RTC; // turn on digital interface clock
    3ee4:	4a1e      	ldr	r2, [pc, #120]	; (3f60 <rtc_initialize+0x80>)
    3ee6:	6991      	ldr	r1, [r2, #24]
    3ee8:	430b      	orrs	r3, r1
    3eea:	6193      	str	r3, [r2, #24]
    
#if (MASTER_PCB_v32==1)
    SYSCTRL->XOSC32K.reg = //SYSCTRL_XOSC32K_ONDEMAND |
    3eec:	4b1d      	ldr	r3, [pc, #116]	; (3f64 <rtc_initialize+0x84>)
    3eee:	4a1e      	ldr	r2, [pc, #120]	; (3f68 <rtc_initialize+0x88>)
    3ef0:	829a      	strh	r2, [r3, #20]
        SYSCTRL_XOSC32K_RUNSTDBY |
        SYSCTRL_XOSC32K_EN32K |
        SYSCTRL_XOSC32K_XTALEN |
        SYSCTRL_XOSC32K_STARTUP(6);
    SYSCTRL->XOSC32K.bit.ENABLE = 1;    
    3ef2:	2202      	movs	r2, #2
    3ef4:	8a99      	ldrh	r1, [r3, #20]
    3ef6:	430a      	orrs	r2, r1
    3ef8:	829a      	strh	r2, [r3, #20]
    SYSCTRL->OSC32K.bit.ENABLE = 1;
    //while((SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) == 0);
#endif      
   
    /* Attach peripheral clock to 32k oscillator */
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(2)|GCLK_GENDIV_DIV(4);// divided by: 2^(GENDIV.DIV+1)=32
    3efa:	4b1c      	ldr	r3, [pc, #112]	; (3f6c <rtc_initialize+0x8c>)
    3efc:	4a1c      	ldr	r2, [pc, #112]	; (3f70 <rtc_initialize+0x90>)
    3efe:	609a      	str	r2, [r3, #8]
    while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
    3f00:	785a      	ldrb	r2, [r3, #1]
    3f02:	b252      	sxtb	r2, r2
    3f04:	2a00      	cmp	r2, #0
    3f06:	dbfb      	blt.n	3f00 <rtc_initialize+0x20>
    
#if (MASTER_PCB_v32==1)
    GCLK->GENCTRL.reg = (GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_XOSC32K | GCLK_GENCTRL_ID(2) | GCLK_GENCTRL_DIVSEL );
    3f08:	4a1a      	ldr	r2, [pc, #104]	; (3f74 <rtc_initialize+0x94>)
    3f0a:	605a      	str	r2, [r3, #4]
#elif (MASTER_PCB_v32==0)
    GCLK->GENCTRL.reg = (GCLK_GENCTRL_GENEN | GCLK_GENCTRL_SRC_OSC32K | GCLK_GENCTRL_ID(2) | GCLK_GENCTRL_DIVSEL );
#endif
    while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
    3f0c:	785a      	ldrb	r2, [r3, #1]
    3f0e:	b252      	sxtb	r2, r2
    3f10:	2a00      	cmp	r2, #0
    3f12:	dbfb      	blt.n	3f0c <rtc_initialize+0x2c>
    GCLK->CLKCTRL.reg = (uint32_t)((GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK2 | (RTC_GCLK_ID << GCLK_CLKCTRL_ID_Pos)));
    3f14:	4a18      	ldr	r2, [pc, #96]	; (3f78 <rtc_initialize+0x98>)
    3f16:	805a      	strh	r2, [r3, #2]
    while (GCLK->STATUS.bit.SYNCBUSY);       
    3f18:	785a      	ldrb	r2, [r3, #1]
    3f1a:	09d2      	lsrs	r2, r2, #7
    3f1c:	d1fc      	bne.n	3f18 <rtc_initialize+0x38>
    
    RTCdisable();
    3f1e:	4b17      	ldr	r3, [pc, #92]	; (3f7c <rtc_initialize+0x9c>)
    3f20:	4798      	blx	r3
    RTCreset();
    3f22:	4b17      	ldr	r3, [pc, #92]	; (3f80 <rtc_initialize+0xa0>)
    3f24:	4798      	blx	r3
    tmp_reg |= RTC_MODE2_CTRL_MODE_CLOCK; // set clock operating mode
    tmp_reg |= RTC_MODE2_CTRL_PRESCALER_DIV1024; // set prescaler to 1024 for MODE2
    tmp_reg &= ~RTC_MODE2_CTRL_MATCHCLR; // disable clear on match    
    //According to the datasheet RTC_MODE2_CTRL_CLKREP = 0 for 24h
    tmp_reg &= ~RTC_MODE2_CTRL_CLKREP; // 24h time representation
    RTC->MODE2.READREQ.reg &= ~RTC_READREQ_RCONT; // disable continuously mode
    3f26:	4b17      	ldr	r3, [pc, #92]	; (3f84 <rtc_initialize+0xa4>)
    3f28:	4917      	ldr	r1, [pc, #92]	; (3f88 <rtc_initialize+0xa8>)
    3f2a:	885a      	ldrh	r2, [r3, #2]
    3f2c:	400a      	ands	r2, r1
    3f2e:	805a      	strh	r2, [r3, #2]
    RTC->MODE2.CTRL.reg = tmp_reg;
    3f30:	4a16      	ldr	r2, [pc, #88]	; (3f8c <rtc_initialize+0xac>)
    3f32:	801a      	strh	r2, [r3, #0]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3f34:	7a9a      	ldrb	r2, [r3, #10]
    3f36:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3f38:	d1fc      	bne.n	3f34 <rtc_initialize+0x54>
    3f3a:	2108      	movs	r1, #8
    3f3c:	4a14      	ldr	r2, [pc, #80]	; (3f90 <rtc_initialize+0xb0>)
    3f3e:	6011      	str	r1, [r2, #0]
    NVIC_EnableIRQ(RTC_IRQn); // enable RTC interrupt 
    //NVIC_SetPriority(RTC_IRQn, 0x00);
    RTC->MODE2.INTENSET.reg |= RTC_MODE2_INTENSET_ALARM0; // enable alarm interrupt
    3f40:	2201      	movs	r2, #1
    3f42:	79d9      	ldrb	r1, [r3, #7]
    3f44:	430a      	orrs	r2, r1
    RTC->MODE2.Mode2Alarm[0].MASK.bit.SEL = RTC_MODE2_MASK_SEL_OFF_Val; // default alarm match is off (disabled)    
    3f46:	2107      	movs	r1, #7
    RTC->MODE2.INTENSET.reg |= RTC_MODE2_INTENSET_ALARM0; // enable alarm interrupt
    3f48:	71da      	strb	r2, [r3, #7]
    RTC->MODE2.Mode2Alarm[0].MASK.bit.SEL = RTC_MODE2_MASK_SEL_OFF_Val; // default alarm match is off (disabled)    
    3f4a:	7f1a      	ldrb	r2, [r3, #28]
    3f4c:	438a      	bics	r2, r1
    3f4e:	771a      	strb	r2, [r3, #28]
    return (RTC->MODE2.STATUS.bit.SYNCBUSY);
    3f50:	7a9a      	ldrb	r2, [r3, #10]
    3f52:	09d2      	lsrs	r2, r2, #7
    while (RTCisSyncing());
    3f54:	d1fc      	bne.n	3f50 <rtc_initialize+0x70>
    RTCenable();
    3f56:	4b0f      	ldr	r3, [pc, #60]	; (3f94 <rtc_initialize+0xb4>)
    3f58:	4798      	blx	r3
    RTCresetRemove();
    3f5a:	4b0f      	ldr	r3, [pc, #60]	; (3f98 <rtc_initialize+0xb8>)
    3f5c:	4798      	blx	r3
}
    3f5e:	bd10      	pop	{r4, pc}
    3f60:	40000400 	.word	0x40000400
    3f64:	40000800 	.word	0x40000800
    3f68:	0000064c 	.word	0x0000064c
    3f6c:	40000c00 	.word	0x40000c00
    3f70:	00000402 	.word	0x00000402
    3f74:	00110502 	.word	0x00110502
    3f78:	00004202 	.word	0x00004202
    3f7c:	00003e81 	.word	0x00003e81
    3f80:	00003eb1 	.word	0x00003eb1
    3f84:	40001400 	.word	0x40001400
    3f88:	ffffbfff 	.word	0xffffbfff
    3f8c:	00000a08 	.word	0x00000a08
    3f90:	e000e100 	.word	0xe000e100
    3f94:	00003e99 	.word	0x00003e99
    3f98:	00003ec9 	.word	0x00003ec9

00003f9c <sysstate_to_str>:
char * sysstate_status_to_str(unsigned char sysstate)
{
    if(sysstate&0x80) return("OK "); else return("XX ");
}
char * sysstate_to_str(unsigned char sysstate)
{
    3f9c:	230f      	movs	r3, #15
    3f9e:	4003      	ands	r3, r0
    3fa0:	4803      	ldr	r0, [pc, #12]	; (3fb0 <sysstate_to_str+0x14>)
    3fa2:	2b03      	cmp	r3, #3
    3fa4:	d803      	bhi.n	3fae <sysstate_to_str+0x12>
    3fa6:	4803      	ldr	r0, [pc, #12]	; (3fb4 <sysstate_to_str+0x18>)
    3fa8:	009b      	lsls	r3, r3, #2
    3faa:	18c3      	adds	r3, r0, r3
    3fac:	6918      	ldr	r0, [r3, #16]
      case 3: 
        return("ERROR ");
      default: 
        return("??????");
    }
}
    3fae:	4770      	bx	lr
    3fb0:	0000aac9 	.word	0x0000aac9
    3fb4:	0000aa8c 	.word	0x0000aa8c

00003fb8 <scc_init>:
    return (short)v;
}

void scc_init(uint8_t onoff)
{
    scc_do_probe=onoff;
    3fb8:	4b01      	ldr	r3, [pc, #4]	; (3fc0 <scc_init+0x8>)
    3fba:	7018      	strb	r0, [r3, #0]
}
    3fbc:	4770      	bx	lr
    3fbe:	46c0      	nop			; (mov r8, r8)
    3fc0:	2000052a 	.word	0x2000052a

00003fc4 <scc_monitor>:
    unsigned char checksum,checksum_chk;
    int8_t step;
    unsigned short tmp_adc;    
    unsigned short day_meter,minute_meter;

    if(s>(MAX_NOF_SCC-1)) return 0;
    3fc4:	2300      	movs	r3, #0
{
    3fc6:	b5f0      	push	{r4, r5, r6, r7, lr}
    3fc8:	b08b      	sub	sp, #44	; 0x2c
    3fca:	0004      	movs	r4, r0
    if(s>(MAX_NOF_SCC-1)) return 0;
    3fcc:	9302      	str	r3, [sp, #8]
    3fce:	2803      	cmp	r0, #3
    3fd0:	d900      	bls.n	3fd4 <scc_monitor+0x10>
    3fd2:	e116      	b.n	4202 <scc_monitor+0x23e>
    uart_print(0,"scc_monitor[%d]=0x%x\n\r",s,scc_i2c_addr[s]);
    3fd4:	4fa4      	ldr	r7, [pc, #656]	; (4268 <scc_monitor+0x2a4>)
    3fd6:	0002      	movs	r2, r0
    3fd8:	1c7b      	adds	r3, r7, #1
    3fda:	5c1b      	ldrb	r3, [r3, r0]
    3fdc:	49a3      	ldr	r1, [pc, #652]	; (426c <scc_monitor+0x2a8>)
    3fde:	2000      	movs	r0, #0
    3fe0:	4da3      	ldr	r5, [pc, #652]	; (4270 <scc_monitor+0x2ac>)
    3fe2:	47a8      	blx	r5

    if(scc_errors>5) { 
    3fe4:	797b      	ldrb	r3, [r7, #5]
    3fe6:	2b05      	cmp	r3, #5
    3fe8:	d907      	bls.n	3ffa <scc_monitor+0x36>
        scc_errors=0; 
    3fea:	466b      	mov	r3, sp
    3fec:	7a1b      	ldrb	r3, [r3, #8]
    3fee:	717b      	strb	r3, [r7, #5]
        i2c_reset();
    3ff0:	4ba0      	ldr	r3, [pc, #640]	; (4274 <scc_monitor+0x2b0>)
    3ff2:	4798      	blx	r3
        delay_ms(20);
    3ff4:	2014      	movs	r0, #20
    3ff6:	4ba0      	ldr	r3, [pc, #640]	; (4278 <scc_monitor+0x2b4>)
    3ff8:	4798      	blx	r3
    }
        
    sysval.watchdog=0;
    3ffa:	2200      	movs	r2, #0
    3ffc:	4b9f      	ldr	r3, [pc, #636]	; (427c <scc_monitor+0x2b8>)
    
    i2c_sla=scc_i2c_addr[s];
    memset(i2c_data,0,16);
    3ffe:	ad06      	add	r5, sp, #24
    sysval.watchdog=0;
    4000:	751a      	strb	r2, [r3, #20]
    i2c_sla=scc_i2c_addr[s];
    4002:	1c7b      	adds	r3, r7, #1
    4004:	5d1b      	ldrb	r3, [r3, r4]
    memset(i2c_data,0,16);
    4006:	2210      	movs	r2, #16
    i2c_sla=scc_i2c_addr[s];
    4008:	9302      	str	r3, [sp, #8]
    memset(i2c_data,0,16);
    400a:	2100      	movs	r1, #0
    400c:	4b9c      	ldr	r3, [pc, #624]	; (4280 <scc_monitor+0x2bc>)
    400e:	0028      	movs	r0, r5
    4010:	4798      	blx	r3
    sysval.scc_sysstate[s]&=0x7f;
    4012:	227f      	movs	r2, #127	; 0x7f
    4014:	4b99      	ldr	r3, [pc, #612]	; (427c <scc_monitor+0x2b8>)
    i2c_cmd[0]=I2C_CMD_STAT_WDT;
    4016:	a905      	add	r1, sp, #20
    sysval.scc_sysstate[s]&=0x7f;
    4018:	191b      	adds	r3, r3, r4
    401a:	332d      	adds	r3, #45	; 0x2d
    401c:	9303      	str	r3, [sp, #12]
    401e:	781b      	ldrb	r3, [r3, #0]
    i2c_cmd[1]=scc_loadstate;
    if(i2c_transact(i2c_sla,i2c_cmd,2,i2c_data,16) >= 0) {
    4020:	9802      	ldr	r0, [sp, #8]
    sysval.scc_sysstate[s]&=0x7f;
    4022:	4013      	ands	r3, r2
    4024:	9a03      	ldr	r2, [sp, #12]
    if(i2c_transact(i2c_sla,i2c_cmd,2,i2c_data,16) >= 0) {
    4026:	4e97      	ldr	r6, [pc, #604]	; (4284 <scc_monitor+0x2c0>)
    sysval.scc_sysstate[s]&=0x7f;
    4028:	7013      	strb	r3, [r2, #0]
    i2c_cmd[0]=I2C_CMD_STAT_WDT;
    402a:	23a7      	movs	r3, #167	; 0xa7
    402c:	700b      	strb	r3, [r1, #0]
    i2c_cmd[1]=scc_loadstate;
    402e:	79bb      	ldrb	r3, [r7, #6]
    if(i2c_transact(i2c_sla,i2c_cmd,2,i2c_data,16) >= 0) {
    4030:	2202      	movs	r2, #2
    i2c_cmd[1]=scc_loadstate;
    4032:	704b      	strb	r3, [r1, #1]
    if(i2c_transact(i2c_sla,i2c_cmd,2,i2c_data,16) >= 0) {
    4034:	2310      	movs	r3, #16
    4036:	9300      	str	r3, [sp, #0]
    4038:	002b      	movs	r3, r5
    403a:	47b0      	blx	r6
    403c:	2800      	cmp	r0, #0
    403e:	da00      	bge.n	4042 <scc_monitor+0x7e>
    4040:	e104      	b.n	424c <scc_monitor+0x288>
        int i;
        checksum=i2c_data[15];
        i2c_data[15]=0;
    4042:	2300      	movs	r3, #0
        checksum=i2c_data[15];
    4044:	7be9      	ldrb	r1, [r5, #15]
        i2c_data[15]=0;
    4046:	73eb      	strb	r3, [r5, #15]
        checksum_chk=0;
    4048:	2300      	movs	r3, #0
        for(i=0;i<16;i++) {
    404a:	001a      	movs	r2, r3
            checksum_chk+=i2c_data[i];
    404c:	5ca8      	ldrb	r0, [r5, r2]
        for(i=0;i<16;i++) {
    404e:	3201      	adds	r2, #1
            checksum_chk+=i2c_data[i];
    4050:	181b      	adds	r3, r3, r0
    4052:	b2db      	uxtb	r3, r3
        for(i=0;i<16;i++) {
    4054:	2a10      	cmp	r2, #16
    4056:	d1f9      	bne.n	404c <scc_monitor+0x88>
        }
        if(checksum_chk==checksum) {
    4058:	4299      	cmp	r1, r3
    405a:	d000      	beq.n	405e <scc_monitor+0x9a>
    405c:	e0d7      	b.n	420e <scc_monitor+0x24a>
            i=1;
            day_meter =((unsigned short)i2c_data[i++])<<8;
    405e:	786b      	ldrb	r3, [r5, #1]
            day_meter|=((unsigned short)i2c_data[i++])&0xff;
    4060:	78aa      	ldrb	r2, [r5, #2]
            day_meter =((unsigned short)i2c_data[i++])<<8;
    4062:	021b      	lsls	r3, r3, #8
            day_meter|=((unsigned short)i2c_data[i++])&0xff;
    4064:	431a      	orrs	r2, r3
            sysval.scc_days[s]       = day_meter;
    4066:	0023      	movs	r3, r4
    4068:	4984      	ldr	r1, [pc, #528]	; (427c <scc_monitor+0x2b8>)
    406a:	3340      	adds	r3, #64	; 0x40
    406c:	005b      	lsls	r3, r3, #1
    406e:	18cb      	adds	r3, r1, r3
    4070:	80da      	strh	r2, [r3, #6]
            minute_meter =((unsigned short)i2c_data[i++])<<8;
            minute_meter|=((unsigned short)i2c_data[i++])&0xff;
            //uart_print(0,"[%d] dayl=%d min=%d\n\r",s,day_meter,minute_meter);                    
                    
            i=5;
            sysval.scc_sysstate[s]   = i2c_data[i++];
    4072:	190b      	adds	r3, r1, r4
    4074:	001a      	movs	r2, r3
            sysval.scc_battstate[s]  = i2c_data[i++];
            sysval.scc_solarstate[s] = i2c_data[i++];
            sysval.scc_loadstate[s]  = i2c_data[i++];
            sysval.scc_soc[s]        = i2c_data[i++];
                    
            step                     = (int8_t)i2c_data[i++]; // mppt_indicator
    4076:	270a      	movs	r7, #10
            sysval.scc_sysstate[s]   = i2c_data[i++];
    4078:	7969      	ldrb	r1, [r5, #5]
    407a:	322d      	adds	r2, #45	; 0x2d
    407c:	7011      	strb	r1, [r2, #0]
            sysval.scc_battstate[s]  = i2c_data[i++];
    407e:	79a9      	ldrb	r1, [r5, #6]
            sysval.scc_soc[s]        = i2c_data[i++];
    4080:	3341      	adds	r3, #65	; 0x41
            sysval.scc_battstate[s]  = i2c_data[i++];
    4082:	7111      	strb	r1, [r2, #4]
            sysval.scc_solarstate[s] = i2c_data[i++];
    4084:	79e9      	ldrb	r1, [r5, #7]
            uart_print(0,"MPPT=%d:",step);
    4086:	2000      	movs	r0, #0
            sysval.scc_solarstate[s] = i2c_data[i++];
    4088:	7211      	strb	r1, [r2, #8]
            sysval.scc_loadstate[s]  = i2c_data[i++];
    408a:	7a29      	ldrb	r1, [r5, #8]
            uart_print(0,"MPPT=%d:",step);
    408c:	4e78      	ldr	r6, [pc, #480]	; (4270 <scc_monitor+0x2ac>)
            sysval.scc_loadstate[s]  = i2c_data[i++];
    408e:	7311      	strb	r1, [r2, #12]
            sysval.scc_soc[s]        = i2c_data[i++];
    4090:	7a6a      	ldrb	r2, [r5, #9]
            uart_print(0,"MPPT=%d:",step);
    4092:	497d      	ldr	r1, [pc, #500]	; (4288 <scc_monitor+0x2c4>)
            sysval.scc_soc[s]        = i2c_data[i++];
    4094:	701a      	strb	r2, [r3, #0]
            step                     = (int8_t)i2c_data[i++]; // mppt_indicator
    4096:	57ef      	ldrsb	r7, [r5, r7]
            uart_print(0,"MPPT=%d:",step);
    4098:	003a      	movs	r2, r7
    409a:	47b0      	blx	r6
            if(step<-5)     uart_print(0,"[<<<|   ]\n\r");
    409c:	497b      	ldr	r1, [pc, #492]	; (428c <scc_monitor+0x2c8>)
    409e:	1d7b      	adds	r3, r7, #5
    40a0:	db09      	blt.n	40b6 <scc_monitor+0xf2>
            else if(step<0) uart_print(0,"[  <|   ]\n\r");
    40a2:	497b      	ldr	r1, [pc, #492]	; (4290 <scc_monitor+0x2cc>)
    40a4:	2f00      	cmp	r7, #0
    40a6:	db06      	blt.n	40b6 <scc_monitor+0xf2>
            else if(step>5) uart_print(0,"[   |>>>]\n\r");
    40a8:	497a      	ldr	r1, [pc, #488]	; (4294 <scc_monitor+0x2d0>)
    40aa:	2f05      	cmp	r7, #5
    40ac:	dc03      	bgt.n	40b6 <scc_monitor+0xf2>
            else if(step>0) uart_print(0,"[   |>  ]\n\r");
    40ae:	2f00      	cmp	r7, #0
    40b0:	d100      	bne.n	40b4 <scc_monitor+0xf0>
    40b2:	e0a9      	b.n	4208 <scc_monitor+0x244>
    40b4:	4978      	ldr	r1, [pc, #480]	; (4298 <scc_monitor+0x2d4>)
    40b6:	2000      	movs	r0, #0
            else            uart_print(0,"[   |   ]\n\r");
    40b8:	47b0      	blx	r6
                    
            sysval.scc_door[s]       = i2c_data[i++];
    40ba:	0023      	movs	r3, r4
    40bc:	4a6f      	ldr	r2, [pc, #444]	; (427c <scc_monitor+0x2b8>)
    40be:	3334      	adds	r3, #52	; 0x34
    40c0:	005b      	lsls	r3, r3, #1
    40c2:	18d3      	adds	r3, r2, r3
    40c4:	7aea      	ldrb	r2, [r5, #11]
            sysval.scc_daystate[s]   = i2c_data[i++];
                
            day_meter =((unsigned short)i2c_data[i++])<<8;
            day_meter|=((unsigned short)i2c_data[i++])&0xff;
            sysval.scc_ydayl[s]      = day_meter;                    
    40c6:	496d      	ldr	r1, [pc, #436]	; (427c <scc_monitor+0x2b8>)
            sysval.scc_door[s]       = i2c_data[i++];
    40c8:	80da      	strh	r2, [r3, #6]
            sysval.scc_daystate[s]   = i2c_data[i++];
    40ca:	4b6c      	ldr	r3, [pc, #432]	; (427c <scc_monitor+0x2b8>)
    40cc:	7b2a      	ldrb	r2, [r5, #12]
    40ce:	191b      	adds	r3, r3, r4
    40d0:	333d      	adds	r3, #61	; 0x3d
    40d2:	701a      	strb	r2, [r3, #0]
            day_meter =((unsigned short)i2c_data[i++])<<8;
    40d4:	7b6b      	ldrb	r3, [r5, #13]
            day_meter|=((unsigned short)i2c_data[i++])&0xff;
    40d6:	7baa      	ldrb	r2, [r5, #14]
            day_meter =((unsigned short)i2c_data[i++])<<8;
    40d8:	021b      	lsls	r3, r3, #8
            day_meter|=((unsigned short)i2c_data[i++])&0xff;
    40da:	431a      	orrs	r2, r3
            sysval.scc_ydayl[s]      = day_meter;                    
    40dc:	0023      	movs	r3, r4
    40de:	333c      	adds	r3, #60	; 0x3c
    40e0:	005b      	lsls	r3, r3, #1
    40e2:	18cb      	adds	r3, r1, r3
    40e4:	80da      	strh	r2, [r3, #6]
        } else uart_print(0,"1 checksum error\r\n");    
        
        delay_ms(20);
        memset(i2c_data,0,16);
    40e6:	2610      	movs	r6, #16
        delay_ms(20);
    40e8:	2014      	movs	r0, #20
    40ea:	4b63      	ldr	r3, [pc, #396]	; (4278 <scc_monitor+0x2b4>)
    40ec:	4798      	blx	r3
        memset(i2c_data,0,16);
    40ee:	0032      	movs	r2, r6
    40f0:	2100      	movs	r1, #0
    40f2:	4b63      	ldr	r3, [pc, #396]	; (4280 <scc_monitor+0x2bc>)
    40f4:	0028      	movs	r0, r5
    40f6:	4798      	blx	r3
        i2c_cmd[0]=I2C_CMD_READADC;
    40f8:	23a5      	movs	r3, #165	; 0xa5
    40fa:	a905      	add	r1, sp, #20
    40fc:	700b      	strb	r3, [r1, #0]
        if(i2c_transact(i2c_sla,i2c_cmd,1,i2c_data,16) >= 0) {                   
    40fe:	2201      	movs	r2, #1
    4100:	9600      	str	r6, [sp, #0]
    4102:	002b      	movs	r3, r5
    4104:	9802      	ldr	r0, [sp, #8]
    4106:	4e5f      	ldr	r6, [pc, #380]	; (4284 <scc_monitor+0x2c0>)
    4108:	47b0      	blx	r6
    410a:	2800      	cmp	r0, #0
    410c:	da00      	bge.n	4110 <scc_monitor+0x14c>
    410e:	e093      	b.n	4238 <scc_monitor+0x274>
            int i;
            checksum=i2c_data[15];
            i2c_data[15]=0;
    4110:	2300      	movs	r3, #0
            checksum_chk=0;
            for(i=0;i<16;i++) {
    4112:	001a      	movs	r2, r3
            checksum=i2c_data[15];
    4114:	7be9      	ldrb	r1, [r5, #15]
            i2c_data[15]=0;
    4116:	73eb      	strb	r3, [r5, #15]
                checksum_chk+=i2c_data[i];
    4118:	ad06      	add	r5, sp, #24
    411a:	5d50      	ldrb	r0, [r2, r5]
            for(i=0;i<16;i++) {
    411c:	3201      	adds	r2, #1
                checksum_chk+=i2c_data[i];
    411e:	181b      	adds	r3, r3, r0
    4120:	b2db      	uxtb	r3, r3
            for(i=0;i<16;i++) {
    4122:	2a10      	cmp	r2, #16
    4124:	d1f9      	bne.n	411a <scc_monitor+0x156>
            }
            if(checksum_chk==checksum) {
    4126:	4299      	cmp	r1, r3
    4128:	d000      	beq.n	412c <scc_monitor+0x168>
    412a:	e075      	b.n	4218 <scc_monitor+0x254>
                i=1;
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    412c:	786b      	ldrb	r3, [r5, #1]
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    412e:	78a8      	ldrb	r0, [r5, #2]
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4130:	021b      	lsls	r3, r3, #8
    uint32_t v=(uint32_t)vsolar;
    4132:	4318      	orrs	r0, r3
    v *= 13255;
    4134:	4b59      	ldr	r3, [pc, #356]	; (429c <scc_monitor+0x2d8>)
    v /= 1023;
    4136:	495a      	ldr	r1, [pc, #360]	; (42a0 <scc_monitor+0x2dc>)
    v *= 13255;
    4138:	4358      	muls	r0, r3
    v /= 1023;
    413a:	4b5a      	ldr	r3, [pc, #360]	; (42a4 <scc_monitor+0x2e0>)
    413c:	4798      	blx	r3
                uart_print(0,"[%d] vpv_oc=%d\n\r",s,vsolar_to_volt(tmp_adc));
    413e:	4f4c      	ldr	r7, [pc, #304]	; (4270 <scc_monitor+0x2ac>)
    4140:	b203      	sxth	r3, r0
    4142:	0022      	movs	r2, r4
    4144:	4958      	ldr	r1, [pc, #352]	; (42a8 <scc_monitor+0x2e4>)
    4146:	2000      	movs	r0, #0
    4148:	47b8      	blx	r7
                            
                i=3;
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
                sysval.scc_vpv[s]=tmp_adc;
    414a:	0023      	movs	r3, r4
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    414c:	78e9      	ldrb	r1, [r5, #3]
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    414e:	792a      	ldrb	r2, [r5, #4]
                sysval.scc_vpv[s]=tmp_adc;
    4150:	4e4a      	ldr	r6, [pc, #296]	; (427c <scc_monitor+0x2b8>)
    4152:	3328      	adds	r3, #40	; 0x28
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4154:	0209      	lsls	r1, r1, #8
                sysval.scc_vpv[s]=tmp_adc;
    4156:	005b      	lsls	r3, r3, #1
    4158:	18f3      	adds	r3, r6, r3
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    415a:	430a      	orrs	r2, r1
                sysval.scc_vpv[s]=tmp_adc;
    415c:	80da      	strh	r2, [r3, #6]
    
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
                sysval.scc_icharge[s]=tmp_adc;
    415e:	0023      	movs	r3, r4
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4160:	7969      	ldrb	r1, [r5, #5]
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    4162:	79aa      	ldrb	r2, [r5, #6]
                sysval.scc_icharge[s]=tmp_adc;
    4164:	332c      	adds	r3, #44	; 0x2c
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4166:	0209      	lsls	r1, r1, #8
                sysval.scc_icharge[s]=tmp_adc;
    4168:	005b      	lsls	r3, r3, #1
    416a:	18f3      	adds	r3, r6, r3
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    416c:	430a      	orrs	r2, r1
                sysval.scc_icharge[s]=tmp_adc;
    416e:	80da      	strh	r2, [r3, #6]
    
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
                sysval.scc_vbatt[s]=tmp_adc;
    4170:	0023      	movs	r3, r4
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4172:	79e9      	ldrb	r1, [r5, #7]
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    4174:	7a2a      	ldrb	r2, [r5, #8]
                sysval.scc_vbatt[s]=tmp_adc;
    4176:	3324      	adds	r3, #36	; 0x24
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4178:	0209      	lsls	r1, r1, #8
                sysval.scc_vbatt[s]=tmp_adc;
    417a:	005b      	lsls	r3, r3, #1
    417c:	18f3      	adds	r3, r6, r3
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    417e:	430a      	orrs	r2, r1
                sysval.scc_vbatt[s]=tmp_adc;
    4180:	80da      	strh	r2, [r3, #6]
    
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
                sysval.scc_iload[s]=tmp_adc;                            
    4182:	0023      	movs	r3, r4
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    4184:	7a69      	ldrb	r1, [r5, #9]
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    4186:	7aaa      	ldrb	r2, [r5, #10]
                sysval.scc_iload[s]=tmp_adc;                            
    4188:	3330      	adds	r3, #48	; 0x30
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    418a:	0209      	lsls	r1, r1, #8
                sysval.scc_iload[s]=tmp_adc;                            
    418c:	005b      	lsls	r3, r3, #1
    418e:	18f3      	adds	r3, r6, r3
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    4190:	430a      	orrs	r2, r1
    
                sysval.scc_temp[s]=i2c_data[i++];                            
    4192:	1936      	adds	r6, r6, r4
                sysval.scc_iload[s]=tmp_adc;                            
    4194:	80da      	strh	r2, [r3, #6]
                sysval.scc_temp[s]=i2c_data[i++];                            
    4196:	0033      	movs	r3, r6
    4198:	7aea      	ldrb	r2, [r5, #11]
    419a:	3349      	adds	r3, #73	; 0x49
    419c:	701a      	strb	r2, [r3, #0]
                            
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    419e:	7b2b      	ldrb	r3, [r5, #12]
                tmp_adc|=((unsigned short)i2c_data[i++])&0xff;
    41a0:	7b68      	ldrb	r0, [r5, #13]
                tmp_adc =((unsigned short)i2c_data[i++])<<8;
    41a2:	021b      	lsls	r3, r3, #8
    uint32_t v=(uint32_t)vsolar;
    41a4:	4318      	orrs	r0, r3
    v *= 13255;
    41a6:	4b3d      	ldr	r3, [pc, #244]	; (429c <scc_monitor+0x2d8>)
    v /= 1023;
    41a8:	493d      	ldr	r1, [pc, #244]	; (42a0 <scc_monitor+0x2dc>)
    v *= 13255;
    41aa:	4358      	muls	r0, r3
    v /= 1023;
    41ac:	4b3d      	ldr	r3, [pc, #244]	; (42a4 <scc_monitor+0x2e0>)
    41ae:	4798      	blx	r3
                uart_print(0,"[%d] vpv_sp=%d\n\r",s,vsolar_to_volt(tmp_adc));
    41b0:	0022      	movs	r2, r4
    41b2:	b203      	sxth	r3, r0
    41b4:	493d      	ldr	r1, [pc, #244]	; (42ac <scc_monitor+0x2e8>)
    41b6:	2000      	movs	r0, #0
    41b8:	47b8      	blx	r7
                //uart_print(0,"[%d] Vfloat=%d\n\r",s,vbatt_to_volt(tmp_adc));
                            
                uart_print(0,"scc[%d] FW=%x\n\r",s,i2c_data[i++]);                            
    41ba:	7bab      	ldrb	r3, [r5, #14]
    41bc:	0022      	movs	r2, r4
    41be:	493c      	ldr	r1, [pc, #240]	; (42b0 <scc_monitor+0x2ec>)
    41c0:	2000      	movs	r0, #0
    41c2:	47b8      	blx	r7

                sysval.scc_sysstate[s] |= 0x80; //communication was OK 
    41c4:	2380      	movs	r3, #128	; 0x80
    41c6:	362d      	adds	r6, #45	; 0x2d
    41c8:	7832      	ldrb	r2, [r6, #0]
    41ca:	425b      	negs	r3, r3
    41cc:	4313      	orrs	r3, r2
                scc_errors=0;
    41ce:	2200      	movs	r2, #0
                sysval.scc_sysstate[s] |= 0x80; //communication was OK 
    41d0:	7033      	strb	r3, [r6, #0]
                scc_errors=0;
    41d2:	4b25      	ldr	r3, [pc, #148]	; (4268 <scc_monitor+0x2a4>)
    41d4:	715a      	strb	r2, [r3, #5]
        uart_print(0,"2 comm error\r\n"); 
        sysval.scc_sysstate[s] |= 0x20; 
        scc_errors++;
    }//communication was ERROR

    if(scc_errors) {
    41d6:	4b24      	ldr	r3, [pc, #144]	; (4268 <scc_monitor+0x2a4>)
    41d8:	795b      	ldrb	r3, [r3, #5]
    41da:	2b00      	cmp	r3, #0
    41dc:	d011      	beq.n	4202 <scc_monitor+0x23e>
        int i;
        uart_print(0,"scc i2c error:");
    41de:	4935      	ldr	r1, [pc, #212]	; (42b4 <scc_monitor+0x2f0>)
    41e0:	2000      	movs	r0, #0
    41e2:	4d23      	ldr	r5, [pc, #140]	; (4270 <scc_monitor+0x2ac>)
    41e4:	47a8      	blx	r5
        for(i=0;i<16;i++) uart_print(0,"[%x]",i2c_data[i]);
    41e6:	2400      	movs	r4, #0
    41e8:	ab06      	add	r3, sp, #24
    41ea:	5ce2      	ldrb	r2, [r4, r3]
    41ec:	4932      	ldr	r1, [pc, #200]	; (42b8 <scc_monitor+0x2f4>)
    41ee:	2000      	movs	r0, #0
    41f0:	3401      	adds	r4, #1
    41f2:	47a8      	blx	r5
    41f4:	2c10      	cmp	r4, #16
    41f6:	d1f7      	bne.n	41e8 <scc_monitor+0x224>
        uart_print(0,"\n\r");
    41f8:	4930      	ldr	r1, [pc, #192]	; (42bc <scc_monitor+0x2f8>)
    41fa:	2000      	movs	r0, #0
    41fc:	47a8      	blx	r5
        return 0; 
    41fe:	2300      	movs	r3, #0
    4200:	9302      	str	r3, [sp, #8]
    } else return i2c_sla;
}
    4202:	9802      	ldr	r0, [sp, #8]
    4204:	b00b      	add	sp, #44	; 0x2c
    4206:	bdf0      	pop	{r4, r5, r6, r7, pc}
            else            uart_print(0,"[   |   ]\n\r");
    4208:	492d      	ldr	r1, [pc, #180]	; (42c0 <scc_monitor+0x2fc>)
    420a:	0038      	movs	r0, r7
    420c:	e754      	b.n	40b8 <scc_monitor+0xf4>
        } else uart_print(0,"1 checksum error\r\n");    
    420e:	492d      	ldr	r1, [pc, #180]	; (42c4 <scc_monitor+0x300>)
    4210:	2000      	movs	r0, #0
    4212:	4b17      	ldr	r3, [pc, #92]	; (4270 <scc_monitor+0x2ac>)
    4214:	4798      	blx	r3
    4216:	e766      	b.n	40e6 <scc_monitor+0x122>
                uart_print(0,"2 checksum error\r\n"); 
    4218:	4b15      	ldr	r3, [pc, #84]	; (4270 <scc_monitor+0x2ac>)
    421a:	492b      	ldr	r1, [pc, #172]	; (42c8 <scc_monitor+0x304>)
    421c:	2000      	movs	r0, #0
    421e:	4798      	blx	r3
                sysval.scc_sysstate[s] |= 0x40; scc_errors++; 
    4220:	4b16      	ldr	r3, [pc, #88]	; (427c <scc_monitor+0x2b8>)
    4222:	191c      	adds	r4, r3, r4
    4224:	2340      	movs	r3, #64	; 0x40
    4226:	342d      	adds	r4, #45	; 0x2d
    4228:	7822      	ldrb	r2, [r4, #0]
            sysval.scc_sysstate[s] |= 0x20; 
    422a:	4313      	orrs	r3, r2
            scc_errors++; 
    422c:	4a0e      	ldr	r2, [pc, #56]	; (4268 <scc_monitor+0x2a4>)
            sysval.scc_sysstate[s] |= 0x20; 
    422e:	7023      	strb	r3, [r4, #0]
            scc_errors++; 
    4230:	7953      	ldrb	r3, [r2, #5]
    4232:	3301      	adds	r3, #1
    4234:	7153      	strb	r3, [r2, #5]
    4236:	e7ce      	b.n	41d6 <scc_monitor+0x212>
            uart_print(0,"1 comm error\r\n"); 
    4238:	4b0d      	ldr	r3, [pc, #52]	; (4270 <scc_monitor+0x2ac>)
    423a:	4924      	ldr	r1, [pc, #144]	; (42cc <scc_monitor+0x308>)
    423c:	2000      	movs	r0, #0
    423e:	4798      	blx	r3
            sysval.scc_sysstate[s] |= 0x20; 
    4240:	4b0e      	ldr	r3, [pc, #56]	; (427c <scc_monitor+0x2b8>)
    4242:	191c      	adds	r4, r3, r4
    4244:	342d      	adds	r4, #45	; 0x2d
    4246:	7822      	ldrb	r2, [r4, #0]
    4248:	2320      	movs	r3, #32
    424a:	e7ee      	b.n	422a <scc_monitor+0x266>
        uart_print(0,"2 comm error\r\n"); 
    424c:	4b08      	ldr	r3, [pc, #32]	; (4270 <scc_monitor+0x2ac>)
    424e:	4920      	ldr	r1, [pc, #128]	; (42d0 <scc_monitor+0x30c>)
    4250:	2000      	movs	r0, #0
    4252:	4798      	blx	r3
        sysval.scc_sysstate[s] |= 0x20; 
    4254:	9b03      	ldr	r3, [sp, #12]
    4256:	781a      	ldrb	r2, [r3, #0]
    4258:	2320      	movs	r3, #32
    425a:	4313      	orrs	r3, r2
    425c:	9a03      	ldr	r2, [sp, #12]
    425e:	7013      	strb	r3, [r2, #0]
        scc_errors++;
    4260:	797b      	ldrb	r3, [r7, #5]
    4262:	3301      	adds	r3, #1
    4264:	717b      	strb	r3, [r7, #5]
    4266:	e7b6      	b.n	41d6 <scc_monitor+0x212>
    4268:	2000052a 	.word	0x2000052a
    426c:	0000aadf 	.word	0x0000aadf
    4270:	00007b99 	.word	0x00007b99
    4274:	00007795 	.word	0x00007795
    4278:	00007c05 	.word	0x00007c05
    427c:	20000a58 	.word	0x20000a58
    4280:	00008957 	.word	0x00008957
    4284:	00007935 	.word	0x00007935
    4288:	0000aaf6 	.word	0x0000aaf6
    428c:	0000aaff 	.word	0x0000aaff
    4290:	0000ab0b 	.word	0x0000ab0b
    4294:	0000ab17 	.word	0x0000ab17
    4298:	0000ab23 	.word	0x0000ab23
    429c:	000033c7 	.word	0x000033c7
    42a0:	000003ff 	.word	0x000003ff
    42a4:	00007f89 	.word	0x00007f89
    42a8:	0000ab4e 	.word	0x0000ab4e
    42ac:	0000ab5f 	.word	0x0000ab5f
    42b0:	0000ab70 	.word	0x0000ab70
    42b4:	0000abb1 	.word	0x0000abb1
    42b8:	0000abc0 	.word	0x0000abc0
    42bc:	0000a6f2 	.word	0x0000a6f2
    42c0:	0000ab2f 	.word	0x0000ab2f
    42c4:	0000ab3b 	.word	0x0000ab3b
    42c8:	0000ab80 	.word	0x0000ab80
    42cc:	0000ab93 	.word	0x0000ab93
    42d0:	0000aba2 	.word	0x0000aba2

000042d4 <scc_probe>:
{
    42d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        scc_i2c_addr[i]=I2C_SCC_BASE_ADDR+i;
    42d6:	222c      	movs	r2, #44	; 0x2c
    sysval.scc_nof_scc=0;
    42d8:	4e20      	ldr	r6, [pc, #128]	; (435c <scc_probe+0x88>)
    42da:	2400      	movs	r4, #0
    42dc:	0033      	movs	r3, r6
        scc_i2c_addr[i]=I2C_SCC_BASE_ADDR+i;
    42de:	4d20      	ldr	r5, [pc, #128]	; (4360 <scc_probe+0x8c>)
    sysval.scc_nof_scc=0;
    42e0:	332c      	adds	r3, #44	; 0x2c
        scc_i2c_addr[i]=I2C_SCC_BASE_ADDR+i;
    42e2:	706a      	strb	r2, [r5, #1]
    42e4:	3201      	adds	r2, #1
    42e6:	70aa      	strb	r2, [r5, #2]
    42e8:	3201      	adds	r2, #1
    42ea:	70ea      	strb	r2, [r5, #3]
    42ec:	3201      	adds	r2, #1
    sysval.scc_nof_scc=0;
    42ee:	701c      	strb	r4, [r3, #0]
        scc_i2c_addr[i]=I2C_SCC_BASE_ADDR+i;
    42f0:	712a      	strb	r2, [r5, #4]
        valid_addr=scc_monitor(i);
    42f2:	b2e4      	uxtb	r4, r4
    42f4:	0020      	movs	r0, r4
    42f6:	4b1b      	ldr	r3, [pc, #108]	; (4364 <scc_probe+0x90>)
    42f8:	4798      	blx	r3
        if(valid_addr) {
    42fa:	2800      	cmp	r0, #0
    42fc:	d006      	beq.n	430c <scc_probe+0x38>
            scc_i2c_addr[sysval.scc_nof_scc]=valid_addr;
    42fe:	0032      	movs	r2, r6
    4300:	322c      	adds	r2, #44	; 0x2c
    4302:	7813      	ldrb	r3, [r2, #0]
    4304:	1c69      	adds	r1, r5, #1
    4306:	54c8      	strb	r0, [r1, r3]
            sysval.scc_nof_scc++;
    4308:	3301      	adds	r3, #1
    430a:	7013      	strb	r3, [r2, #0]
    430c:	3401      	adds	r4, #1
    430e:	b2e3      	uxtb	r3, r4
    4310:	b25c      	sxtb	r4, r3
    for (i=0;i<MAX_NOF_SCC;i++) {
    4312:	2b04      	cmp	r3, #4
    4314:	d1ed      	bne.n	42f2 <scc_probe+0x1e>
    for (i=sysval.scc_nof_scc;i<MAX_NOF_SCC;i++) {
    4316:	0033      	movs	r3, r6
        scc_i2c_addr[i]=0;
    4318:	2000      	movs	r0, #0
    for (i=sysval.scc_nof_scc;i<MAX_NOF_SCC;i++) {
    431a:	332c      	adds	r3, #44	; 0x2c
    431c:	781a      	ldrb	r2, [r3, #0]
        scc_i2c_addr[i]=0;
    431e:	1c69      	adds	r1, r5, #1
    for (i=sysval.scc_nof_scc;i<MAX_NOF_SCC;i++) {
    4320:	b253      	sxtb	r3, r2
    4322:	2b03      	cmp	r3, #3
    4324:	dd15      	ble.n	4352 <scc_probe+0x7e>
    uart_print(0,"scc: %d SCC's detected\n\r",sysval.scc_nof_scc);
    4326:	4910      	ldr	r1, [pc, #64]	; (4368 <scc_probe+0x94>)
    4328:	2000      	movs	r0, #0
    432a:	4b10      	ldr	r3, [pc, #64]	; (436c <scc_probe+0x98>)
    432c:	4798      	blx	r3
    432e:	2400      	movs	r4, #0
        uart_print(0,"scc[%d]=0x%x\n\r",i,scc_i2c_addr[i]);
    4330:	1c6b      	adds	r3, r5, #1
    4332:	5ce3      	ldrb	r3, [r4, r3]
    4334:	0022      	movs	r2, r4
    4336:	490e      	ldr	r1, [pc, #56]	; (4370 <scc_probe+0x9c>)
    4338:	2000      	movs	r0, #0
    433a:	4f0c      	ldr	r7, [pc, #48]	; (436c <scc_probe+0x98>)
    433c:	3401      	adds	r4, #1
    433e:	47b8      	blx	r7
    for (i=0;i<MAX_NOF_SCC;i++) {
    4340:	2c04      	cmp	r4, #4
    4342:	d1f5      	bne.n	4330 <scc_probe+0x5c>
    if(sysval.scc_nof_scc>0) scc_do_probe=0;
    4344:	362c      	adds	r6, #44	; 0x2c
    4346:	7833      	ldrb	r3, [r6, #0]
    4348:	2b00      	cmp	r3, #0
    434a:	d001      	beq.n	4350 <scc_probe+0x7c>
    434c:	2300      	movs	r3, #0
    434e:	702b      	strb	r3, [r5, #0]
}
    4350:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        scc_i2c_addr[i]=0;
    4352:	54c8      	strb	r0, [r1, r3]
    4354:	3301      	adds	r3, #1
    4356:	b25b      	sxtb	r3, r3
    4358:	e7e3      	b.n	4322 <scc_probe+0x4e>
    435a:	46c0      	nop			; (mov r8, r8)
    435c:	20000a58 	.word	0x20000a58
    4360:	2000052a 	.word	0x2000052a
    4364:	00003fc5 	.word	0x00003fc5
    4368:	0000abc5 	.word	0x0000abc5
    436c:	00007b99 	.word	0x00007b99
    4370:	0000abde 	.word	0x0000abde

00004374 <scc_send_cmd>:


void scc_send_cmd(uint8_t cmd, uint8_t val, uint8_t write_val)
{
    4374:	b5f0      	push	{r4, r5, r6, r7, lr}
    4376:	b08f      	sub	sp, #60	; 0x3c
    uint8_t i2c_cmd[2];
    uint8_t i2c_cmd_len;
    uint8_t i2c_data[16];
    unsigned char s,checksum,checksum_chk;

    i2c_cmd[0]=cmd;    
    4378:	ab09      	add	r3, sp, #36	; 0x24
    437a:	7018      	strb	r0, [r3, #0]
    if(write_val) {
        i2c_cmd[1]=val;
        i2c_cmd_len=2;
    } else {
        i2c_cmd_len=1;
    437c:	2001      	movs	r0, #1
    437e:	9005      	str	r0, [sp, #20]
    if(write_val) {
    4380:	2a00      	cmp	r2, #0
    4382:	d002      	beq.n	438a <scc_send_cmd+0x16>
        i2c_cmd[1]=val;
    4384:	7059      	strb	r1, [r3, #1]
        i2c_cmd_len=2;
    4386:	2302      	movs	r3, #2
    4388:	9305      	str	r3, [sp, #20]
    }

    // send command to all SCC boards
    for(s=0;s<sysval.scc_nof_scc;s++) {
    438a:	2700      	movs	r7, #0
    438c:	4b32      	ldr	r3, [pc, #200]	; (4458 <scc_send_cmd+0xe4>)
    438e:	332c      	adds	r3, #44	; 0x2c
    4390:	9307      	str	r3, [sp, #28]
    4392:	9b07      	ldr	r3, [sp, #28]
    4394:	781b      	ldrb	r3, [r3, #0]
    4396:	42bb      	cmp	r3, r7
    4398:	d812      	bhi.n	43c0 <scc_send_cmd+0x4c>
                scc_errors++;
            }
            if(scc_errors==0) break;
        }
    }
}
    439a:	b00f      	add	sp, #60	; 0x3c
    439c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    sysval.scc_sysstate[s] |= 0x40; //communication was ERROR
    439e:	2240      	movs	r2, #64	; 0x40
    43a0:	7818      	ldrb	r0, [r3, #0]
    43a2:	4302      	orrs	r2, r0
    43a4:	701a      	strb	r2, [r3, #0]
                    scc_errors++;
    43a6:	794b      	ldrb	r3, [r1, #5]
    43a8:	3301      	adds	r3, #1
    43aa:	e04d      	b.n	4448 <scc_send_cmd+0xd4>
                sysval.scc_sysstate[s] |= 0x20; //communication was ERROR
    43ac:	9b03      	ldr	r3, [sp, #12]
    43ae:	781a      	ldrb	r2, [r3, #0]
    43b0:	2320      	movs	r3, #32
    43b2:	4313      	orrs	r3, r2
    43b4:	9a03      	ldr	r2, [sp, #12]
    43b6:	7013      	strb	r3, [r2, #0]
                scc_errors++;
    43b8:	796b      	ldrb	r3, [r5, #5]
    43ba:	3301      	adds	r3, #1
    43bc:	716b      	strb	r3, [r5, #5]
    43be:	e044      	b.n	444a <scc_send_cmd+0xd6>
    43c0:	230b      	movs	r3, #11
    43c2:	9304      	str	r3, [sp, #16]
    43c4:	9b04      	ldr	r3, [sp, #16]
    43c6:	3b01      	subs	r3, #1
    43c8:	b2db      	uxtb	r3, r3
    43ca:	9304      	str	r3, [sp, #16]
        while(retries--) {
    43cc:	2b00      	cmp	r3, #0
    43ce:	d03f      	beq.n	4450 <scc_send_cmd+0xdc>
            if(scc_errors>5) { 
    43d0:	4d22      	ldr	r5, [pc, #136]	; (445c <scc_send_cmd+0xe8>)
    43d2:	796b      	ldrb	r3, [r5, #5]
    43d4:	2b05      	cmp	r3, #5
    43d6:	d906      	bls.n	43e6 <scc_send_cmd+0x72>
                scc_errors=0; 
    43d8:	2300      	movs	r3, #0
    43da:	716b      	strb	r3, [r5, #5]
                i2c_reset();
    43dc:	4b20      	ldr	r3, [pc, #128]	; (4460 <scc_send_cmd+0xec>)
    43de:	4798      	blx	r3
                delay_ms(20);
    43e0:	2014      	movs	r0, #20
    43e2:	4b20      	ldr	r3, [pc, #128]	; (4464 <scc_send_cmd+0xf0>)
    43e4:	4798      	blx	r3
            i2c_sla=scc_i2c_addr[s];
    43e6:	1c6b      	adds	r3, r5, #1
    43e8:	5ddb      	ldrb	r3, [r3, r7]
            memset(i2c_data,0,16);
    43ea:	ae0a      	add	r6, sp, #40	; 0x28
            i2c_sla=scc_i2c_addr[s];
    43ec:	9306      	str	r3, [sp, #24]
            memset(i2c_data,0,16);
    43ee:	2210      	movs	r2, #16
    43f0:	2100      	movs	r1, #0
    43f2:	4b1d      	ldr	r3, [pc, #116]	; (4468 <scc_send_cmd+0xf4>)
    43f4:	0030      	movs	r0, r6
    43f6:	4798      	blx	r3
            sysval.scc_sysstate[s] &= 0x0f; // reset bit 7..4
    43f8:	220f      	movs	r2, #15
    43fa:	4b17      	ldr	r3, [pc, #92]	; (4458 <scc_send_cmd+0xe4>)
            if(i2c_transact(i2c_sla,i2c_cmd,i2c_cmd_len,i2c_data,16) >= 0) {
    43fc:	a909      	add	r1, sp, #36	; 0x24
            sysval.scc_sysstate[s] &= 0x0f; // reset bit 7..4
    43fe:	19dc      	adds	r4, r3, r7
    4400:	342d      	adds	r4, #45	; 0x2d
    4402:	7823      	ldrb	r3, [r4, #0]
    4404:	9403      	str	r4, [sp, #12]
    4406:	4013      	ands	r3, r2
    4408:	7023      	strb	r3, [r4, #0]
            if(i2c_transact(i2c_sla,i2c_cmd,i2c_cmd_len,i2c_data,16) >= 0) {
    440a:	2310      	movs	r3, #16
    440c:	9a05      	ldr	r2, [sp, #20]
    440e:	9300      	str	r3, [sp, #0]
    4410:	9806      	ldr	r0, [sp, #24]
    4412:	0033      	movs	r3, r6
    4414:	4c15      	ldr	r4, [pc, #84]	; (446c <scc_send_cmd+0xf8>)
    4416:	47a0      	blx	r4
    4418:	4910      	ldr	r1, [pc, #64]	; (445c <scc_send_cmd+0xe8>)
    441a:	2800      	cmp	r0, #0
    441c:	dbc6      	blt.n	43ac <scc_send_cmd+0x38>
                i2c_data[15]=0;
    441e:	2300      	movs	r3, #0
                checksum_chk=0;
    4420:	001a      	movs	r2, r3
                checksum=i2c_data[15];
    4422:	7bf0      	ldrb	r0, [r6, #15]
                i2c_data[15]=0;
    4424:	73f3      	strb	r3, [r6, #15]
                    checksum_chk+=i2c_data[i];
    4426:	5cf4      	ldrb	r4, [r6, r3]
                for(i=0;i<16;i++) {
    4428:	3301      	adds	r3, #1
                    checksum_chk+=i2c_data[i];
    442a:	1912      	adds	r2, r2, r4
    442c:	b2d2      	uxtb	r2, r2
                for(i=0;i<16;i++) {
    442e:	2b10      	cmp	r3, #16
    4430:	d1f9      	bne.n	4426 <scc_send_cmd+0xb2>
                    sysval.scc_sysstate[s] |= 0x80; //communication was OK
    4432:	4b09      	ldr	r3, [pc, #36]	; (4458 <scc_send_cmd+0xe4>)
    4434:	19db      	adds	r3, r3, r7
    4436:	332d      	adds	r3, #45	; 0x2d
                if(checksum_chk==checksum) {
    4438:	4290      	cmp	r0, r2
    443a:	d1b0      	bne.n	439e <scc_send_cmd+0x2a>
                    sysval.scc_sysstate[s] |= 0x80; //communication was OK
    443c:	2280      	movs	r2, #128	; 0x80
    443e:	7818      	ldrb	r0, [r3, #0]
    4440:	4252      	negs	r2, r2
    4442:	4302      	orrs	r2, r0
    4444:	701a      	strb	r2, [r3, #0]
                    scc_errors=0;
    4446:	2300      	movs	r3, #0
                    scc_errors++;
    4448:	714b      	strb	r3, [r1, #5]
            if(scc_errors==0) break;
    444a:	794b      	ldrb	r3, [r1, #5]
    444c:	2b00      	cmp	r3, #0
    444e:	d1b9      	bne.n	43c4 <scc_send_cmd+0x50>
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4450:	3701      	adds	r7, #1
    4452:	b2ff      	uxtb	r7, r7
    4454:	e79d      	b.n	4392 <scc_send_cmd+0x1e>
    4456:	46c0      	nop			; (mov r8, r8)
    4458:	20000a58 	.word	0x20000a58
    445c:	2000052a 	.word	0x2000052a
    4460:	00007795 	.word	0x00007795
    4464:	00007c05 	.word	0x00007c05
    4468:	00008957 	.word	0x00008957
    446c:	00007935 	.word	0x00007935

00004470 <scc_set_load>:

void scc_set_load(uint8_t onoff)
{
    4470:	b510      	push	{r4, lr}
    4472:	4b06      	ldr	r3, [pc, #24]	; (448c <scc_set_load+0x1c>)
    if(onoff != 0) scc_loadstate=1; else scc_loadstate=0;
    4474:	2800      	cmp	r0, #0
    4476:	d007      	beq.n	4488 <scc_set_load+0x18>
    4478:	2201      	movs	r2, #1
    447a:	719a      	strb	r2, [r3, #6]
    uart_print(0,"scc_set_load(%d)\n\r",scc_loadstate);
    447c:	799a      	ldrb	r2, [r3, #6]
    447e:	4904      	ldr	r1, [pc, #16]	; (4490 <scc_set_load+0x20>)
    4480:	2000      	movs	r0, #0
    4482:	4b04      	ldr	r3, [pc, #16]	; (4494 <scc_set_load+0x24>)
    4484:	4798      	blx	r3
}
    4486:	bd10      	pop	{r4, pc}
    if(onoff != 0) scc_loadstate=1; else scc_loadstate=0;
    4488:	7198      	strb	r0, [r3, #6]
    448a:	e7f7      	b.n	447c <scc_set_load+0xc>
    448c:	2000052a 	.word	0x2000052a
    4490:	0000abed 	.word	0x0000abed
    4494:	00007b99 	.word	0x00007b99

00004498 <scc_cal_temp>:

void scc_cal_temp(uint8_t temp)
{
    4498:	b510      	push	{r4, lr}
    449a:	0004      	movs	r4, r0
    uart_print(0,"scc_cal_temp(%d)\n\r",temp);
    449c:	0002      	movs	r2, r0
    449e:	4905      	ldr	r1, [pc, #20]	; (44b4 <scc_cal_temp+0x1c>)
    44a0:	2000      	movs	r0, #0
    44a2:	4b05      	ldr	r3, [pc, #20]	; (44b8 <scc_cal_temp+0x20>)
    44a4:	4798      	blx	r3
    scc_send_cmd(I2C_CMD_CALTEMP,temp,1);
    44a6:	2201      	movs	r2, #1
    44a8:	0021      	movs	r1, r4
    44aa:	20ab      	movs	r0, #171	; 0xab
    44ac:	4b03      	ldr	r3, [pc, #12]	; (44bc <scc_cal_temp+0x24>)
    44ae:	4798      	blx	r3
}
    44b0:	bd10      	pop	{r4, pc}
    44b2:	46c0      	nop			; (mov r8, r8)
    44b4:	0000ac00 	.word	0x0000ac00
    44b8:	00007b99 	.word	0x00007b99
    44bc:	00004375 	.word	0x00004375

000044c0 <scc_cal_batt>:

void scc_cal_batt(int8_t offset)
{
    44c0:	b510      	push	{r4, lr}
    44c2:	0004      	movs	r4, r0
    uart_print(0,"scc_cal_batt(%d)\n\r",offset);
    44c4:	0002      	movs	r2, r0
    44c6:	4905      	ldr	r1, [pc, #20]	; (44dc <scc_cal_batt+0x1c>)
    44c8:	2000      	movs	r0, #0
    44ca:	4b05      	ldr	r3, [pc, #20]	; (44e0 <scc_cal_batt+0x20>)
    44cc:	4798      	blx	r3
    scc_send_cmd(I2C_CMD_CALBATT,offset,1);
    44ce:	b2e1      	uxtb	r1, r4
    44d0:	2201      	movs	r2, #1
    44d2:	20ae      	movs	r0, #174	; 0xae
    44d4:	4b03      	ldr	r3, [pc, #12]	; (44e4 <scc_cal_batt+0x24>)
    44d6:	4798      	blx	r3
}
    44d8:	bd10      	pop	{r4, pc}
    44da:	46c0      	nop			; (mov r8, r8)
    44dc:	0000ac13 	.word	0x0000ac13
    44e0:	00007b99 	.word	0x00007b99
    44e4:	00004375 	.word	0x00004375

000044e8 <scc_set_ah_batt>:

void scc_set_ah_batt(int8_t ah)
{
    44e8:	b510      	push	{r4, lr}
    44ea:	0004      	movs	r4, r0
    uart_print(0,"scc_set_ah_batt(%d)\n\r",ah);
    44ec:	0002      	movs	r2, r0
    44ee:	4905      	ldr	r1, [pc, #20]	; (4504 <scc_set_ah_batt+0x1c>)
    44f0:	2000      	movs	r0, #0
    44f2:	4b05      	ldr	r3, [pc, #20]	; (4508 <scc_set_ah_batt+0x20>)
    44f4:	4798      	blx	r3
    scc_send_cmd(I2C_CMD_SETAHBATT,ah,1);
    44f6:	b2e1      	uxtb	r1, r4
    44f8:	2201      	movs	r2, #1
    44fa:	20af      	movs	r0, #175	; 0xaf
    44fc:	4b03      	ldr	r3, [pc, #12]	; (450c <scc_set_ah_batt+0x24>)
    44fe:	4798      	blx	r3
}
    4500:	bd10      	pop	{r4, pc}
    4502:	46c0      	nop			; (mov r8, r8)
    4504:	0000ac26 	.word	0x0000ac26
    4508:	00007b99 	.word	0x00007b99
    450c:	00004375 	.word	0x00004375

00004510 <scc_start_equalize>:

void scc_start_equalize(void)
{
    4510:	b510      	push	{r4, lr}
    uart_print(0,"scc_start_equalize()\n\r");
    4512:	4905      	ldr	r1, [pc, #20]	; (4528 <scc_start_equalize+0x18>)
    4514:	2000      	movs	r0, #0
    4516:	4b05      	ldr	r3, [pc, #20]	; (452c <scc_start_equalize+0x1c>)
    4518:	4798      	blx	r3
    scc_send_cmd(I2C_CMD_EQUALIZE,0,0);
    451a:	2200      	movs	r2, #0
    451c:	20ad      	movs	r0, #173	; 0xad
    451e:	0011      	movs	r1, r2
    4520:	4b03      	ldr	r3, [pc, #12]	; (4530 <scc_start_equalize+0x20>)
    4522:	4798      	blx	r3
}
    4524:	bd10      	pop	{r4, pc}
    4526:	46c0      	nop			; (mov r8, r8)
    4528:	0000ac3c 	.word	0x0000ac3c
    452c:	00007b99 	.word	0x00007b99
    4530:	00004375 	.word	0x00004375

00004534 <scc_read_battery>:

uint8_t scc_read_battery(uint8_t s)
{
    uint8_t i2c_sla;
    uint8_t i2c_cmd = I2C_CMD_READBATT;
    4534:	230f      	movs	r3, #15
    4536:	22ac      	movs	r2, #172	; 0xac
{
    4538:	b5f0      	push	{r4, r5, r6, r7, lr}
    453a:	b08b      	sub	sp, #44	; 0x2c
    uint8_t i2c_cmd = I2C_CMD_READBATT;
    453c:	a902      	add	r1, sp, #8
    453e:	185b      	adds	r3, r3, r1
{
    4540:	0004      	movs	r4, r0
    uint8_t i2c_cmd = I2C_CMD_READBATT;
    4542:	701a      	strb	r2, [r3, #0]
    unsigned char checksum,checksum_chk;
    uint32_t As, As_max;
    uint16_t Ah;
    uint8_t equalizing;

    if(s>(MAX_NOF_SCC-1)) return 0;
    4544:	2500      	movs	r5, #0
    4546:	2803      	cmp	r0, #3
    4548:	d900      	bls.n	454c <scc_read_battery+0x18>
    454a:	e08e      	b.n	466a <scc_read_battery+0x136>
    uart_print(0,"scc_read_battery[%d]\n\r",s);
    454c:	0002      	movs	r2, r0
    454e:	4b53      	ldr	r3, [pc, #332]	; (469c <scc_read_battery+0x168>)
    4550:	4953      	ldr	r1, [pc, #332]	; (46a0 <scc_read_battery+0x16c>)
    4552:	0028      	movs	r0, r5
    4554:	4798      	blx	r3
            
    if(scc_errors>5) { 
    4556:	4f53      	ldr	r7, [pc, #332]	; (46a4 <scc_read_battery+0x170>)
    4558:	797b      	ldrb	r3, [r7, #5]
    455a:	2b05      	cmp	r3, #5
    455c:	d905      	bls.n	456a <scc_read_battery+0x36>
        scc_errors=0; 
        i2c_reset();
    455e:	4b52      	ldr	r3, [pc, #328]	; (46a8 <scc_read_battery+0x174>)
        scc_errors=0; 
    4560:	717d      	strb	r5, [r7, #5]
        i2c_reset();
    4562:	4798      	blx	r3
        delay_ms(20);
    4564:	2014      	movs	r0, #20
    4566:	4b51      	ldr	r3, [pc, #324]	; (46ac <scc_read_battery+0x178>)
    4568:	4798      	blx	r3
    }

    i2c_sla=scc_i2c_addr[s];
    456a:	1c7b      	adds	r3, r7, #1
    456c:	5d1b      	ldrb	r3, [r3, r4]
    memset(i2c_data,0,16);
    456e:	ae06      	add	r6, sp, #24
    i2c_sla=scc_i2c_addr[s];
    4570:	9303      	str	r3, [sp, #12]
    memset(i2c_data,0,16);
    4572:	2210      	movs	r2, #16
    4574:	2100      	movs	r1, #0
    4576:	4b4e      	ldr	r3, [pc, #312]	; (46b0 <scc_read_battery+0x17c>)
    4578:	0030      	movs	r0, r6
    457a:	4798      	blx	r3
    sysval.scc_sysstate[s]&=0x7f;
    457c:	227f      	movs	r2, #127	; 0x7f
    457e:	4b4d      	ldr	r3, [pc, #308]	; (46b4 <scc_read_battery+0x180>)
    if(i2c_transact(i2c_sla,&i2c_cmd,1,i2c_data,16) >= 0) {
    4580:	210f      	movs	r1, #15
    sysval.scc_sysstate[s]&=0x7f;
    4582:	191d      	adds	r5, r3, r4
    4584:	352d      	adds	r5, #45	; 0x2d
    4586:	782b      	ldrb	r3, [r5, #0]
    if(i2c_transact(i2c_sla,&i2c_cmd,1,i2c_data,16) >= 0) {
    4588:	a802      	add	r0, sp, #8
    sysval.scc_sysstate[s]&=0x7f;
    458a:	4013      	ands	r3, r2
    458c:	702b      	strb	r3, [r5, #0]
    if(i2c_transact(i2c_sla,&i2c_cmd,1,i2c_data,16) >= 0) {
    458e:	2310      	movs	r3, #16
    sysval.scc_sysstate[s]&=0x7f;
    4590:	9502      	str	r5, [sp, #8]
    if(i2c_transact(i2c_sla,&i2c_cmd,1,i2c_data,16) >= 0) {
    4592:	9300      	str	r3, [sp, #0]
    4594:	1809      	adds	r1, r1, r0
    4596:	0033      	movs	r3, r6
    4598:	2201      	movs	r2, #1
    459a:	9803      	ldr	r0, [sp, #12]
    459c:	4d46      	ldr	r5, [pc, #280]	; (46b8 <scc_read_battery+0x184>)
    459e:	47a8      	blx	r5
    45a0:	2800      	cmp	r0, #0
    45a2:	da00      	bge.n	45a6 <scc_read_battery+0x72>
    45a4:	e06f      	b.n	4686 <scc_read_battery+0x152>
        int i;
        checksum=i2c_data[15];
        i2c_data[15]=0;
    45a6:	2300      	movs	r3, #0
        checksum_chk=0;
    45a8:	001a      	movs	r2, r3
        checksum=i2c_data[15];
    45aa:	7bf1      	ldrb	r1, [r6, #15]
        i2c_data[15]=0;
    45ac:	73f3      	strb	r3, [r6, #15]
        for(i=0;i<16;i++) {
            checksum_chk+=i2c_data[i];
    45ae:	5cf0      	ldrb	r0, [r6, r3]
        for(i=0;i<16;i++) {
    45b0:	3301      	adds	r3, #1
            checksum_chk+=i2c_data[i];
    45b2:	1812      	adds	r2, r2, r0
    45b4:	b2d2      	uxtb	r2, r2
        for(i=0;i<16;i++) {
    45b6:	2b10      	cmp	r3, #16
    45b8:	d1f9      	bne.n	45ae <scc_read_battery+0x7a>
        }
        if(checksum_chk==checksum) {
    45ba:	4291      	cmp	r1, r2
    45bc:	d158      	bne.n	4670 <scc_read_battery+0x13c>
            i=1;
            As =((uint32_t)i2c_data[i++])<<24;
    45be:	7873      	ldrb	r3, [r6, #1]
            As|=((uint32_t)i2c_data[i++])<<16;
    45c0:	78b5      	ldrb	r5, [r6, #2]
            As =((uint32_t)i2c_data[i++])<<24;
    45c2:	061b      	lsls	r3, r3, #24
            As|=((uint32_t)i2c_data[i++])<<16;
    45c4:	042d      	lsls	r5, r5, #16
    45c6:	431d      	orrs	r5, r3
            As|=((uint32_t)i2c_data[i++])<<8;
            As|=((uint32_t)i2c_data[i++])&0xff;
    45c8:	7933      	ldrb	r3, [r6, #4]
                
            As_max =((uint32_t)i2c_data[i++])<<24;
    45ca:	7972      	ldrb	r2, [r6, #5]
    45cc:	432b      	orrs	r3, r5
            As|=((uint32_t)i2c_data[i++])<<8;
    45ce:	78f5      	ldrb	r5, [r6, #3]
            As_max =((uint32_t)i2c_data[i++])<<24;
    45d0:	0612      	lsls	r2, r2, #24
            As|=((uint32_t)i2c_data[i++])<<8;
    45d2:	022d      	lsls	r5, r5, #8
            As|=((uint32_t)i2c_data[i++])&0xff;
    45d4:	431d      	orrs	r5, r3
            As_max|=((uint32_t)i2c_data[i++])<<16;
    45d6:	79b3      	ldrb	r3, [r6, #6]
            As_max|=((uint32_t)i2c_data[i++])<<8;
            As_max|=((uint32_t)i2c_data[i++])&0xff;
                
            equalizing = i2c_data[i++];
                            
            uart_print(0,"[%d] As=%ld As_max=%ld equalize=%d\n\r",s,As,As_max,equalizing);
    45d8:	4938      	ldr	r1, [pc, #224]	; (46bc <scc_read_battery+0x188>)
            As_max|=((uint32_t)i2c_data[i++])<<16;
    45da:	041b      	lsls	r3, r3, #16
    45dc:	4313      	orrs	r3, r2
            As_max|=((uint32_t)i2c_data[i++])&0xff;
    45de:	7a32      	ldrb	r2, [r6, #8]
            uart_print(0,"[%d] As=%ld As_max=%ld equalize=%d\n\r",s,As,As_max,equalizing);
    45e0:	2000      	movs	r0, #0
    45e2:	4313      	orrs	r3, r2
            As_max|=((uint32_t)i2c_data[i++])<<8;
    45e4:	79f2      	ldrb	r2, [r6, #7]
            Ah=(uint16_t)(As/3600L);
            sysval.scc_Ah[s] = Ah;
    45e6:	0027      	movs	r7, r4
            As_max|=((uint32_t)i2c_data[i++])<<8;
    45e8:	0212      	lsls	r2, r2, #8
            As_max|=((uint32_t)i2c_data[i++])&0xff;
    45ea:	431a      	orrs	r2, r3
    45ec:	9202      	str	r2, [sp, #8]
            uart_print(0,"[%d] As=%ld As_max=%ld equalize=%d\n\r",s,As,As_max,equalizing);
    45ee:	7a73      	ldrb	r3, [r6, #9]
    45f0:	9200      	str	r2, [sp, #0]
    45f2:	9301      	str	r3, [sp, #4]
    45f4:	0022      	movs	r2, r4
    45f6:	002b      	movs	r3, r5
    45f8:	4e28      	ldr	r6, [pc, #160]	; (469c <scc_read_battery+0x168>)
    45fa:	47b0      	blx	r6
            Ah=(uint16_t)(As/3600L);
    45fc:	21e1      	movs	r1, #225	; 0xe1
    45fe:	4b30      	ldr	r3, [pc, #192]	; (46c0 <scc_read_battery+0x18c>)
    4600:	0109      	lsls	r1, r1, #4
    4602:	0028      	movs	r0, r5
    4604:	4798      	blx	r3
            sysval.scc_Ah[s] = Ah;
    4606:	4e2b      	ldr	r6, [pc, #172]	; (46b4 <scc_read_battery+0x180>)
    4608:	3738      	adds	r7, #56	; 0x38
    460a:	007f      	lsls	r7, r7, #1
            //uart_print(0,"[%d] Ah=%d\n\r",s,sysval.scc_Ah[s]);
                
            if((As_max >= As) && (As > 0)) {
    460c:	9b02      	ldr	r3, [sp, #8]
            sysval.scc_Ah[s] = Ah;
    460e:	19f7      	adds	r7, r6, r7
    4610:	80f8      	strh	r0, [r7, #6]
            if((As_max >= As) && (As > 0)) {
    4612:	429d      	cmp	r5, r3
    4614:	d809      	bhi.n	462a <scc_read_battery+0xf6>
    4616:	2d00      	cmp	r5, #0
    4618:	d007      	beq.n	462a <scc_read_battery+0xf6>
                As *= 100UL;
    461a:	2064      	movs	r0, #100	; 0x64
                As = As / As_max;                        
    461c:	0019      	movs	r1, r3
                As *= 100UL;
    461e:	4368      	muls	r0, r5
                As = As / As_max;                        
    4620:	4b27      	ldr	r3, [pc, #156]	; (46c0 <scc_read_battery+0x18c>)
    4622:	4798      	blx	r3
                sysval.scc_socc[s] = (uint8_t)As;
    4624:	1937      	adds	r7, r6, r4
    4626:	3745      	adds	r7, #69	; 0x45
    4628:	7038      	strb	r0, [r7, #0]
                //uart_print(0,"[%d] SoCC=%d\n\r",s,sysval.scc_socc[s]);
            }
            sysval.scc_sysstate[s] |= 0x80; //communication was OK
    462a:	2380      	movs	r3, #128	; 0x80
    462c:	1934      	adds	r4, r6, r4
    462e:	342d      	adds	r4, #45	; 0x2d
    4630:	7822      	ldrb	r2, [r4, #0]
    4632:	425b      	negs	r3, r3
    4634:	4313      	orrs	r3, r2
    4636:	7023      	strb	r3, [r4, #0]
            scc_errors=0;
    4638:	2300      	movs	r3, #0
        } else {
            sysval.scc_sysstate[s] |= 0x40; //communication was ERROR
            scc_errors++;
    463a:	4a1a      	ldr	r2, [pc, #104]	; (46a4 <scc_read_battery+0x170>)
    463c:	7153      	strb	r3, [r2, #5]
        }
    } else {
        sysval.scc_sysstate[s] |= 0x20; //communication was ERROR
        scc_errors++;
    }
    if(scc_errors) {
    463e:	4b19      	ldr	r3, [pc, #100]	; (46a4 <scc_read_battery+0x170>)
        int i;
        uart_print(0,"scc i2c error:");
        for(i=0;i<16;i++) uart_print(0,"[%x]",i2c_data[i]);
        uart_print(0,"\n\r");
        return 0; 
    } else return 1;
    4640:	2501      	movs	r5, #1
    if(scc_errors) {
    4642:	795b      	ldrb	r3, [r3, #5]
    4644:	2b00      	cmp	r3, #0
    4646:	d010      	beq.n	466a <scc_read_battery+0x136>
        uart_print(0,"scc i2c error:");
    4648:	491e      	ldr	r1, [pc, #120]	; (46c4 <scc_read_battery+0x190>)
    464a:	2000      	movs	r0, #0
    464c:	4d13      	ldr	r5, [pc, #76]	; (469c <scc_read_battery+0x168>)
    464e:	47a8      	blx	r5
        for(i=0;i<16;i++) uart_print(0,"[%x]",i2c_data[i]);
    4650:	2400      	movs	r4, #0
    4652:	ab06      	add	r3, sp, #24
    4654:	5ce2      	ldrb	r2, [r4, r3]
    4656:	491c      	ldr	r1, [pc, #112]	; (46c8 <scc_read_battery+0x194>)
    4658:	2000      	movs	r0, #0
    465a:	3401      	adds	r4, #1
    465c:	47a8      	blx	r5
    465e:	2c10      	cmp	r4, #16
    4660:	d1f7      	bne.n	4652 <scc_read_battery+0x11e>
        uart_print(0,"\n\r");
    4662:	491a      	ldr	r1, [pc, #104]	; (46cc <scc_read_battery+0x198>)
    4664:	2000      	movs	r0, #0
    4666:	47a8      	blx	r5
        return 0; 
    4668:	2500      	movs	r5, #0
}
    466a:	0028      	movs	r0, r5
    466c:	b00b      	add	sp, #44	; 0x2c
    466e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            sysval.scc_sysstate[s] |= 0x40; //communication was ERROR
    4670:	4b10      	ldr	r3, [pc, #64]	; (46b4 <scc_read_battery+0x180>)
    4672:	191c      	adds	r4, r3, r4
    4674:	2340      	movs	r3, #64	; 0x40
    4676:	342d      	adds	r4, #45	; 0x2d
    4678:	7822      	ldrb	r2, [r4, #0]
    467a:	4313      	orrs	r3, r2
    467c:	7023      	strb	r3, [r4, #0]
            scc_errors++;
    467e:	4b09      	ldr	r3, [pc, #36]	; (46a4 <scc_read_battery+0x170>)
    4680:	795b      	ldrb	r3, [r3, #5]
    4682:	3301      	adds	r3, #1
    4684:	e7d9      	b.n	463a <scc_read_battery+0x106>
        sysval.scc_sysstate[s] |= 0x20; //communication was ERROR
    4686:	9b02      	ldr	r3, [sp, #8]
    4688:	781a      	ldrb	r2, [r3, #0]
    468a:	2320      	movs	r3, #32
    468c:	4313      	orrs	r3, r2
    468e:	9a02      	ldr	r2, [sp, #8]
    4690:	7013      	strb	r3, [r2, #0]
        scc_errors++;
    4692:	797b      	ldrb	r3, [r7, #5]
    4694:	3301      	adds	r3, #1
    4696:	717b      	strb	r3, [r7, #5]
    4698:	e7d1      	b.n	463e <scc_read_battery+0x10a>
    469a:	46c0      	nop			; (mov r8, r8)
    469c:	00007b99 	.word	0x00007b99
    46a0:	0000ac53 	.word	0x0000ac53
    46a4:	2000052a 	.word	0x2000052a
    46a8:	00007795 	.word	0x00007795
    46ac:	00007c05 	.word	0x00007c05
    46b0:	00008957 	.word	0x00008957
    46b4:	20000a58 	.word	0x20000a58
    46b8:	00007935 	.word	0x00007935
    46bc:	0000ac6a 	.word	0x0000ac6a
    46c0:	00007f89 	.word	0x00007f89
    46c4:	0000abb1 	.word	0x0000abb1
    46c8:	0000abc0 	.word	0x0000abc0
    46cc:	0000a6f2 	.word	0x0000a6f2

000046d0 <scc_monitor_dump>:
    }    
    scc_monitor_dump(NULL,0);
}

uint16_t scc_monitor_dump(char *output_buf, int part)
{
    46d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    46d2:	0005      	movs	r5, r0
    46d4:	000c      	movs	r4, r1
    uint16_t len=0;
    uint8_t i2c_sla,s;
    
    if(output_buf==NULL) {
    46d6:	2800      	cmp	r0, #0
    46d8:	d000      	beq.n	46dc <scc_monitor_dump+0xc>
    46da:	e0c5      	b.n	4868 <scc_monitor_dump+0x198>
        if(part==0) {
    46dc:	2900      	cmp	r1, #0
    46de:	d000      	beq.n	46e2 <scc_monitor_dump+0x12>
    46e0:	e089      	b.n	47f6 <scc_monitor_dump+0x126>
            uart_print(0,"\r\nSCC:    system battst solst SoC   Vpv  Icharge  Vbatt  Iload temp loadstate");
    46e2:	49dc      	ldr	r1, [pc, #880]	; (4a54 <scc_monitor_dump+0x384>)
    46e4:	0020      	movs	r0, r4
    46e6:	4ddc      	ldr	r5, [pc, #880]	; (4a58 <scc_monitor_dump+0x388>)
    46e8:	47a8      	blx	r5
            uart_print(0,"\r\n--------------+------+-----+---+------+--------+-----+------+----+---------");
    46ea:	49dc      	ldr	r1, [pc, #880]	; (4a5c <scc_monitor_dump+0x38c>)
    46ec:	0020      	movs	r0, r4
    46ee:	47a8      	blx	r5
            for(s=0;s<sysval.scc_nof_scc;s++) {
    46f0:	4edb      	ldr	r6, [pc, #876]	; (4a60 <scc_monitor_dump+0x390>)
    46f2:	0033      	movs	r3, r6
    46f4:	332c      	adds	r3, #44	; 0x2c
    46f6:	781b      	ldrb	r3, [r3, #0]
    46f8:	42a3      	cmp	r3, r4
    46fa:	d806      	bhi.n	470a <scc_monitor_dump+0x3a>
                uart_print(0,"    %4d ",sysval.scc_vbatt[s]);
                uart_print(0," %4d ",sysval.scc_iload[s]);
                uart_print(0,"    %2d ",sysval.scc_temp[s]);
                uart_print(0,"%s",loadstate_to_str(sysval.scc_loadstate[s]));
            }
            uart_print(0,"\r\n");
    46fc:	49d9      	ldr	r1, [pc, #868]	; (4a64 <scc_monitor_dump+0x394>)
    46fe:	2000      	movs	r0, #0
    4700:	4bd5      	ldr	r3, [pc, #852]	; (4a58 <scc_monitor_dump+0x388>)
    4702:	4798      	blx	r3
    uint16_t len=0;
    4704:	2600      	movs	r6, #0
            }
            len+=sprintf(&output_buf[len],"\r\n");
        }
    }
    return len;
}
    4706:	0030      	movs	r0, r6
    4708:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                i2c_sla=scc_i2c_addr[s];
    470a:	4bd7      	ldr	r3, [pc, #860]	; (4a68 <scc_monitor_dump+0x398>)
                uart_print(0,"\r\n[%2x]:",i2c_sla);
    470c:	49d7      	ldr	r1, [pc, #860]	; (4a6c <scc_monitor_dump+0x39c>)
                i2c_sla=scc_i2c_addr[s];
    470e:	3301      	adds	r3, #1
                uart_print(0,"\r\n[%2x]:",i2c_sla);
    4710:	5d1a      	ldrb	r2, [r3, r4]
    4712:	2000      	movs	r0, #0
    4714:	47a8      	blx	r5
                uart_print(0,"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    4716:	1933      	adds	r3, r6, r4
    4718:	332d      	adds	r3, #45	; 0x2d
    if(sysstate&0x80) return("OK "); else return("XX ");
    471a:	781b      	ldrb	r3, [r3, #0]
    471c:	4ad4      	ldr	r2, [pc, #848]	; (4a70 <scc_monitor_dump+0x3a0>)
    471e:	2b7f      	cmp	r3, #127	; 0x7f
    4720:	d800      	bhi.n	4724 <scc_monitor_dump+0x54>
    4722:	4ad4      	ldr	r2, [pc, #848]	; (4a74 <scc_monitor_dump+0x3a4>)
                uart_print(0,"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    4724:	4fd4      	ldr	r7, [pc, #848]	; (4a78 <scc_monitor_dump+0x3a8>)
    4726:	2000      	movs	r0, #0
    4728:	0039      	movs	r1, r7
    472a:	47a8      	blx	r5
                uart_print(0,"%s",sysstate_to_str(sysval.scc_sysstate[s]));
    472c:	1933      	adds	r3, r6, r4
    472e:	332d      	adds	r3, #45	; 0x2d
    4730:	7818      	ldrb	r0, [r3, #0]
    4732:	4bd2      	ldr	r3, [pc, #840]	; (4a7c <scc_monitor_dump+0x3ac>)
    4734:	4798      	blx	r3
    4736:	0039      	movs	r1, r7
    4738:	0002      	movs	r2, r0
    473a:	2000      	movs	r0, #0
    473c:	47a8      	blx	r5
                uart_print(0,"%s",battstate_to_str(sysval.scc_battstate[s]));
    473e:	1933      	adds	r3, r6, r4
    4740:	3331      	adds	r3, #49	; 0x31
    4742:	781b      	ldrb	r3, [r3, #0]
    4744:	4ace      	ldr	r2, [pc, #824]	; (4a80 <scc_monitor_dump+0x3b0>)
    4746:	2b03      	cmp	r3, #3
    4748:	d802      	bhi.n	4750 <scc_monitor_dump+0x80>
    474a:	4ace      	ldr	r2, [pc, #824]	; (4a84 <scc_monitor_dump+0x3b4>)
    474c:	009b      	lsls	r3, r3, #2
    474e:	589a      	ldr	r2, [r3, r2]
                uart_print(0,"%s",solarstate_to_str(sysval.scc_solarstate[s]));
    4750:	1936      	adds	r6, r6, r4
                uart_print(0,"%s",battstate_to_str(sysval.scc_battstate[s]));
    4752:	0039      	movs	r1, r7
    4754:	2000      	movs	r0, #0
                uart_print(0,"%s",solarstate_to_str(sysval.scc_solarstate[s]));
    4756:	3635      	adds	r6, #53	; 0x35
                uart_print(0,"%s",battstate_to_str(sysval.scc_battstate[s]));
    4758:	47a8      	blx	r5
                uart_print(0,"%s",solarstate_to_str(sysval.scc_solarstate[s]));
    475a:	7833      	ldrb	r3, [r6, #0]
    475c:	4aca      	ldr	r2, [pc, #808]	; (4a88 <scc_monitor_dump+0x3b8>)
    475e:	2b02      	cmp	r3, #2
    4760:	d803      	bhi.n	476a <scc_monitor_dump+0x9a>
    4762:	4ac8      	ldr	r2, [pc, #800]	; (4a84 <scc_monitor_dump+0x3b4>)
    4764:	009b      	lsls	r3, r3, #2
    4766:	18d3      	adds	r3, r2, r3
    4768:	6a1a      	ldr	r2, [r3, #32]
    476a:	0039      	movs	r1, r7
    476c:	2000      	movs	r0, #0
    476e:	47a8      	blx	r5
                uart_print(0," %3d ",sysval.scc_soc[s]);
    4770:	4ebb      	ldr	r6, [pc, #748]	; (4a60 <scc_monitor_dump+0x390>)
    4772:	49c6      	ldr	r1, [pc, #792]	; (4a8c <scc_monitor_dump+0x3bc>)
    4774:	1933      	adds	r3, r6, r4
    4776:	9300      	str	r3, [sp, #0]
    4778:	3341      	adds	r3, #65	; 0x41
    477a:	781a      	ldrb	r2, [r3, #0]
    477c:	2000      	movs	r0, #0
    477e:	47a8      	blx	r5
                uart_print(0," %4d ",sysval.scc_vpv[s]);
    4780:	0023      	movs	r3, r4
    4782:	3328      	adds	r3, #40	; 0x28
    4784:	4fc2      	ldr	r7, [pc, #776]	; (4a90 <scc_monitor_dump+0x3c0>)
    4786:	005b      	lsls	r3, r3, #1
    4788:	18f3      	adds	r3, r6, r3
    478a:	2206      	movs	r2, #6
    478c:	5e9a      	ldrsh	r2, [r3, r2]
    478e:	0039      	movs	r1, r7
    4790:	2000      	movs	r0, #0
    4792:	47a8      	blx	r5
                uart_print(0," %4d ",sysval.scc_icharge[s]);
    4794:	0023      	movs	r3, r4
    4796:	332c      	adds	r3, #44	; 0x2c
    4798:	005b      	lsls	r3, r3, #1
    479a:	18f3      	adds	r3, r6, r3
    479c:	2206      	movs	r2, #6
    479e:	5e9a      	ldrsh	r2, [r3, r2]
    47a0:	0039      	movs	r1, r7
    47a2:	2000      	movs	r0, #0
    47a4:	47a8      	blx	r5
                uart_print(0,"    %4d ",sysval.scc_vbatt[s]);
    47a6:	0023      	movs	r3, r4
    47a8:	3324      	adds	r3, #36	; 0x24
    47aa:	005b      	lsls	r3, r3, #1
    47ac:	18f3      	adds	r3, r6, r3
    47ae:	2206      	movs	r2, #6
    47b0:	5e9a      	ldrsh	r2, [r3, r2]
    47b2:	49b8      	ldr	r1, [pc, #736]	; (4a94 <scc_monitor_dump+0x3c4>)
    47b4:	2000      	movs	r0, #0
    47b6:	47a8      	blx	r5
                uart_print(0," %4d ",sysval.scc_iload[s]);
    47b8:	0023      	movs	r3, r4
    47ba:	3330      	adds	r3, #48	; 0x30
    47bc:	005b      	lsls	r3, r3, #1
    47be:	18f6      	adds	r6, r6, r3
    47c0:	2306      	movs	r3, #6
    47c2:	5ef2      	ldrsh	r2, [r6, r3]
    47c4:	0039      	movs	r1, r7
    47c6:	2000      	movs	r0, #0
    47c8:	47a8      	blx	r5
                uart_print(0,"    %2d ",sysval.scc_temp[s]);
    47ca:	9b00      	ldr	r3, [sp, #0]
    47cc:	49b2      	ldr	r1, [pc, #712]	; (4a98 <scc_monitor_dump+0x3c8>)
    47ce:	3349      	adds	r3, #73	; 0x49
    47d0:	781a      	ldrb	r2, [r3, #0]
    47d2:	2000      	movs	r0, #0
    47d4:	47a8      	blx	r5
                uart_print(0,"%s",loadstate_to_str(sysval.scc_loadstate[s]));
    47d6:	9b00      	ldr	r3, [sp, #0]
    47d8:	4aa9      	ldr	r2, [pc, #676]	; (4a80 <scc_monitor_dump+0x3b0>)
    47da:	3339      	adds	r3, #57	; 0x39
    47dc:	781b      	ldrb	r3, [r3, #0]
    47de:	2b03      	cmp	r3, #3
    47e0:	d803      	bhi.n	47ea <scc_monitor_dump+0x11a>
    47e2:	4aa8      	ldr	r2, [pc, #672]	; (4a84 <scc_monitor_dump+0x3b4>)
    47e4:	009b      	lsls	r3, r3, #2
    47e6:	18d3      	adds	r3, r2, r3
    47e8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    47ea:	49a3      	ldr	r1, [pc, #652]	; (4a78 <scc_monitor_dump+0x3a8>)
    47ec:	2000      	movs	r0, #0
            for(s=0;s<sysval.scc_nof_scc;s++) {
    47ee:	3401      	adds	r4, #1
                uart_print(0,"%s",loadstate_to_str(sysval.scc_loadstate[s]));
    47f0:	47a8      	blx	r5
            for(s=0;s<sysval.scc_nof_scc;s++) {
    47f2:	b2e4      	uxtb	r4, r4
    47f4:	e77c      	b.n	46f0 <scc_monitor_dump+0x20>
    uint16_t len=0;
    47f6:	0006      	movs	r6, r0
        } else if(part==1) {    
    47f8:	2901      	cmp	r1, #1
    47fa:	d000      	beq.n	47fe <scc_monitor_dump+0x12e>
    47fc:	e783      	b.n	4706 <scc_monitor_dump+0x36>
            uart_print(0,"\r\nSCC:  days  ydayl   Ah   SoCC ");
    47fe:	49a7      	ldr	r1, [pc, #668]	; (4a9c <scc_monitor_dump+0x3cc>)
    4800:	4e95      	ldr	r6, [pc, #596]	; (4a58 <scc_monitor_dump+0x388>)
    4802:	47b0      	blx	r6
            uart_print(0,"\r\n----------+------+------+----+");    
    4804:	49a6      	ldr	r1, [pc, #664]	; (4aa0 <scc_monitor_dump+0x3d0>)
    4806:	0028      	movs	r0, r5
    4808:	47b0      	blx	r6
            for(s=0;s<sysval.scc_nof_scc;s++) {
    480a:	4c95      	ldr	r4, [pc, #596]	; (4a60 <scc_monitor_dump+0x390>)
    480c:	0023      	movs	r3, r4
    480e:	332c      	adds	r3, #44	; 0x2c
    4810:	781b      	ldrb	r3, [r3, #0]
    4812:	42ab      	cmp	r3, r5
    4814:	d800      	bhi.n	4818 <scc_monitor_dump+0x148>
    4816:	e771      	b.n	46fc <scc_monitor_dump+0x2c>
                i2c_sla=scc_i2c_addr[s];
    4818:	4b93      	ldr	r3, [pc, #588]	; (4a68 <scc_monitor_dump+0x398>)
                uart_print(0,"\r\n[%2x]:",i2c_sla);
    481a:	4994      	ldr	r1, [pc, #592]	; (4a6c <scc_monitor_dump+0x39c>)
                i2c_sla=scc_i2c_addr[s];
    481c:	3301      	adds	r3, #1
                uart_print(0,"\r\n[%2x]:",i2c_sla);
    481e:	5d5a      	ldrb	r2, [r3, r5]
    4820:	2000      	movs	r0, #0
    4822:	47b0      	blx	r6
                uart_print(0," %4d",sysval.scc_days[s]);
    4824:	002b      	movs	r3, r5
    4826:	3340      	adds	r3, #64	; 0x40
    4828:	005b      	lsls	r3, r3, #1
    482a:	18e3      	adds	r3, r4, r3
    482c:	88da      	ldrh	r2, [r3, #6]
    482e:	499d      	ldr	r1, [pc, #628]	; (4aa4 <scc_monitor_dump+0x3d4>)
    4830:	2000      	movs	r0, #0
    4832:	47b0      	blx	r6
                uart_print(0,"  %4d",sysval.scc_ydayl[s]);
    4834:	002b      	movs	r3, r5
    4836:	333c      	adds	r3, #60	; 0x3c
    4838:	005b      	lsls	r3, r3, #1
    483a:	18e3      	adds	r3, r4, r3
    483c:	88da      	ldrh	r2, [r3, #6]
    483e:	499a      	ldr	r1, [pc, #616]	; (4aa8 <scc_monitor_dump+0x3d8>)
    4840:	2000      	movs	r0, #0
    4842:	47b0      	blx	r6
                uart_print(0,"  %5d",sysval.scc_Ah[s]);
    4844:	002b      	movs	r3, r5
    4846:	3338      	adds	r3, #56	; 0x38
    4848:	005b      	lsls	r3, r3, #1
    484a:	18e3      	adds	r3, r4, r3
                uart_print(0,"  %3d",sysval.scc_socc[s]);        
    484c:	1964      	adds	r4, r4, r5
                uart_print(0,"  %5d",sysval.scc_Ah[s]);
    484e:	2206      	movs	r2, #6
    4850:	5e9a      	ldrsh	r2, [r3, r2]
    4852:	4996      	ldr	r1, [pc, #600]	; (4aac <scc_monitor_dump+0x3dc>)
    4854:	2000      	movs	r0, #0
                uart_print(0,"  %3d",sysval.scc_socc[s]);        
    4856:	3445      	adds	r4, #69	; 0x45
                uart_print(0,"  %5d",sysval.scc_Ah[s]);
    4858:	47b0      	blx	r6
            for(s=0;s<sysval.scc_nof_scc;s++) {
    485a:	3501      	adds	r5, #1
                uart_print(0,"  %3d",sysval.scc_socc[s]);        
    485c:	7822      	ldrb	r2, [r4, #0]
    485e:	4994      	ldr	r1, [pc, #592]	; (4ab0 <scc_monitor_dump+0x3e0>)
    4860:	2000      	movs	r0, #0
    4862:	47b0      	blx	r6
            for(s=0;s<sysval.scc_nof_scc;s++) {
    4864:	b2ed      	uxtb	r5, r5
    4866:	e7d0      	b.n	480a <scc_monitor_dump+0x13a>
        if(part==0) {
    4868:	2900      	cmp	r1, #0
    486a:	d000      	beq.n	486e <scc_monitor_dump+0x19e>
    486c:	e0ab      	b.n	49c6 <scc_monitor_dump+0x2f6>
            len=sprintf(output_buf,       "\r\nSCC:    system battst solst SoC   Vpv  Icharge  Vbatt  Iload temp loadstat\r\n");
    486e:	264e      	movs	r6, #78	; 0x4e
    4870:	4990      	ldr	r1, [pc, #576]	; (4ab4 <scc_monitor_dump+0x3e4>)
    4872:	4b91      	ldr	r3, [pc, #580]	; (4ab8 <scc_monitor_dump+0x3e8>)
    4874:	4798      	blx	r3
            for(s=0;s<sysval.scc_nof_scc;s++) {
    4876:	9400      	str	r4, [sp, #0]
    4878:	4f79      	ldr	r7, [pc, #484]	; (4a60 <scc_monitor_dump+0x390>)
    487a:	9a00      	ldr	r2, [sp, #0]
    487c:	003b      	movs	r3, r7
    487e:	332c      	adds	r3, #44	; 0x2c
    4880:	781b      	ldrb	r3, [r3, #0]
    4882:	4293      	cmp	r3, r2
    4884:	d806      	bhi.n	4894 <scc_monitor_dump+0x1c4>
            len+=sprintf(&output_buf[len],"\r\n");
    4886:	19a8      	adds	r0, r5, r6
    4888:	4976      	ldr	r1, [pc, #472]	; (4a64 <scc_monitor_dump+0x394>)
    488a:	4b8b      	ldr	r3, [pc, #556]	; (4ab8 <scc_monitor_dump+0x3e8>)
    488c:	3602      	adds	r6, #2
    488e:	4798      	blx	r3
    4890:	b2b6      	uxth	r6, r6
    4892:	e738      	b.n	4706 <scc_monitor_dump+0x36>
                i2c_sla=scc_i2c_addr[s];
    4894:	4b74      	ldr	r3, [pc, #464]	; (4a68 <scc_monitor_dump+0x398>)
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    4896:	9a00      	ldr	r2, [sp, #0]
                i2c_sla=scc_i2c_addr[s];
    4898:	3301      	adds	r3, #1
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    489a:	5c9a      	ldrb	r2, [r3, r2]
    489c:	19a8      	adds	r0, r5, r6
    489e:	4987      	ldr	r1, [pc, #540]	; (4abc <scc_monitor_dump+0x3ec>)
    48a0:	4b87      	ldr	r3, [pc, #540]	; (4ac0 <scc_monitor_dump+0x3f0>)
    48a2:	4798      	blx	r3
                len+=sprintf(&output_buf[len],"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    48a4:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    48a6:	1836      	adds	r6, r6, r0
                len+=sprintf(&output_buf[len],"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    48a8:	18fb      	adds	r3, r7, r3
    48aa:	332d      	adds	r3, #45	; 0x2d
    if(sysstate&0x80) return("OK "); else return("XX ");
    48ac:	781b      	ldrb	r3, [r3, #0]
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    48ae:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len],"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    48b0:	19a8      	adds	r0, r5, r6
    if(sysstate&0x80) return("OK "); else return("XX ");
    48b2:	496f      	ldr	r1, [pc, #444]	; (4a70 <scc_monitor_dump+0x3a0>)
    48b4:	2b7f      	cmp	r3, #127	; 0x7f
    48b6:	d800      	bhi.n	48ba <scc_monitor_dump+0x1ea>
    48b8:	496e      	ldr	r1, [pc, #440]	; (4a74 <scc_monitor_dump+0x3a4>)
                len+=sprintf(&output_buf[len],"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    48ba:	4b7f      	ldr	r3, [pc, #508]	; (4ab8 <scc_monitor_dump+0x3e8>)
    48bc:	4798      	blx	r3
                len+=sprintf(&output_buf[len],"%s",sysstate_to_str(sysval.scc_sysstate[s]));
    48be:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len],"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    48c0:	3603      	adds	r6, #3
                len+=sprintf(&output_buf[len],"%s",sysstate_to_str(sysval.scc_sysstate[s]));
    48c2:	18fb      	adds	r3, r7, r3
    48c4:	9301      	str	r3, [sp, #4]
    48c6:	332d      	adds	r3, #45	; 0x2d
    48c8:	7818      	ldrb	r0, [r3, #0]
    48ca:	4b6c      	ldr	r3, [pc, #432]	; (4a7c <scc_monitor_dump+0x3ac>)
    48cc:	4798      	blx	r3
    48ce:	4c6a      	ldr	r4, [pc, #424]	; (4a78 <scc_monitor_dump+0x3a8>)
                len+=sprintf(&output_buf[len],"%s",sysstate_status_to_str(sysval.scc_sysstate[s]));
    48d0:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len],"%s",sysstate_to_str(sysval.scc_sysstate[s]));
    48d2:	0002      	movs	r2, r0
    48d4:	4b7a      	ldr	r3, [pc, #488]	; (4ac0 <scc_monitor_dump+0x3f0>)
    48d6:	19a8      	adds	r0, r5, r6
    48d8:	0021      	movs	r1, r4
    48da:	4798      	blx	r3
                len+=sprintf(&output_buf[len],"%s",battstate_to_str(sysval.scc_battstate[s]));
    48dc:	9b01      	ldr	r3, [sp, #4]
                len+=sprintf(&output_buf[len],"%s",sysstate_to_str(sysval.scc_sysstate[s]));
    48de:	1830      	adds	r0, r6, r0
                len+=sprintf(&output_buf[len],"%s",battstate_to_str(sysval.scc_battstate[s]));
    48e0:	3331      	adds	r3, #49	; 0x31
    48e2:	781b      	ldrb	r3, [r3, #0]
                len+=sprintf(&output_buf[len],"%s",sysstate_to_str(sysval.scc_sysstate[s]));
    48e4:	b286      	uxth	r6, r0
                len+=sprintf(&output_buf[len],"%s",battstate_to_str(sysval.scc_battstate[s]));
    48e6:	19a8      	adds	r0, r5, r6
    48e8:	4a65      	ldr	r2, [pc, #404]	; (4a80 <scc_monitor_dump+0x3b0>)
    48ea:	2b03      	cmp	r3, #3
    48ec:	d802      	bhi.n	48f4 <scc_monitor_dump+0x224>
    48ee:	4a65      	ldr	r2, [pc, #404]	; (4a84 <scc_monitor_dump+0x3b4>)
    48f0:	009b      	lsls	r3, r3, #2
    48f2:	589a      	ldr	r2, [r3, r2]
    48f4:	4b72      	ldr	r3, [pc, #456]	; (4ac0 <scc_monitor_dump+0x3f0>)
    48f6:	0021      	movs	r1, r4
    48f8:	4798      	blx	r3
                len+=sprintf(&output_buf[len],"%s",solarstate_to_str(sysval.scc_solarstate[s]));
    48fa:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len],"%s",battstate_to_str(sysval.scc_battstate[s]));
    48fc:	1836      	adds	r6, r6, r0
                len+=sprintf(&output_buf[len],"%s",solarstate_to_str(sysval.scc_solarstate[s]));
    48fe:	18ff      	adds	r7, r7, r3
    4900:	3735      	adds	r7, #53	; 0x35
    4902:	783b      	ldrb	r3, [r7, #0]
                len+=sprintf(&output_buf[len],"%s",battstate_to_str(sysval.scc_battstate[s]));
    4904:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len],"%s",solarstate_to_str(sysval.scc_solarstate[s]));
    4906:	19a8      	adds	r0, r5, r6
    4908:	4a5f      	ldr	r2, [pc, #380]	; (4a88 <scc_monitor_dump+0x3b8>)
    490a:	2b02      	cmp	r3, #2
    490c:	d803      	bhi.n	4916 <scc_monitor_dump+0x246>
    490e:	4a5d      	ldr	r2, [pc, #372]	; (4a84 <scc_monitor_dump+0x3b4>)
    4910:	009b      	lsls	r3, r3, #2
    4912:	18d3      	adds	r3, r2, r3
    4914:	6a1a      	ldr	r2, [r3, #32]
    4916:	4f6a      	ldr	r7, [pc, #424]	; (4ac0 <scc_monitor_dump+0x3f0>)
    4918:	0021      	movs	r1, r4
    491a:	47b8      	blx	r7
    491c:	1836      	adds	r6, r6, r0
    491e:	b2b4      	uxth	r4, r6
                len+=sprintf(&output_buf[len]," %3d ",sysval.scc_soc[s]);
    4920:	9b00      	ldr	r3, [sp, #0]
    4922:	4e4f      	ldr	r6, [pc, #316]	; (4a60 <scc_monitor_dump+0x390>)
    4924:	1928      	adds	r0, r5, r4
    4926:	18f3      	adds	r3, r6, r3
    4928:	9301      	str	r3, [sp, #4]
    492a:	3341      	adds	r3, #65	; 0x41
    492c:	781a      	ldrb	r2, [r3, #0]
    492e:	4957      	ldr	r1, [pc, #348]	; (4a8c <scc_monitor_dump+0x3bc>)
    4930:	47b8      	blx	r7
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_vpv[s]);
    4932:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len]," %3d ",sysval.scc_soc[s]);
    4934:	1824      	adds	r4, r4, r0
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_vpv[s]);
    4936:	3328      	adds	r3, #40	; 0x28
    4938:	005b      	lsls	r3, r3, #1
    493a:	18f3      	adds	r3, r6, r3
                len+=sprintf(&output_buf[len]," %3d ",sysval.scc_soc[s]);
    493c:	b2a4      	uxth	r4, r4
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_vpv[s]);
    493e:	2206      	movs	r2, #6
    4940:	5e9a      	ldrsh	r2, [r3, r2]
    4942:	1928      	adds	r0, r5, r4
    4944:	4952      	ldr	r1, [pc, #328]	; (4a90 <scc_monitor_dump+0x3c0>)
    4946:	47b8      	blx	r7
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_icharge[s]);
    4948:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_vpv[s]);
    494a:	1824      	adds	r4, r4, r0
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_icharge[s]);
    494c:	332c      	adds	r3, #44	; 0x2c
    494e:	005b      	lsls	r3, r3, #1
    4950:	18f3      	adds	r3, r6, r3
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_vpv[s]);
    4952:	b2a4      	uxth	r4, r4
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_icharge[s]);
    4954:	2206      	movs	r2, #6
    4956:	5e9a      	ldrsh	r2, [r3, r2]
    4958:	1928      	adds	r0, r5, r4
    495a:	494d      	ldr	r1, [pc, #308]	; (4a90 <scc_monitor_dump+0x3c0>)
    495c:	47b8      	blx	r7
                len+=sprintf(&output_buf[len],"    %4d ",sysval.scc_vbatt[s]);
    495e:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_icharge[s]);
    4960:	1824      	adds	r4, r4, r0
                len+=sprintf(&output_buf[len],"    %4d ",sysval.scc_vbatt[s]);
    4962:	3324      	adds	r3, #36	; 0x24
    4964:	005b      	lsls	r3, r3, #1
    4966:	18f3      	adds	r3, r6, r3
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_icharge[s]);
    4968:	b2a4      	uxth	r4, r4
                len+=sprintf(&output_buf[len],"    %4d ",sysval.scc_vbatt[s]);
    496a:	2206      	movs	r2, #6
    496c:	5e9a      	ldrsh	r2, [r3, r2]
    496e:	1928      	adds	r0, r5, r4
    4970:	4948      	ldr	r1, [pc, #288]	; (4a94 <scc_monitor_dump+0x3c4>)
    4972:	47b8      	blx	r7
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_iload[s]);
    4974:	9b00      	ldr	r3, [sp, #0]
                len+=sprintf(&output_buf[len],"    %4d ",sysval.scc_vbatt[s]);
    4976:	1824      	adds	r4, r4, r0
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_iload[s]);
    4978:	3330      	adds	r3, #48	; 0x30
    497a:	005b      	lsls	r3, r3, #1
    497c:	18f3      	adds	r3, r6, r3
                len+=sprintf(&output_buf[len],"    %4d ",sysval.scc_vbatt[s]);
    497e:	b2a4      	uxth	r4, r4
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_iload[s]);
    4980:	2206      	movs	r2, #6
    4982:	5e9a      	ldrsh	r2, [r3, r2]
    4984:	1928      	adds	r0, r5, r4
    4986:	4942      	ldr	r1, [pc, #264]	; (4a90 <scc_monitor_dump+0x3c0>)
    4988:	47b8      	blx	r7
                len+=sprintf(&output_buf[len],"    %2d ",sysval.scc_temp[s]);
    498a:	9b01      	ldr	r3, [sp, #4]
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_iload[s]);
    498c:	1824      	adds	r4, r4, r0
                len+=sprintf(&output_buf[len],"    %2d ",sysval.scc_temp[s]);
    498e:	3349      	adds	r3, #73	; 0x49
                len+=sprintf(&output_buf[len]," %4d ",sysval.scc_iload[s]);
    4990:	b2a4      	uxth	r4, r4
                len+=sprintf(&output_buf[len],"    %2d ",sysval.scc_temp[s]);
    4992:	781a      	ldrb	r2, [r3, #0]
    4994:	1928      	adds	r0, r5, r4
    4996:	4940      	ldr	r1, [pc, #256]	; (4a98 <scc_monitor_dump+0x3c8>)
    4998:	47b8      	blx	r7
                len+=sprintf(&output_buf[len],"%s\r\n",loadstate_to_str(sysval.scc_loadstate[s]));
    499a:	9b01      	ldr	r3, [sp, #4]
                len+=sprintf(&output_buf[len],"    %2d ",sysval.scc_temp[s]);
    499c:	1824      	adds	r4, r4, r0
                len+=sprintf(&output_buf[len],"%s\r\n",loadstate_to_str(sysval.scc_loadstate[s]));
    499e:	3339      	adds	r3, #57	; 0x39
    49a0:	781b      	ldrb	r3, [r3, #0]
                len+=sprintf(&output_buf[len],"    %2d ",sysval.scc_temp[s]);
    49a2:	b2a4      	uxth	r4, r4
                len+=sprintf(&output_buf[len],"%s\r\n",loadstate_to_str(sysval.scc_loadstate[s]));
    49a4:	1928      	adds	r0, r5, r4
    49a6:	4a36      	ldr	r2, [pc, #216]	; (4a80 <scc_monitor_dump+0x3b0>)
    49a8:	2b03      	cmp	r3, #3
    49aa:	d803      	bhi.n	49b4 <scc_monitor_dump+0x2e4>
    49ac:	4a35      	ldr	r2, [pc, #212]	; (4a84 <scc_monitor_dump+0x3b4>)
    49ae:	009b      	lsls	r3, r3, #2
    49b0:	18d3      	adds	r3, r2, r3
    49b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    49b4:	4943      	ldr	r1, [pc, #268]	; (4ac4 <scc_monitor_dump+0x3f4>)
    49b6:	47b8      	blx	r7
    49b8:	1824      	adds	r4, r4, r0
    49ba:	b2a6      	uxth	r6, r4
            for(s=0;s<sysval.scc_nof_scc;s++) {
    49bc:	9c00      	ldr	r4, [sp, #0]
    49be:	3401      	adds	r4, #1
    49c0:	b2e3      	uxtb	r3, r4
    49c2:	9300      	str	r3, [sp, #0]
    49c4:	e758      	b.n	4878 <scc_monitor_dump+0x1a8>
    uint16_t len=0;
    49c6:	2600      	movs	r6, #0
        } else if(part==1) {
    49c8:	2901      	cmp	r1, #1
    49ca:	d000      	beq.n	49ce <scc_monitor_dump+0x2fe>
    49cc:	e69b      	b.n	4706 <scc_monitor_dump+0x36>
            len=sprintf(output_buf,       "\r\nSCC:  days  ydayl   Ah   SoCC\r\n");
    49ce:	493e      	ldr	r1, [pc, #248]	; (4ac8 <scc_monitor_dump+0x3f8>)
    49d0:	4b39      	ldr	r3, [pc, #228]	; (4ab8 <scc_monitor_dump+0x3e8>)
    49d2:	4798      	blx	r3
            for(s=0;s<sysval.scc_nof_scc;s++) {
    49d4:	0034      	movs	r4, r6
            len=sprintf(output_buf,       "\r\nSCC:  days  ydayl   Ah   SoCC\r\n");
    49d6:	3621      	adds	r6, #33	; 0x21
            for(s=0;s<sysval.scc_nof_scc;s++) {
    49d8:	4b21      	ldr	r3, [pc, #132]	; (4a60 <scc_monitor_dump+0x390>)
    49da:	332c      	adds	r3, #44	; 0x2c
    49dc:	781b      	ldrb	r3, [r3, #0]
    49de:	42a3      	cmp	r3, r4
    49e0:	d800      	bhi.n	49e4 <scc_monitor_dump+0x314>
    49e2:	e750      	b.n	4886 <scc_monitor_dump+0x1b6>
                i2c_sla=scc_i2c_addr[s];
    49e4:	4b20      	ldr	r3, [pc, #128]	; (4a68 <scc_monitor_dump+0x398>)
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    49e6:	4f36      	ldr	r7, [pc, #216]	; (4ac0 <scc_monitor_dump+0x3f0>)
                i2c_sla=scc_i2c_addr[s];
    49e8:	3301      	adds	r3, #1
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    49ea:	5d1a      	ldrb	r2, [r3, r4]
    49ec:	19a8      	adds	r0, r5, r6
    49ee:	4933      	ldr	r1, [pc, #204]	; (4abc <scc_monitor_dump+0x3ec>)
    49f0:	47b8      	blx	r7
                len+=sprintf(&output_buf[len]," %4d",sysval.scc_days[s]);
    49f2:	0023      	movs	r3, r4
    49f4:	4a1a      	ldr	r2, [pc, #104]	; (4a60 <scc_monitor_dump+0x390>)
    49f6:	3340      	adds	r3, #64	; 0x40
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    49f8:	1836      	adds	r6, r6, r0
                len+=sprintf(&output_buf[len]," %4d",sysval.scc_days[s]);
    49fa:	005b      	lsls	r3, r3, #1
    49fc:	18d3      	adds	r3, r2, r3
                len+=sprintf(&output_buf[len],"[%2x]:",i2c_sla);
    49fe:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len]," %4d",sysval.scc_days[s]);
    4a00:	88da      	ldrh	r2, [r3, #6]
    4a02:	19a8      	adds	r0, r5, r6
    4a04:	4927      	ldr	r1, [pc, #156]	; (4aa4 <scc_monitor_dump+0x3d4>)
    4a06:	47b8      	blx	r7
                len+=sprintf(&output_buf[len],"  %4d",sysval.scc_ydayl[s]);
    4a08:	0023      	movs	r3, r4
    4a0a:	4a15      	ldr	r2, [pc, #84]	; (4a60 <scc_monitor_dump+0x390>)
    4a0c:	333c      	adds	r3, #60	; 0x3c
                len+=sprintf(&output_buf[len]," %4d",sysval.scc_days[s]);
    4a0e:	1836      	adds	r6, r6, r0
                len+=sprintf(&output_buf[len],"  %4d",sysval.scc_ydayl[s]);
    4a10:	005b      	lsls	r3, r3, #1
    4a12:	18d3      	adds	r3, r2, r3
                len+=sprintf(&output_buf[len]," %4d",sysval.scc_days[s]);
    4a14:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len],"  %4d",sysval.scc_ydayl[s]);
    4a16:	88da      	ldrh	r2, [r3, #6]
    4a18:	19a8      	adds	r0, r5, r6
    4a1a:	4923      	ldr	r1, [pc, #140]	; (4aa8 <scc_monitor_dump+0x3d8>)
    4a1c:	47b8      	blx	r7
                len+=sprintf(&output_buf[len],"  %5d",sysval.scc_Ah[s]);
    4a1e:	0023      	movs	r3, r4
    4a20:	4a0f      	ldr	r2, [pc, #60]	; (4a60 <scc_monitor_dump+0x390>)
    4a22:	3338      	adds	r3, #56	; 0x38
                len+=sprintf(&output_buf[len],"  %4d",sysval.scc_ydayl[s]);
    4a24:	1836      	adds	r6, r6, r0
                len+=sprintf(&output_buf[len],"  %5d",sysval.scc_Ah[s]);
    4a26:	005b      	lsls	r3, r3, #1
    4a28:	18d3      	adds	r3, r2, r3
                len+=sprintf(&output_buf[len],"  %4d",sysval.scc_ydayl[s]);
    4a2a:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len],"  %5d",sysval.scc_Ah[s]);
    4a2c:	2206      	movs	r2, #6
    4a2e:	5e9a      	ldrsh	r2, [r3, r2]
    4a30:	19a8      	adds	r0, r5, r6
    4a32:	491e      	ldr	r1, [pc, #120]	; (4aac <scc_monitor_dump+0x3dc>)
    4a34:	47b8      	blx	r7
                len+=sprintf(&output_buf[len],"  %3d\r\n",sysval.scc_socc[s]);                
    4a36:	4b0a      	ldr	r3, [pc, #40]	; (4a60 <scc_monitor_dump+0x390>)
                len+=sprintf(&output_buf[len],"  %5d",sysval.scc_Ah[s]);
    4a38:	1836      	adds	r6, r6, r0
                len+=sprintf(&output_buf[len],"  %3d\r\n",sysval.scc_socc[s]);                
    4a3a:	191b      	adds	r3, r3, r4
                len+=sprintf(&output_buf[len],"  %5d",sysval.scc_Ah[s]);
    4a3c:	b2b6      	uxth	r6, r6
                len+=sprintf(&output_buf[len],"  %3d\r\n",sysval.scc_socc[s]);                
    4a3e:	3345      	adds	r3, #69	; 0x45
    4a40:	19a8      	adds	r0, r5, r6
    4a42:	781a      	ldrb	r2, [r3, #0]
    4a44:	4921      	ldr	r1, [pc, #132]	; (4acc <scc_monitor_dump+0x3fc>)
    4a46:	47b8      	blx	r7
            for(s=0;s<sysval.scc_nof_scc;s++) {
    4a48:	3401      	adds	r4, #1
                len+=sprintf(&output_buf[len],"  %3d\r\n",sysval.scc_socc[s]);                
    4a4a:	1836      	adds	r6, r6, r0
    4a4c:	b2b6      	uxth	r6, r6
            for(s=0;s<sysval.scc_nof_scc;s++) {
    4a4e:	b2e4      	uxtb	r4, r4
    4a50:	e7c2      	b.n	49d8 <scc_monitor_dump+0x308>
    4a52:	46c0      	nop			; (mov r8, r8)
    4a54:	0000ac8f 	.word	0x0000ac8f
    4a58:	00007b99 	.word	0x00007b99
    4a5c:	0000acdd 	.word	0x0000acdd
    4a60:	20000a58 	.word	0x20000a58
    4a64:	00009f82 	.word	0x00009f82
    4a68:	2000052a 	.word	0x2000052a
    4a6c:	0000ad2b 	.word	0x0000ad2b
    4a70:	0000aad0 	.word	0x0000aad0
    4a74:	0000aad4 	.word	0x0000aad4
    4a78:	0000ad34 	.word	0x0000ad34
    4a7c:	00003f9d 	.word	0x00003f9d
    4a80:	0000aac8 	.word	0x0000aac8
    4a84:	0000aa8c 	.word	0x0000aa8c
    4a88:	0000aad8 	.word	0x0000aad8
    4a8c:	0000ad37 	.word	0x0000ad37
    4a90:	0000ad40 	.word	0x0000ad40
    4a94:	0000ad3d 	.word	0x0000ad3d
    4a98:	0000ad46 	.word	0x0000ad46
    4a9c:	0000ad4f 	.word	0x0000ad4f
    4aa0:	0000ad70 	.word	0x0000ad70
    4aa4:	0000ad92 	.word	0x0000ad92
    4aa8:	0000ad91 	.word	0x0000ad91
    4aac:	0000ad97 	.word	0x0000ad97
    4ab0:	0000ad9d 	.word	0x0000ad9d
    4ab4:	0000ada3 	.word	0x0000ada3
    4ab8:	00008a2f 	.word	0x00008a2f
    4abc:	0000ad2d 	.word	0x0000ad2d
    4ac0:	00008969 	.word	0x00008969
    4ac4:	0000adf2 	.word	0x0000adf2
    4ac8:	0000adf7 	.word	0x0000adf7
    4acc:	0000ae19 	.word	0x0000ae19

00004ad0 <scc_read_batteries>:
{
    4ad0:	b570      	push	{r4, r5, r6, lr}
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4ad2:	2400      	movs	r4, #0
    4ad4:	4d07      	ldr	r5, [pc, #28]	; (4af4 <scc_read_batteries+0x24>)
    4ad6:	352c      	adds	r5, #44	; 0x2c
    4ad8:	782b      	ldrb	r3, [r5, #0]
    4ada:	42a3      	cmp	r3, r4
    4adc:	d804      	bhi.n	4ae8 <scc_read_batteries+0x18>
    scc_monitor_dump(NULL,1);
    4ade:	2101      	movs	r1, #1
    4ae0:	4b05      	ldr	r3, [pc, #20]	; (4af8 <scc_read_batteries+0x28>)
    4ae2:	2000      	movs	r0, #0
    4ae4:	4798      	blx	r3
}
    4ae6:	bd70      	pop	{r4, r5, r6, pc}
        scc_read_battery(s);
    4ae8:	0020      	movs	r0, r4
    4aea:	4b04      	ldr	r3, [pc, #16]	; (4afc <scc_read_batteries+0x2c>)
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4aec:	3401      	adds	r4, #1
        scc_read_battery(s);
    4aee:	4798      	blx	r3
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4af0:	b2e4      	uxtb	r4, r4
    4af2:	e7f1      	b.n	4ad8 <scc_read_batteries+0x8>
    4af4:	20000a58 	.word	0x20000a58
    4af8:	000046d1 	.word	0x000046d1
    4afc:	00004535 	.word	0x00004535

00004b00 <scc_update_sysval>:
{
    4b00:	49b2      	ldr	r1, [pc, #712]	; (4dcc <scc_update_sysval+0x2cc>)
    4b02:	b5f0      	push	{r4, r5, r6, r7, lr}
    4b04:	000b      	movs	r3, r1
    4b06:	33b6      	adds	r3, #182	; 0xb6
    4b08:	781b      	ldrb	r3, [r3, #0]
    4b0a:	b099      	sub	sp, #100	; 0x64
    4b0c:	930d      	str	r3, [sp, #52]	; 0x34
    4b0e:	000b      	movs	r3, r1
    4b10:	33b5      	adds	r3, #181	; 0xb5
    4b12:	781b      	ldrb	r3, [r3, #0]
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4b14:	0008      	movs	r0, r1
    4b16:	930e      	str	r3, [sp, #56]	; 0x38
    4b18:	000b      	movs	r3, r1
    4b1a:	33b7      	adds	r3, #183	; 0xb7
    4b1c:	781b      	ldrb	r3, [r3, #0]
    4b1e:	302c      	adds	r0, #44	; 0x2c
    4b20:	930f      	str	r3, [sp, #60]	; 0x3c
    4b22:	000b      	movs	r3, r1
    4b24:	33b8      	adds	r3, #184	; 0xb8
    4b26:	781f      	ldrb	r7, [r3, #0]
    4b28:	000b      	movs	r3, r1
    4b2a:	33b9      	adds	r3, #185	; 0xb9
    4b2c:	781d      	ldrb	r5, [r3, #0]
    4b2e:	000b      	movs	r3, r1
    4b30:	33ba      	adds	r3, #186	; 0xba
    4b32:	781b      	ldrb	r3, [r3, #0]
    4b34:	4aa6      	ldr	r2, [pc, #664]	; (4dd0 <scc_update_sysval+0x2d0>)
    4b36:	9310      	str	r3, [sp, #64]	; 0x40
    4b38:	7800      	ldrb	r0, [r0, #0]
    4b3a:	4ba6      	ldr	r3, [pc, #664]	; (4dd4 <scc_update_sysval+0x2d4>)
    4b3c:	302d      	adds	r0, #45	; 0x2d
    4b3e:	1840      	adds	r0, r0, r1
    4b40:	9017      	str	r0, [sp, #92]	; 0x5c
    4b42:	48a5      	ldr	r0, [pc, #660]	; (4dd8 <scc_update_sysval+0x2d8>)
    4b44:	4341      	muls	r1, r0
    4b46:	48a5      	ldr	r0, [pc, #660]	; (4ddc <scc_update_sysval+0x2dc>)
    4b48:	1809      	adds	r1, r1, r0
    4b4a:	2000      	movs	r0, #0
    4b4c:	9116      	str	r1, [sp, #88]	; 0x58
            sysval.scc_daystate[s]   = 0x0;
    4b4e:	0004      	movs	r4, r0
        sysval.load_state &= ~(3<<(s*2)); // reset bit pair
    4b50:	2103      	movs	r1, #3
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4b52:	9011      	str	r0, [sp, #68]	; 0x44
    int32_t pin=0,pout=0, Ah=0;
    4b54:	900c      	str	r0, [sp, #48]	; 0x30
    4b56:	900b      	str	r0, [sp, #44]	; 0x2c
    4b58:	900a      	str	r0, [sp, #40]	; 0x28
    uint16_t ydayl=0;
    4b5a:	9009      	str	r0, [sp, #36]	; 0x24
    int16_t vpv=0, icharge=0, vbatt=0, iload=0, soc=0, socc=0, temp=0;
    4b5c:	9008      	str	r0, [sp, #32]
    4b5e:	9007      	str	r0, [sp, #28]
    4b60:	9006      	str	r0, [sp, #24]
    4b62:	9005      	str	r0, [sp, #20]
    4b64:	9004      	str	r0, [sp, #16]
    4b66:	9003      	str	r0, [sp, #12]
    4b68:	9002      	str	r0, [sp, #8]
    int s,nof_scc=0;
    4b6a:	9001      	str	r0, [sp, #4]
    for(s=0;s<sysval.scc_nof_scc;s++) {
    4b6c:	9e17      	ldr	r6, [sp, #92]	; 0x5c
    4b6e:	429e      	cmp	r6, r3
    4b70:	d000      	beq.n	4b74 <scc_update_sysval+0x74>
    4b72:	e08b      	b.n	4c8c <scc_update_sysval+0x18c>
    4b74:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4b76:	2b00      	cmp	r3, #0
    4b78:	d006      	beq.n	4b88 <scc_update_sysval+0x88>
    4b7a:	466a      	mov	r2, sp
    4b7c:	2140      	movs	r1, #64	; 0x40
    4b7e:	4b93      	ldr	r3, [pc, #588]	; (4dcc <scc_update_sysval+0x2cc>)
    4b80:	1852      	adds	r2, r2, r1
    4b82:	7812      	ldrb	r2, [r2, #0]
    4b84:	33ba      	adds	r3, #186	; 0xba
    4b86:	701a      	strb	r2, [r3, #0]
    4b88:	2800      	cmp	r0, #0
    4b8a:	d01a      	beq.n	4bc2 <scc_update_sysval+0xc2>
    4b8c:	4b8f      	ldr	r3, [pc, #572]	; (4dcc <scc_update_sysval+0x2cc>)
    4b8e:	2034      	movs	r0, #52	; 0x34
    4b90:	4669      	mov	r1, sp
    4b92:	001a      	movs	r2, r3
    4b94:	1809      	adds	r1, r1, r0
    4b96:	7809      	ldrb	r1, [r1, #0]
    4b98:	32b6      	adds	r2, #182	; 0xb6
    4b9a:	7011      	strb	r1, [r2, #0]
    4b9c:	4669      	mov	r1, sp
    4b9e:	001a      	movs	r2, r3
    4ba0:	3004      	adds	r0, #4
    4ba2:	1809      	adds	r1, r1, r0
    4ba4:	7809      	ldrb	r1, [r1, #0]
    4ba6:	32b5      	adds	r2, #181	; 0xb5
    4ba8:	7011      	strb	r1, [r2, #0]
    4baa:	4669      	mov	r1, sp
    4bac:	001a      	movs	r2, r3
    4bae:	3004      	adds	r0, #4
    4bb0:	1809      	adds	r1, r1, r0
    4bb2:	7809      	ldrb	r1, [r1, #0]
    4bb4:	32b7      	adds	r2, #183	; 0xb7
    4bb6:	7011      	strb	r1, [r2, #0]
    4bb8:	001a      	movs	r2, r3
    4bba:	33b9      	adds	r3, #185	; 0xb9
    4bbc:	32b8      	adds	r2, #184	; 0xb8
    4bbe:	7017      	strb	r7, [r2, #0]
    4bc0:	701d      	strb	r5, [r3, #0]
    if(nof_scc>0) {
    4bc2:	9b01      	ldr	r3, [sp, #4]
    4bc4:	2b00      	cmp	r3, #0
    4bc6:	d05b      	beq.n	4c80 <scc_update_sysval+0x180>
        sysval.SoC      = (uint8_t)(soc / nof_scc);  // average
    4bc8:	4c80      	ldr	r4, [pc, #512]	; (4dcc <scc_update_sysval+0x2cc>)
    4bca:	4d85      	ldr	r5, [pc, #532]	; (4de0 <scc_update_sysval+0x2e0>)
    4bcc:	0019      	movs	r1, r3
    4bce:	9806      	ldr	r0, [sp, #24]
    4bd0:	47a8      	blx	r5
    4bd2:	0023      	movs	r3, r4
    4bd4:	33ac      	adds	r3, #172	; 0xac
    4bd6:	7018      	strb	r0, [r3, #0]
        sysval.SoCC     = (uint8_t)(socc / nof_scc);  // average
    4bd8:	9901      	ldr	r1, [sp, #4]
    4bda:	9807      	ldr	r0, [sp, #28]
    4bdc:	47a8      	blx	r5
    4bde:	0023      	movs	r3, r4
    4be0:	33ad      	adds	r3, #173	; 0xad
    4be2:	7018      	strb	r0, [r3, #0]
        sysval.temp     = (uint8_t)(temp / nof_scc); // average
    4be4:	9901      	ldr	r1, [sp, #4]
    4be6:	9808      	ldr	r0, [sp, #32]
    4be8:	47a8      	blx	r5
    4bea:	0023      	movs	r3, r4
    4bec:	33b4      	adds	r3, #180	; 0xb4
    4bee:	7018      	strb	r0, [r3, #0]
        sysval.Vpv      = vpv   / nof_scc; // average
    4bf0:	9901      	ldr	r1, [sp, #4]
    4bf2:	9802      	ldr	r0, [sp, #8]
    4bf4:	47a8      	blx	r5
    4bf6:	0023      	movs	r3, r4
    4bf8:	338e      	adds	r3, #142	; 0x8e
    4bfa:	8018      	strh	r0, [r3, #0]
        sysval.Vbatt    = vbatt / nof_scc; // average
    4bfc:	9901      	ldr	r1, [sp, #4]
    4bfe:	9804      	ldr	r0, [sp, #16]
    4c00:	47a8      	blx	r5
    4c02:	0023      	movs	r3, r4
    4c04:	3390      	adds	r3, #144	; 0x90
    4c06:	8018      	strh	r0, [r3, #0]
        sysval.ydayl    = ydayl / nof_scc; // average
    4c08:	9901      	ldr	r1, [sp, #4]
    4c0a:	9809      	ldr	r0, [sp, #36]	; 0x24
    4c0c:	47a8      	blx	r5
        sysval.Ah       = Ah;      // sum
    4c0e:	0023      	movs	r3, r4
    4c10:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    4c12:	33b0      	adds	r3, #176	; 0xb0
    4c14:	601a      	str	r2, [r3, #0]
        sysval.I_charge = icharge; // sum
    4c16:	466a      	mov	r2, sp
    4c18:	0023      	movs	r3, r4
    4c1a:	8992      	ldrh	r2, [r2, #12]
    4c1c:	3392      	adds	r3, #146	; 0x92
    4c1e:	801a      	strh	r2, [r3, #0]
        sysval.I_load   = iload;   // sum
    4c20:	466a      	mov	r2, sp
    4c22:	0023      	movs	r3, r4
    4c24:	8a92      	ldrh	r2, [r2, #20]
    4c26:	3394      	adds	r3, #148	; 0x94
    4c28:	801a      	strh	r2, [r3, #0]
        pin  += (int32_t)5000;     // integer roundoff +0.5
    4c2a:	4a6e      	ldr	r2, [pc, #440]	; (4de4 <scc_update_sysval+0x2e4>)
    4c2c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4c2e:	4694      	mov	ip, r2
    4c30:	4463      	add	r3, ip
        sysval.ydayl    = ydayl / nof_scc; // average
    4c32:	8160      	strh	r0, [r4, #10]
        sysval.P_in     = pin/(int32_t)10000;  // to Watt
    4c34:	496c      	ldr	r1, [pc, #432]	; (4de8 <scc_update_sysval+0x2e8>)
        pin  += (int32_t)5000;     // integer roundoff +0.5
    4c36:	0018      	movs	r0, r3
        sysval.P_in     = pin/(int32_t)10000;  // to Watt
    4c38:	47a8      	blx	r5
    4c3a:	0023      	movs	r3, r4
        pout += (int32_t)5000;     // integer roundoff +0.5
    4c3c:	4a69      	ldr	r2, [pc, #420]	; (4de4 <scc_update_sysval+0x2e4>)
        sysval.P_in     = pin/(int32_t)10000;  // to Watt
    4c3e:	b206      	sxth	r6, r0
        pout += (int32_t)5000;     // integer roundoff +0.5
    4c40:	4694      	mov	ip, r2
        sysval.P_in     = pin/(int32_t)10000;  // to Watt
    4c42:	339a      	adds	r3, #154	; 0x9a
    4c44:	801e      	strh	r6, [r3, #0]
        pout += (int32_t)5000;     // integer roundoff +0.5
    4c46:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        sysval.P_out    = pout/(int32_t)10000; // to Watt   
    4c48:	4967      	ldr	r1, [pc, #412]	; (4de8 <scc_update_sysval+0x2e8>)
        pout += (int32_t)5000;     // integer roundoff +0.5
    4c4a:	4463      	add	r3, ip
    4c4c:	0018      	movs	r0, r3
        sysval.P_out    = pout/(int32_t)10000; // to Watt   
    4c4e:	47a8      	blx	r5
    4c50:	0023      	movs	r3, r4
    4c52:	b200      	sxth	r0, r0
    4c54:	339c      	adds	r3, #156	; 0x9c
    4c56:	8018      	strh	r0, [r3, #0]
            dt=0;
    4c58:	2300      	movs	r3, #0
        if(sysval.seconds_old==0) {
    4c5a:	6862      	ldr	r2, [r4, #4]
    4c5c:	429a      	cmp	r2, r3
    4c5e:	d002      	beq.n	4c66 <scc_update_sysval+0x166>
            dt=(uint16_t)(sysval.seconds - sysval.seconds_old);
    4c60:	6823      	ldr	r3, [r4, #0]
    4c62:	1a9a      	subs	r2, r3, r2
    4c64:	b293      	uxth	r3, r2
        sysval.seconds_old=sysval.seconds;
    4c66:	6822      	ldr	r2, [r4, #0]
        sysval.Ws_in+=(uint32_t)(sysval.P_in * dt);
    4c68:	435e      	muls	r6, r3
        sysval.seconds_old=sysval.seconds;
    4c6a:	6062      	str	r2, [r4, #4]
        sysval.Ws_in+=(uint32_t)(sysval.P_in * dt);
    4c6c:	0022      	movs	r2, r4
    4c6e:	32a0      	adds	r2, #160	; 0xa0
    4c70:	6811      	ldr	r1, [r2, #0]
        sysval.Ws_out+=(uint32_t)(sysval.P_out * dt);
    4c72:	4343      	muls	r3, r0
    4c74:	34a4      	adds	r4, #164	; 0xa4
        sysval.Ws_in+=(uint32_t)(sysval.P_in * dt);
    4c76:	198e      	adds	r6, r1, r6
    4c78:	6016      	str	r6, [r2, #0]
        sysval.Ws_out+=(uint32_t)(sysval.P_out * dt);
    4c7a:	6822      	ldr	r2, [r4, #0]
    4c7c:	18d3      	adds	r3, r2, r3
    4c7e:	6023      	str	r3, [r4, #0]
    scc_monitor_dump(NULL,0);
    4c80:	2100      	movs	r1, #0
    4c82:	4b5a      	ldr	r3, [pc, #360]	; (4dec <scc_update_sysval+0x2ec>)
    4c84:	0008      	movs	r0, r1
    4c86:	4798      	blx	r3
}
    4c88:	b019      	add	sp, #100	; 0x64
    4c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4c8c:	9816      	ldr	r0, [sp, #88]	; 0x58
    4c8e:	18c0      	adds	r0, r0, r3
    4c90:	0040      	lsls	r0, r0, #1
    4c92:	4684      	mov	ip, r0
        sysval.load_state &= ~(3<<(s*2)); // reset bit pair
    4c94:	0008      	movs	r0, r1
    4c96:	4666      	mov	r6, ip
    4c98:	40b0      	lsls	r0, r6
    4c9a:	43c0      	mvns	r0, r0
    4c9c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    4c9e:	b240      	sxtb	r0, r0
    4ca0:	4006      	ands	r6, r0
    4ca2:	b276      	sxtb	r6, r6
    4ca4:	9612      	str	r6, [sp, #72]	; 0x48
        sysval.solar_state &= ~(3<<(s*2)); // reset bit pair
    4ca6:	9e0e      	ldr	r6, [sp, #56]	; 0x38
        sysval.day_state &= ~(3<<(s*2)); // reset bit pair
    4ca8:	4005      	ands	r5, r0
        sysval.solar_state &= ~(3<<(s*2)); // reset bit pair
    4caa:	4006      	ands	r6, r0
    4cac:	b276      	sxtb	r6, r6
    4cae:	9613      	str	r6, [sp, #76]	; 0x4c
        sysval.batt_state &= ~(3<<(s*2)); // reset bit pair
    4cb0:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
        sysval.sys_state &= ~(3<<(s*2)); // reset bit pair
    4cb2:	4007      	ands	r7, r0
        sysval.batt_state &= ~(3<<(s*2)); // reset bit pair
    4cb4:	4006      	ands	r6, r0
        sysval.day_state &= ~(3<<(s*2)); // reset bit pair
    4cb6:	b268      	sxtb	r0, r5
        sysval.batt_state &= ~(3<<(s*2)); // reset bit pair
    4cb8:	b276      	sxtb	r6, r6
        sysval.day_state &= ~(3<<(s*2)); // reset bit pair
    4cba:	9015      	str	r0, [sp, #84]	; 0x54
        if(sysval.scc_sysstate[s] & 0x80) { // valid SCC?
    4cbc:	7818      	ldrb	r0, [r3, #0]
        sysval.batt_state &= ~(3<<(s*2)); // reset bit pair
    4cbe:	960f      	str	r6, [sp, #60]	; 0x3c
        sysval.sys_state &= ~(3<<(s*2)); // reset bit pair
    4cc0:	b27e      	sxtb	r6, r7
    4cc2:	9614      	str	r6, [sp, #80]	; 0x50
    4cc4:	001d      	movs	r5, r3
        if(sysval.scc_sysstate[s] & 0x80) { // valid SCC?
    4cc6:	287f      	cmp	r0, #127	; 0x7f
    4cc8:	d970      	bls.n	4dac <scc_update_sysval+0x2ac>
            nof_scc++;
    4cca:	9801      	ldr	r0, [sp, #4]
            soc     += (int16_t)sysval.scc_soc[s];
    4ccc:	9e06      	ldr	r6, [sp, #24]
            nof_scc++;
    4cce:	3001      	adds	r0, #1
    4cd0:	9001      	str	r0, [sp, #4]
            soc     += (int16_t)sysval.scc_soc[s];
    4cd2:	7d18      	ldrb	r0, [r3, #20]
            vbatt   += sysval.scc_vbatt[s];
    4cd4:	9f04      	ldr	r7, [sp, #16]
            soc     += (int16_t)sysval.scc_soc[s];
    4cd6:	1980      	adds	r0, r0, r6
    4cd8:	b200      	sxth	r0, r0
            socc    += (int16_t)sysval.scc_socc[s];
    4cda:	9e07      	ldr	r6, [sp, #28]
            soc     += (int16_t)sysval.scc_soc[s];
    4cdc:	9006      	str	r0, [sp, #24]
            socc    += (int16_t)sysval.scc_socc[s];
    4cde:	7e18      	ldrb	r0, [r3, #24]
    4ce0:	1980      	adds	r0, r0, r6
    4ce2:	b200      	sxth	r0, r0
            temp    += (int16_t)sysval.scc_temp[s];
    4ce4:	9e08      	ldr	r6, [sp, #32]
            socc    += (int16_t)sysval.scc_socc[s];
    4ce6:	9007      	str	r0, [sp, #28]
            temp    += (int16_t)sysval.scc_temp[s];
    4ce8:	7f18      	ldrb	r0, [r3, #28]
    4cea:	1980      	adds	r0, r0, r6
    4cec:	b200      	sxth	r0, r0
            vpv     += sysval.scc_vpv[s];
    4cee:	9e02      	ldr	r6, [sp, #8]
            temp    += (int16_t)sysval.scc_temp[s];
    4cf0:	9008      	str	r0, [sp, #32]
            vpv     += sysval.scc_vpv[s];
    4cf2:	8910      	ldrh	r0, [r2, #8]
    4cf4:	1980      	adds	r0, r0, r6
    4cf6:	b200      	sxth	r0, r0
    4cf8:	9002      	str	r0, [sp, #8]
            icharge += sysval.scc_icharge[s];
    4cfa:	2010      	movs	r0, #16
    4cfc:	5e16      	ldrsh	r6, [r2, r0]
    4cfe:	9803      	ldr	r0, [sp, #12]
    4d00:	960e      	str	r6, [sp, #56]	; 0x38
    4d02:	1830      	adds	r0, r6, r0
    4d04:	b200      	sxth	r0, r0
    4d06:	9003      	str	r0, [sp, #12]
            vbatt   += sysval.scc_vbatt[s];
    4d08:	2000      	movs	r0, #0
    4d0a:	5e16      	ldrsh	r6, [r2, r0]
    4d0c:	19f7      	adds	r7, r6, r7
    4d0e:	b23f      	sxth	r7, r7
    4d10:	9704      	str	r7, [sp, #16]
            iload   += sysval.scc_iload[s];
    4d12:	2018      	movs	r0, #24
    4d14:	5e17      	ldrsh	r7, [r2, r0]
    4d16:	9805      	ldr	r0, [sp, #20]
            vbatt   += sysval.scc_vbatt[s];
    4d18:	960d      	str	r6, [sp, #52]	; 0x34
            iload   += sysval.scc_iload[s];
    4d1a:	1838      	adds	r0, r7, r0
    4d1c:	b200      	sxth	r0, r0
    4d1e:	9005      	str	r0, [sp, #20]
            pin     += ((int32_t)sysval.scc_vbatt[s] * (int32_t)sysval.scc_icharge[s]);
    4d20:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    4d22:	980d      	ldr	r0, [sp, #52]	; 0x34
    4d24:	4346      	muls	r6, r0
    4d26:	980a      	ldr	r0, [sp, #40]	; 0x28
    4d28:	1980      	adds	r0, r0, r6
    4d2a:	900a      	str	r0, [sp, #40]	; 0x28
            pout    += ((int32_t)sysval.scc_vbatt[s] * (int32_t)sysval.scc_iload[s]);
    4d2c:	980d      	ldr	r0, [sp, #52]	; 0x34
    4d2e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    4d30:	4378      	muls	r0, r7
    4d32:	1830      	adds	r0, r6, r0
    4d34:	900b      	str	r0, [sp, #44]	; 0x2c
            Ah      += (int32_t)sysval.scc_Ah[s];
    4d36:	2628      	movs	r6, #40	; 0x28
    4d38:	5f90      	ldrsh	r0, [r2, r6]
    4d3a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    4d3c:	1830      	adds	r0, r6, r0
    4d3e:	900c      	str	r0, [sp, #48]	; 0x30
            sysval.Door_open += sysval.scc_door[s];
    4d40:	9e10      	ldr	r6, [sp, #64]	; 0x40
    4d42:	8c10      	ldrh	r0, [r2, #32]
    4d44:	1830      	adds	r0, r6, r0
    4d46:	b2c0      	uxtb	r0, r0
            ydayl   += sysval.scc_ydayl[s];
    4d48:	9e09      	ldr	r6, [sp, #36]	; 0x24
            sysval.Door_open += sysval.scc_door[s];
    4d4a:	9010      	str	r0, [sp, #64]	; 0x40
            ydayl   += sysval.scc_ydayl[s];
    4d4c:	8e10      	ldrh	r0, [r2, #48]	; 0x30
    4d4e:	1830      	adds	r0, r6, r0
    4d50:	b280      	uxth	r0, r0
    4d52:	9009      	str	r0, [sp, #36]	; 0x24
    4d54:	2001      	movs	r0, #1
    4d56:	9011      	str	r0, [sp, #68]	; 0x44
        sysval.load_state |= ((sysval.scc_loadstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d58:	4660      	mov	r0, ip
    4d5a:	7b2e      	ldrb	r6, [r5, #12]
        sysval.solar_state |= ((sysval.scc_solarstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d5c:	4667      	mov	r7, ip
        sysval.load_state |= ((sysval.scc_loadstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d5e:	400e      	ands	r6, r1
    4d60:	4086      	lsls	r6, r0
    4d62:	9812      	ldr	r0, [sp, #72]	; 0x48
    4d64:	3301      	adds	r3, #1
    4d66:	4330      	orrs	r0, r6
        sysval.solar_state |= ((sysval.scc_solarstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d68:	7a2e      	ldrb	r6, [r5, #8]
        sysval.load_state |= ((sysval.scc_loadstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d6a:	b2c0      	uxtb	r0, r0
        sysval.solar_state |= ((sysval.scc_solarstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d6c:	400e      	ands	r6, r1
    4d6e:	40be      	lsls	r6, r7
    4d70:	9f13      	ldr	r7, [sp, #76]	; 0x4c
        sysval.load_state |= ((sysval.scc_loadstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d72:	900d      	str	r0, [sp, #52]	; 0x34
        sysval.solar_state |= ((sysval.scc_solarstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d74:	4337      	orrs	r7, r6
    4d76:	b2fe      	uxtb	r6, r7
        sysval.batt_state |= ((sysval.scc_battstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d78:	4667      	mov	r7, ip
        sysval.solar_state |= ((sysval.scc_solarstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d7a:	960e      	str	r6, [sp, #56]	; 0x38
        sysval.batt_state |= ((sysval.scc_battstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d7c:	792e      	ldrb	r6, [r5, #4]
    4d7e:	3202      	adds	r2, #2
    4d80:	400e      	ands	r6, r1
    4d82:	40be      	lsls	r6, r7
    4d84:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    4d86:	2001      	movs	r0, #1
    4d88:	4337      	orrs	r7, r6
    4d8a:	b2fe      	uxtb	r6, r7
    4d8c:	960f      	str	r6, [sp, #60]	; 0x3c
        sysval.sys_state |= ((sysval.scc_sysstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d8e:	4666      	mov	r6, ip
    4d90:	782f      	ldrb	r7, [r5, #0]
        sysval.day_state |= ((sysval.scc_daystate[s]&0x3)<<(s*2)); // fill in bit pair
    4d92:	7c2d      	ldrb	r5, [r5, #16]
        sysval.sys_state |= ((sysval.scc_sysstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d94:	400f      	ands	r7, r1
    4d96:	40b7      	lsls	r7, r6
    4d98:	9e14      	ldr	r6, [sp, #80]	; 0x50
        sysval.day_state |= ((sysval.scc_daystate[s]&0x3)<<(s*2)); // fill in bit pair
    4d9a:	400d      	ands	r5, r1
        sysval.sys_state |= ((sysval.scc_sysstate[s]&0x3)<<(s*2)); // fill in bit pair
    4d9c:	433e      	orrs	r6, r7
    4d9e:	b2f7      	uxtb	r7, r6
        sysval.day_state |= ((sysval.scc_daystate[s]&0x3)<<(s*2)); // fill in bit pair
    4da0:	4666      	mov	r6, ip
    4da2:	40b5      	lsls	r5, r6
    4da4:	9e15      	ldr	r6, [sp, #84]	; 0x54
    4da6:	432e      	orrs	r6, r5
    4da8:	b2f5      	uxtb	r5, r6
    4daa:	e6df      	b.n	4b6c <scc_update_sysval+0x6c>
            sysval.scc_loadstate[s] = 0x2;
    4dac:	2002      	movs	r0, #2
            sysval.scc_solarstate[s] = 0x3;
    4dae:	7219      	strb	r1, [r3, #8]
            sysval.scc_loadstate[s] = 0x2;
    4db0:	7318      	strb	r0, [r3, #12]
            sysval.scc_battstate[s]  = 0x3;
    4db2:	7119      	strb	r1, [r3, #4]
            sysval.scc_sysstate[s]   = 0x3;
    4db4:	7019      	strb	r1, [r3, #0]
            sysval.scc_daystate[s]   = 0x0;
    4db6:	741c      	strb	r4, [r3, #16]
            sysval.scc_soc[s]=0;
    4db8:	751c      	strb	r4, [r3, #20]
            sysval.scc_socc[s]=0;
    4dba:	761c      	strb	r4, [r3, #24]
            sysval.scc_temp[s]=0;
    4dbc:	771c      	strb	r4, [r3, #28]
            sysval.scc_vpv[s]=0;
    4dbe:	8114      	strh	r4, [r2, #8]
            sysval.scc_icharge[s]=0;
    4dc0:	8214      	strh	r4, [r2, #16]
            sysval.scc_vbatt[s]=0;
    4dc2:	8014      	strh	r4, [r2, #0]
            sysval.scc_iload[s]=0;
    4dc4:	8314      	strh	r4, [r2, #24]
            sysval.scc_ydayl[s]=0;
    4dc6:	8614      	strh	r4, [r2, #48]	; 0x30
    4dc8:	e7c6      	b.n	4d58 <scc_update_sysval+0x258>
    4dca:	46c0      	nop			; (mov r8, r8)
    4dcc:	20000a58 	.word	0x20000a58
    4dd0:	20000aa6 	.word	0x20000aa6
    4dd4:	20000a85 	.word	0x20000a85
    4dd8:	7fffffff 	.word	0x7fffffff
    4ddc:	7fffffd3 	.word	0x7fffffd3
    4de0:	0000809d 	.word	0x0000809d
    4de4:	00001388 	.word	0x00001388
    4de8:	00002710 	.word	0x00002710
    4dec:	000046d1 	.word	0x000046d1

00004df0 <scc_tasks>:
{
    4df0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    4df2:	b672      	cpsid	i
    sysval.scc_tasklist&=0x7f;    
    4df4:	227f      	movs	r2, #127	; 0x7f
    tasklist=sysval.scc_tasklist;
    4df6:	4d10      	ldr	r5, [pc, #64]	; (4e38 <scc_tasks+0x48>)
    4df8:	7bab      	ldrb	r3, [r5, #14]
    sysval.scc_tasklist&=0x7f;    
    4dfa:	401a      	ands	r2, r3
    4dfc:	73aa      	strb	r2, [r5, #14]
  __ASM volatile ("cpsie i" : : : "memory");
    4dfe:	b662      	cpsie	i
    if(tasklist & 0x80) { // task allowed to run
    4e00:	b25b      	sxtb	r3, r3
    4e02:	2b00      	cmp	r3, #0
    4e04:	da05      	bge.n	4e12 <scc_tasks+0x22>
        if(scc_do_probe) {
    4e06:	4b0d      	ldr	r3, [pc, #52]	; (4e3c <scc_tasks+0x4c>)
    4e08:	781e      	ldrb	r6, [r3, #0]
    4e0a:	2e00      	cmp	r6, #0
    4e0c:	d002      	beq.n	4e14 <scc_tasks+0x24>
            scc_probe();
    4e0e:	4b0c      	ldr	r3, [pc, #48]	; (4e40 <scc_tasks+0x50>)
    4e10:	4798      	blx	r3
}
    4e12:	bd70      	pop	{r4, r5, r6, pc}
    subtask=sysval.scc_taskidx;
    4e14:	7bec      	ldrb	r4, [r5, #15]
        scc_monitor(subtask);
    4e16:	4b0b      	ldr	r3, [pc, #44]	; (4e44 <scc_tasks+0x54>)
    4e18:	0020      	movs	r0, r4
    4e1a:	4798      	blx	r3
        scc_update_sysval(); 
    4e1c:	4b0a      	ldr	r3, [pc, #40]	; (4e48 <scc_tasks+0x58>)
    4e1e:	4798      	blx	r3
        if(subtask>=sysval.scc_nof_scc) sysval.scc_taskidx=0; else sysval.scc_taskidx=subtask;
    4e20:	002b      	movs	r3, r5
    4e22:	332c      	adds	r3, #44	; 0x2c
        subtask++;
    4e24:	3401      	adds	r4, #1
        if(subtask>=sysval.scc_nof_scc) sysval.scc_taskidx=0; else sysval.scc_taskidx=subtask;
    4e26:	781b      	ldrb	r3, [r3, #0]
        subtask++;
    4e28:	b2e4      	uxtb	r4, r4
        if(subtask>=sysval.scc_nof_scc) sysval.scc_taskidx=0; else sysval.scc_taskidx=subtask;
    4e2a:	42a3      	cmp	r3, r4
    4e2c:	d801      	bhi.n	4e32 <scc_tasks+0x42>
    4e2e:	73ee      	strb	r6, [r5, #15]
    4e30:	e7ef      	b.n	4e12 <scc_tasks+0x22>
    4e32:	73ec      	strb	r4, [r5, #15]
    4e34:	e7ed      	b.n	4e12 <scc_tasks+0x22>
    4e36:	46c0      	nop			; (mov r8, r8)
    4e38:	20000a58 	.word	0x20000a58
    4e3c:	2000052a 	.word	0x2000052a
    4e40:	000042d5 	.word	0x000042d5
    4e44:	00003fc5 	.word	0x00003fc5
    4e48:	00004b01 	.word	0x00004b01

00004e4c <HAL_GPIO_SIM_STATUS_PIN_read>:
HAL_GPIO_PIN(SIM_STATUS_PIN,A, 5)
    4e4c:	4b02      	ldr	r3, [pc, #8]	; (4e58 <HAL_GPIO_SIM_STATUS_PIN_read+0xc>)
    4e4e:	6a18      	ldr	r0, [r3, #32]
    4e50:	0680      	lsls	r0, r0, #26
    4e52:	0fc0      	lsrs	r0, r0, #31
    4e54:	4770      	bx	lr
    4e56:	46c0      	nop			; (mov r8, r8)
    4e58:	41004400 	.word	0x41004400

00004e5c <Receive_SIM_Byte>:

unsigned char Receive_SIM_Byte(void)
{
    unsigned char tmptail;
    /* Wait for incoming data */
    while (UART_SIM_RxHead == UART_SIM_RxTail);
    4e5c:	4b05      	ldr	r3, [pc, #20]	; (4e74 <Receive_SIM_Byte+0x18>)
    4e5e:	7819      	ldrb	r1, [r3, #0]
    4e60:	785a      	ldrb	r2, [r3, #1]
    4e62:	4291      	cmp	r1, r2
    4e64:	d0fb      	beq.n	4e5e <Receive_SIM_Byte+0x2>
    /* Calculate buffer index */
    tmptail = (UART_SIM_RxTail + 1) & UART_SIM_RX_BUFFER_MASK;
    4e66:	785a      	ldrb	r2, [r3, #1]
    4e68:	3201      	adds	r2, #1
    4e6a:	b2d2      	uxtb	r2, r2
    /* Store new index */
    UART_SIM_RxTail = tmptail;
    4e6c:	705a      	strb	r2, [r3, #1]
    /* Return data */
    return UART_SIM_RxBuf[tmptail];
    4e6e:	3302      	adds	r3, #2
    4e70:	5c98      	ldrb	r0, [r3, r2]
}
    4e72:	4770      	bx	lr
    4e74:	20000531 	.word	0x20000531

00004e78 <Poll_SIM>:

unsigned char Poll_SIM(void)
{
    return (UART_SIM_RxHead != UART_SIM_RxTail);
    4e78:	4b03      	ldr	r3, [pc, #12]	; (4e88 <Poll_SIM+0x10>)
    4e7a:	7818      	ldrb	r0, [r3, #0]
    4e7c:	785b      	ldrb	r3, [r3, #1]
    4e7e:	1ac0      	subs	r0, r0, r3
    4e80:	1e43      	subs	r3, r0, #1
    4e82:	4198      	sbcs	r0, r3
    4e84:	b2c0      	uxtb	r0, r0
}
    4e86:	4770      	bx	lr
    4e88:	20000531 	.word	0x20000531

00004e8c <SERCOM0_Handler>:
 */
void SERCOM0_Handler(void)
{
   unsigned char data;
   unsigned char tmphead;
   if (SERCOM0->USART.INTFLAG.bit.RXC) {
    4e8c:	4b06      	ldr	r3, [pc, #24]	; (4ea8 <SERCOM0_Handler+0x1c>)
    4e8e:	7b9a      	ldrb	r2, [r3, #14]
    4e90:	0752      	lsls	r2, r2, #29
    4e92:	d508      	bpl.n	4ea6 <SERCOM0_Handler+0x1a>
       data = SERCOM0->USART.DATA.bit.DATA;
       /* Calculate buffer index */ 
       tmphead = (UART_SIM_RxHead + 1) & UART_SIM_RX_BUFFER_MASK;
    4e94:	4a05      	ldr	r2, [pc, #20]	; (4eac <SERCOM0_Handler+0x20>)
       data = SERCOM0->USART.DATA.bit.DATA;
    4e96:	8b19      	ldrh	r1, [r3, #24]
       tmphead = (UART_SIM_RxHead + 1) & UART_SIM_RX_BUFFER_MASK;
    4e98:	7813      	ldrb	r3, [r2, #0]
    4e9a:	3301      	adds	r3, #1
    4e9c:	b2db      	uxtb	r3, r3
       /* Store new index */
       UART_SIM_RxHead = tmphead;
    4e9e:	7013      	strb	r3, [r2, #0]
       if (tmphead == UART_SIM_RxTail) {
    4ea0:	7850      	ldrb	r0, [r2, #1]
               /* ERROR! Receive buffer overflow */
       }
       /* Store received data in buffer */
       UART_SIM_RxBuf[tmphead] = data;
    4ea2:	3202      	adds	r2, #2
    4ea4:	54d1      	strb	r1, [r2, r3]
   }
}
    4ea6:	4770      	bx	lr
    4ea8:	42000800 	.word	0x42000800
    4eac:	20000531 	.word	0x20000531

00004eb0 <EIC_Handler>:

void EIC_Handler(void)
{
    if((EIC->INTFLAG.reg & 5) != 0) { // EXTINT0 | EXTINT2
    4eb0:	2205      	movs	r2, #5
{
    4eb2:	b510      	push	{r4, lr}
    if((EIC->INTFLAG.reg & 5) != 0) { // EXTINT0 | EXTINT2
    4eb4:	4b0b      	ldr	r3, [pc, #44]	; (4ee4 <EIC_Handler+0x34>)
    4eb6:	6919      	ldr	r1, [r3, #16]
    4eb8:	4211      	tst	r1, r2
    4eba:	d011      	beq.n	4ee0 <EIC_Handler+0x30>
        EIC->INTFLAG.reg=5;           // clear pin interrupts EXTINT0, EXTINT2
    4ebc:	611a      	str	r2, [r3, #16]
HAL_GPIO_PIN(RC_PIN,    A, 16)
    4ebe:	4b0a      	ldr	r3, [pc, #40]	; (4ee8 <EIC_Handler+0x38>)
    4ec0:	6a1b      	ldr	r3, [r3, #32]
        }
*/
#endif

        // RC_PIN is on EXTINT00
        if(HAL_GPIO_RC_PIN_read()==0 && irrecv_get_irparams_rcvstate()==STATE_IDLE) {
    4ec2:	03db      	lsls	r3, r3, #15
    4ec4:	d40c      	bmi.n	4ee0 <EIC_Handler+0x30>
    4ec6:	4b09      	ldr	r3, [pc, #36]	; (4eec <EIC_Handler+0x3c>)
    4ec8:	4798      	blx	r3
    4eca:	2802      	cmp	r0, #2
    4ecc:	d108      	bne.n	4ee0 <EIC_Handler+0x30>
            TC1->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    4ece:	4b08      	ldr	r3, [pc, #32]	; (4ef0 <EIC_Handler+0x40>)
    4ed0:	881a      	ldrh	r2, [r3, #0]
    4ed2:	4310      	orrs	r0, r2
    4ed4:	2280      	movs	r2, #128	; 0x80
    4ed6:	b280      	uxth	r0, r0
    4ed8:	8018      	strh	r0, [r3, #0]
    4eda:	4b06      	ldr	r3, [pc, #24]	; (4ef4 <EIC_Handler+0x44>)
    4edc:	01d2      	lsls	r2, r2, #7
    4ede:	601a      	str	r2, [r3, #0]
#if (MASTER_PCB_v32==0)
            HAL_GPIO_LED_RED_set();
#endif
        }
    }
}
    4ee0:	bd10      	pop	{r4, pc}
    4ee2:	46c0      	nop			; (mov r8, r8)
    4ee4:	40001800 	.word	0x40001800
    4ee8:	41004400 	.word	0x41004400
    4eec:	00001269 	.word	0x00001269
    4ef0:	42002400 	.word	0x42002400
    4ef4:	e000e100 	.word	0xe000e100

00004ef8 <sim_ri_init>:
    4ef8:	2101      	movs	r1, #1
        NVIC_EnableIRQ(SERCOM0_IRQn);
    }    
}

void sim_ri_init(int8_t onoff)
{
    4efa:	b570      	push	{r4, r5, r6, lr}
    4efc:	240f      	movs	r4, #15
    4efe:	4a26      	ldr	r2, [pc, #152]	; (4f98 <sim_ri_init+0xa0>)


#if (MASTER_PCB_v32==1)

HAL_GPIO_PIN(SIM_RI_PIN,A, 2)
    4f00:	4e26      	ldr	r6, [pc, #152]	; (4f9c <sim_ri_init+0xa4>)
HAL_GPIO_PIN(RC_PIN,    A, 16)
    4f02:	7813      	ldrb	r3, [r2, #0]
    4f04:	4d26      	ldr	r5, [pc, #152]	; (4fa0 <sim_ri_init+0xa8>)
    4f06:	430b      	orrs	r3, r1
    4f08:	7013      	strb	r3, [r2, #0]
    4f0a:	4a26      	ldr	r2, [pc, #152]	; (4fa4 <sim_ri_init+0xac>)
    4f0c:	7813      	ldrb	r3, [r2, #0]
    4f0e:	43a3      	bics	r3, r4
    4f10:	7013      	strb	r3, [r2, #0]
HAL_GPIO_PIN(SIM_RI_PIN,A, 2)
    4f12:	4b25      	ldr	r3, [pc, #148]	; (4fa8 <sim_ri_init+0xb0>)
    4f14:	781a      	ldrb	r2, [r3, #0]
    4f16:	430a      	orrs	r2, r1
    4f18:	701a      	strb	r2, [r3, #0]
    4f1a:	7832      	ldrb	r2, [r6, #0]
    4f1c:	43a2      	bics	r2, r4
    4f1e:	7032      	strb	r2, [r6, #0]
    4f20:	2204      	movs	r2, #4
    4f22:	606a      	str	r2, [r5, #4]
    4f24:	781e      	ldrb	r6, [r3, #0]
    4f26:	3c0d      	subs	r4, #13
    4f28:	4334      	orrs	r4, r6
    4f2a:	701c      	strb	r4, [r3, #0]
    4f2c:	781c      	ldrb	r4, [r3, #0]
    4f2e:	4394      	bics	r4, r2
    4f30:	701c      	strb	r4, [r3, #0]
    4f32:	61aa      	str	r2, [r5, #24]
    4f34:	781c      	ldrb	r4, [r3, #0]
    4f36:	4322      	orrs	r2, r4
    4f38:	701a      	strb	r2, [r3, #0]
    4f3a:	4b1c      	ldr	r3, [pc, #112]	; (4fac <sim_ri_init+0xb4>)
    4f3c:	2240      	movs	r2, #64	; 0x40
#endif
    
    HAL_GPIO_SIM_RI_PIN_in();
    HAL_GPIO_SIM_RI_PIN_pullup();
    
    if(onoff==0) {
    4f3e:	2800      	cmp	r0, #0
    4f40:	d103      	bne.n	4f4a <sim_ri_init+0x52>
        PM->APBAMASK.reg &= ~PM_APBAMASK_EIC;
    4f42:	6999      	ldr	r1, [r3, #24]
    4f44:	4391      	bics	r1, r2
    4f46:	6199      	str	r1, [r3, #24]
        EIC->CONFIG[0].reg = 0x8 | 0x2; // filter | interrupt on falling edge (page 296)
  
        EIC->CTRL.bit.ENABLE=1;
        NVIC_EnableIRQ(EIC_IRQn);  
    }      
}
    4f48:	bd70      	pop	{r4, r5, r6, pc}
        PM->APBAMASK.reg |= PM_APBAMASK_EIC;
    4f4a:	6998      	ldr	r0, [r3, #24]
    4f4c:	4302      	orrs	r2, r0
    4f4e:	619a      	str	r2, [r3, #24]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(GCLK_CLKCTRL_ID_EIC) |
    4f50:	4a17      	ldr	r2, [pc, #92]	; (4fb0 <sim_ri_init+0xb8>)
    4f52:	4b18      	ldr	r3, [pc, #96]	; (4fb4 <sim_ri_init+0xbc>)
    4f54:	805a      	strh	r2, [r3, #2]
        EIC->CTRL.bit.SWRST=1;
    4f56:	4b18      	ldr	r3, [pc, #96]	; (4fb8 <sim_ri_init+0xc0>)
    4f58:	781a      	ldrb	r2, [r3, #0]
    4f5a:	4311      	orrs	r1, r2
    4f5c:	7019      	strb	r1, [r3, #0]
        while (EIC->CTRL.bit.SWRST | EIC->STATUS.bit.SYNCBUSY) { }
    4f5e:	781a      	ldrb	r2, [r3, #0]
    4f60:	7859      	ldrb	r1, [r3, #1]
    4f62:	07d2      	lsls	r2, r2, #31
    4f64:	0fd2      	lsrs	r2, r2, #31
    4f66:	09c9      	lsrs	r1, r1, #7
    4f68:	430a      	orrs	r2, r1
    4f6a:	d1f8      	bne.n	4f5e <sim_ri_init+0x66>
        EIC->EVCTRL.reg |= EIC_EVCTRL_EXTINTEO2;
    4f6c:	2104      	movs	r1, #4
        EIC->EVCTRL.reg = EIC_EVCTRL_EXTINTEO0;
    4f6e:	3201      	adds	r2, #1
    4f70:	605a      	str	r2, [r3, #4]
        EIC->EVCTRL.reg |= EIC_EVCTRL_EXTINTEO2;
    4f72:	6858      	ldr	r0, [r3, #4]
    4f74:	4301      	orrs	r1, r0
    4f76:	6059      	str	r1, [r3, #4]
        EIC->INTENSET.bit.EXTINT0 = 1;
    4f78:	68d9      	ldr	r1, [r3, #12]
    4f7a:	4311      	orrs	r1, r2
    4f7c:	60d9      	str	r1, [r3, #12]
        EIC->WAKEUP.bit.WAKEUPEN0 = 1;
    4f7e:	6959      	ldr	r1, [r3, #20]
    4f80:	430a      	orrs	r2, r1
    4f82:	615a      	str	r2, [r3, #20]
        EIC->CONFIG[0].reg = 0x8 | 0x2; // filter | interrupt on falling edge (page 296)
    4f84:	220a      	movs	r2, #10
    4f86:	619a      	str	r2, [r3, #24]
        EIC->CTRL.bit.ENABLE=1;
    4f88:	7819      	ldrb	r1, [r3, #0]
    4f8a:	3a08      	subs	r2, #8
    4f8c:	430a      	orrs	r2, r1
    4f8e:	701a      	strb	r2, [r3, #0]
    4f90:	2210      	movs	r2, #16
    4f92:	4b0a      	ldr	r3, [pc, #40]	; (4fbc <sim_ri_init+0xc4>)
    4f94:	601a      	str	r2, [r3, #0]
}
    4f96:	e7d7      	b.n	4f48 <sim_ri_init+0x50>
    4f98:	41004450 	.word	0x41004450
    4f9c:	41004431 	.word	0x41004431
    4fa0:	41004400 	.word	0x41004400
    4fa4:	41004438 	.word	0x41004438
    4fa8:	41004442 	.word	0x41004442
    4fac:	40000400 	.word	0x40000400
    4fb0:	00004003 	.word	0x00004003
    4fb4:	40000c00 	.word	0x40000c00
    4fb8:	40001800 	.word	0x40001800
    4fbc:	e000e100 	.word	0xe000e100

00004fc0 <sim_rxflush>:

char sim_rxflush(void)
{
    4fc0:	b570      	push	{r4, r5, r6, lr}
    char ch=0;
#ifdef SIM_DEBUG
    uart_print(0,"\n\rrxflush:");
    4fc2:	490f      	ldr	r1, [pc, #60]	; (5000 <sim_rxflush+0x40>)
    4fc4:	2000      	movs	r0, #0
    4fc6:	4d0f      	ldr	r5, [pc, #60]	; (5004 <sim_rxflush+0x44>)
    4fc8:	47a8      	blx	r5
#endif
    sim_timeout=3;
    4fca:	2303      	movs	r3, #3
    char ch=0;
    4fcc:	2400      	movs	r4, #0
    sim_timeout=3;
    4fce:	4e0e      	ldr	r6, [pc, #56]	; (5008 <sim_rxflush+0x48>)
    4fd0:	7033      	strb	r3, [r6, #0]
    while(sim_timeout>0) {
    4fd2:	7830      	ldrb	r0, [r6, #0]
    4fd4:	2800      	cmp	r0, #0
    4fd6:	d103      	bne.n	4fe0 <sim_rxflush+0x20>
            uart_print(0,"[%x]",ch);
#endif
        }
    }
#ifdef SIM_DEBUG
    uart_print(0,"\n\r");
    4fd8:	490c      	ldr	r1, [pc, #48]	; (500c <sim_rxflush+0x4c>)
    4fda:	47a8      	blx	r5
#endif
    return ch;
}
    4fdc:	0020      	movs	r0, r4
    4fde:	bd70      	pop	{r4, r5, r6, pc}
        delay_ms(10);
    4fe0:	4b0b      	ldr	r3, [pc, #44]	; (5010 <sim_rxflush+0x50>)
    4fe2:	200a      	movs	r0, #10
    4fe4:	4798      	blx	r3
        if(Poll_SIM()) {            
    4fe6:	4b0b      	ldr	r3, [pc, #44]	; (5014 <sim_rxflush+0x54>)
    4fe8:	4798      	blx	r3
    4fea:	2800      	cmp	r0, #0
    4fec:	d0f1      	beq.n	4fd2 <sim_rxflush+0x12>
            ch=Receive_SIM_Byte();
    4fee:	4b0a      	ldr	r3, [pc, #40]	; (5018 <sim_rxflush+0x58>)
    4ff0:	4798      	blx	r3
            uart_print(0,"[%x]",ch);
    4ff2:	490a      	ldr	r1, [pc, #40]	; (501c <sim_rxflush+0x5c>)
            ch=Receive_SIM_Byte();
    4ff4:	0004      	movs	r4, r0
            uart_print(0,"[%x]",ch);
    4ff6:	0002      	movs	r2, r0
    4ff8:	2000      	movs	r0, #0
    4ffa:	47a8      	blx	r5
    4ffc:	e7e9      	b.n	4fd2 <sim_rxflush+0x12>
    4ffe:	46c0      	nop			; (mov r8, r8)
    5000:	0000ae92 	.word	0x0000ae92
    5004:	00007b99 	.word	0x00007b99
    5008:	20000d0b 	.word	0x20000d0b
    500c:	0000a6f2 	.word	0x0000a6f2
    5010:	00007c05 	.word	0x00007c05
    5014:	00004e79 	.word	0x00004e79
    5018:	00004e5d 	.word	0x00004e5d
    501c:	0000abc0 	.word	0x0000abc0

00005020 <sim_read>:
 * returns:
 *  0 if len=0 or 'expect' not found
 * >0 if len>0
 */
uint16_t sim_read(char *sim_bufptr, const char *expect, int timeout_centisec, uint16_t maxlen)
{
    5020:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5022:	0014      	movs	r4, r2
    5024:	9100      	str	r1, [sp, #0]
    5026:	9301      	str	r3, [sp, #4]
    5028:	0006      	movs	r6, r0
    uint16_t len=0;
    char ch=0, found=0;

#ifdef SIM_DEBUG
    uart_print(0,"\n\rsim_read:");
    502a:	4927      	ldr	r1, [pc, #156]	; (50c8 <sim_read+0xa8>)
    502c:	2000      	movs	r0, #0
    502e:	4b27      	ldr	r3, [pc, #156]	; (50cc <sim_read+0xac>)
    5030:	4798      	blx	r3
#endif
    sim_timeout=timeout_centisec;
    5032:	4f27      	ldr	r7, [pc, #156]	; (50d0 <sim_read+0xb0>)
    5034:	703c      	strb	r4, [r7, #0]
    uint16_t len=0;
    5036:	2400      	movs	r4, #0
    while(sim_timeout>0) {
    5038:	783d      	ldrb	r5, [r7, #0]
    503a:	2d00      	cmp	r5, #0
    503c:	d116      	bne.n	506c <sim_read+0x4c>
           if(strstr(sim_bufptr,expect)!=NULL) { found=1; break; }
        } else {
            delay_ms(10);
        }
    }
    if(sim_timeout == 0) {
    503e:	783f      	ldrb	r7, [r7, #0]
    5040:	2f00      	cmp	r7, #0
    5042:	d104      	bne.n	504e <sim_read+0x2e>
       uart_print(0,"sim timeout\n\r");
    5044:	4923      	ldr	r1, [pc, #140]	; (50d4 <sim_read+0xb4>)
    5046:	0038      	movs	r0, r7
    5048:	4b20      	ldr	r3, [pc, #128]	; (50cc <sim_read+0xac>)
    504a:	4798      	blx	r3
       len=0;
    504c:	003c      	movs	r4, r7
    }
    sim_bufptr[len]=0;
    504e:	2700      	movs	r7, #0
    len=strlen(sim_bufptr);
    5050:	0030      	movs	r0, r6
    sim_bufptr[len]=0;
    5052:	5537      	strb	r7, [r6, r4]
    len=strlen(sim_bufptr);
    5054:	4b20      	ldr	r3, [pc, #128]	; (50d8 <sim_read+0xb8>)
    5056:	4798      	blx	r3
    5058:	0004      	movs	r4, r0
     * OK=status, but can also be something else.
     */
#ifdef SIM_DEBUG
    uart_print(0,"\n\rlen=%d\n\r",len);	
#endif
    if(found) {  
    505a:	426d      	negs	r5, r5
    uart_print(0,"\n\rlen=%d\n\r",len);	
    505c:	b282      	uxth	r2, r0
    if(found) {  
    505e:	402c      	ands	r4, r5
    uart_print(0,"\n\rlen=%d\n\r",len);	
    5060:	0038      	movs	r0, r7
    5062:	491e      	ldr	r1, [pc, #120]	; (50dc <sim_read+0xbc>)
    5064:	4b19      	ldr	r3, [pc, #100]	; (50cc <sim_read+0xac>)
    5066:	4798      	blx	r3
        return len;
    } else {
        return 0;
    }
}
    5068:	b2a0      	uxth	r0, r4
    506a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if(len>=(maxlen-1)) break;	 
    506c:	9b01      	ldr	r3, [sp, #4]
    506e:	3b01      	subs	r3, #1
    5070:	429c      	cmp	r4, r3
    5072:	da27      	bge.n	50c4 <sim_read+0xa4>
        if(Poll_SIM()) {           
    5074:	4b1a      	ldr	r3, [pc, #104]	; (50e0 <sim_read+0xc0>)
    5076:	4798      	blx	r3
    5078:	2800      	cmp	r0, #0
    507a:	d01f      	beq.n	50bc <sim_read+0x9c>
           ch = Receive_SIM_Byte();			
    507c:	4b19      	ldr	r3, [pc, #100]	; (50e4 <sim_read+0xc4>)
    507e:	4798      	blx	r3
    5080:	4b12      	ldr	r3, [pc, #72]	; (50cc <sim_read+0xac>)
    5082:	1e05      	subs	r5, r0, #0
           if(ch==0) uart_print(0,"\\0");
    5084:	4918      	ldr	r1, [pc, #96]	; (50e8 <sim_read+0xc8>)
    5086:	d002      	beq.n	508e <sim_read+0x6e>
           else if(ch=='\n') uart_print(0,"\\n");
    5088:	280a      	cmp	r0, #10
    508a:	d10f      	bne.n	50ac <sim_read+0x8c>
    508c:	4917      	ldr	r1, [pc, #92]	; (50ec <sim_read+0xcc>)
    508e:	2000      	movs	r0, #0
    5090:	4798      	blx	r3
           sim_bufptr[len]=0;
    5092:	2300      	movs	r3, #0
           sim_bufptr[len]=ch;
    5094:	5535      	strb	r5, [r6, r4]
           len++;
    5096:	3401      	adds	r4, #1
    5098:	b2a4      	uxth	r4, r4
           sim_bufptr[len]=0;
    509a:	5533      	strb	r3, [r6, r4]
           if(strstr(sim_bufptr,expect)!=NULL) { found=1; break; }
    509c:	9900      	ldr	r1, [sp, #0]
    509e:	0030      	movs	r0, r6
    50a0:	4b13      	ldr	r3, [pc, #76]	; (50f0 <sim_read+0xd0>)
    50a2:	4798      	blx	r3
    50a4:	2800      	cmp	r0, #0
    50a6:	d0c7      	beq.n	5038 <sim_read+0x18>
    50a8:	2501      	movs	r5, #1
    50aa:	e7c8      	b.n	503e <sim_read+0x1e>
           else if(ch=='\r') uart_print(0,"\\r");
    50ac:	4911      	ldr	r1, [pc, #68]	; (50f4 <sim_read+0xd4>)
    50ae:	280d      	cmp	r0, #13
    50b0:	d0ed      	beq.n	508e <sim_read+0x6e>
           else uart_print(0,"%c",ch);
    50b2:	0002      	movs	r2, r0
    50b4:	4910      	ldr	r1, [pc, #64]	; (50f8 <sim_read+0xd8>)
    50b6:	2000      	movs	r0, #0
    50b8:	4798      	blx	r3
    50ba:	e7ea      	b.n	5092 <sim_read+0x72>
            delay_ms(10);
    50bc:	200a      	movs	r0, #10
    50be:	4b0f      	ldr	r3, [pc, #60]	; (50fc <sim_read+0xdc>)
    50c0:	4798      	blx	r3
    50c2:	e7b9      	b.n	5038 <sim_read+0x18>
    char ch=0, found=0;
    50c4:	2500      	movs	r5, #0
    50c6:	e7ba      	b.n	503e <sim_read+0x1e>
    50c8:	0000ae9d 	.word	0x0000ae9d
    50cc:	00007b99 	.word	0x00007b99
    50d0:	20000d0b 	.word	0x20000d0b
    50d4:	0000aeb5 	.word	0x0000aeb5
    50d8:	00008a3f 	.word	0x00008a3f
    50dc:	0000aec3 	.word	0x0000aec3
    50e0:	00004e79 	.word	0x00004e79
    50e4:	00004e5d 	.word	0x00004e5d
    50e8:	0000aea9 	.word	0x0000aea9
    50ec:	0000aeac 	.word	0x0000aeac
    50f0:	00008ae1 	.word	0x00008ae1
    50f4:	0000aeaf 	.word	0x0000aeaf
    50f8:	0000aeb2 	.word	0x0000aeb2
    50fc:	00007c05 	.word	0x00007c05

00005100 <sim_read_multi>:
 * returns:
 *  NULL if none in 'expect' is found
 *  *expect string if that one is found
 */
char * sim_read_multi(char *sim_bufptr, const char *expect[], const int nof_expect, int timeout_centisec, uint16_t maxlen)
{
    5100:	b5f0      	push	{r4, r5, r6, r7, lr}
    5102:	001c      	movs	r4, r3
    5104:	b085      	sub	sp, #20
    5106:	ab0a      	add	r3, sp, #40	; 0x28
    5108:	881b      	ldrh	r3, [r3, #0]
    510a:	9101      	str	r1, [sp, #4]
    510c:	9303      	str	r3, [sp, #12]
    510e:	0006      	movs	r6, r0
    int i;
    char ch=0, found=0;
    char *found_ptr=NULL;

#ifdef SIM_DEBUG
    uart_print(0,"\n\rsim_read_multi:");
    5110:	4b24      	ldr	r3, [pc, #144]	; (51a4 <sim_read_multi+0xa4>)
    5112:	4925      	ldr	r1, [pc, #148]	; (51a8 <sim_read_multi+0xa8>)
    5114:	2000      	movs	r0, #0
{
    5116:	9202      	str	r2, [sp, #8]
    uart_print(0,"\n\rsim_read_multi:");
    5118:	4798      	blx	r3
#endif
    sim_timeout=timeout_centisec;
    511a:	4b24      	ldr	r3, [pc, #144]	; (51ac <sim_read_multi+0xac>)
    511c:	701c      	strb	r4, [r3, #0]
    uint16_t len=0;
    511e:	2400      	movs	r4, #0
    while(sim_timeout>0) {
    5120:	4b22      	ldr	r3, [pc, #136]	; (51ac <sim_read_multi+0xac>)
    5122:	7818      	ldrb	r0, [r3, #0]
    5124:	2800      	cmp	r0, #0
    5126:	d10a      	bne.n	513e <sim_read_multi+0x3e>
            if(found) break;
        } else {
            delay_ms(10);
        }
    }			 
    if(sim_timeout == 0) {
    5128:	4b20      	ldr	r3, [pc, #128]	; (51ac <sim_read_multi+0xac>)
    512a:	781c      	ldrb	r4, [r3, #0]
    512c:	2c00      	cmp	r4, #0
    512e:	d104      	bne.n	513a <sim_read_multi+0x3a>
       uart_print(0,"sim timeout\n\r");
    5130:	0020      	movs	r0, r4
    5132:	491f      	ldr	r1, [pc, #124]	; (51b0 <sim_read_multi+0xb0>)
    5134:	4b1b      	ldr	r3, [pc, #108]	; (51a4 <sim_read_multi+0xa4>)
    5136:	4798      	blx	r3
       found_ptr=NULL;
    5138:	0020      	movs	r0, r4
    }
    return found_ptr;
}
    513a:	b005      	add	sp, #20
    513c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if(len>=(maxlen-1)) break;	 
    513e:	9b03      	ldr	r3, [sp, #12]
    5140:	3b01      	subs	r3, #1
    5142:	429c      	cmp	r4, r3
    5144:	da2c      	bge.n	51a0 <sim_read_multi+0xa0>
        if(Poll_SIM()) {
    5146:	4b1b      	ldr	r3, [pc, #108]	; (51b4 <sim_read_multi+0xb4>)
    5148:	4798      	blx	r3
    514a:	2800      	cmp	r0, #0
    514c:	d024      	beq.n	5198 <sim_read_multi+0x98>
            ch = Receive_SIM_Byte();			
    514e:	4b1a      	ldr	r3, [pc, #104]	; (51b8 <sim_read_multi+0xb8>)
    5150:	4798      	blx	r3
    5152:	4b14      	ldr	r3, [pc, #80]	; (51a4 <sim_read_multi+0xa4>)
    5154:	1e05      	subs	r5, r0, #0
            if(ch==0) uart_print(0,"\\0");
    5156:	4919      	ldr	r1, [pc, #100]	; (51bc <sim_read_multi+0xbc>)
    5158:	d002      	beq.n	5160 <sim_read_multi+0x60>
            else if(ch=='\n') uart_print(0,"\\n");
    515a:	280a      	cmp	r0, #10
    515c:	d114      	bne.n	5188 <sim_read_multi+0x88>
    515e:	4918      	ldr	r1, [pc, #96]	; (51c0 <sim_read_multi+0xc0>)
    5160:	2000      	movs	r0, #0
    5162:	4798      	blx	r3
            sim_bufptr[len]=ch;
    5164:	5535      	strb	r5, [r6, r4]
            sim_bufptr[len]=0;
    5166:	2500      	movs	r5, #0
            len++;
    5168:	3401      	adds	r4, #1
    516a:	b2a4      	uxth	r4, r4
                if((found_ptr=strstr(sim_bufptr,expect[i]))!=NULL) { found=1; break; }
    516c:	4f15      	ldr	r7, [pc, #84]	; (51c4 <sim_read_multi+0xc4>)
            sim_bufptr[len]=0;
    516e:	5535      	strb	r5, [r6, r4]
            for(i=0;i<nof_expect;i++) {
    5170:	9b02      	ldr	r3, [sp, #8]
    5172:	429d      	cmp	r5, r3
    5174:	dad4      	bge.n	5120 <sim_read_multi+0x20>
                if((found_ptr=strstr(sim_bufptr,expect[i]))!=NULL) { found=1; break; }
    5176:	9a01      	ldr	r2, [sp, #4]
    5178:	00ab      	lsls	r3, r5, #2
    517a:	58d1      	ldr	r1, [r2, r3]
    517c:	0030      	movs	r0, r6
    517e:	47b8      	blx	r7
    5180:	2800      	cmp	r0, #0
    5182:	d1d1      	bne.n	5128 <sim_read_multi+0x28>
            for(i=0;i<nof_expect;i++) {
    5184:	3501      	adds	r5, #1
    5186:	e7f3      	b.n	5170 <sim_read_multi+0x70>
            else if(ch=='\r') uart_print(0,"\\r");
    5188:	490f      	ldr	r1, [pc, #60]	; (51c8 <sim_read_multi+0xc8>)
    518a:	280d      	cmp	r0, #13
    518c:	d0e8      	beq.n	5160 <sim_read_multi+0x60>
            else uart_print(0,"%c",ch);
    518e:	0002      	movs	r2, r0
    5190:	490e      	ldr	r1, [pc, #56]	; (51cc <sim_read_multi+0xcc>)
    5192:	2000      	movs	r0, #0
    5194:	4798      	blx	r3
    5196:	e7e5      	b.n	5164 <sim_read_multi+0x64>
            delay_ms(10);
    5198:	200a      	movs	r0, #10
    519a:	4b0d      	ldr	r3, [pc, #52]	; (51d0 <sim_read_multi+0xd0>)
    519c:	4798      	blx	r3
    519e:	e7bf      	b.n	5120 <sim_read_multi+0x20>
    51a0:	2000      	movs	r0, #0
    51a2:	e7c1      	b.n	5128 <sim_read_multi+0x28>
    51a4:	00007b99 	.word	0x00007b99
    51a8:	0000aece 	.word	0x0000aece
    51ac:	20000d0b 	.word	0x20000d0b
    51b0:	0000aeb5 	.word	0x0000aeb5
    51b4:	00004e79 	.word	0x00004e79
    51b8:	00004e5d 	.word	0x00004e5d
    51bc:	0000aea9 	.word	0x0000aea9
    51c0:	0000aeac 	.word	0x0000aeac
    51c4:	00008ae1 	.word	0x00008ae1
    51c8:	0000aeaf 	.word	0x0000aeaf
    51cc:	0000aeb2 	.word	0x0000aeb2
    51d0:	00007c05 	.word	0x00007c05

000051d4 <sim_tx_char>:

void sim_tx_char(char c)
{
    51d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint16_t timeout;
    
    timeout=2000;    
    while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE)) {
    51d6:	25fa      	movs	r5, #250	; 0xfa
{
    51d8:	0004      	movs	r4, r0
    while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE)) {
    51da:	2701      	movs	r7, #1
    51dc:	00ed      	lsls	r5, r5, #3
    51de:	4e17      	ldr	r6, [pc, #92]	; (523c <sim_tx_char+0x68>)
    51e0:	7bb3      	ldrb	r3, [r6, #14]
    51e2:	423b      	tst	r3, r7
    51e4:	d106      	bne.n	51f4 <sim_tx_char+0x20>
    51e6:	3d01      	subs	r5, #1
        delay_us(10);
    51e8:	200a      	movs	r0, #10
    51ea:	4b15      	ldr	r3, [pc, #84]	; (5240 <sim_tx_char+0x6c>)
    51ec:	b2ad      	uxth	r5, r5
    51ee:	4798      	blx	r3
        timeout--;
        if(timeout==0) break;
    51f0:	2d00      	cmp	r5, #0
    51f2:	d1f4      	bne.n	51de <sim_tx_char+0xa>
    while (!(SERCOM0->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE)) {
    51f4:	25fa      	movs	r5, #250	; 0xfa
HAL_GPIO_PIN(SIM_CTS_PIN,   A, 3)
    51f6:	2708      	movs	r7, #8
    51f8:	00ed      	lsls	r5, r5, #3
    51fa:	4b12      	ldr	r3, [pc, #72]	; (5244 <sim_tx_char+0x70>)
    51fc:	6a1b      	ldr	r3, [r3, #32]
    }      
    
    timeout=2000;           
    while (HAL_GPIO_SIM_CTS_PIN_read()==1) {
    51fe:	423b      	tst	r3, r7
    5200:	d006      	beq.n	5210 <sim_tx_char+0x3c>
    5202:	3d01      	subs	r5, #1
       delay_us(10);
    5204:	200a      	movs	r0, #10
    5206:	4b0e      	ldr	r3, [pc, #56]	; (5240 <sim_tx_char+0x6c>)
    5208:	b2ad      	uxth	r5, r5
    520a:	4798      	blx	r3
       timeout--;
       if(timeout==0) break;
    520c:	2d00      	cmp	r5, #0
    520e:	d1f4      	bne.n	51fa <sim_tx_char+0x26>
    }  

    SERCOM0->USART.DATA.reg = c;
    5210:	b2a3      	uxth	r3, r4
    5212:	8333      	strh	r3, [r6, #24]
    5214:	4b0c      	ldr	r3, [pc, #48]	; (5248 <sim_tx_char+0x74>)
#ifdef SIM_DEBUG
    if(c==0) uart_print(0,"\\0");
    5216:	2c00      	cmp	r4, #0
    5218:	d103      	bne.n	5222 <sim_tx_char+0x4e>
    521a:	490c      	ldr	r1, [pc, #48]	; (524c <sim_tx_char+0x78>)
	else if(c=='\n') uart_print(0,"\\n");
	else if(c=='\r') uart_print(0,"\\r");
    521c:	2000      	movs	r0, #0
    521e:	4798      	blx	r3
	else uart_print(0,"%c",c);
#endif
}
    5220:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	else if(c=='\n') uart_print(0,"\\n");
    5222:	490b      	ldr	r1, [pc, #44]	; (5250 <sim_tx_char+0x7c>)
    5224:	2c0a      	cmp	r4, #10
    5226:	d0f9      	beq.n	521c <sim_tx_char+0x48>
	else if(c=='\r') uart_print(0,"\\r");
    5228:	2c0d      	cmp	r4, #13
    522a:	d101      	bne.n	5230 <sim_tx_char+0x5c>
    522c:	4909      	ldr	r1, [pc, #36]	; (5254 <sim_tx_char+0x80>)
    522e:	e7f5      	b.n	521c <sim_tx_char+0x48>
	else uart_print(0,"%c",c);
    5230:	0022      	movs	r2, r4
    5232:	4909      	ldr	r1, [pc, #36]	; (5258 <sim_tx_char+0x84>)
    5234:	2000      	movs	r0, #0
    5236:	4798      	blx	r3
}
    5238:	e7f2      	b.n	5220 <sim_tx_char+0x4c>
    523a:	46c0      	nop			; (mov r8, r8)
    523c:	42000800 	.word	0x42000800
    5240:	00007bf5 	.word	0x00007bf5
    5244:	41004400 	.word	0x41004400
    5248:	00007b99 	.word	0x00007b99
    524c:	0000aea9 	.word	0x0000aea9
    5250:	0000aeac 	.word	0x0000aeac
    5254:	0000aeaf 	.word	0x0000aeaf
    5258:	0000aeb2 	.word	0x0000aeb2

0000525c <sim_tx>:

void sim_tx(const char *buf, int len)
{
    525c:	b570      	push	{r4, r5, r6, lr}
    525e:	0005      	movs	r5, r0
    5260:	000e      	movs	r6, r1
    char c;
    int i;
#ifdef SIM_DEBUG
	uart_print(0,"\n\rsim_write:");
    5262:	2000      	movs	r0, #0
    5264:	4906      	ldr	r1, [pc, #24]	; (5280 <sim_tx+0x24>)
    5266:	4b07      	ldr	r3, [pc, #28]	; (5284 <sim_tx+0x28>)
    5268:	4798      	blx	r3
#endif
    for(i=0;i<len;i++) {
    526a:	002c      	movs	r4, r5
    526c:	1b63      	subs	r3, r4, r5
    526e:	429e      	cmp	r6, r3
    5270:	dc00      	bgt.n	5274 <sim_tx+0x18>
        c=buf[i];
        sim_tx_char(c);
    }
}
    5272:	bd70      	pop	{r4, r5, r6, pc}
        sim_tx_char(c);
    5274:	7820      	ldrb	r0, [r4, #0]
    5276:	4b04      	ldr	r3, [pc, #16]	; (5288 <sim_tx+0x2c>)
    5278:	4798      	blx	r3
    527a:	3401      	adds	r4, #1
    527c:	e7f6      	b.n	526c <sim_tx+0x10>
    527e:	46c0      	nop			; (mov r8, r8)
    5280:	0000aee0 	.word	0x0000aee0
    5284:	00007b99 	.word	0x00007b99
    5288:	000051d5 	.word	0x000051d5

0000528c <phonenr_ok>:

int phonenr_ok(const char *nr)
{
    528c:	b510      	push	{r4, lr}
    int i;
    if(strlen(nr) < SIM_MIN_PHONE_NR_LENGTH) return 0;
    528e:	4b0b      	ldr	r3, [pc, #44]	; (52bc <phonenr_ok+0x30>)
{
    5290:	0004      	movs	r4, r0
    if(strlen(nr) < SIM_MIN_PHONE_NR_LENGTH) return 0;
    5292:	4798      	blx	r3
    5294:	0002      	movs	r2, r0
    5296:	3a0a      	subs	r2, #10
    5298:	2300      	movs	r3, #0
    529a:	2a0a      	cmp	r2, #10
    529c:	d804      	bhi.n	52a8 <phonenr_ok+0x1c>
    529e:	1c63      	adds	r3, r4, #1
    52a0:	1824      	adds	r4, r4, r0
    if(strlen(nr) > SIM_MAX_PHONE_NR_LENGTH) return 0;
    //if(nr[0] != '+') return 0;
    for(i=1;i<strlen(nr);i++) {
    52a2:	42a3      	cmp	r3, r4
    52a4:	d102      	bne.n	52ac <phonenr_ok+0x20>
        if(!isdigit(nr[i])) return 0;
    }
    return 1;
    52a6:	2301      	movs	r3, #1
}
    52a8:	0018      	movs	r0, r3
    52aa:	bd10      	pop	{r4, pc}
        if(!isdigit(nr[i])) return 0;
    52ac:	781a      	ldrb	r2, [r3, #0]
    52ae:	3301      	adds	r3, #1
    52b0:	3a30      	subs	r2, #48	; 0x30
    52b2:	2a09      	cmp	r2, #9
    52b4:	d9f5      	bls.n	52a2 <phonenr_ok+0x16>
    if(strlen(nr) < SIM_MIN_PHONE_NR_LENGTH) return 0;
    52b6:	2300      	movs	r3, #0
    52b8:	e7f6      	b.n	52a8 <phonenr_ok+0x1c>
    52ba:	46c0      	nop			; (mov r8, r8)
    52bc:	00008a3f 	.word	0x00008a3f

000052c0 <sim_send_sms>:

void sim_send_sms(sim_task_t *task)
{
    52c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    return;
}

uint8_t sim_is_on(void)
{
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    52c2:	4b4a      	ldr	r3, [pc, #296]	; (53ec <sim_send_sms+0x12c>)
{
    52c4:	b0c9      	sub	sp, #292	; 0x124
    52c6:	0004      	movs	r4, r0
    uint8_t next_state=task->state;
    52c8:	7945      	ldrb	r5, [r0, #5]
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    52ca:	4798      	blx	r3
    if(!sim_is_on()) {
    52cc:	b2c0      	uxtb	r0, r0
    52ce:	2800      	cmp	r0, #0
    52d0:	d102      	bne.n	52d8 <sim_send_sms+0x18>
        task->retries = 5;
    52d2:	2305      	movs	r3, #5
        task->state = SIM_TASK_STATE_FINISHED;
    52d4:	7160      	strb	r0, [r4, #5]
        task->retries = 5;
    52d6:	71a3      	strb	r3, [r4, #6]
    if(task->retries > 5) {
    52d8:	79a3      	ldrb	r3, [r4, #6]
    52da:	2b05      	cmp	r3, #5
    52dc:	d902      	bls.n	52e4 <sim_send_sms+0x24>
        task->state = SIM_TASK_STATE_FINISHED;
    52de:	2300      	movs	r3, #0
    52e0:	7163      	strb	r3, [r4, #5]
        task->retries = 0;
    52e2:	71a3      	strb	r3, [r4, #6]
    switch(task->state) {
    52e4:	7960      	ldrb	r0, [r4, #5]
    52e6:	3801      	subs	r0, #1
    52e8:	2803      	cmp	r0, #3
    52ea:	d900      	bls.n	52ee <sim_send_sms+0x2e>
    52ec:	e075      	b.n	53da <sim_send_sms+0x11a>
    52ee:	f002 fe37 	bl	7f60 <__gnu_thumb1_case_uqi>
    52f2:	7a06      	.short	0x7a06
    52f4:	5d02      	.short	0x5d02
          next_state = SIM_TASK_STATE_SENDSMS_RESPONSE;
    52f6:	2504      	movs	r5, #4
    task->state = next_state;
    52f8:	7165      	strb	r5, [r4, #5]
}
    52fa:	b049      	add	sp, #292	; 0x124
    52fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    52fe:	493c      	ldr	r1, [pc, #240]	; (53f0 <sim_send_sms+0x130>)
    5300:	2000      	movs	r0, #0
    5302:	4b3c      	ldr	r3, [pc, #240]	; (53f4 <sim_send_sms+0x134>)
    5304:	4798      	blx	r3
          uart_print(0,"size=%d len=%d\n\r",task->arg1,strlen(UART_SIM_TxBuf));
    5306:	4b3c      	ldr	r3, [pc, #240]	; (53f8 <sim_send_sms+0x138>)
    5308:	3302      	adds	r3, #2
    530a:	9301      	str	r3, [sp, #4]
    530c:	0018      	movs	r0, r3
    530e:	4b3b      	ldr	r3, [pc, #236]	; (53fc <sim_send_sms+0x13c>)
    5310:	4798      	blx	r3
    5312:	8862      	ldrh	r2, [r4, #2]
    5314:	0003      	movs	r3, r0
    5316:	493a      	ldr	r1, [pc, #232]	; (5400 <sim_send_sms+0x140>)
    5318:	2000      	movs	r0, #0
    531a:	4e36      	ldr	r6, [pc, #216]	; (53f4 <sim_send_sms+0x134>)
    531c:	47b0      	blx	r6
          uart_print(0,"sendsms:%s\n\r",UART_SIM_TxBuf);
    531e:	9a01      	ldr	r2, [sp, #4]
    5320:	4938      	ldr	r1, [pc, #224]	; (5404 <sim_send_sms+0x144>)
    5322:	2000      	movs	r0, #0
    5324:	4b33      	ldr	r3, [pc, #204]	; (53f4 <sim_send_sms+0x134>)
    5326:	4798      	blx	r3
          if(!phonenr_ok(sysval.sms_phonenr)) {
    5328:	4f37      	ldr	r7, [pc, #220]	; (5408 <sim_send_sms+0x148>)
    532a:	4b38      	ldr	r3, [pc, #224]	; (540c <sim_send_sms+0x14c>)
    532c:	0038      	movs	r0, r7
    532e:	4798      	blx	r3
              task->retries = 5;
    5330:	2305      	movs	r3, #5
          if(!phonenr_ok(sysval.sms_phonenr)) {
    5332:	2800      	cmp	r0, #0
    5334:	d027      	beq.n	5386 <sim_send_sms+0xc6>
          sim_tx("AT+CMGS=\"",9);
    5336:	2109      	movs	r1, #9
    5338:	4835      	ldr	r0, [pc, #212]	; (5410 <sim_send_sms+0x150>)
    533a:	4e36      	ldr	r6, [pc, #216]	; (5414 <sim_send_sms+0x154>)
    533c:	47b0      	blx	r6
          len=sprintf(buf,"%s\"\r",sysval.sms_phonenr);
    533e:	003a      	movs	r2, r7
    5340:	4935      	ldr	r1, [pc, #212]	; (5418 <sim_send_sms+0x158>)
    5342:	4b36      	ldr	r3, [pc, #216]	; (541c <sim_send_sms+0x15c>)
    5344:	a803      	add	r0, sp, #12
    5346:	4798      	blx	r3
          sim_tx(buf,len);
    5348:	23ff      	movs	r3, #255	; 0xff
    534a:	0001      	movs	r1, r0
    534c:	a803      	add	r0, sp, #12
    534e:	4019      	ands	r1, r3
    5350:	47b0      	blx	r6
          if(sim_read(sim_rxbuf,">",5,sizeof(sim_rxbuf))==0) {
    5352:	2380      	movs	r3, #128	; 0x80
    5354:	2205      	movs	r2, #5
    5356:	005b      	lsls	r3, r3, #1
    5358:	4931      	ldr	r1, [pc, #196]	; (5420 <sim_send_sms+0x160>)
    535a:	a808      	add	r0, sp, #32
    535c:	4f31      	ldr	r7, [pc, #196]	; (5424 <sim_send_sms+0x164>)
    535e:	47b8      	blx	r7
    5360:	2800      	cmp	r0, #0
    5362:	d112      	bne.n	538a <sim_send_sms+0xca>
              uart_print(0,"abort\n\r");
    5364:	4930      	ldr	r1, [pc, #192]	; (5428 <sim_send_sms+0x168>)
    5366:	4b23      	ldr	r3, [pc, #140]	; (53f4 <sim_send_sms+0x134>)
    5368:	4798      	blx	r3
              len=sprintf(buf,"%c",0x1b); // abort by send ESC
    536a:	221b      	movs	r2, #27
    536c:	492f      	ldr	r1, [pc, #188]	; (542c <sim_send_sms+0x16c>)
    536e:	4b2b      	ldr	r3, [pc, #172]	; (541c <sim_send_sms+0x15c>)
    5370:	a803      	add	r0, sp, #12
    5372:	4798      	blx	r3
              sim_tx(buf,len);
    5374:	23ff      	movs	r3, #255	; 0xff
    5376:	0001      	movs	r1, r0
    5378:	a803      	add	r0, sp, #12
    537a:	4019      	ands	r1, r3
    537c:	47b0      	blx	r6
              sim_rxflush();
    537e:	4b2c      	ldr	r3, [pc, #176]	; (5430 <sim_send_sms+0x170>)
    5380:	4798      	blx	r3
              task->retries++;
    5382:	79a3      	ldrb	r3, [r4, #6]
    5384:	3301      	adds	r3, #1
    5386:	71a3      	strb	r3, [r4, #6]
              break;
    5388:	e7b6      	b.n	52f8 <sim_send_sms+0x38>
          sim_tx(UART_SIM_TxBuf,task->arg1); // send prepared sms message
    538a:	8861      	ldrh	r1, [r4, #2]
    538c:	9801      	ldr	r0, [sp, #4]
    538e:	47b0      	blx	r6
          len=sprintf(buf,"%c",0x1a); // end SMS
    5390:	221a      	movs	r2, #26
    5392:	4926      	ldr	r1, [pc, #152]	; (542c <sim_send_sms+0x16c>)
    5394:	4b21      	ldr	r3, [pc, #132]	; (541c <sim_send_sms+0x15c>)
    5396:	a803      	add	r0, sp, #12
    5398:	4798      	blx	r3
          sim_tx(buf,len);
    539a:	23ff      	movs	r3, #255	; 0xff
    539c:	0001      	movs	r1, r0
    539e:	a803      	add	r0, sp, #12
    53a0:	4019      	ands	r1, r3
    53a2:	47b0      	blx	r6
          task->retries = 0;
    53a4:	2300      	movs	r3, #0
              task->retries++;
    53a6:	71a3      	strb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_SENDSMS_WAIT1;
    53a8:	2502      	movs	r5, #2
              break;
    53aa:	e7a5      	b.n	52f8 <sim_send_sms+0x38>
          uart_print(0,"SIM_TASK_STATE_SENDSMS_RESPONSE\n\r");
    53ac:	4921      	ldr	r1, [pc, #132]	; (5434 <sim_send_sms+0x174>)
    53ae:	2000      	movs	r0, #0
    53b0:	4b10      	ldr	r3, [pc, #64]	; (53f4 <sim_send_sms+0x134>)
    53b2:	4798      	blx	r3
          if(sim_read(sim_rxbuf,"+CMGS",20,sizeof(sim_rxbuf))==0) {
    53b4:	2380      	movs	r3, #128	; 0x80
    53b6:	2214      	movs	r2, #20
    53b8:	005b      	lsls	r3, r3, #1
    53ba:	491f      	ldr	r1, [pc, #124]	; (5438 <sim_send_sms+0x178>)
    53bc:	a808      	add	r0, sp, #32
    53be:	4d19      	ldr	r5, [pc, #100]	; (5424 <sim_send_sms+0x164>)
    53c0:	47a8      	blx	r5
    53c2:	2800      	cmp	r0, #0
    53c4:	d102      	bne.n	53cc <sim_send_sms+0x10c>
              task->retries++;
    53c6:	79a3      	ldrb	r3, [r4, #6]
    53c8:	3301      	adds	r3, #1
    53ca:	e7ec      	b.n	53a6 <sim_send_sms+0xe6>
          task->retries = 0;
    53cc:	2500      	movs	r5, #0
          strcpy(sysval.sms_phonenr," "); // reset
    53ce:	491b      	ldr	r1, [pc, #108]	; (543c <sim_send_sms+0x17c>)
    53d0:	480d      	ldr	r0, [pc, #52]	; (5408 <sim_send_sms+0x148>)
    53d2:	4b1b      	ldr	r3, [pc, #108]	; (5440 <sim_send_sms+0x180>)
    53d4:	4798      	blx	r3
          task->retries = 0;
    53d6:	71a5      	strb	r5, [r4, #6]
          break;
    53d8:	e78e      	b.n	52f8 <sim_send_sms+0x38>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    53da:	491a      	ldr	r1, [pc, #104]	; (5444 <sim_send_sms+0x184>)
    53dc:	2000      	movs	r0, #0
    53de:	4b05      	ldr	r3, [pc, #20]	; (53f4 <sim_send_sms+0x134>)
    53e0:	4798      	blx	r3
          next_state = SIM_TASK_STATE_FINISHED;
    53e2:	2500      	movs	r5, #0
          break;
    53e4:	e788      	b.n	52f8 <sim_send_sms+0x38>
          next_state = SIM_TASK_STATE_SENDSMS_WAIT2;
    53e6:	2503      	movs	r5, #3
    53e8:	e786      	b.n	52f8 <sim_send_sms+0x38>
    53ea:	46c0      	nop			; (mov r8, r8)
    53ec:	00004e4d 	.word	0x00004e4d
    53f0:	0000aeed 	.word	0x0000aeed
    53f4:	00007b99 	.word	0x00007b99
    53f8:	20000631 	.word	0x20000631
    53fc:	00008a3f 	.word	0x00008a3f
    5400:	0000af04 	.word	0x0000af04
    5404:	0000af15 	.word	0x0000af15
    5408:	20000a70 	.word	0x20000a70
    540c:	0000528d 	.word	0x0000528d
    5410:	0000af22 	.word	0x0000af22
    5414:	0000525d 	.word	0x0000525d
    5418:	0000af2c 	.word	0x0000af2c
    541c:	00008969 	.word	0x00008969
    5420:	0000af31 	.word	0x0000af31
    5424:	00005021 	.word	0x00005021
    5428:	0000af33 	.word	0x0000af33
    542c:	0000aeb2 	.word	0x0000aeb2
    5430:	00004fc1 	.word	0x00004fc1
    5434:	0000af3b 	.word	0x0000af3b
    5438:	0000af5d 	.word	0x0000af5d
    543c:	0000ae46 	.word	0x0000ae46
    5440:	00008a2f 	.word	0x00008a2f
    5444:	0000af63 	.word	0x0000af63

00005448 <sim_delete_sms>:
{
    5448:	b510      	push	{r4, lr}
    sim_tx("AT+CMGD=1\r",10);
    544a:	4c0a      	ldr	r4, [pc, #40]	; (5474 <sim_delete_sms+0x2c>)
{
    544c:	b088      	sub	sp, #32
    sim_tx("AT+CMGD=1\r",10);
    544e:	0020      	movs	r0, r4
    5450:	210a      	movs	r1, #10
    5452:	4b09      	ldr	r3, [pc, #36]	; (5478 <sim_delete_sms+0x30>)
    5454:	4798      	blx	r3
    sim_read(sim_rxbuf,"AT+CMGD=1\r",7,sizeof(sim_rxbuf)); // read echo
    5456:	0021      	movs	r1, r4
    5458:	2320      	movs	r3, #32
    545a:	4c08      	ldr	r4, [pc, #32]	; (547c <sim_delete_sms+0x34>)
    545c:	2207      	movs	r2, #7
    545e:	4668      	mov	r0, sp
    5460:	47a0      	blx	r4
    len=sim_read(sim_rxbuf,"OK\r\n",7,sizeof(sim_rxbuf));	
    5462:	2320      	movs	r3, #32
    5464:	2207      	movs	r2, #7
    5466:	4906      	ldr	r1, [pc, #24]	; (5480 <sim_delete_sms+0x38>)
    5468:	4668      	mov	r0, sp
    546a:	47a0      	blx	r4
    return (uint8_t)len;
    546c:	b2c0      	uxtb	r0, r0
}
    546e:	b008      	add	sp, #32
    5470:	bd10      	pop	{r4, pc}
    5472:	46c0      	nop			; (mov r8, r8)
    5474:	0000af7f 	.word	0x0000af7f
    5478:	0000525d 	.word	0x0000525d
    547c:	00005021 	.word	0x00005021
    5480:	0000afa0 	.word	0x0000afa0

00005484 <sim_receive_sms>:
{
    5484:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    5486:	4b47      	ldr	r3, [pc, #284]	; (55a4 <sim_receive_sms+0x120>)
{
    5488:	b0b3      	sub	sp, #204	; 0xcc
    548a:	0004      	movs	r4, r0
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    548c:	4798      	blx	r3
    if(!sim_is_on()) {
    548e:	b2c0      	uxtb	r0, r0
    5490:	2800      	cmp	r0, #0
    5492:	d102      	bne.n	549a <sim_receive_sms+0x16>
        task->retries = 1;
    5494:	2301      	movs	r3, #1
        task->state = SIM_TASK_STATE_FINISHED;
    5496:	7160      	strb	r0, [r4, #5]
        task->retries = 1;
    5498:	71a3      	strb	r3, [r4, #6]
    if(task->retries > 1) {
    549a:	79a3      	ldrb	r3, [r4, #6]
    549c:	2b01      	cmp	r3, #1
    549e:	d901      	bls.n	54a4 <sim_receive_sms+0x20>
        task->state = SIM_TASK_STATE_REC_SMS_DEL;
    54a0:	2303      	movs	r3, #3
    54a2:	7163      	strb	r3, [r4, #5]
    switch(task->state) {
    54a4:	7963      	ldrb	r3, [r4, #5]
    54a6:	2b02      	cmp	r3, #2
    54a8:	d013      	beq.n	54d2 <sim_receive_sms+0x4e>
    54aa:	2b03      	cmp	r3, #3
    54ac:	d100      	bne.n	54b0 <sim_receive_sms+0x2c>
    54ae:	e070      	b.n	5592 <sim_receive_sms+0x10e>
    54b0:	4a3d      	ldr	r2, [pc, #244]	; (55a8 <sim_receive_sms+0x124>)
    54b2:	2b01      	cmp	r3, #1
    54b4:	d000      	beq.n	54b8 <sim_receive_sms+0x34>
    54b6:	e070      	b.n	559a <sim_receive_sms+0x116>
          uart_print(0,"SIM_TASK_STATE_START\n\r"); 
    54b8:	493c      	ldr	r1, [pc, #240]	; (55ac <sim_receive_sms+0x128>)
    54ba:	2000      	movs	r0, #0
    54bc:	4790      	blx	r2
          sim_rxflush(); // dump the "SMS Ready" URC message         
    54be:	4b3c      	ldr	r3, [pc, #240]	; (55b0 <sim_receive_sms+0x12c>)
    54c0:	4798      	blx	r3
          sim_tx("AT+CMGL\r",8);
    54c2:	2108      	movs	r1, #8
    54c4:	483b      	ldr	r0, [pc, #236]	; (55b4 <sim_receive_sms+0x130>)
    54c6:	4b3c      	ldr	r3, [pc, #240]	; (55b8 <sim_receive_sms+0x134>)
    54c8:	4798      	blx	r3
          next_state = SIM_TASK_STATE_REC_SMS_CHK;
    54ca:	2502      	movs	r5, #2
    task->state = next_state;
    54cc:	7165      	strb	r5, [r4, #5]
}
    54ce:	b033      	add	sp, #204	; 0xcc
    54d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if(sim_read(sim_rxbuf,"REC UNREAD",7,sizeof(sim_rxbuf))==0) {
    54d2:	23c8      	movs	r3, #200	; 0xc8
    54d4:	2207      	movs	r2, #7
    54d6:	4939      	ldr	r1, [pc, #228]	; (55bc <sim_receive_sms+0x138>)
    54d8:	4668      	mov	r0, sp
    54da:	4d39      	ldr	r5, [pc, #228]	; (55c0 <sim_receive_sms+0x13c>)
    54dc:	47a8      	blx	r5
    54de:	2800      	cmp	r0, #0
    54e0:	d104      	bne.n	54ec <sim_receive_sms+0x68>
              task->retries++;
    54e2:	79a3      	ldrb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_START;
    54e4:	2501      	movs	r5, #1
              task->retries++;
    54e6:	3301      	adds	r3, #1
    54e8:	71a3      	strb	r3, [r4, #6]
              break;
    54ea:	e7ef      	b.n	54cc <sim_receive_sms+0x48>
          if(sim_read(sim_rxbuf,"\r\nOK\r\n",7,sizeof(sim_rxbuf))==0) {
    54ec:	23c8      	movs	r3, #200	; 0xc8
    54ee:	2207      	movs	r2, #7
    54f0:	4934      	ldr	r1, [pc, #208]	; (55c4 <sim_receive_sms+0x140>)
    54f2:	4668      	mov	r0, sp
    54f4:	47a8      	blx	r5
    54f6:	2800      	cmp	r0, #0
    54f8:	d0f3      	beq.n	54e2 <sim_receive_sms+0x5e>
    54fa:	2300      	movs	r3, #0
    54fc:	466d      	mov	r5, sp
    54fe:	001e      	movs	r6, r3
          while((c=*sim_bufptr) != 0) {
    5500:	782a      	ldrb	r2, [r5, #0]
    5502:	2a00      	cmp	r2, #0
    5504:	d017      	beq.n	5536 <sim_receive_sms+0xb2>
              if(c=='\"') match++;
    5506:	2a22      	cmp	r2, #34	; 0x22
    5508:	d101      	bne.n	550e <sim_receive_sms+0x8a>
    550a:	3301      	adds	r3, #1
    550c:	b2db      	uxtb	r3, r3
              sim_bufptr++;
    550e:	1c6f      	adds	r7, r5, #1
              if(match==2) {
    5510:	2b02      	cmp	r3, #2
    5512:	d107      	bne.n	5524 <sim_receive_sms+0xa0>
                  uart_print(0,"phonenr: ");
    5514:	4b24      	ldr	r3, [pc, #144]	; (55a8 <sim_receive_sms+0x124>)
    5516:	492c      	ldr	r1, [pc, #176]	; (55c8 <sim_receive_sms+0x144>)
    5518:	2000      	movs	r0, #0
    551a:	4798      	blx	r3
                  phonenr_ptr=sim_bufptr;
    551c:	003e      	movs	r6, r7
                  match++;
    551e:	2303      	movs	r3, #3
    5520:	003d      	movs	r5, r7
    5522:	e7ed      	b.n	5500 <sim_receive_sms+0x7c>
              if(match==4) {
    5524:	2b04      	cmp	r3, #4
    5526:	d1fb      	bne.n	5520 <sim_receive_sms+0x9c>
                  *(sim_bufptr-1)=0; // eos for phone number
    5528:	2000      	movs	r0, #0
                  uart_print(0,"%s\n\r",phonenr_ptr);
    552a:	0032      	movs	r2, r6
                  *(sim_bufptr-1)=0; // eos for phone number
    552c:	7028      	strb	r0, [r5, #0]
                  uart_print(0,"%s\n\r",phonenr_ptr);
    552e:	4927      	ldr	r1, [pc, #156]	; (55cc <sim_receive_sms+0x148>)
    5530:	4b1d      	ldr	r3, [pc, #116]	; (55a8 <sim_receive_sms+0x124>)
                  sim_bufptr++;
    5532:	3502      	adds	r5, #2
                  uart_print(0,"%s\n\r",phonenr_ptr);
    5534:	4798      	blx	r3
          sim_bufptr=strstr(sim_bufptr,"\r\n");
    5536:	4b26      	ldr	r3, [pc, #152]	; (55d0 <sim_receive_sms+0x14c>)
    5538:	4926      	ldr	r1, [pc, #152]	; (55d4 <sim_receive_sms+0x150>)
    553a:	0028      	movs	r0, r5
    553c:	4798      	blx	r3
          sim_bufptr+=2; // point to message
    553e:	1c87      	adds	r7, r0, #2
          ptr=sim_bufptr;
    5540:	003b      	movs	r3, r7
          if(sim_bufptr==NULL) { 
    5542:	2800      	cmp	r0, #0
    5544:	d105      	bne.n	5552 <sim_receive_sms+0xce>
              uart_print(0,"nothing\n\r"); 
    5546:	4924      	ldr	r1, [pc, #144]	; (55d8 <sim_receive_sms+0x154>)
    5548:	4b17      	ldr	r3, [pc, #92]	; (55a8 <sim_receive_sms+0x124>)
    554a:	4798      	blx	r3
              next_state = SIM_TASK_STATE_REC_SMS_DEL;
    554c:	2503      	movs	r5, #3
              break;
    554e:	e7bd      	b.n	54cc <sim_receive_sms+0x48>
              ptr++;
    5550:	3301      	adds	r3, #1
          while((c=*ptr) != 0) {
    5552:	781a      	ldrb	r2, [r3, #0]
    5554:	2a00      	cmp	r2, #0
    5556:	d003      	beq.n	5560 <sim_receive_sms+0xdc>
              if(c=='\r') {
    5558:	2a0d      	cmp	r2, #13
    555a:	d1f9      	bne.n	5550 <sim_receive_sms+0xcc>
                  *ptr=0;
    555c:	2200      	movs	r2, #0
    555e:	701a      	strb	r2, [r3, #0]
          uart_print(0,"sms:%s\n\r",sim_bufptr);
    5560:	003a      	movs	r2, r7
    5562:	491e      	ldr	r1, [pc, #120]	; (55dc <sim_receive_sms+0x158>)
    5564:	2000      	movs	r0, #0
    5566:	4b10      	ldr	r3, [pc, #64]	; (55a8 <sim_receive_sms+0x124>)
    5568:	4798      	blx	r3
          if(phonenr_ok(phonenr_ptr)) {
    556a:	0030      	movs	r0, r6
    556c:	4b1c      	ldr	r3, [pc, #112]	; (55e0 <sim_receive_sms+0x15c>)
    556e:	4798      	blx	r3
          next_state = SIM_TASK_STATE_REC_SMS_DEL;
    5570:	2503      	movs	r5, #3
          if(phonenr_ok(phonenr_ptr)) {
    5572:	2800      	cmp	r0, #0
    5574:	d0aa      	beq.n	54cc <sim_receive_sms+0x48>
              uart_print(0,"phone number OK\n\r");
    5576:	491b      	ldr	r1, [pc, #108]	; (55e4 <sim_receive_sms+0x160>)
    5578:	2000      	movs	r0, #0
    557a:	4b0b      	ldr	r3, [pc, #44]	; (55a8 <sim_receive_sms+0x124>)
    557c:	4798      	blx	r3
              strcpy(sysval.sms_phonenr,phonenr_ptr);   // Leon's SMART nr        
    557e:	0031      	movs	r1, r6
    5580:	4b19      	ldr	r3, [pc, #100]	; (55e8 <sim_receive_sms+0x164>)
    5582:	481a      	ldr	r0, [pc, #104]	; (55ec <sim_receive_sms+0x168>)
    5584:	4798      	blx	r3
              cmd_task_add(CMD_TASK_SMS,sim_bufptr,0);
    5586:	2200      	movs	r2, #0
    5588:	0039      	movs	r1, r7
    558a:	4b19      	ldr	r3, [pc, #100]	; (55f0 <sim_receive_sms+0x16c>)
    558c:	2001      	movs	r0, #1
    558e:	4798      	blx	r3
    5590:	e79c      	b.n	54cc <sim_receive_sms+0x48>
          sim_delete_sms();
    5592:	4b18      	ldr	r3, [pc, #96]	; (55f4 <sim_receive_sms+0x170>)
    5594:	4798      	blx	r3
          next_state = SIM_TASK_STATE_FINISHED;
    5596:	2500      	movs	r5, #0
          break;
    5598:	e798      	b.n	54cc <sim_receive_sms+0x48>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    559a:	4917      	ldr	r1, [pc, #92]	; (55f8 <sim_receive_sms+0x174>)
    559c:	2000      	movs	r0, #0
    559e:	4790      	blx	r2
    55a0:	e7f9      	b.n	5596 <sim_receive_sms+0x112>
    55a2:	46c0      	nop			; (mov r8, r8)
    55a4:	00004e4d 	.word	0x00004e4d
    55a8:	00007b99 	.word	0x00007b99
    55ac:	0000aeed 	.word	0x0000aeed
    55b0:	00004fc1 	.word	0x00004fc1
    55b4:	0000af8a 	.word	0x0000af8a
    55b8:	0000525d 	.word	0x0000525d
    55bc:	0000af93 	.word	0x0000af93
    55c0:	00005021 	.word	0x00005021
    55c4:	0000af9e 	.word	0x0000af9e
    55c8:	0000afa5 	.word	0x0000afa5
    55cc:	00009efa 	.word	0x00009efa
    55d0:	00008ae1 	.word	0x00008ae1
    55d4:	00009f82 	.word	0x00009f82
    55d8:	0000afaf 	.word	0x0000afaf
    55dc:	0000af19 	.word	0x0000af19
    55e0:	0000528d 	.word	0x0000528d
    55e4:	0000afb9 	.word	0x0000afb9
    55e8:	00008a2f 	.word	0x00008a2f
    55ec:	20000a70 	.word	0x20000a70
    55f0:	00000809 	.word	0x00000809
    55f4:	00005449 	.word	0x00005449
    55f8:	0000af63 	.word	0x0000af63

000055fc <sim_delete_all_sms>:
{
    55fc:	b510      	push	{r4, lr}
    sim_tx(cmd,strlen(cmd));
    55fe:	4c0a      	ldr	r4, [pc, #40]	; (5628 <sim_delete_all_sms+0x2c>)
{
    5600:	b088      	sub	sp, #32
    sim_tx(cmd,strlen(cmd));
    5602:	0020      	movs	r0, r4
    5604:	2113      	movs	r1, #19
    5606:	4b09      	ldr	r3, [pc, #36]	; (562c <sim_delete_all_sms+0x30>)
    5608:	4798      	blx	r3
    sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
    560a:	0021      	movs	r1, r4
    560c:	2320      	movs	r3, #32
    560e:	4c08      	ldr	r4, [pc, #32]	; (5630 <sim_delete_all_sms+0x34>)
    5610:	220a      	movs	r2, #10
    5612:	4668      	mov	r0, sp
    5614:	47a0      	blx	r4
    len=sim_read(sim_rxbuf,"OK\r\n",10,sizeof(sim_rxbuf));	
    5616:	2320      	movs	r3, #32
    5618:	220a      	movs	r2, #10
    561a:	4906      	ldr	r1, [pc, #24]	; (5634 <sim_delete_all_sms+0x38>)
    561c:	4668      	mov	r0, sp
    561e:	47a0      	blx	r4
    return (uint8_t)len;
    5620:	b2c0      	uxtb	r0, r0
}
    5622:	b008      	add	sp, #32
    5624:	bd10      	pop	{r4, pc}
    5626:	46c0      	nop			; (mov r8, r8)
    5628:	0000afcb 	.word	0x0000afcb
    562c:	0000525d 	.word	0x0000525d
    5630:	00005021 	.word	0x00005021
    5634:	0000afa0 	.word	0x0000afa0

00005638 <sim_read_IMEI>:
{
    5638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    563a:	0006      	movs	r6, r0
    563c:	000f      	movs	r7, r1
    563e:	2504      	movs	r5, #4
        sim_tx(cmd,strlen(cmd));
    5640:	4c1f      	ldr	r4, [pc, #124]	; (56c0 <sim_read_IMEI+0x88>)
    5642:	2107      	movs	r1, #7
    5644:	0020      	movs	r0, r4
    5646:	4b1f      	ldr	r3, [pc, #124]	; (56c4 <sim_read_IMEI+0x8c>)
    5648:	4798      	blx	r3
        sim_read(sim_rxbuf,cmd,5,maxlen); // read echo
    564a:	0021      	movs	r1, r4
    564c:	003b      	movs	r3, r7
    564e:	4c1e      	ldr	r4, [pc, #120]	; (56c8 <sim_read_IMEI+0x90>)
    5650:	2205      	movs	r2, #5
    5652:	0030      	movs	r0, r6
    5654:	47a0      	blx	r4
        if(sim_read(sim_rxbuf,"OK\r\n",5,maxlen)==0) {
    5656:	003b      	movs	r3, r7
    5658:	2205      	movs	r2, #5
    565a:	491c      	ldr	r1, [pc, #112]	; (56cc <sim_read_IMEI+0x94>)
    565c:	0030      	movs	r0, r6
    565e:	47a0      	blx	r4
    5660:	1e04      	subs	r4, r0, #0
    5662:	d00c      	beq.n	567e <sim_read_IMEI+0x46>
    5664:	0034      	movs	r4, r6
        while((c=*ptr_imei) != 0) {
    5666:	7823      	ldrb	r3, [r4, #0]
    5668:	2b00      	cmp	r3, #0
    566a:	d118      	bne.n	569e <sim_read_IMEI+0x66>
        if(strlen(ptr_imei)>10) break;
    566c:	0020      	movs	r0, r4
    566e:	4b18      	ldr	r3, [pc, #96]	; (56d0 <sim_read_IMEI+0x98>)
    5670:	4798      	blx	r3
    5672:	280a      	cmp	r0, #10
    5674:	d811      	bhi.n	569a <sim_read_IMEI+0x62>
            delay_ms(50);
    5676:	2032      	movs	r0, #50	; 0x32
    5678:	4b16      	ldr	r3, [pc, #88]	; (56d4 <sim_read_IMEI+0x9c>)
    567a:	4798      	blx	r3
    567c:	e006      	b.n	568c <sim_read_IMEI+0x54>
            delay_ms(50);
    567e:	2032      	movs	r0, #50	; 0x32
    5680:	4b14      	ldr	r3, [pc, #80]	; (56d4 <sim_read_IMEI+0x9c>)
    5682:	4798      	blx	r3
            uart_print(0,"bad imei");
    5684:	4914      	ldr	r1, [pc, #80]	; (56d8 <sim_read_IMEI+0xa0>)
    5686:	0020      	movs	r0, r4
    5688:	4b14      	ldr	r3, [pc, #80]	; (56dc <sim_read_IMEI+0xa4>)
    568a:	4798      	blx	r3
    568c:	3d01      	subs	r5, #1
            sim_rxflush();
    568e:	4b14      	ldr	r3, [pc, #80]	; (56e0 <sim_read_IMEI+0xa8>)
    5690:	b2ed      	uxtb	r5, r5
    5692:	4798      	blx	r3
    while(retry) {
    5694:	2dff      	cmp	r5, #255	; 0xff
    5696:	d1d3      	bne.n	5640 <sim_read_IMEI+0x8>
    if(retry==0) return "NO-IMEI";
    5698:	4c12      	ldr	r4, [pc, #72]	; (56e4 <sim_read_IMEI+0xac>)
}
    569a:	0020      	movs	r0, r4
    569c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        	if(c=='\r' || c=='\n') {
    569e:	2b0d      	cmp	r3, #13
    56a0:	d00a      	beq.n	56b8 <sim_read_IMEI+0x80>
    56a2:	2b0a      	cmp	r3, #10
    56a4:	d008      	beq.n	56b8 <sim_read_IMEI+0x80>
    56a6:	0023      	movs	r3, r4
        while((c=*ptr) != 0) {
    56a8:	781a      	ldrb	r2, [r3, #0]
    56aa:	2a00      	cmp	r2, #0
    56ac:	d0de      	beq.n	566c <sim_read_IMEI+0x34>
        	if(c=='\r') {
    56ae:	2a0d      	cmp	r2, #13
    56b0:	d104      	bne.n	56bc <sim_read_IMEI+0x84>
        		*ptr=0;
    56b2:	2200      	movs	r2, #0
    56b4:	701a      	strb	r2, [r3, #0]
        		break;
    56b6:	e7d9      	b.n	566c <sim_read_IMEI+0x34>
        		ptr_imei++;
    56b8:	3401      	adds	r4, #1
        		continue;
    56ba:	e7d4      	b.n	5666 <sim_read_IMEI+0x2e>
        	ptr++;
    56bc:	3301      	adds	r3, #1
    56be:	e7f3      	b.n	56a8 <sim_read_IMEI+0x70>
    56c0:	0000afe7 	.word	0x0000afe7
    56c4:	0000525d 	.word	0x0000525d
    56c8:	00005021 	.word	0x00005021
    56cc:	0000afa0 	.word	0x0000afa0
    56d0:	00008a3f 	.word	0x00008a3f
    56d4:	00007c05 	.word	0x00007c05
    56d8:	0000afef 	.word	0x0000afef
    56dc:	00007b99 	.word	0x00007b99
    56e0:	00004fc1 	.word	0x00004fc1
    56e4:	0000afdf 	.word	0x0000afdf

000056e8 <sim_read_signalstrength>:
{
    56e8:	b510      	push	{r4, lr}
    sim_rxflush();
    56ea:	4b15      	ldr	r3, [pc, #84]	; (5740 <sim_read_signalstrength+0x58>)
{
    56ec:	b08a      	sub	sp, #40	; 0x28
    sim_rxflush();
    56ee:	4798      	blx	r3
    sim_tx(cmd,strlen(cmd));
    56f0:	4c14      	ldr	r4, [pc, #80]	; (5744 <sim_read_signalstrength+0x5c>)
    56f2:	2107      	movs	r1, #7
    56f4:	0020      	movs	r0, r4
    56f6:	4b14      	ldr	r3, [pc, #80]	; (5748 <sim_read_signalstrength+0x60>)
    56f8:	4798      	blx	r3
    sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
    56fa:	0021      	movs	r1, r4
    56fc:	2320      	movs	r3, #32
    56fe:	220a      	movs	r2, #10
    5700:	a802      	add	r0, sp, #8
    5702:	4c12      	ldr	r4, [pc, #72]	; (574c <sim_read_signalstrength+0x64>)
    5704:	47a0      	blx	r4
    if(sim_read(sim_rxbuf,"OK\r\n",10,sizeof(sim_rxbuf))==0)
    5706:	2320      	movs	r3, #32
    5708:	220a      	movs	r2, #10
    570a:	4911      	ldr	r1, [pc, #68]	; (5750 <sim_read_signalstrength+0x68>)
    570c:	a802      	add	r0, sp, #8
    570e:	47a0      	blx	r4
    5710:	2800      	cmp	r0, #0
    5712:	d00f      	beq.n	5734 <sim_read_signalstrength+0x4c>
    found=sscanf(ptr,"\r\n+CSQ: %d,%d",&signal,&ber);    
    5714:	ab01      	add	r3, sp, #4
    5716:	466a      	mov	r2, sp
    5718:	490e      	ldr	r1, [pc, #56]	; (5754 <sim_read_signalstrength+0x6c>)
    571a:	a802      	add	r0, sp, #8
    571c:	4c0e      	ldr	r4, [pc, #56]	; (5758 <sim_read_signalstrength+0x70>)
    571e:	47a0      	blx	r4
    if(found==2) {
    5720:	2802      	cmp	r0, #2
    5722:	d10a      	bne.n	573a <sim_read_signalstrength+0x52>
        uart_print(0,"CSQ:%d\n\r",signal);
    5724:	2000      	movs	r0, #0
    5726:	9a00      	ldr	r2, [sp, #0]
    5728:	490c      	ldr	r1, [pc, #48]	; (575c <sim_read_signalstrength+0x74>)
    572a:	4b0d      	ldr	r3, [pc, #52]	; (5760 <sim_read_signalstrength+0x78>)
    572c:	4798      	blx	r3
        return signal;
    572e:	9800      	ldr	r0, [sp, #0]
}
    5730:	b00a      	add	sp, #40	; 0x28
    5732:	bd10      	pop	{r4, pc}
        return -3;
    5734:	2003      	movs	r0, #3
    } else return -4;
    5736:	4240      	negs	r0, r0
    5738:	e7fa      	b.n	5730 <sim_read_signalstrength+0x48>
    573a:	2004      	movs	r0, #4
    573c:	e7fb      	b.n	5736 <sim_read_signalstrength+0x4e>
    573e:	46c0      	nop			; (mov r8, r8)
    5740:	00004fc1 	.word	0x00004fc1
    5744:	0000aff8 	.word	0x0000aff8
    5748:	0000525d 	.word	0x0000525d
    574c:	00005021 	.word	0x00005021
    5750:	0000afa0 	.word	0x0000afa0
    5754:	0000b000 	.word	0x0000b000
    5758:	000089ad 	.word	0x000089ad
    575c:	0000b00e 	.word	0x0000b00e
    5760:	00007b99 	.word	0x00007b99

00005764 <sim_2g_state>:
{
    5764:	b570      	push	{r4, r5, r6, lr}
    5766:	0004      	movs	r4, r0
    5768:	000e      	movs	r6, r1
    sim_tx(cmd,strlen(cmd));    
    576a:	4d0e      	ldr	r5, [pc, #56]	; (57a4 <sim_2g_state+0x40>)
    576c:	210d      	movs	r1, #13
    576e:	0028      	movs	r0, r5
    5770:	4b0d      	ldr	r3, [pc, #52]	; (57a8 <sim_2g_state+0x44>)
    5772:	4798      	blx	r3
    sim_read(sim_rxbuf,cmd,20,maxlen); // read echo
    5774:	0029      	movs	r1, r5
    5776:	0033      	movs	r3, r6
    5778:	2214      	movs	r2, #20
    577a:	0020      	movs	r0, r4
    577c:	4d0b      	ldr	r5, [pc, #44]	; (57ac <sim_2g_state+0x48>)
    577e:	47a8      	blx	r5
    if(sim_read(sim_rxbuf,"STATE: ",20,maxlen)==0)
    5780:	0033      	movs	r3, r6
    5782:	2214      	movs	r2, #20
    5784:	490a      	ldr	r1, [pc, #40]	; (57b0 <sim_2g_state+0x4c>)
    5786:	0020      	movs	r0, r4
    5788:	47a8      	blx	r5
    578a:	2800      	cmp	r0, #0
    578c:	d102      	bne.n	5794 <sim_2g_state+0x30>
        return NULL;
    578e:	2400      	movs	r4, #0
}
    5790:	0020      	movs	r0, r4
    5792:	bd70      	pop	{r4, r5, r6, pc}
    if(sim_read(sim_rxbuf,"\r\n",20,maxlen)==0)
    5794:	0033      	movs	r3, r6
    5796:	2214      	movs	r2, #20
    5798:	4906      	ldr	r1, [pc, #24]	; (57b4 <sim_2g_state+0x50>)
    579a:	0020      	movs	r0, r4
    579c:	47a8      	blx	r5
    579e:	2800      	cmp	r0, #0
    57a0:	d1f6      	bne.n	5790 <sim_2g_state+0x2c>
    57a2:	e7f4      	b.n	578e <sim_2g_state+0x2a>
    57a4:	0000b030 	.word	0x0000b030
    57a8:	0000525d 	.word	0x0000525d
    57ac:	00005021 	.word	0x00005021
    57b0:	0000b03e 	.word	0x0000b03e
    57b4:	00009f82 	.word	0x00009f82

000057b8 <sim_start_2g>:
{
    57b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    57ba:	4bc3      	ldr	r3, [pc, #780]	; (5ac8 <sim_start_2g+0x310>)
{
    57bc:	b0c9      	sub	sp, #292	; 0x124
    57be:	0004      	movs	r4, r0
    uint8_t next_state=task->state;
    57c0:	7945      	ldrb	r5, [r0, #5]
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    57c2:	4798      	blx	r3
    if(!sim_is_on()) {
    57c4:	b2c0      	uxtb	r0, r0
    57c6:	2800      	cmp	r0, #0
    57c8:	d102      	bne.n	57d0 <sim_start_2g+0x18>
        task->retries = 5;
    57ca:	2305      	movs	r3, #5
        task->state = SIM_TASK_STATE_FINISHED;
    57cc:	7160      	strb	r0, [r4, #5]
        task->retries = 5;
    57ce:	71a3      	strb	r3, [r4, #6]
    if(task->retries > 5) {
    57d0:	79a3      	ldrb	r3, [r4, #6]
    57d2:	2b05      	cmp	r3, #5
    57d4:	d901      	bls.n	57da <sim_start_2g+0x22>
        task->state = SIM_TASK_STATE_FINISHED;        
    57d6:	2300      	movs	r3, #0
    57d8:	7163      	strb	r3, [r4, #5]
    switch(task->state) {
    57da:	7960      	ldrb	r0, [r4, #5]
    57dc:	4ebb      	ldr	r6, [pc, #748]	; (5acc <sim_start_2g+0x314>)
    57de:	3801      	subs	r0, #1
    57e0:	280a      	cmp	r0, #10
    57e2:	d900      	bls.n	57e6 <sim_start_2g+0x2e>
    57e4:	e16c      	b.n	5ac0 <sim_start_2g+0x308>
    57e6:	f002 fbc5 	bl	7f74 <__gnu_thumb1_case_uhi>
    57ea:	000b      	.short	0x000b
    57ec:	00610025 	.word	0x00610025
    57f0:	00f100e6 	.word	0x00f100e6
    57f4:	00fd016b 	.word	0x00fd016b
    57f8:	012a010f 	.word	0x012a010f
    57fc:	014f013b 	.word	0x014f013b
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    5800:	49b3      	ldr	r1, [pc, #716]	; (5ad0 <sim_start_2g+0x318>)
    5802:	2000      	movs	r0, #0
    5804:	47b0      	blx	r6
          sim_tx(cmd1,strlen(cmd1));
    5806:	211e      	movs	r1, #30
    5808:	48b2      	ldr	r0, [pc, #712]	; (5ad4 <sim_start_2g+0x31c>)
    580a:	4bb3      	ldr	r3, [pc, #716]	; (5ad8 <sim_start_2g+0x320>)
    580c:	4798      	blx	r3
          sim_read(sim_rxbuf,"AT+SAPBR=3,1,",2,sizeof(sim_rxbuf)); // read echo
    580e:	2380      	movs	r3, #128	; 0x80
    5810:	2202      	movs	r2, #2
    5812:	005b      	lsls	r3, r3, #1
    5814:	49b1      	ldr	r1, [pc, #708]	; (5adc <sim_start_2g+0x324>)
    5816:	a808      	add	r0, sp, #32
    5818:	4eb1      	ldr	r6, [pc, #708]	; (5ae0 <sim_start_2g+0x328>)
    581a:	47b0      	blx	r6
          if(sim_read(sim_rxbuf,"OK\r\n",2,sizeof(sim_rxbuf))==0) {
    581c:	2380      	movs	r3, #128	; 0x80
    581e:	2202      	movs	r2, #2
    5820:	005b      	lsls	r3, r3, #1
    5822:	49b0      	ldr	r1, [pc, #704]	; (5ae4 <sim_start_2g+0x32c>)
    5824:	a808      	add	r0, sp, #32
    5826:	47b0      	blx	r6
          if(sim_read(sim_rxbuf,"OK\r\n",15,sizeof(sim_rxbuf))==0) {
    5828:	2800      	cmp	r0, #0
    582a:	d05e      	beq.n	58ea <sim_start_2g+0x132>
          task->retries = 0;
    582c:	2300      	movs	r3, #0
          next_state = SIM_TASK_STATE_START2G_GET_SIMSTATE;
    582e:	2502      	movs	r5, #2
          task->retries = 0;
    5830:	71a3      	strb	r3, [r4, #6]
          break;
    5832:	e038      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"SIM_TASK_STATE_START2G_GET_SIMSTATE\n\r");
    5834:	49ac      	ldr	r1, [pc, #688]	; (5ae8 <sim_start_2g+0x330>)
    5836:	2000      	movs	r0, #0
    5838:	47b0      	blx	r6
          memset(sim_rxbuf,0,sizeof(sim_rxbuf));
    583a:	2280      	movs	r2, #128	; 0x80
    583c:	2100      	movs	r1, #0
    583e:	0052      	lsls	r2, r2, #1
    5840:	4baa      	ldr	r3, [pc, #680]	; (5aec <sim_start_2g+0x334>)
    5842:	a808      	add	r0, sp, #32
    5844:	4798      	blx	r3
          sim_state=sim_2g_state(sim_rxbuf,sizeof(sim_rxbuf));
    5846:	2180      	movs	r1, #128	; 0x80
    5848:	4ba9      	ldr	r3, [pc, #676]	; (5af0 <sim_start_2g+0x338>)
    584a:	0049      	lsls	r1, r1, #1
    584c:	a808      	add	r0, sp, #32
    584e:	4798      	blx	r3
    5850:	0007      	movs	r7, r0
          uart_print(0,"2g:state=%s\n\r",sim_state);
    5852:	0002      	movs	r2, r0
    5854:	49a7      	ldr	r1, [pc, #668]	; (5af4 <sim_start_2g+0x33c>)
    5856:	2000      	movs	r0, #0
    5858:	47b0      	blx	r6
          if(strncmp(sim_state,"IP INITIAL",10)==0) {
    585a:	220a      	movs	r2, #10
    585c:	49a6      	ldr	r1, [pc, #664]	; (5af8 <sim_start_2g+0x340>)
    585e:	0038      	movs	r0, r7
    5860:	4ea6      	ldr	r6, [pc, #664]	; (5afc <sim_start_2g+0x344>)
    5862:	47b0      	blx	r6
              next_state = SIM_TASK_STATE_START2G_INIT;
    5864:	2503      	movs	r5, #3
          if(strncmp(sim_state,"IP INITIAL",10)==0) {
    5866:	2800      	cmp	r0, #0
    5868:	d01d      	beq.n	58a6 <sim_start_2g+0xee>
          } else if(strncmp(sim_state,"IP START",8)==0) {
    586a:	2208      	movs	r2, #8
    586c:	49a4      	ldr	r1, [pc, #656]	; (5b00 <sim_start_2g+0x348>)
    586e:	0038      	movs	r0, r7
    5870:	47b0      	blx	r6
              next_state = SIM_TASK_STATE_START2G_START;
    5872:	3501      	adds	r5, #1
          } else if(strncmp(sim_state,"IP START",8)==0) {
    5874:	2800      	cmp	r0, #0
    5876:	d016      	beq.n	58a6 <sim_start_2g+0xee>
          } else if(strncmp(sim_state,"IP GPRSACT",10)==0) {
    5878:	220a      	movs	r2, #10
    587a:	49a2      	ldr	r1, [pc, #648]	; (5b04 <sim_start_2g+0x34c>)
    587c:	0038      	movs	r0, r7
    587e:	47b0      	blx	r6
              next_state = SIM_TASK_STATE_START2G_GPRSACT;
    5880:	3504      	adds	r5, #4
          } else if(strncmp(sim_state,"IP GPRSACT",10)==0) {
    5882:	2800      	cmp	r0, #0
    5884:	d00f      	beq.n	58a6 <sim_start_2g+0xee>
          } else if(strncmp(sim_state,"IP STATUS",9)==0) {
    5886:	2209      	movs	r2, #9
    5888:	499f      	ldr	r1, [pc, #636]	; (5b08 <sim_start_2g+0x350>)
    588a:	0038      	movs	r0, r7
    588c:	47b0      	blx	r6
              next_state = SIM_TASK_STATE_START2G_STATUS;
    588e:	3501      	adds	r5, #1
          } else if(strncmp(sim_state,"IP STATUS",9)==0) {
    5890:	2800      	cmp	r0, #0
    5892:	d008      	beq.n	58a6 <sim_start_2g+0xee>
          } else if(strncmp(sim_state,"PDP DEACT",9)==0) {
    5894:	002a      	movs	r2, r5
    5896:	499d      	ldr	r1, [pc, #628]	; (5b0c <sim_start_2g+0x354>)
    5898:	0038      	movs	r0, r7
    589a:	47b0      	blx	r6
              next_state = SIM_TASK_STATE_FINISHED;
    589c:	4243      	negs	r3, r0
    589e:	4158      	adcs	r0, r3
              next_state = SIM_TASK_STATE_START2G_DEACT;
    58a0:	3502      	adds	r5, #2
              next_state = SIM_TASK_STATE_FINISHED;
    58a2:	4240      	negs	r0, r0
    58a4:	4005      	ands	r5, r0
    task->state = next_state;
    58a6:	7165      	strb	r5, [r4, #5]
}
    58a8:	b049      	add	sp, #292	; 0x124
    58aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
          uart_print(0,"SIM_TASK_STATE_START2G_INIT\n\r");
    58ac:	4998      	ldr	r1, [pc, #608]	; (5b10 <sim_start_2g+0x358>)
    58ae:	2000      	movs	r0, #0
    58b0:	47b0      	blx	r6
          sim_tx(cmd2,strlen(cmd2));
    58b2:	2114      	movs	r1, #20
    58b4:	4897      	ldr	r0, [pc, #604]	; (5b14 <sim_start_2g+0x35c>)
    58b6:	4e88      	ldr	r6, [pc, #544]	; (5ad8 <sim_start_2g+0x320>)
    58b8:	47b0      	blx	r6
          len=sprintf(buf,"%s\"\r",eeprom_sim.apn);
    58ba:	4a97      	ldr	r2, [pc, #604]	; (5b18 <sim_start_2g+0x360>)
    58bc:	4b97      	ldr	r3, [pc, #604]	; (5b1c <sim_start_2g+0x364>)
    58be:	4998      	ldr	r1, [pc, #608]	; (5b20 <sim_start_2g+0x368>)
    58c0:	a803      	add	r0, sp, #12
    58c2:	4798      	blx	r3
          sim_tx(buf,len);
    58c4:	21ff      	movs	r1, #255	; 0xff
    58c6:	4001      	ands	r1, r0
    58c8:	a803      	add	r0, sp, #12
    58ca:	47b0      	blx	r6
          sim_read(sim_rxbuf,"AT+SAPBR=3,1,",2,sizeof(sim_rxbuf)); // read echo
    58cc:	2380      	movs	r3, #128	; 0x80
    58ce:	2202      	movs	r2, #2
    58d0:	005b      	lsls	r3, r3, #1
    58d2:	4982      	ldr	r1, [pc, #520]	; (5adc <sim_start_2g+0x324>)
    58d4:	a808      	add	r0, sp, #32
    58d6:	4f82      	ldr	r7, [pc, #520]	; (5ae0 <sim_start_2g+0x328>)
    58d8:	47b8      	blx	r7
          if(sim_read(sim_rxbuf,"OK\r\n",2,sizeof(sim_rxbuf))==0) {
    58da:	2380      	movs	r3, #128	; 0x80
    58dc:	2202      	movs	r2, #2
    58de:	005b      	lsls	r3, r3, #1
    58e0:	4980      	ldr	r1, [pc, #512]	; (5ae4 <sim_start_2g+0x32c>)
    58e2:	a808      	add	r0, sp, #32
    58e4:	47b8      	blx	r7
    58e6:	2800      	cmp	r0, #0
    58e8:	d103      	bne.n	58f2 <sim_start_2g+0x13a>
              task->retries++;
    58ea:	79a3      	ldrb	r3, [r4, #6]
    58ec:	3301      	adds	r3, #1
    58ee:	71a3      	strb	r3, [r4, #6]
              break;
    58f0:	e7d9      	b.n	58a6 <sim_start_2g+0xee>
          sim_tx(cmd3,strlen(cmd3));
    58f2:	2115      	movs	r1, #21
    58f4:	488b      	ldr	r0, [pc, #556]	; (5b24 <sim_start_2g+0x36c>)
    58f6:	47b0      	blx	r6
          len=sprintf(buf,"%s\"\r",eeprom_sim.user);
    58f8:	4a8b      	ldr	r2, [pc, #556]	; (5b28 <sim_start_2g+0x370>)
    58fa:	4b88      	ldr	r3, [pc, #544]	; (5b1c <sim_start_2g+0x364>)
    58fc:	4988      	ldr	r1, [pc, #544]	; (5b20 <sim_start_2g+0x368>)
    58fe:	a803      	add	r0, sp, #12
    5900:	4798      	blx	r3
          sim_tx(buf,len);
    5902:	21ff      	movs	r1, #255	; 0xff
    5904:	4001      	ands	r1, r0
    5906:	a803      	add	r0, sp, #12
    5908:	47b0      	blx	r6
          sim_read(sim_rxbuf,"AT+SAPBR=3,1,",2,sizeof(sim_rxbuf)); // read echo
    590a:	2380      	movs	r3, #128	; 0x80
    590c:	2202      	movs	r2, #2
    590e:	005b      	lsls	r3, r3, #1
    5910:	4972      	ldr	r1, [pc, #456]	; (5adc <sim_start_2g+0x324>)
    5912:	a808      	add	r0, sp, #32
    5914:	47b8      	blx	r7
          if(sim_read(sim_rxbuf,"OK\r\n",2,sizeof(sim_rxbuf))==0) {
    5916:	2380      	movs	r3, #128	; 0x80
    5918:	2202      	movs	r2, #2
    591a:	005b      	lsls	r3, r3, #1
    591c:	4971      	ldr	r1, [pc, #452]	; (5ae4 <sim_start_2g+0x32c>)
    591e:	a808      	add	r0, sp, #32
    5920:	47b8      	blx	r7
    5922:	2800      	cmp	r0, #0
    5924:	d0e1      	beq.n	58ea <sim_start_2g+0x132>
          sim_tx(cmd4,strlen(cmd4));
    5926:	2114      	movs	r1, #20
    5928:	4880      	ldr	r0, [pc, #512]	; (5b2c <sim_start_2g+0x374>)
    592a:	47b0      	blx	r6
          len=sprintf(buf,"%s\"\r",eeprom_sim.pwd);
    592c:	4b80      	ldr	r3, [pc, #512]	; (5b30 <sim_start_2g+0x378>)
    592e:	497c      	ldr	r1, [pc, #496]	; (5b20 <sim_start_2g+0x368>)
    5930:	334b      	adds	r3, #75	; 0x4b
    5932:	001a      	movs	r2, r3
    5934:	9301      	str	r3, [sp, #4]
    5936:	a803      	add	r0, sp, #12
    5938:	4b78      	ldr	r3, [pc, #480]	; (5b1c <sim_start_2g+0x364>)
    593a:	4798      	blx	r3
          sim_tx(buf,len);
    593c:	21ff      	movs	r1, #255	; 0xff
    593e:	4001      	ands	r1, r0
    5940:	a803      	add	r0, sp, #12
    5942:	47b0      	blx	r6
          sim_read(sim_rxbuf,"AT+SAPBR=3,1,",2,sizeof(sim_rxbuf)); // read echo
    5944:	2380      	movs	r3, #128	; 0x80
    5946:	2202      	movs	r2, #2
    5948:	005b      	lsls	r3, r3, #1
    594a:	4964      	ldr	r1, [pc, #400]	; (5adc <sim_start_2g+0x324>)
    594c:	a808      	add	r0, sp, #32
    594e:	47b8      	blx	r7
          if(sim_read(sim_rxbuf,"OK\r\n",2,sizeof(sim_rxbuf))==0) {
    5950:	2380      	movs	r3, #128	; 0x80
    5952:	2202      	movs	r2, #2
    5954:	005b      	lsls	r3, r3, #1
    5956:	4963      	ldr	r1, [pc, #396]	; (5ae4 <sim_start_2g+0x32c>)
    5958:	a808      	add	r0, sp, #32
    595a:	47b8      	blx	r7
    595c:	2800      	cmp	r0, #0
    595e:	d0c4      	beq.n	58ea <sim_start_2g+0x132>
          sim_tx(cmd5,strlen(cmd5));
    5960:	2109      	movs	r1, #9
    5962:	4874      	ldr	r0, [pc, #464]	; (5b34 <sim_start_2g+0x37c>)
    5964:	47b0      	blx	r6
          len=sprintf(buf,"%s\",\"",eeprom_sim.apn);
    5966:	4a6c      	ldr	r2, [pc, #432]	; (5b18 <sim_start_2g+0x360>)
    5968:	4b6c      	ldr	r3, [pc, #432]	; (5b1c <sim_start_2g+0x364>)
    596a:	4973      	ldr	r1, [pc, #460]	; (5b38 <sim_start_2g+0x380>)
    596c:	a803      	add	r0, sp, #12
    596e:	4798      	blx	r3
          sim_tx(buf,len);
    5970:	21ff      	movs	r1, #255	; 0xff
    5972:	4001      	ands	r1, r0
    5974:	a803      	add	r0, sp, #12
    5976:	47b0      	blx	r6
          len=sprintf(buf,"%s\",\"",eeprom_sim.user);
    5978:	4a6b      	ldr	r2, [pc, #428]	; (5b28 <sim_start_2g+0x370>)
    597a:	4b68      	ldr	r3, [pc, #416]	; (5b1c <sim_start_2g+0x364>)
    597c:	496e      	ldr	r1, [pc, #440]	; (5b38 <sim_start_2g+0x380>)
    597e:	a803      	add	r0, sp, #12
    5980:	4798      	blx	r3
          sim_tx(buf,len);
    5982:	21ff      	movs	r1, #255	; 0xff
    5984:	4001      	ands	r1, r0
    5986:	a803      	add	r0, sp, #12
    5988:	47b0      	blx	r6
          len=sprintf(buf,"%s\"\r",eeprom_sim.pwd);
    598a:	9a01      	ldr	r2, [sp, #4]
    598c:	4b63      	ldr	r3, [pc, #396]	; (5b1c <sim_start_2g+0x364>)
    598e:	4964      	ldr	r1, [pc, #400]	; (5b20 <sim_start_2g+0x368>)
    5990:	a803      	add	r0, sp, #12
    5992:	4798      	blx	r3
          sim_tx(buf,len);
    5994:	21ff      	movs	r1, #255	; 0xff
    5996:	4001      	ands	r1, r0
    5998:	a803      	add	r0, sp, #12
    599a:	47b0      	blx	r6
          sim_read(sim_rxbuf,"AT+CSTT=",15,sizeof(sim_rxbuf)); // read echo
    599c:	2380      	movs	r3, #128	; 0x80
    599e:	220f      	movs	r2, #15
    59a0:	005b      	lsls	r3, r3, #1
    59a2:	4966      	ldr	r1, [pc, #408]	; (5b3c <sim_start_2g+0x384>)
    59a4:	a808      	add	r0, sp, #32
    59a6:	47b8      	blx	r7
          if(sim_read(sim_rxbuf,"OK\r\n",15,sizeof(sim_rxbuf))==0) {
    59a8:	2380      	movs	r3, #128	; 0x80
    59aa:	220f      	movs	r2, #15
    59ac:	005b      	lsls	r3, r3, #1
    59ae:	494d      	ldr	r1, [pc, #308]	; (5ae4 <sim_start_2g+0x32c>)
    59b0:	a808      	add	r0, sp, #32
    59b2:	47b8      	blx	r7
    59b4:	e738      	b.n	5828 <sim_start_2g+0x70>
          uart_print(0,"SIM_TASK_STATE_START2G_START\n\r");
    59b6:	4962      	ldr	r1, [pc, #392]	; (5b40 <sim_start_2g+0x388>)
    59b8:	2000      	movs	r0, #0
    59ba:	47b0      	blx	r6
          sim_tx(cmd6,strlen(cmd6));
    59bc:	4b46      	ldr	r3, [pc, #280]	; (5ad8 <sim_start_2g+0x320>)
    59be:	2109      	movs	r1, #9
    59c0:	4860      	ldr	r0, [pc, #384]	; (5b44 <sim_start_2g+0x38c>)
    59c2:	4798      	blx	r3
          task->arg2=20; // seconds wait
    59c4:	2314      	movs	r3, #20
          next_state = SIM_TASK_STATE_START2G_START_WAIT1;
    59c6:	2505      	movs	r5, #5
          task->arg2=20; // seconds wait
    59c8:	7123      	strb	r3, [r4, #4]
          break;
    59ca:	e76c      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"SIM_TASK_STATE_START2G_START_WAIT1\n\r");
    59cc:	495e      	ldr	r1, [pc, #376]	; (5b48 <sim_start_2g+0x390>)
    59ce:	2000      	movs	r0, #0
    59d0:	47b0      	blx	r6
          task->arg2--;
    59d2:	7923      	ldrb	r3, [r4, #4]
    59d4:	3b01      	subs	r3, #1
    59d6:	b2db      	uxtb	r3, r3
    59d8:	7123      	strb	r3, [r4, #4]
          if(task->arg2 == 0) {
    59da:	2b00      	cmp	r3, #0
    59dc:	d000      	beq.n	59e0 <sim_start_2g+0x228>
    59de:	e762      	b.n	58a6 <sim_start_2g+0xee>
              next_state = SIM_TASK_STATE_START2G_START2;
    59e0:	2507      	movs	r5, #7
    59e2:	e760      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"SIM_TASK_STATE_START2G_START2\n\r");
    59e4:	4959      	ldr	r1, [pc, #356]	; (5b4c <sim_start_2g+0x394>)
    59e6:	2000      	movs	r0, #0
    59e8:	47b0      	blx	r6
          if(sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf))==0) {
    59ea:	2380      	movs	r3, #128	; 0x80
    59ec:	2214      	movs	r2, #20
    59ee:	005b      	lsls	r3, r3, #1
    59f0:	493c      	ldr	r1, [pc, #240]	; (5ae4 <sim_start_2g+0x32c>)
    59f2:	a808      	add	r0, sp, #32
    59f4:	4d3a      	ldr	r5, [pc, #232]	; (5ae0 <sim_start_2g+0x328>)
    59f6:	47a8      	blx	r5
    59f8:	2800      	cmp	r0, #0
    59fa:	d000      	beq.n	59fe <sim_start_2g+0x246>
    59fc:	e716      	b.n	582c <sim_start_2g+0x74>
              task->retries++;
    59fe:	79a3      	ldrb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_START2G_START;              
    5a00:	2504      	movs	r5, #4
              task->retries++;
    5a02:	3301      	adds	r3, #1
    5a04:	71a3      	strb	r3, [r4, #6]
              break;
    5a06:	e74e      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"SIM_TASK_STATE_START2G_GPRSACT\n\r");
    5a08:	4951      	ldr	r1, [pc, #324]	; (5b50 <sim_start_2g+0x398>)
    5a0a:	2000      	movs	r0, #0
    5a0c:	47b0      	blx	r6
          sim_tx(cmd7,strlen(cmd7));
    5a0e:	4e51      	ldr	r6, [pc, #324]	; (5b54 <sim_start_2g+0x39c>)
    5a10:	2109      	movs	r1, #9
    5a12:	0030      	movs	r0, r6
    5a14:	4b30      	ldr	r3, [pc, #192]	; (5ad8 <sim_start_2g+0x320>)
    5a16:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd7,15,sizeof(sim_rxbuf)); // read echo
    5a18:	2380      	movs	r3, #128	; 0x80
    5a1a:	0031      	movs	r1, r6
    5a1c:	005b      	lsls	r3, r3, #1
    5a1e:	220f      	movs	r2, #15
    5a20:	a808      	add	r0, sp, #32
    5a22:	4e2f      	ldr	r6, [pc, #188]	; (5ae0 <sim_start_2g+0x328>)
    5a24:	47b0      	blx	r6
          if(sim_read(sim_rxbuf,".",15,sizeof(sim_rxbuf))==0) { // response is the ip address
    5a26:	2380      	movs	r3, #128	; 0x80
    5a28:	220f      	movs	r2, #15
    5a2a:	005b      	lsls	r3, r3, #1
    5a2c:	494a      	ldr	r1, [pc, #296]	; (5b58 <sim_start_2g+0x3a0>)
    5a2e:	a808      	add	r0, sp, #32
    5a30:	47b0      	blx	r6
    5a32:	2800      	cmp	r0, #0
    5a34:	d100      	bne.n	5a38 <sim_start_2g+0x280>
    5a36:	e758      	b.n	58ea <sim_start_2g+0x132>
          sim_rxflush();
    5a38:	4b48      	ldr	r3, [pc, #288]	; (5b5c <sim_start_2g+0x3a4>)
    5a3a:	4798      	blx	r3
    5a3c:	e6f6      	b.n	582c <sim_start_2g+0x74>
          uart_print(0,"SIM_TASK_STATE_START2G_STATUS\n\r");
    5a3e:	4948      	ldr	r1, [pc, #288]	; (5b60 <sim_start_2g+0x3a8>)
    5a40:	2000      	movs	r0, #0
    5a42:	47b0      	blx	r6
          sim_tx(cmd8,strlen(cmd8));
    5a44:	4d47      	ldr	r5, [pc, #284]	; (5b64 <sim_start_2g+0x3ac>)
    5a46:	210d      	movs	r1, #13
    5a48:	0028      	movs	r0, r5
    5a4a:	4b23      	ldr	r3, [pc, #140]	; (5ad8 <sim_start_2g+0x320>)
    5a4c:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd8,20,sizeof(sim_rxbuf)); // read echo
    5a4e:	2380      	movs	r3, #128	; 0x80
    5a50:	0029      	movs	r1, r5
    5a52:	005b      	lsls	r3, r3, #1
    5a54:	4d22      	ldr	r5, [pc, #136]	; (5ae0 <sim_start_2g+0x328>)
    5a56:	2214      	movs	r2, #20
    5a58:	a808      	add	r0, sp, #32
    5a5a:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_START2G_STATUS2;
    5a5c:	250a      	movs	r5, #10
          break;
    5a5e:	e722      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"SIM_TASK_STATE_START2G_STATUS2\n\r");
    5a60:	4941      	ldr	r1, [pc, #260]	; (5b68 <sim_start_2g+0x3b0>)
    5a62:	2000      	movs	r0, #0
    5a64:	47b0      	blx	r6
          if(sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf))==0) {
    5a66:	2380      	movs	r3, #128	; 0x80
    5a68:	2214      	movs	r2, #20
    5a6a:	005b      	lsls	r3, r3, #1
    5a6c:	491d      	ldr	r1, [pc, #116]	; (5ae4 <sim_start_2g+0x32c>)
    5a6e:	a808      	add	r0, sp, #32
    5a70:	4d1b      	ldr	r5, [pc, #108]	; (5ae0 <sim_start_2g+0x328>)
    5a72:	47a8      	blx	r5
    5a74:	2800      	cmp	r0, #0
    5a76:	d104      	bne.n	5a82 <sim_start_2g+0x2ca>
              task->retries++;
    5a78:	79a3      	ldrb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_START2G_STATUS;
    5a7a:	2509      	movs	r5, #9
              task->retries++;
    5a7c:	3301      	adds	r3, #1
    5a7e:	71a3      	strb	r3, [r4, #6]
              break;
    5a80:	e711      	b.n	58a6 <sim_start_2g+0xee>
          task->retries = 0;
    5a82:	2500      	movs	r5, #0
    5a84:	71a5      	strb	r5, [r4, #6]
          break;
    5a86:	e70e      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"SIM_TASK_STATE_START2G_DEACT\n\r");
    5a88:	4938      	ldr	r1, [pc, #224]	; (5b6c <sim_start_2g+0x3b4>)
    5a8a:	2000      	movs	r0, #0
    5a8c:	47b0      	blx	r6
          sim_tx(cmd9_shut,strlen(cmd9_shut));
    5a8e:	4d38      	ldr	r5, [pc, #224]	; (5b70 <sim_start_2g+0x3b8>)
    5a90:	210b      	movs	r1, #11
    5a92:	0028      	movs	r0, r5
    5a94:	4b10      	ldr	r3, [pc, #64]	; (5ad8 <sim_start_2g+0x320>)
    5a96:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd9_shut,20,sizeof(sim_rxbuf)); // read echo
    5a98:	2380      	movs	r3, #128	; 0x80
    5a9a:	0029      	movs	r1, r5
    5a9c:	2214      	movs	r2, #20
    5a9e:	005b      	lsls	r3, r3, #1
    5aa0:	4d0f      	ldr	r5, [pc, #60]	; (5ae0 <sim_start_2g+0x328>)
    5aa2:	a808      	add	r0, sp, #32
    5aa4:	47a8      	blx	r5
          delay_ms(200);
    5aa6:	20c8      	movs	r0, #200	; 0xc8
    5aa8:	4b32      	ldr	r3, [pc, #200]	; (5b74 <sim_start_2g+0x3bc>)
    5aaa:	4798      	blx	r3
          sim_read(sim_rxbuf,"SHUT OK\r\n",40,sizeof(sim_rxbuf));
    5aac:	2380      	movs	r3, #128	; 0x80
    5aae:	2228      	movs	r2, #40	; 0x28
    5ab0:	005b      	lsls	r3, r3, #1
    5ab2:	4931      	ldr	r1, [pc, #196]	; (5b78 <sim_start_2g+0x3c0>)
    5ab4:	a808      	add	r0, sp, #32
    5ab6:	47a8      	blx	r5
          task->retries = 5; // does not make sense to send2g message
    5ab8:	2305      	movs	r3, #5
    5aba:	71a3      	strb	r3, [r4, #6]
          next_state = SIM_TASK_STATE_FINISHED;
    5abc:	2500      	movs	r5, #0
          break;
    5abe:	e6f2      	b.n	58a6 <sim_start_2g+0xee>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    5ac0:	492e      	ldr	r1, [pc, #184]	; (5b7c <sim_start_2g+0x3c4>)
    5ac2:	2000      	movs	r0, #0
    5ac4:	47b0      	blx	r6
    5ac6:	e7f9      	b.n	5abc <sim_start_2g+0x304>
    5ac8:	00004e4d 	.word	0x00004e4d
    5acc:	00007b99 	.word	0x00007b99
    5ad0:	0000aeed 	.word	0x0000aeed
    5ad4:	0000b046 	.word	0x0000b046
    5ad8:	0000525d 	.word	0x0000525d
    5adc:	0000b065 	.word	0x0000b065
    5ae0:	00005021 	.word	0x00005021
    5ae4:	0000afa0 	.word	0x0000afa0
    5ae8:	0000b073 	.word	0x0000b073
    5aec:	00008957 	.word	0x00008957
    5af0:	00005765 	.word	0x00005765
    5af4:	0000b099 	.word	0x0000b099
    5af8:	0000b0a7 	.word	0x0000b0a7
    5afc:	00008a95 	.word	0x00008a95
    5b00:	0000b0b2 	.word	0x0000b0b2
    5b04:	0000b0bb 	.word	0x0000b0bb
    5b08:	0000b0c6 	.word	0x0000b0c6
    5b0c:	0000b0d0 	.word	0x0000b0d0
    5b10:	0000b0da 	.word	0x0000b0da
    5b14:	0000b0f8 	.word	0x0000b0f8
    5b18:	2000085c 	.word	0x2000085c
    5b1c:	00008969 	.word	0x00008969
    5b20:	0000af2c 	.word	0x0000af2c
    5b24:	0000b10d 	.word	0x0000b10d
    5b28:	2000086c 	.word	0x2000086c
    5b2c:	0000b123 	.word	0x0000b123
    5b30:	20000831 	.word	0x20000831
    5b34:	0000b138 	.word	0x0000b138
    5b38:	0000b142 	.word	0x0000b142
    5b3c:	0000b148 	.word	0x0000b148
    5b40:	0000b151 	.word	0x0000b151
    5b44:	0000b170 	.word	0x0000b170
    5b48:	0000b17a 	.word	0x0000b17a
    5b4c:	0000b19f 	.word	0x0000b19f
    5b50:	0000b1bf 	.word	0x0000b1bf
    5b54:	0000b1e0 	.word	0x0000b1e0
    5b58:	0000b1ea 	.word	0x0000b1ea
    5b5c:	00004fc1 	.word	0x00004fc1
    5b60:	0000b1ec 	.word	0x0000b1ec
    5b64:	0000b20c 	.word	0x0000b20c
    5b68:	0000b21a 	.word	0x0000b21a
    5b6c:	0000b23b 	.word	0x0000b23b
    5b70:	0000b25a 	.word	0x0000b25a
    5b74:	00007c05 	.word	0x00007c05
    5b78:	0000b266 	.word	0x0000b266
    5b7c:	0000af63 	.word	0x0000af63

00005b80 <sim_send_2g_msg>:
{
    5b80:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    5b82:	4b97      	ldr	r3, [pc, #604]	; (5de0 <sim_send_2g_msg+0x260>)
{
    5b84:	b0e3      	sub	sp, #396	; 0x18c
    5b86:	0004      	movs	r4, r0
    uint8_t next_state=task->state;
    5b88:	7947      	ldrb	r7, [r0, #5]
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    5b8a:	4798      	blx	r3
    if(!sim_is_on()) {
    5b8c:	b2c0      	uxtb	r0, r0
    5b8e:	2800      	cmp	r0, #0
    5b90:	d102      	bne.n	5b98 <sim_send_2g_msg+0x18>
        task->retries = 5;
    5b92:	2305      	movs	r3, #5
        task->state = SIM_TASK_STATE_FINISHED;
    5b94:	7160      	strb	r0, [r4, #5]
        task->retries = 5;
    5b96:	71a3      	strb	r3, [r4, #6]
    if(task->retries > 5) {
    5b98:	79a3      	ldrb	r3, [r4, #6]
    5b9a:	2b05      	cmp	r3, #5
    5b9c:	d903      	bls.n	5ba6 <sim_send_2g_msg+0x26>
        task->state = SIM_TASK_STATE_SEND2G_TERM;
    5b9e:	230c      	movs	r3, #12
    5ba0:	7163      	strb	r3, [r4, #5]
        task->retries = 0;
    5ba2:	2300      	movs	r3, #0
    5ba4:	71a3      	strb	r3, [r4, #6]
    switch(task->state) {
    5ba6:	7960      	ldrb	r0, [r4, #5]
    5ba8:	4d8e      	ldr	r5, [pc, #568]	; (5de4 <sim_send_2g_msg+0x264>)
    5baa:	3801      	subs	r0, #1
    5bac:	280b      	cmp	r0, #11
    5bae:	d900      	bls.n	5bb2 <sim_send_2g_msg+0x32>
    5bb0:	e111      	b.n	5dd6 <sim_send_2g_msg+0x256>
    5bb2:	f002 f9df 	bl	7f74 <__gnu_thumb1_case_uhi>
    5bb6:	000c      	.short	0x000c
    5bb8:	0054003a 	.word	0x0054003a
    5bbc:	008c0081 	.word	0x008c0081
    5bc0:	00aa0097 	.word	0x00aa0097
    5bc4:	00ce00c5 	.word	0x00ce00c5
    5bc8:	00d800d3 	.word	0x00d800d3
    5bcc:	00f7      	.short	0x00f7
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    5bce:	4986      	ldr	r1, [pc, #536]	; (5de8 <sim_send_2g_msg+0x268>)
    5bd0:	2000      	movs	r0, #0
    5bd2:	47a8      	blx	r5
          sim_tx(cmd1_init,strlen(cmd1_init));
    5bd4:	4d85      	ldr	r5, [pc, #532]	; (5dec <sim_send_2g_msg+0x26c>)
    5bd6:	210c      	movs	r1, #12
    5bd8:	0028      	movs	r0, r5
    5bda:	4b85      	ldr	r3, [pc, #532]	; (5df0 <sim_send_2g_msg+0x270>)
    5bdc:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd1_init,10,sizeof(sim_rxbuf)); // read echo
    5bde:	23c0      	movs	r3, #192	; 0xc0
    5be0:	0029      	movs	r1, r5
    5be2:	005b      	lsls	r3, r3, #1
    5be4:	220a      	movs	r2, #10
    5be6:	a802      	add	r0, sp, #8
    5be8:	4d82      	ldr	r5, [pc, #520]	; (5df4 <sim_send_2g_msg+0x274>)
    5bea:	47a8      	blx	r5
          if(sim_read(sim_rxbuf,"OK\r\n",15,sizeof(sim_rxbuf))==0) {
    5bec:	23c0      	movs	r3, #192	; 0xc0
    5bee:	4e82      	ldr	r6, [pc, #520]	; (5df8 <sim_send_2g_msg+0x278>)
    5bf0:	005b      	lsls	r3, r3, #1
    5bf2:	220f      	movs	r2, #15
    5bf4:	0031      	movs	r1, r6
    5bf6:	a802      	add	r0, sp, #8
    5bf8:	47a8      	blx	r5
    5bfa:	2800      	cmp	r0, #0
    5bfc:	d10f      	bne.n	5c1e <sim_send_2g_msg+0x9e>
              sim_rxflush();
    5bfe:	4b7f      	ldr	r3, [pc, #508]	; (5dfc <sim_send_2g_msg+0x27c>)
    5c00:	4798      	blx	r3
              sim_tx(cmd2_term,strlen(cmd2_term));
    5c02:	210c      	movs	r1, #12
    5c04:	487e      	ldr	r0, [pc, #504]	; (5e00 <sim_send_2g_msg+0x280>)
    5c06:	4b7a      	ldr	r3, [pc, #488]	; (5df0 <sim_send_2g_msg+0x270>)
    5c08:	4798      	blx	r3
              sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf));
    5c0a:	23c0      	movs	r3, #192	; 0xc0
    5c0c:	2214      	movs	r2, #20
    5c0e:	005b      	lsls	r3, r3, #1
    5c10:	0031      	movs	r1, r6
    5c12:	a802      	add	r0, sp, #8
    5c14:	47a8      	blx	r5
              task->retries++;
    5c16:	79a3      	ldrb	r3, [r4, #6]
    5c18:	3301      	adds	r3, #1
    5c1a:	71a3      	strb	r3, [r4, #6]
              break;
    5c1c:	e002      	b.n	5c24 <sim_send_2g_msg+0xa4>
          task->retries = 0;
    5c1e:	2300      	movs	r3, #0
          next_state = SIM_TASK_STATE_SEND2G_HTTPPARA_CID;
    5c20:	2702      	movs	r7, #2
          task->retries = 0;
    5c22:	71a3      	strb	r3, [r4, #6]
    task->state = next_state;
    5c24:	7167      	strb	r7, [r4, #5]
}
    5c26:	b063      	add	sp, #396	; 0x18c
    5c28:	bdf0      	pop	{r4, r5, r6, r7, pc}
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPPARA_CID\n\r");
    5c2a:	4976      	ldr	r1, [pc, #472]	; (5e04 <sim_send_2g_msg+0x284>)
    5c2c:	2000      	movs	r0, #0
    5c2e:	47a8      	blx	r5
          sim_tx(cmd3_para_cid,strlen(cmd3_para_cid));
    5c30:	2114      	movs	r1, #20
    5c32:	4875      	ldr	r0, [pc, #468]	; (5e08 <sim_send_2g_msg+0x288>)
    5c34:	4b6e      	ldr	r3, [pc, #440]	; (5df0 <sim_send_2g_msg+0x270>)
    5c36:	4798      	blx	r3
          sim_read(sim_rxbuf,"AT+HTTPPARA=",10,sizeof(sim_rxbuf)); // read echo
    5c38:	23c0      	movs	r3, #192	; 0xc0
    5c3a:	220a      	movs	r2, #10
    5c3c:	005b      	lsls	r3, r3, #1
    5c3e:	4973      	ldr	r1, [pc, #460]	; (5e0c <sim_send_2g_msg+0x28c>)
    5c40:	a802      	add	r0, sp, #8
    5c42:	4d6c      	ldr	r5, [pc, #432]	; (5df4 <sim_send_2g_msg+0x274>)
    5c44:	47a8      	blx	r5
          if(sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf))==0) {
    5c46:	23c0      	movs	r3, #192	; 0xc0
    5c48:	2214      	movs	r2, #20
    5c4a:	005b      	lsls	r3, r3, #1
    5c4c:	496a      	ldr	r1, [pc, #424]	; (5df8 <sim_send_2g_msg+0x278>)
    5c4e:	a802      	add	r0, sp, #8
    5c50:	47a8      	blx	r5
    5c52:	2800      	cmp	r0, #0
    5c54:	d0df      	beq.n	5c16 <sim_send_2g_msg+0x96>
          task->retries = 0;
    5c56:	2300      	movs	r3, #0
          next_state = SIM_TASK_STATE_SEND2G_HTTPPARA_URL;
    5c58:	2703      	movs	r7, #3
          task->retries = 0;
    5c5a:	71a3      	strb	r3, [r4, #6]
          break;
    5c5c:	e7e2      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPPARA_URL\n\r");
    5c5e:	496c      	ldr	r1, [pc, #432]	; (5e10 <sim_send_2g_msg+0x290>)
    5c60:	2000      	movs	r0, #0
    5c62:	47a8      	blx	r5
          uart_print(0,"send2g:%s\n\r",UART_SIM_TxBuf);
    5c64:	4e6b      	ldr	r6, [pc, #428]	; (5e14 <sim_send_2g_msg+0x294>)
    5c66:	496c      	ldr	r1, [pc, #432]	; (5e18 <sim_send_2g_msg+0x298>)
    5c68:	1cb3      	adds	r3, r6, #2
    5c6a:	001a      	movs	r2, r3
    5c6c:	2000      	movs	r0, #0
    5c6e:	9301      	str	r3, [sp, #4]
    5c70:	47a8      	blx	r5
          sim_tx(cmd4_para_url,strlen(cmd4_para_url));
    5c72:	4e5f      	ldr	r6, [pc, #380]	; (5df0 <sim_send_2g_msg+0x270>)
    5c74:	2113      	movs	r1, #19
    5c76:	4869      	ldr	r0, [pc, #420]	; (5e1c <sim_send_2g_msg+0x29c>)
    5c78:	47b0      	blx	r6
          sim_tx(UART_SIM_TxBuf,task->arg1); // send prepared command+msg
    5c7a:	8861      	ldrh	r1, [r4, #2]
    5c7c:	9801      	ldr	r0, [sp, #4]
    5c7e:	47b0      	blx	r6
          sim_tx("\"\r",2); // end of command
    5c80:	2102      	movs	r1, #2
    5c82:	4867      	ldr	r0, [pc, #412]	; (5e20 <sim_send_2g_msg+0x2a0>)
    5c84:	47b0      	blx	r6
          uart_print(0,"send2g:sent!\n\r");
    5c86:	4967      	ldr	r1, [pc, #412]	; (5e24 <sim_send_2g_msg+0x2a4>)
    5c88:	2000      	movs	r0, #0
    5c8a:	47a8      	blx	r5
          sim_read(sim_rxbuf,"AT+HTTPPARA=",20,sizeof(sim_rxbuf)); // read echo
    5c8c:	23c0      	movs	r3, #192	; 0xc0
    5c8e:	2214      	movs	r2, #20
    5c90:	005b      	lsls	r3, r3, #1
    5c92:	495e      	ldr	r1, [pc, #376]	; (5e0c <sim_send_2g_msg+0x28c>)
    5c94:	a802      	add	r0, sp, #8
    5c96:	4e57      	ldr	r6, [pc, #348]	; (5df4 <sim_send_2g_msg+0x274>)
    5c98:	47b0      	blx	r6
          uart_print(0,"echo rec\n\r");
    5c9a:	4963      	ldr	r1, [pc, #396]	; (5e28 <sim_send_2g_msg+0x2a8>)
    5c9c:	2000      	movs	r0, #0
    5c9e:	47a8      	blx	r5
          if(sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf))==0) {
    5ca0:	23c0      	movs	r3, #192	; 0xc0
    5ca2:	2214      	movs	r2, #20
    5ca4:	005b      	lsls	r3, r3, #1
    5ca6:	4954      	ldr	r1, [pc, #336]	; (5df8 <sim_send_2g_msg+0x278>)
    5ca8:	a802      	add	r0, sp, #8
    5caa:	47b0      	blx	r6
    5cac:	2800      	cmp	r0, #0
    5cae:	d0b2      	beq.n	5c16 <sim_send_2g_msg+0x96>
          task->retries = 0;
    5cb0:	2300      	movs	r3, #0
              task->retries++;
    5cb2:	71a3      	strb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_SEND2G_HTTPACTION;
    5cb4:	2704      	movs	r7, #4
              break;
    5cb6:	e7b5      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPACTION\n\r");
    5cb8:	495c      	ldr	r1, [pc, #368]	; (5e2c <sim_send_2g_msg+0x2ac>)
    5cba:	2000      	movs	r0, #0
    5cbc:	47a8      	blx	r5
          sim_tx(cmd5_action,strlen(cmd5_action));
    5cbe:	4b4c      	ldr	r3, [pc, #304]	; (5df0 <sim_send_2g_msg+0x270>)
    5cc0:	2110      	movs	r1, #16
    5cc2:	485b      	ldr	r0, [pc, #364]	; (5e30 <sim_send_2g_msg+0x2b0>)
    5cc4:	4798      	blx	r3
          task->arg2=20; // seconds wait  
    5cc6:	2314      	movs	r3, #20
          next_state = SIM_TASK_STATE_SEND2G_HTTPACTION_WAIT1;
    5cc8:	2705      	movs	r7, #5
          task->arg2=20; // seconds wait  
    5cca:	7123      	strb	r3, [r4, #4]
          break;
    5ccc:	e7aa      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPACTION_WAIT1\n\r");
    5cce:	4959      	ldr	r1, [pc, #356]	; (5e34 <sim_send_2g_msg+0x2b4>)
    5cd0:	2000      	movs	r0, #0
    5cd2:	47a8      	blx	r5
          task->arg2--;
    5cd4:	7923      	ldrb	r3, [r4, #4]
    5cd6:	3b01      	subs	r3, #1
    5cd8:	b2db      	uxtb	r3, r3
    5cda:	7123      	strb	r3, [r4, #4]
          if(task->arg2 == 0) {
    5cdc:	2b00      	cmp	r3, #0
    5cde:	d1a1      	bne.n	5c24 <sim_send_2g_msg+0xa4>
              next_state = SIM_TASK_STATE_SEND2G_HTTPACTION2;
    5ce0:	2706      	movs	r7, #6
    5ce2:	e79f      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPACTION2\n\r");
    5ce4:	4954      	ldr	r1, [pc, #336]	; (5e38 <sim_send_2g_msg+0x2b8>)
    5ce6:	2000      	movs	r0, #0
    5ce8:	47a8      	blx	r5
          if(sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf))==0) {
    5cea:	23c0      	movs	r3, #192	; 0xc0
    5cec:	2214      	movs	r2, #20
    5cee:	005b      	lsls	r3, r3, #1
    5cf0:	4941      	ldr	r1, [pc, #260]	; (5df8 <sim_send_2g_msg+0x278>)
    5cf2:	a802      	add	r0, sp, #8
    5cf4:	4d3f      	ldr	r5, [pc, #252]	; (5df4 <sim_send_2g_msg+0x274>)
    5cf6:	47a8      	blx	r5
    5cf8:	2800      	cmp	r0, #0
    5cfa:	d102      	bne.n	5d02 <sim_send_2g_msg+0x182>
              task->retries++;
    5cfc:	79a3      	ldrb	r3, [r4, #6]
    5cfe:	3301      	adds	r3, #1
    5d00:	e7d7      	b.n	5cb2 <sim_send_2g_msg+0x132>
          task->retries = 0;
    5d02:	2300      	movs	r3, #0
          next_state = SIM_TASK_STATE_SEND2G_HTTPREAD;
    5d04:	2707      	movs	r7, #7
          task->retries = 0;
    5d06:	71a3      	strb	r3, [r4, #6]
          break;          
    5d08:	e78c      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPREAD\n\r");
    5d0a:	494c      	ldr	r1, [pc, #304]	; (5e3c <sim_send_2g_msg+0x2bc>)
    5d0c:	2000      	movs	r0, #0
    5d0e:	47a8      	blx	r5
          sim_tx(cmd7_httpread,strlen(cmd7_httpread));
    5d10:	4d4b      	ldr	r5, [pc, #300]	; (5e40 <sim_send_2g_msg+0x2c0>)
    5d12:	2112      	movs	r1, #18
    5d14:	0028      	movs	r0, r5
    5d16:	4b36      	ldr	r3, [pc, #216]	; (5df0 <sim_send_2g_msg+0x270>)
    5d18:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd7_httpread,20,sizeof(sim_rxbuf)); // read echo
    5d1a:	23c0      	movs	r3, #192	; 0xc0
    5d1c:	0029      	movs	r1, r5
    5d1e:	005b      	lsls	r3, r3, #1
    5d20:	2214      	movs	r2, #20
    5d22:	4d34      	ldr	r5, [pc, #208]	; (5df4 <sim_send_2g_msg+0x274>)
    5d24:	a802      	add	r0, sp, #8
    5d26:	47a8      	blx	r5
          sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf));
    5d28:	23c0      	movs	r3, #192	; 0xc0
    5d2a:	2214      	movs	r2, #20
    5d2c:	005b      	lsls	r3, r3, #1
    5d2e:	4932      	ldr	r1, [pc, #200]	; (5df8 <sim_send_2g_msg+0x278>)
    5d30:	a802      	add	r0, sp, #8
    5d32:	47a8      	blx	r5
          sim_rxflush();
    5d34:	4b31      	ldr	r3, [pc, #196]	; (5dfc <sim_send_2g_msg+0x27c>)
    5d36:	4798      	blx	r3
          task->retries = 0;
    5d38:	2300      	movs	r3, #0
              task->retries++;
    5d3a:	71a3      	strb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_SEND2G_HTTPSTATUS;
    5d3c:	2708      	movs	r7, #8
              break;
    5d3e:	e771      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPSTATUS\n\r");
    5d40:	4940      	ldr	r1, [pc, #256]	; (5e44 <sim_send_2g_msg+0x2c4>)
    5d42:	2000      	movs	r0, #0
    5d44:	47a8      	blx	r5
          sim_tx(cmd6_status,strlen(cmd6_status));
    5d46:	210f      	movs	r1, #15
    5d48:	483f      	ldr	r0, [pc, #252]	; (5e48 <sim_send_2g_msg+0x2c8>)
    5d4a:	4b29      	ldr	r3, [pc, #164]	; (5df0 <sim_send_2g_msg+0x270>)
    5d4c:	4798      	blx	r3
          next_state = SIM_TASK_STATE_SEND2G_HTTPSTATUS_WAIT1;
    5d4e:	2709      	movs	r7, #9
          break;
    5d50:	e768      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPSTATUS_WAIT1\n\r");
    5d52:	493e      	ldr	r1, [pc, #248]	; (5e4c <sim_send_2g_msg+0x2cc>)
    5d54:	2000      	movs	r0, #0
    5d56:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_SEND2G_HTTPSTATUS_WAIT2;
    5d58:	270a      	movs	r7, #10
          break;  
    5d5a:	e763      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPSTATUS_WAIT2\n\r");          
    5d5c:	493c      	ldr	r1, [pc, #240]	; (5e50 <sim_send_2g_msg+0x2d0>)
    5d5e:	2000      	movs	r0, #0
    5d60:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_SEND2G_HTTPSTATUS2;
    5d62:	270b      	movs	r7, #11
          break;
    5d64:	e75e      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_HTTPSTATUS2\n\r");
    5d66:	493b      	ldr	r1, [pc, #236]	; (5e54 <sim_send_2g_msg+0x2d4>)
    5d68:	2000      	movs	r0, #0
    5d6a:	47a8      	blx	r5
          sim_read(sim_rxbuf,cmd6_status,20,sizeof(sim_rxbuf)); // read echo
    5d6c:	23c0      	movs	r3, #192	; 0xc0
    5d6e:	2214      	movs	r2, #20
    5d70:	005b      	lsls	r3, r3, #1
    5d72:	4935      	ldr	r1, [pc, #212]	; (5e48 <sim_send_2g_msg+0x2c8>)
    5d74:	a802      	add	r0, sp, #8
    5d76:	4d1f      	ldr	r5, [pc, #124]	; (5df4 <sim_send_2g_msg+0x274>)
    5d78:	47a8      	blx	r5
          if(sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf))==0) {
    5d7a:	23c0      	movs	r3, #192	; 0xc0
    5d7c:	2214      	movs	r2, #20
    5d7e:	005b      	lsls	r3, r3, #1
    5d80:	491d      	ldr	r1, [pc, #116]	; (5df8 <sim_send_2g_msg+0x278>)
    5d82:	a802      	add	r0, sp, #8
    5d84:	47a8      	blx	r5
    5d86:	2800      	cmp	r0, #0
    5d88:	d102      	bne.n	5d90 <sim_send_2g_msg+0x210>
              task->retries++;
    5d8a:	79a3      	ldrb	r3, [r4, #6]
    5d8c:	3301      	adds	r3, #1
    5d8e:	e7d4      	b.n	5d3a <sim_send_2g_msg+0x1ba>
          if(strstr(sim_rxbuf,"GET,0,0,0")==NULL) { // response should become 0,0,0
    5d90:	4931      	ldr	r1, [pc, #196]	; (5e58 <sim_send_2g_msg+0x2d8>)
    5d92:	a802      	add	r0, sp, #8
    5d94:	4b31      	ldr	r3, [pc, #196]	; (5e5c <sim_send_2g_msg+0x2dc>)
    5d96:	4798      	blx	r3
    5d98:	2800      	cmp	r0, #0
    5d9a:	d0f6      	beq.n	5d8a <sim_send_2g_msg+0x20a>
          task->retries = 0;
    5d9c:	2300      	movs	r3, #0
          next_state = SIM_TASK_STATE_SEND2G_TERM;
    5d9e:	270c      	movs	r7, #12
          task->retries = 0;
    5da0:	71a3      	strb	r3, [r4, #6]
          break;
    5da2:	e73f      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"SIM_TASK_STATE_SEND2G_TERM\n\r");
    5da4:	492e      	ldr	r1, [pc, #184]	; (5e60 <sim_send_2g_msg+0x2e0>)
    5da6:	2000      	movs	r0, #0
    5da8:	47a8      	blx	r5
          sim_rxflush();
    5daa:	4b14      	ldr	r3, [pc, #80]	; (5dfc <sim_send_2g_msg+0x27c>)
    5dac:	4798      	blx	r3
          sim_tx(cmd2_term,strlen(cmd2_term));
    5dae:	4d14      	ldr	r5, [pc, #80]	; (5e00 <sim_send_2g_msg+0x280>)
    5db0:	210c      	movs	r1, #12
    5db2:	0028      	movs	r0, r5
    5db4:	4b0e      	ldr	r3, [pc, #56]	; (5df0 <sim_send_2g_msg+0x270>)
    5db6:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd2_term,10,sizeof(sim_rxbuf)); // read echo
    5db8:	23c0      	movs	r3, #192	; 0xc0
    5dba:	0029      	movs	r1, r5
    5dbc:	005b      	lsls	r3, r3, #1
    5dbe:	220a      	movs	r2, #10
    5dc0:	a802      	add	r0, sp, #8
    5dc2:	4d0c      	ldr	r5, [pc, #48]	; (5df4 <sim_send_2g_msg+0x274>)
    5dc4:	47a8      	blx	r5
          sim_read(sim_rxbuf,"OK\r\n",20,sizeof(sim_rxbuf));
    5dc6:	23c0      	movs	r3, #192	; 0xc0
    5dc8:	2214      	movs	r2, #20
    5dca:	005b      	lsls	r3, r3, #1
    5dcc:	490a      	ldr	r1, [pc, #40]	; (5df8 <sim_send_2g_msg+0x278>)
    5dce:	a802      	add	r0, sp, #8
    5dd0:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_FINISHED;
    5dd2:	2700      	movs	r7, #0
          break;
    5dd4:	e726      	b.n	5c24 <sim_send_2g_msg+0xa4>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    5dd6:	4923      	ldr	r1, [pc, #140]	; (5e64 <sim_send_2g_msg+0x2e4>)
    5dd8:	2000      	movs	r0, #0
    5dda:	47a8      	blx	r5
    5ddc:	e7f9      	b.n	5dd2 <sim_send_2g_msg+0x252>
    5dde:	46c0      	nop			; (mov r8, r8)
    5de0:	00004e4d 	.word	0x00004e4d
    5de4:	00007b99 	.word	0x00007b99
    5de8:	0000aeed 	.word	0x0000aeed
    5dec:	0000b270 	.word	0x0000b270
    5df0:	0000525d 	.word	0x0000525d
    5df4:	00005021 	.word	0x00005021
    5df8:	0000afa0 	.word	0x0000afa0
    5dfc:	00004fc1 	.word	0x00004fc1
    5e00:	0000b27d 	.word	0x0000b27d
    5e04:	0000b28a 	.word	0x0000b28a
    5e08:	0000b2af 	.word	0x0000b2af
    5e0c:	0000b2c4 	.word	0x0000b2c4
    5e10:	0000b2d1 	.word	0x0000b2d1
    5e14:	20000631 	.word	0x20000631
    5e18:	0000b2f6 	.word	0x0000b2f6
    5e1c:	0000b302 	.word	0x0000b302
    5e20:	0000afdc 	.word	0x0000afdc
    5e24:	0000b316 	.word	0x0000b316
    5e28:	0000b325 	.word	0x0000b325
    5e2c:	0000b330 	.word	0x0000b330
    5e30:	0000b353 	.word	0x0000b353
    5e34:	0000b364 	.word	0x0000b364
    5e38:	0000b38d 	.word	0x0000b38d
    5e3c:	0000b3b1 	.word	0x0000b3b1
    5e40:	0000b3d2 	.word	0x0000b3d2
    5e44:	0000b3e5 	.word	0x0000b3e5
    5e48:	0000b408 	.word	0x0000b408
    5e4c:	0000b418 	.word	0x0000b418
    5e50:	0000b441 	.word	0x0000b441
    5e54:	0000b46a 	.word	0x0000b46a
    5e58:	0000b48e 	.word	0x0000b48e
    5e5c:	00008ae1 	.word	0x00008ae1
    5e60:	0000b498 	.word	0x0000b498
    5e64:	0000af63 	.word	0x0000af63

00005e68 <sim_wait>:
{
    5e68:	b570      	push	{r4, r5, r6, lr}
    uint8_t next_state=task->state;
    5e6a:	7945      	ldrb	r5, [r0, #5]
{
    5e6c:	0004      	movs	r4, r0
    5e6e:	4e0c      	ldr	r6, [pc, #48]	; (5ea0 <sim_wait+0x38>)
    switch(task->state) {
    5e70:	2d01      	cmp	r5, #1
    5e72:	d10d      	bne.n	5e90 <sim_wait+0x28>
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    5e74:	490b      	ldr	r1, [pc, #44]	; (5ea4 <sim_wait+0x3c>)
    5e76:	2000      	movs	r0, #0
    5e78:	47b0      	blx	r6
          task->arg1--;
    5e7a:	8862      	ldrh	r2, [r4, #2]
    5e7c:	3a01      	subs	r2, #1
    5e7e:	b292      	uxth	r2, r2
    5e80:	8062      	strh	r2, [r4, #2]
          if(task->arg1 == 0) {
    5e82:	2a00      	cmp	r2, #0
    5e84:	d009      	beq.n	5e9a <sim_wait+0x32>
              uart_print(0,"wait %d more seconds\n\r",task->arg1);
    5e86:	4908      	ldr	r1, [pc, #32]	; (5ea8 <sim_wait+0x40>)
    5e88:	2000      	movs	r0, #0
    5e8a:	47b0      	blx	r6
    task->state = next_state;
    5e8c:	7165      	strb	r5, [r4, #5]
}
    5e8e:	bd70      	pop	{r4, r5, r6, pc}
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    5e90:	4906      	ldr	r1, [pc, #24]	; (5eac <sim_wait+0x44>)
    5e92:	2000      	movs	r0, #0
    5e94:	47b0      	blx	r6
          next_state = SIM_TASK_STATE_FINISHED;
    5e96:	2500      	movs	r5, #0
          break;
    5e98:	e7f8      	b.n	5e8c <sim_wait+0x24>
              next_state = SIM_TASK_STATE_FINISHED;
    5e9a:	0015      	movs	r5, r2
    5e9c:	e7f6      	b.n	5e8c <sim_wait+0x24>
    5e9e:	46c0      	nop			; (mov r8, r8)
    5ea0:	00007b99 	.word	0x00007b99
    5ea4:	0000aeed 	.word	0x0000aeed
    5ea8:	0000b4b5 	.word	0x0000b4b5
    5eac:	0000af63 	.word	0x0000af63

00005eb0 <sim_stop_2g>:
{
    5eb0:	b530      	push	{r4, r5, lr}
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    5eb2:	4b31      	ldr	r3, [pc, #196]	; (5f78 <sim_stop_2g+0xc8>)
{
    5eb4:	b091      	sub	sp, #68	; 0x44
    5eb6:	0004      	movs	r4, r0
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    5eb8:	4798      	blx	r3
    if(!sim_is_on()) {
    5eba:	b2c0      	uxtb	r0, r0
    5ebc:	2800      	cmp	r0, #0
    5ebe:	d100      	bne.n	5ec2 <sim_stop_2g+0x12>
        task->state = SIM_TASK_STATE_FINISHED;
    5ec0:	7160      	strb	r0, [r4, #5]
    if(task->retries > 5) {
    5ec2:	79a3      	ldrb	r3, [r4, #6]
    5ec4:	2b05      	cmp	r3, #5
    5ec6:	d903      	bls.n	5ed0 <sim_stop_2g+0x20>
        task->state = SIM_TASK_STATE_STOP2G_TERM;
    5ec8:	2304      	movs	r3, #4
    5eca:	7163      	strb	r3, [r4, #5]
        task->retries = 0;
    5ecc:	2300      	movs	r3, #0
    5ece:	71a3      	strb	r3, [r4, #6]
    switch(task->state) {
    5ed0:	7960      	ldrb	r0, [r4, #5]
    5ed2:	4b2a      	ldr	r3, [pc, #168]	; (5f7c <sim_stop_2g+0xcc>)
    5ed4:	3801      	subs	r0, #1
    5ed6:	2804      	cmp	r0, #4
    5ed8:	d84a      	bhi.n	5f70 <sim_stop_2g+0xc0>
    5eda:	f002 f841 	bl	7f60 <__gnu_thumb1_case_uqi>
    5ede:	1503      	.short	0x1503
    5ee0:	2e1a      	.short	0x2e1a
    5ee2:	3e          	.byte	0x3e
    5ee3:	00          	.byte	0x00
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    5ee4:	4926      	ldr	r1, [pc, #152]	; (5f80 <sim_stop_2g+0xd0>)
    5ee6:	2000      	movs	r0, #0
    5ee8:	4798      	blx	r3
          sim_tx(cmd1_sapbr,strlen(cmd1_sapbr));
    5eea:	4d26      	ldr	r5, [pc, #152]	; (5f84 <sim_stop_2g+0xd4>)
    5eec:	210d      	movs	r1, #13
    5eee:	0028      	movs	r0, r5
    5ef0:	4b25      	ldr	r3, [pc, #148]	; (5f88 <sim_stop_2g+0xd8>)
    5ef2:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd1_sapbr,10,sizeof(sim_rxbuf)); // read echo
    5ef4:	2340      	movs	r3, #64	; 0x40
    5ef6:	0029      	movs	r1, r5
    5ef8:	220a      	movs	r2, #10
    5efa:	4668      	mov	r0, sp
    5efc:	4d23      	ldr	r5, [pc, #140]	; (5f8c <sim_stop_2g+0xdc>)
    5efe:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_STOP2G_WAIT;
    5f00:	2302      	movs	r3, #2
    task->state = next_state;
    5f02:	7163      	strb	r3, [r4, #5]
}
    5f04:	b011      	add	sp, #68	; 0x44
    5f06:	bd30      	pop	{r4, r5, pc}
          uart_print(0,"SIM_TASK_STATE_STOP2G_WAIT\n\r");
    5f08:	4921      	ldr	r1, [pc, #132]	; (5f90 <sim_stop_2g+0xe0>)
    5f0a:	2000      	movs	r0, #0
    5f0c:	4798      	blx	r3
          next_state = SIM_TASK_STATE_STOP2G_SAPBR_RESPONSE;
    5f0e:	2303      	movs	r3, #3
          break;
    5f10:	e7f7      	b.n	5f02 <sim_stop_2g+0x52>
          uart_print(0,"SIM_TASK_STATE_STOP2G_SAPBR_RESPONSE\n\r");
    5f12:	4920      	ldr	r1, [pc, #128]	; (5f94 <sim_stop_2g+0xe4>)
    5f14:	2000      	movs	r0, #0
    5f16:	4798      	blx	r3
          if(sim_read(sim_rxbuf,"OK\r\n",10,sizeof(sim_rxbuf)) == 0) {
    5f18:	2340      	movs	r3, #64	; 0x40
    5f1a:	220a      	movs	r2, #10
    5f1c:	491e      	ldr	r1, [pc, #120]	; (5f98 <sim_stop_2g+0xe8>)
    5f1e:	4668      	mov	r0, sp
    5f20:	4d1a      	ldr	r5, [pc, #104]	; (5f8c <sim_stop_2g+0xdc>)
    5f22:	47a8      	blx	r5
    5f24:	2800      	cmp	r0, #0
    5f26:	d104      	bne.n	5f32 <sim_stop_2g+0x82>
              task->retries++;
    5f28:	79a3      	ldrb	r3, [r4, #6]
    5f2a:	3301      	adds	r3, #1
    5f2c:	71a3      	strb	r3, [r4, #6]
              next_state = SIM_TASK_STATE_START;
    5f2e:	2301      	movs	r3, #1
              break;
    5f30:	e7e7      	b.n	5f02 <sim_stop_2g+0x52>
          task->retries = 0;
    5f32:	2300      	movs	r3, #0
    5f34:	71a3      	strb	r3, [r4, #6]
          next_state = SIM_TASK_STATE_STOP2G_TERM;
    5f36:	3304      	adds	r3, #4
          break;
    5f38:	e7e3      	b.n	5f02 <sim_stop_2g+0x52>
          uart_print(0,"SIM_TASK_STATE_STOP2G_TERM\n\r");
    5f3a:	4918      	ldr	r1, [pc, #96]	; (5f9c <sim_stop_2g+0xec>)
    5f3c:	2000      	movs	r0, #0
    5f3e:	4798      	blx	r3
          sim_tx(cmd2_shut,strlen(cmd2_shut));
    5f40:	4d17      	ldr	r5, [pc, #92]	; (5fa0 <sim_stop_2g+0xf0>)
    5f42:	210b      	movs	r1, #11
    5f44:	0028      	movs	r0, r5
    5f46:	4b10      	ldr	r3, [pc, #64]	; (5f88 <sim_stop_2g+0xd8>)
    5f48:	4798      	blx	r3
          sim_read(sim_rxbuf,cmd2_shut,10,sizeof(sim_rxbuf)); // read echo
    5f4a:	2340      	movs	r3, #64	; 0x40
    5f4c:	0029      	movs	r1, r5
    5f4e:	220a      	movs	r2, #10
    5f50:	4668      	mov	r0, sp
    5f52:	4d0e      	ldr	r5, [pc, #56]	; (5f8c <sim_stop_2g+0xdc>)
    5f54:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_STOP2G_TERM_WAIT;
    5f56:	2305      	movs	r3, #5
          break;
    5f58:	e7d3      	b.n	5f02 <sim_stop_2g+0x52>
          uart_print(0,"SIM_TASK_STATE_STOP2G_TERM_WAIT\n\r");
    5f5a:	4912      	ldr	r1, [pc, #72]	; (5fa4 <sim_stop_2g+0xf4>)
    5f5c:	2000      	movs	r0, #0
    5f5e:	4798      	blx	r3
          sim_read(sim_rxbuf,"SHUT OK\r\n",10,sizeof(sim_rxbuf));
    5f60:	2340      	movs	r3, #64	; 0x40
    5f62:	220a      	movs	r2, #10
    5f64:	4910      	ldr	r1, [pc, #64]	; (5fa8 <sim_stop_2g+0xf8>)
    5f66:	4668      	mov	r0, sp
    5f68:	4d08      	ldr	r5, [pc, #32]	; (5f8c <sim_stop_2g+0xdc>)
    5f6a:	47a8      	blx	r5
          next_state = SIM_TASK_STATE_FINISHED;
    5f6c:	2300      	movs	r3, #0
          break;
    5f6e:	e7c8      	b.n	5f02 <sim_stop_2g+0x52>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    5f70:	490e      	ldr	r1, [pc, #56]	; (5fac <sim_stop_2g+0xfc>)
    5f72:	2000      	movs	r0, #0
    5f74:	4798      	blx	r3
    5f76:	e7f9      	b.n	5f6c <sim_stop_2g+0xbc>
    5f78:	00004e4d 	.word	0x00004e4d
    5f7c:	00007b99 	.word	0x00007b99
    5f80:	0000aeed 	.word	0x0000aeed
    5f84:	0000b4cc 	.word	0x0000b4cc
    5f88:	0000525d 	.word	0x0000525d
    5f8c:	00005021 	.word	0x00005021
    5f90:	0000b4da 	.word	0x0000b4da
    5f94:	0000b4f7 	.word	0x0000b4f7
    5f98:	0000afa0 	.word	0x0000afa0
    5f9c:	0000b51e 	.word	0x0000b51e
    5fa0:	0000b25a 	.word	0x0000b25a
    5fa4:	0000b53b 	.word	0x0000b53b
    5fa8:	0000b266 	.word	0x0000b266
    5fac:	0000af63 	.word	0x0000af63

00005fb0 <sim_read_CREG>:
{
    5fb0:	b510      	push	{r4, lr}
    sim_tx(cmd,strlen(cmd));
    5fb2:	4c12      	ldr	r4, [pc, #72]	; (5ffc <sim_read_CREG+0x4c>)
{
    5fb4:	b092      	sub	sp, #72	; 0x48
    sim_tx(cmd,strlen(cmd));
    5fb6:	0020      	movs	r0, r4
    5fb8:	2109      	movs	r1, #9
    5fba:	4b11      	ldr	r3, [pc, #68]	; (6000 <sim_read_CREG+0x50>)
    5fbc:	4798      	blx	r3
    sim_read(sim_rxbuf,cmd,10,sizeof(sim_rxbuf)); // read echo
    5fbe:	0021      	movs	r1, r4
    5fc0:	2340      	movs	r3, #64	; 0x40
    5fc2:	220a      	movs	r2, #10
    5fc4:	a802      	add	r0, sp, #8
    5fc6:	4c0f      	ldr	r4, [pc, #60]	; (6004 <sim_read_CREG+0x54>)
    5fc8:	47a0      	blx	r4
    if(sim_read(sim_rxbuf,"OK\r\n",10,sizeof(sim_rxbuf))==0)
    5fca:	2340      	movs	r3, #64	; 0x40
    5fcc:	220a      	movs	r2, #10
    5fce:	490e      	ldr	r1, [pc, #56]	; (6008 <sim_read_CREG+0x58>)
    5fd0:	a802      	add	r0, sp, #8
    5fd2:	47a0      	blx	r4
    5fd4:	2800      	cmp	r0, #0
    5fd6:	d103      	bne.n	5fe0 <sim_read_CREG+0x30>
        return -1;
    5fd8:	2001      	movs	r0, #1
    5fda:	4240      	negs	r0, r0
}
    5fdc:	b012      	add	sp, #72	; 0x48
    5fde:	bd10      	pop	{r4, pc}
    found=sscanf(ptr,"\r\n+CREG: 0,%d",&stat);
    5fe0:	aa01      	add	r2, sp, #4
    5fe2:	490a      	ldr	r1, [pc, #40]	; (600c <sim_read_CREG+0x5c>)
    5fe4:	a802      	add	r0, sp, #8
    5fe6:	4b0a      	ldr	r3, [pc, #40]	; (6010 <sim_read_CREG+0x60>)
    5fe8:	4798      	blx	r3
    if(found==1) {
    5fea:	2801      	cmp	r0, #1
    5fec:	d1f4      	bne.n	5fd8 <sim_read_CREG+0x28>
        uart_print(0,"CREG:%d\n\r",stat);
    5fee:	2000      	movs	r0, #0
    5ff0:	9a01      	ldr	r2, [sp, #4]
    5ff2:	4908      	ldr	r1, [pc, #32]	; (6014 <sim_read_CREG+0x64>)
    5ff4:	4b08      	ldr	r3, [pc, #32]	; (6018 <sim_read_CREG+0x68>)
    5ff6:	4798      	blx	r3
        return stat;
    5ff8:	9801      	ldr	r0, [sp, #4]
    5ffa:	e7ef      	b.n	5fdc <sim_read_CREG+0x2c>
    5ffc:	0000b55d 	.word	0x0000b55d
    6000:	0000525d 	.word	0x0000525d
    6004:	00005021 	.word	0x00005021
    6008:	0000afa0 	.word	0x0000afa0
    600c:	0000b567 	.word	0x0000b567
    6010:	000089ad 	.word	0x000089ad
    6014:	0000b575 	.word	0x0000b575
    6018:	00007b99 	.word	0x00007b99

0000601c <sim_check_creg>:
{
    601c:	b570      	push	{r4, r5, r6, lr}
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    601e:	4b17      	ldr	r3, [pc, #92]	; (607c <sim_check_creg+0x60>)
{
    6020:	0004      	movs	r4, r0
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    6022:	4798      	blx	r3
    if(!sim_is_on()) {
    6024:	b2c0      	uxtb	r0, r0
    6026:	2800      	cmp	r0, #0
    6028:	d102      	bne.n	6030 <sim_check_creg+0x14>
        task->retries = 5;
    602a:	2305      	movs	r3, #5
        task->state = SIM_TASK_STATE_FINISHED;
    602c:	7160      	strb	r0, [r4, #5]
        task->retries = 5;
    602e:	71a3      	strb	r3, [r4, #6]
    if(task->retries > 5) {
    6030:	79a3      	ldrb	r3, [r4, #6]
    6032:	2b05      	cmp	r3, #5
    6034:	d901      	bls.n	603a <sim_check_creg+0x1e>
        task->state = SIM_TASK_STATE_FINISHED;        
    6036:	2300      	movs	r3, #0
    6038:	7163      	strb	r3, [r4, #5]
    switch(task->state) {
    603a:	7963      	ldrb	r3, [r4, #5]
    603c:	4e10      	ldr	r6, [pc, #64]	; (6080 <sim_check_creg+0x64>)
    603e:	2b01      	cmp	r3, #1
    6040:	d118      	bne.n	6074 <sim_check_creg+0x58>
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    6042:	4910      	ldr	r1, [pc, #64]	; (6084 <sim_check_creg+0x68>)
    6044:	2000      	movs	r0, #0
    6046:	47b0      	blx	r6
          creg = sim_read_CREG();
    6048:	4b0f      	ldr	r3, [pc, #60]	; (6088 <sim_check_creg+0x6c>)
    604a:	4798      	blx	r3
          uart_print(0,"creg=%d\n\r",creg);
    604c:	490f      	ldr	r1, [pc, #60]	; (608c <sim_check_creg+0x70>)
          creg = sim_read_CREG();
    604e:	0005      	movs	r5, r0
          uart_print(0,"creg=%d\n\r",creg);
    6050:	0002      	movs	r2, r0
    6052:	2000      	movs	r0, #0
    6054:	47b0      	blx	r6
          if(creg!=1 && creg!=5) { // 1 or 5 is registered
    6056:	2304      	movs	r3, #4
    6058:	439d      	bics	r5, r3
    605a:	2d01      	cmp	r5, #1
    605c:	d004      	beq.n	6068 <sim_check_creg+0x4c>
              task->retries = 5;
    605e:	3301      	adds	r3, #1
    6060:	71a3      	strb	r3, [r4, #6]
    task->state = next_state;
    6062:	2300      	movs	r3, #0
    6064:	7163      	strb	r3, [r4, #5]
}
    6066:	bd70      	pop	{r4, r5, r6, pc}
          sysval.signalstrength=sim_read_signalstrength();
    6068:	4b09      	ldr	r3, [pc, #36]	; (6090 <sim_check_creg+0x74>)
    606a:	4798      	blx	r3
    606c:	4b09      	ldr	r3, [pc, #36]	; (6094 <sim_check_creg+0x78>)
    606e:	33c0      	adds	r3, #192	; 0xc0
    6070:	7018      	strb	r0, [r3, #0]
          break;
    6072:	e7f6      	b.n	6062 <sim_check_creg+0x46>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    6074:	4908      	ldr	r1, [pc, #32]	; (6098 <sim_check_creg+0x7c>)
    6076:	2000      	movs	r0, #0
    6078:	47b0      	blx	r6
          break;
    607a:	e7f2      	b.n	6062 <sim_check_creg+0x46>
    607c:	00004e4d 	.word	0x00004e4d
    6080:	00007b99 	.word	0x00007b99
    6084:	0000aeed 	.word	0x0000aeed
    6088:	00005fb1 	.word	0x00005fb1
    608c:	0000b57f 	.word	0x0000b57f
    6090:	000056e9 	.word	0x000056e9
    6094:	20000a58 	.word	0x20000a58
    6098:	0000af63 	.word	0x0000af63

0000609c <sim_set_flowcontrol>:
{
    609c:	b570      	push	{r4, r5, r6, lr}
    sim_tx(cmd1,strlen(cmd1)); // set hardware flow control
    609e:	210b      	movs	r1, #11
{
    60a0:	b088      	sub	sp, #32
    sim_tx(cmd1,strlen(cmd1)); // set hardware flow control
    60a2:	4e0a      	ldr	r6, [pc, #40]	; (60cc <sim_set_flowcontrol+0x30>)
    60a4:	480a      	ldr	r0, [pc, #40]	; (60d0 <sim_set_flowcontrol+0x34>)
    60a6:	47b0      	blx	r6
    sim_read(sim_rxbuf,"OK\r\n",10,sizeof(sim_rxbuf));
    60a8:	4d0a      	ldr	r5, [pc, #40]	; (60d4 <sim_set_flowcontrol+0x38>)
    60aa:	2320      	movs	r3, #32
    60ac:	220a      	movs	r2, #10
    60ae:	0029      	movs	r1, r5
    60b0:	4c09      	ldr	r4, [pc, #36]	; (60d8 <sim_set_flowcontrol+0x3c>)
    60b2:	4668      	mov	r0, sp
    60b4:	47a0      	blx	r4
    sim_tx(cmd2,strlen(cmd2)); // do not go to sleep
    60b6:	210b      	movs	r1, #11
    60b8:	4808      	ldr	r0, [pc, #32]	; (60dc <sim_set_flowcontrol+0x40>)
    60ba:	47b0      	blx	r6
    return (uint8_t)sim_read(sim_rxbuf,"OK\r\n",10,sizeof(sim_rxbuf));
    60bc:	2320      	movs	r3, #32
    60be:	220a      	movs	r2, #10
    60c0:	0029      	movs	r1, r5
    60c2:	4668      	mov	r0, sp
    60c4:	47a0      	blx	r4
    60c6:	b2c0      	uxtb	r0, r0
}
    60c8:	b008      	add	sp, #32
    60ca:	bd70      	pop	{r4, r5, r6, pc}
    60cc:	0000525d 	.word	0x0000525d
    60d0:	0000b589 	.word	0x0000b589
    60d4:	0000afa0 	.word	0x0000afa0
    60d8:	00005021 	.word	0x00005021
    60dc:	0000b595 	.word	0x0000b595

000060e0 <sim_set_textmode>:
{
    60e0:	b510      	push	{r4, lr}
    sim_tx(cmd,strlen(cmd)); // select text mode
    60e2:	210a      	movs	r1, #10
{
    60e4:	b088      	sub	sp, #32
    sim_tx(cmd,strlen(cmd)); // select text mode
    60e6:	4806      	ldr	r0, [pc, #24]	; (6100 <sim_set_textmode+0x20>)
    60e8:	4b06      	ldr	r3, [pc, #24]	; (6104 <sim_set_textmode+0x24>)
    60ea:	4798      	blx	r3
    return (uint8_t)sim_read(sim_rxbuf,"OK\r\n",5,sizeof(sim_rxbuf));
    60ec:	2320      	movs	r3, #32
    60ee:	2205      	movs	r2, #5
    60f0:	4905      	ldr	r1, [pc, #20]	; (6108 <sim_set_textmode+0x28>)
    60f2:	4668      	mov	r0, sp
    60f4:	4c05      	ldr	r4, [pc, #20]	; (610c <sim_set_textmode+0x2c>)
    60f6:	47a0      	blx	r4
    60f8:	b2c0      	uxtb	r0, r0
}
    60fa:	b008      	add	sp, #32
    60fc:	bd10      	pop	{r4, pc}
    60fe:	46c0      	nop			; (mov r8, r8)
    6100:	0000b5a1 	.word	0x0000b5a1
    6104:	0000525d 	.word	0x0000525d
    6108:	0000afa0 	.word	0x0000afa0
    610c:	00005021 	.word	0x00005021

00006110 <sim_pincode_check>:
{
    6110:	b510      	push	{r4, lr}
    sim_tx(cmd,strlen(cmd));
    6112:	2109      	movs	r1, #9
{
    6114:	b088      	sub	sp, #32
    sim_tx(cmd,strlen(cmd));
    6116:	4809      	ldr	r0, [pc, #36]	; (613c <sim_pincode_check+0x2c>)
    6118:	4b09      	ldr	r3, [pc, #36]	; (6140 <sim_pincode_check+0x30>)
    611a:	4798      	blx	r3
    delay_ms(200);
    611c:	20c8      	movs	r0, #200	; 0xc8
    611e:	4b09      	ldr	r3, [pc, #36]	; (6144 <sim_pincode_check+0x34>)
    6120:	4798      	blx	r3
    len=sim_read(sim_rxbuf,"READY",30,sizeof(sim_rxbuf));
    6122:	221e      	movs	r2, #30
    6124:	4908      	ldr	r1, [pc, #32]	; (6148 <sim_pincode_check+0x38>)
    6126:	2320      	movs	r3, #32
    6128:	4668      	mov	r0, sp
    612a:	4c08      	ldr	r4, [pc, #32]	; (614c <sim_pincode_check+0x3c>)
    612c:	47a0      	blx	r4
    sim_rxflush();
    612e:	4b08      	ldr	r3, [pc, #32]	; (6150 <sim_pincode_check+0x40>)
    len=sim_read(sim_rxbuf,"READY",30,sizeof(sim_rxbuf));
    6130:	0004      	movs	r4, r0
    sim_rxflush();
    6132:	4798      	blx	r3
    return (uint8_t)len;
    6134:	b2e0      	uxtb	r0, r4
}
    6136:	b008      	add	sp, #32
    6138:	bd10      	pop	{r4, pc}
    613a:	46c0      	nop			; (mov r8, r8)
    613c:	0000b5ac 	.word	0x0000b5ac
    6140:	0000525d 	.word	0x0000525d
    6144:	00007c05 	.word	0x00007c05
    6148:	0000b5b6 	.word	0x0000b5b6
    614c:	00005021 	.word	0x00005021
    6150:	00004fc1 	.word	0x00004fc1

00006154 <sim_prepare_data_message>:
    uint8_t len=0;
    6154:	2300      	movs	r3, #0
{
    6156:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6158:	4c11      	ldr	r4, [pc, #68]	; (61a0 <sim_prepare_data_message+0x4c>)
    615a:	9101      	str	r1, [sp, #4]
    615c:	4f11      	ldr	r7, [pc, #68]	; (61a4 <sim_prepare_data_message+0x50>)
    if(!sms_only) {
    615e:	4298      	cmp	r0, r3
    6160:	d114      	bne.n	618c <sim_prepare_data_message+0x38>
        len+=sprintf(&UART_SIM_TxBuf[len],"http://");    
    6162:	1ca5      	adds	r5, r4, #2
    6164:	4e10      	ldr	r6, [pc, #64]	; (61a8 <sim_prepare_data_message+0x54>)
    6166:	4911      	ldr	r1, [pc, #68]	; (61ac <sim_prepare_data_message+0x58>)
    6168:	0028      	movs	r0, r5
    616a:	47b0      	blx	r6
        strcpy(&UART_SIM_TxBuf[len],eeprom_sim.hostname);    
    616c:	0020      	movs	r0, r4
    616e:	4910      	ldr	r1, [pc, #64]	; (61b0 <sim_prepare_data_message+0x5c>)
    6170:	3009      	adds	r0, #9
    6172:	3103      	adds	r1, #3
    6174:	47b0      	blx	r6
        len=strlen(UART_SIM_TxBuf);
    6176:	0028      	movs	r0, r5
    6178:	47b8      	blx	r7
    617a:	b2c3      	uxtb	r3, r0
        len+=sprintf(&UART_SIM_TxBuf[len],"/analytics/datapoint_backend/?data=");
    617c:	b2c0      	uxtb	r0, r0
    617e:	1828      	adds	r0, r5, r0
    6180:	490c      	ldr	r1, [pc, #48]	; (61b4 <sim_prepare_data_message+0x60>)
        len=strlen(UART_SIM_TxBuf);
    6182:	9300      	str	r3, [sp, #0]
        len+=sprintf(&UART_SIM_TxBuf[len],"/analytics/datapoint_backend/?data=");
    6184:	47b0      	blx	r6
    6186:	9b00      	ldr	r3, [sp, #0]
    6188:	3323      	adds	r3, #35	; 0x23
    618a:	b2db      	uxtb	r3, r3
    sprintf(&UART_SIM_TxBuf[len],"%09ld;",system_id);    
    618c:	3402      	adds	r4, #2
    618e:	18e0      	adds	r0, r4, r3
    6190:	9a01      	ldr	r2, [sp, #4]
    6192:	4909      	ldr	r1, [pc, #36]	; (61b8 <sim_prepare_data_message+0x64>)
    6194:	4b09      	ldr	r3, [pc, #36]	; (61bc <sim_prepare_data_message+0x68>)
    6196:	4798      	blx	r3
    len=strlen(UART_SIM_TxBuf);
    6198:	0020      	movs	r0, r4
    619a:	47b8      	blx	r7
    return len;
    619c:	b2c0      	uxtb	r0, r0
}
    619e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    61a0:	20000631 	.word	0x20000631
    61a4:	00008a3f 	.word	0x00008a3f
    61a8:	00008a2f 	.word	0x00008a2f
    61ac:	0000b5bc 	.word	0x0000b5bc
    61b0:	20000831 	.word	0x20000831
    61b4:	0000b5c4 	.word	0x0000b5c4
    61b8:	0000b5e8 	.word	0x0000b5e8
    61bc:	00008969 	.word	0x00008969

000061c0 <sim_addto_data_message>:
{
    61c0:	b510      	push	{r4, lr}
    strcpy(&UART_SIM_TxBuf[offset],str);
    61c2:	4c05      	ldr	r4, [pc, #20]	; (61d8 <sim_addto_data_message+0x18>)
    61c4:	4b05      	ldr	r3, [pc, #20]	; (61dc <sim_addto_data_message+0x1c>)
    61c6:	3402      	adds	r4, #2
    61c8:	1820      	adds	r0, r4, r0
    61ca:	4798      	blx	r3
    return strlen(UART_SIM_TxBuf);
    61cc:	0020      	movs	r0, r4
    61ce:	4b04      	ldr	r3, [pc, #16]	; (61e0 <sim_addto_data_message+0x20>)
    61d0:	4798      	blx	r3
    61d2:	b2c0      	uxtb	r0, r0
}
    61d4:	bd10      	pop	{r4, pc}
    61d6:	46c0      	nop			; (mov r8, r8)
    61d8:	20000631 	.word	0x20000631
    61dc:	00008a2f 	.word	0x00008a2f
    61e0:	00008a3f 	.word	0x00008a3f

000061e4 <sim_available>:
HAL_GPIO_PIN(SIM_POWERKEY_PIN, A, 6)
    61e4:	4a0d      	ldr	r2, [pc, #52]	; (621c <sim_available+0x38>)
    61e6:	2140      	movs	r1, #64	; 0x40
    61e8:	0013      	movs	r3, r2
    61ea:	2002      	movs	r0, #2
{
    61ec:	b530      	push	{r4, r5, lr}
    61ee:	3346      	adds	r3, #70	; 0x46
    61f0:	6051      	str	r1, [r2, #4]
    61f2:	781c      	ldrb	r4, [r3, #0]
    61f4:	4304      	orrs	r4, r0
    61f6:	701c      	strb	r4, [r3, #0]
    61f8:	2404      	movs	r4, #4
    61fa:	781d      	ldrb	r5, [r3, #0]
    61fc:	43a5      	bics	r5, r4
    61fe:	701d      	strb	r5, [r3, #0]
    6200:	6191      	str	r1, [r2, #24]
    6202:	781d      	ldrb	r5, [r3, #0]
    6204:	432c      	orrs	r4, r5
    6206:	701c      	strb	r4, [r3, #0]
    6208:	6a14      	ldr	r4, [r2, #32]
    620a:	6091      	str	r1, [r2, #8]
    620c:	781d      	ldrb	r5, [r3, #0]
    ret = (HAL_GPIO_SIM_POWERKEY_PIN_read()==0);
    620e:	09a4      	lsrs	r4, r4, #6
    6210:	4328      	orrs	r0, r5
    6212:	7018      	strb	r0, [r3, #0]
    return ret;
    6214:	2001      	movs	r0, #1
    6216:	6151      	str	r1, [r2, #20]
    6218:	43a0      	bics	r0, r4
}
    621a:	bd30      	pop	{r4, r5, pc}
    621c:	41004400 	.word	0x41004400

00006220 <sim_power>:
{
    6220:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(task->retries > 5) {
    6222:	7983      	ldrb	r3, [r0, #6]
{
    6224:	b091      	sub	sp, #68	; 0x44
    6226:	0005      	movs	r5, r0
    if(task->retries > 5) {
    6228:	2b05      	cmp	r3, #5
    622a:	d903      	bls.n	6234 <sim_power+0x14>
        task->state = SIM_TASK_STATE_FINISHED;
    622c:	2300      	movs	r3, #0
    622e:	7143      	strb	r3, [r0, #5]
}
    6230:	b011      	add	sp, #68	; 0x44
    6232:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t next_state=task->state;
    6234:	7944      	ldrb	r4, [r0, #5]
    switch(task->state) {
    6236:	1e60      	subs	r0, r4, #1
    6238:	280b      	cmp	r0, #11
    623a:	d900      	bls.n	623e <sim_power+0x1e>
    623c:	e084      	b.n	6348 <sim_power+0x128>
    623e:	f001 fe8f 	bl	7f60 <__gnu_thumb1_case_uqi>
    6242:	1709      	.short	0x1709
    6244:	26890620 	.word	0x26890620
    6248:	574c4028 	.word	0x574c4028
    624c:	675f      	.short	0x675f
          next_state = SIM_TASK_STATE_POWER_PULSEON_WAIT3;
    624e:	2405      	movs	r4, #5
    task->state = next_state;
    6250:	716c      	strb	r4, [r5, #5]
    return;
    6252:	e7ed      	b.n	6230 <sim_power+0x10>
          uart_print(0,"SIM_TASK_STATE_START\n\r");
    6254:	4b40      	ldr	r3, [pc, #256]	; (6358 <sim_power+0x138>)
    6256:	4941      	ldr	r1, [pc, #260]	; (635c <sim_power+0x13c>)
    6258:	2000      	movs	r0, #0
    625a:	4798      	blx	r3
          if(task->arg2 == 0) {
    625c:	792c      	ldrb	r4, [r5, #4]
    625e:	4b40      	ldr	r3, [pc, #256]	; (6360 <sim_power+0x140>)
    6260:	2280      	movs	r2, #128	; 0x80
    6262:	2c00      	cmp	r4, #0
    6264:	d101      	bne.n	626a <sim_power+0x4a>
HAL_GPIO_PIN(SIM_ON_PIN, A, 7)
    6266:	615a      	str	r2, [r3, #20]
    6268:	e7f2      	b.n	6250 <sim_power+0x30>
    626a:	619a      	str	r2, [r3, #24]
              next_state = SIM_TASK_STATE_POWER_PULSEON;
    626c:	2402      	movs	r4, #2
    626e:	e7ef      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_PULSEON\n\r");
    6270:	4b39      	ldr	r3, [pc, #228]	; (6358 <sim_power+0x138>)
    6272:	493c      	ldr	r1, [pc, #240]	; (6364 <sim_power+0x144>)
    6274:	2000      	movs	r0, #0
    6276:	4798      	blx	r3
HAL_GPIO_PIN(SIM_POWERKEY_PIN, A, 6)
    6278:	2240      	movs	r2, #64	; 0x40
    627a:	4b39      	ldr	r3, [pc, #228]	; (6360 <sim_power+0x140>)
          next_state = SIM_TASK_STATE_POWER_PULSEON_WAIT1;
    627c:	2403      	movs	r4, #3
    627e:	619a      	str	r2, [r3, #24]
          break;
    6280:	e7e6      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_PULSEON_WAIT\n\r");
    6282:	4939      	ldr	r1, [pc, #228]	; (6368 <sim_power+0x148>)
    6284:	2000      	movs	r0, #0
    6286:	4b34      	ldr	r3, [pc, #208]	; (6358 <sim_power+0x138>)
    6288:	4798      	blx	r3
          next_state = SIM_TASK_STATE_POWER_PULSEON_WAIT2;
    628a:	2404      	movs	r4, #4
          break;
    628c:	e7e0      	b.n	6250 <sim_power+0x30>
          next_state = SIM_TASK_STATE_POWER_PULSEON_WAIT5;
    628e:	2407      	movs	r4, #7
          break;
    6290:	e7de      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_PULSEON_WAIT5\n\r");
    6292:	4936      	ldr	r1, [pc, #216]	; (636c <sim_power+0x14c>)
    6294:	2000      	movs	r0, #0
    6296:	4b30      	ldr	r3, [pc, #192]	; (6358 <sim_power+0x138>)
    6298:	4798      	blx	r3
    629a:	2240      	movs	r2, #64	; 0x40
    629c:	4b30      	ldr	r3, [pc, #192]	; (6360 <sim_power+0x140>)
    629e:	615a      	str	r2, [r3, #20]
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    62a0:	4b33      	ldr	r3, [pc, #204]	; (6370 <sim_power+0x150>)
    62a2:	4798      	blx	r3
          if(sim_is_on()) {
    62a4:	b2c0      	uxtb	r0, r0
    62a6:	2800      	cmp	r0, #0
    62a8:	d007      	beq.n	62ba <sim_power+0x9a>
              sim_tx("AT\r",3); // help sim with autobauding
    62aa:	4b32      	ldr	r3, [pc, #200]	; (6374 <sim_power+0x154>)
    62ac:	2103      	movs	r1, #3
    62ae:	4832      	ldr	r0, [pc, #200]	; (6378 <sim_power+0x158>)
    62b0:	4798      	blx	r3
              task->retries=0;
    62b2:	2300      	movs	r3, #0
              next_state = SIM_TASK_STATE_POWER_AUTOBAUD;
    62b4:	2408      	movs	r4, #8
              task->retries=0;
    62b6:	71ab      	strb	r3, [r5, #6]
    62b8:	e7ca      	b.n	6250 <sim_power+0x30>
              task->retries++;
    62ba:	79ab      	ldrb	r3, [r5, #6]
    62bc:	3301      	adds	r3, #1
    62be:	71ab      	strb	r3, [r5, #6]
    62c0:	e7d4      	b.n	626c <sim_power+0x4c>
          uart_print(0,"SIM_TASK_STATE_POWER_AUTOBAUD\n\r");
    62c2:	492e      	ldr	r1, [pc, #184]	; (637c <sim_power+0x15c>)
    62c4:	2000      	movs	r0, #0
    62c6:	4b24      	ldr	r3, [pc, #144]	; (6358 <sim_power+0x138>)
    62c8:	4798      	blx	r3
          sim_tx("AT\r",3); // help sim with autobauding
    62ca:	2103      	movs	r1, #3
    62cc:	482a      	ldr	r0, [pc, #168]	; (6378 <sim_power+0x158>)
    62ce:	4b29      	ldr	r3, [pc, #164]	; (6374 <sim_power+0x154>)
    62d0:	4798      	blx	r3
          sim_rxflush();
    62d2:	4b2b      	ldr	r3, [pc, #172]	; (6380 <sim_power+0x160>)
    62d4:	4798      	blx	r3
          next_state = SIM_TASK_STATE_POWER_SET_TEXTMODE;
    62d6:	2409      	movs	r4, #9
          break;
    62d8:	e7ba      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_SET_TEXTMODE\n\r");
    62da:	492a      	ldr	r1, [pc, #168]	; (6384 <sim_power+0x164>)
    62dc:	2000      	movs	r0, #0
    62de:	4b1e      	ldr	r3, [pc, #120]	; (6358 <sim_power+0x138>)
    62e0:	4798      	blx	r3
          sim_set_textmode();
    62e2:	4b29      	ldr	r3, [pc, #164]	; (6388 <sim_power+0x168>)
    62e4:	4798      	blx	r3
          if(task->arg1 != 0) {
    62e6:	886c      	ldrh	r4, [r5, #2]
              next_state = SIM_TASK_STATE_POWER_SET_FLOWCTRL;
    62e8:	4263      	negs	r3, r4
    62ea:	415c      	adcs	r4, r3
    62ec:	340a      	adds	r4, #10
    62ee:	e7af      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_DEL_MSGS\n\r");
    62f0:	4926      	ldr	r1, [pc, #152]	; (638c <sim_power+0x16c>)
    62f2:	2000      	movs	r0, #0
    62f4:	4b18      	ldr	r3, [pc, #96]	; (6358 <sim_power+0x138>)
    62f6:	4798      	blx	r3
          sim_delete_all_sms();
    62f8:	4b25      	ldr	r3, [pc, #148]	; (6390 <sim_power+0x170>)
    62fa:	4798      	blx	r3
          next_state = SIM_TASK_STATE_POWER_SET_FLOWCTRL;
    62fc:	240b      	movs	r4, #11
          break;
    62fe:	e7a7      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_SET_FLOWCTRL\n\r");
    6300:	4924      	ldr	r1, [pc, #144]	; (6394 <sim_power+0x174>)
    6302:	2000      	movs	r0, #0
    6304:	4b14      	ldr	r3, [pc, #80]	; (6358 <sim_power+0x138>)
    6306:	4798      	blx	r3
          sim_set_flowcontrol();
    6308:	4b23      	ldr	r3, [pc, #140]	; (6398 <sim_power+0x178>)
    630a:	4798      	blx	r3
          next_state = SIM_TASK_STATE_POWER_READ_IMEI;
    630c:	240c      	movs	r4, #12
          break;
    630e:	e79f      	b.n	6250 <sim_power+0x30>
          uart_print(0,"SIM_TASK_STATE_POWER_READ_IMEI\n\r");
    6310:	4922      	ldr	r1, [pc, #136]	; (639c <sim_power+0x17c>)
    6312:	2000      	movs	r0, #0
    6314:	4e10      	ldr	r6, [pc, #64]	; (6358 <sim_power+0x138>)
    6316:	47b0      	blx	r6
          ptr = sim_read_IMEI(sim_rxbuf, sizeof(sim_rxbuf));
    6318:	4b21      	ldr	r3, [pc, #132]	; (63a0 <sim_power+0x180>)
    631a:	2140      	movs	r1, #64	; 0x40
    631c:	4668      	mov	r0, sp
    631e:	4798      	blx	r3
          uart_print(0,"IMEI=%s\n\r",ptr);
    6320:	4920      	ldr	r1, [pc, #128]	; (63a4 <sim_power+0x184>)
    6322:	0002      	movs	r2, r0
          ptr = sim_read_IMEI(sim_rxbuf, sizeof(sim_rxbuf));
    6324:	0007      	movs	r7, r0
          uart_print(0,"IMEI=%s\n\r",ptr);
    6326:	2000      	movs	r0, #0
    6328:	47b0      	blx	r6
          uart_print(0,"Pincheck=%s\n\r",(sim_pincode_check() ? "OK" : "FAIL"));
    632a:	4b1f      	ldr	r3, [pc, #124]	; (63a8 <sim_power+0x188>)
    632c:	4798      	blx	r3
    632e:	4a1f      	ldr	r2, [pc, #124]	; (63ac <sim_power+0x18c>)
    6330:	2800      	cmp	r0, #0
    6332:	d100      	bne.n	6336 <sim_power+0x116>
    6334:	4a1e      	ldr	r2, [pc, #120]	; (63b0 <sim_power+0x190>)
    6336:	491f      	ldr	r1, [pc, #124]	; (63b4 <sim_power+0x194>)
    6338:	2000      	movs	r0, #0
    633a:	47b0      	blx	r6
          if(ptr!=NULL) {
    633c:	2f00      	cmp	r7, #0
    633e:	d107      	bne.n	6350 <sim_power+0x130>
              task->retries++;
    6340:	79ab      	ldrb	r3, [r5, #6]
    6342:	3301      	adds	r3, #1
    6344:	71ab      	strb	r3, [r5, #6]
    6346:	e783      	b.n	6250 <sim_power+0x30>
          uart_print(0,"->SIM_TASK_STATE_FINISHED\n\r");
    6348:	491b      	ldr	r1, [pc, #108]	; (63b8 <sim_power+0x198>)
    634a:	2000      	movs	r0, #0
    634c:	4b02      	ldr	r3, [pc, #8]	; (6358 <sim_power+0x138>)
    634e:	4798      	blx	r3
              next_state = SIM_TASK_STATE_FINISHED;
    6350:	2400      	movs	r4, #0
    6352:	e77d      	b.n	6250 <sim_power+0x30>
          next_state = SIM_TASK_STATE_POWER_PULSEON_WAIT4;
    6354:	2406      	movs	r4, #6
    6356:	e77b      	b.n	6250 <sim_power+0x30>
    6358:	00007b99 	.word	0x00007b99
    635c:	0000aeed 	.word	0x0000aeed
    6360:	41004400 	.word	0x41004400
    6364:	0000b5f4 	.word	0x0000b5f4
    6368:	0000b613 	.word	0x0000b613
    636c:	0000b637 	.word	0x0000b637
    6370:	00004e4d 	.word	0x00004e4d
    6374:	0000525d 	.word	0x0000525d
    6378:	0000b65c 	.word	0x0000b65c
    637c:	0000b660 	.word	0x0000b660
    6380:	00004fc1 	.word	0x00004fc1
    6384:	0000b680 	.word	0x0000b680
    6388:	000060e1 	.word	0x000060e1
    638c:	0000b6a4 	.word	0x0000b6a4
    6390:	000055fd 	.word	0x000055fd
    6394:	0000b6c4 	.word	0x0000b6c4
    6398:	0000609d 	.word	0x0000609d
    639c:	0000b6e8 	.word	0x0000b6e8
    63a0:	00005639 	.word	0x00005639
    63a4:	0000b709 	.word	0x0000b709
    63a8:	00006111 	.word	0x00006111
    63ac:	0000ae2e 	.word	0x0000ae2e
    63b0:	0000b5ef 	.word	0x0000b5ef
    63b4:	0000b713 	.word	0x0000b713
    63b8:	0000af63 	.word	0x0000af63

000063bc <sim_is_on>:
{
    63bc:	b510      	push	{r4, lr}
    return (HAL_GPIO_SIM_STATUS_PIN_read());
    63be:	4b02      	ldr	r3, [pc, #8]	; (63c8 <sim_is_on+0xc>)
    63c0:	4798      	blx	r3
    63c2:	b2c0      	uxtb	r0, r0
}
    63c4:	bd10      	pop	{r4, pc}
    63c6:	46c0      	nop			; (mov r8, r8)
    63c8:	00004e4d 	.word	0x00004e4d

000063cc <sim_task_add>:

int8_t sim_task_add(const uint8_t task, const uint16_t arg1, const uint8_t arg2)
{
    63cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int8_t i;
  for(i=0;i<SIM_TASK_QUEUE_LEN;i++) {
    if(sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].id == SIM_TASK_IDLE) {
    63ce:	4d13      	ldr	r5, [pc, #76]	; (641c <sim_task_add+0x50>)
{
    63d0:	0016      	movs	r6, r2
    if(sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].id == SIM_TASK_IDLE) {
    63d2:	002a      	movs	r2, r5
{
    63d4:	0003      	movs	r3, r0
    if(sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].id == SIM_TASK_IDLE) {
    63d6:	2007      	movs	r0, #7
    63d8:	3240      	adds	r2, #64	; 0x40
    63da:	7817      	ldrb	r7, [r2, #0]
    63dc:	4684      	mov	ip, r0
    63de:	2200      	movs	r2, #0
    63e0:	4660      	mov	r0, ip
    63e2:	18bc      	adds	r4, r7, r2
    63e4:	4004      	ands	r4, r0
    63e6:	00e4      	lsls	r4, r4, #3
    63e8:	5d28      	ldrb	r0, [r5, r4]
    63ea:	2800      	cmp	r0, #0
    63ec:	d10b      	bne.n	6406 <sim_task_add+0x3a>
      // queue entry is available
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].id = task;
    63ee:	552b      	strb	r3, [r5, r4]
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].state = SIM_TASK_STATE_START;
    63f0:	192c      	adds	r4, r5, r4
    63f2:	2501      	movs	r5, #1
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].arg1 = arg1;
    63f4:	8061      	strh	r1, [r4, #2]
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].arg2 = arg2;
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].retries = 0;
    63f6:	71a0      	strb	r0, [r4, #6]
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].state = SIM_TASK_STATE_START;
    63f8:	7165      	strb	r5, [r4, #5]
      sim_task_queue.task[((sim_task_queue.current+i)&SIM_TASK_QUEUE_MASK)].arg2 = arg2;
    63fa:	7126      	strb	r6, [r4, #4]
      uart_print(0,"sim_task_add[%d](%d)\n\r",i,task);
    63fc:	4908      	ldr	r1, [pc, #32]	; (6420 <sim_task_add+0x54>)
    63fe:	4c09      	ldr	r4, [pc, #36]	; (6424 <sim_task_add+0x58>)
    6400:	47a0      	blx	r4
      return 1; // ok
    6402:	0028      	movs	r0, r5
    }
  }
  uart_print(0,"sim_task_add(%d) FAIL\n\r",task);
  return 0; // fail
}
    6404:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6406:	3201      	adds	r2, #1
  for(i=0;i<SIM_TASK_QUEUE_LEN;i++) {
    6408:	2a08      	cmp	r2, #8
    640a:	d1e9      	bne.n	63e0 <sim_task_add+0x14>
  uart_print(0,"sim_task_add(%d) FAIL\n\r",task);
    640c:	001a      	movs	r2, r3
    640e:	2000      	movs	r0, #0
    6410:	4905      	ldr	r1, [pc, #20]	; (6428 <sim_task_add+0x5c>)
    6412:	4b04      	ldr	r3, [pc, #16]	; (6424 <sim_task_add+0x58>)
    6414:	4798      	blx	r3
  return 0; // fail
    6416:	2000      	movs	r0, #0
    6418:	e7f4      	b.n	6404 <sim_task_add+0x38>
    641a:	46c0      	nop			; (mov r8, r8)
    641c:	20000b1c 	.word	0x20000b1c
    6420:	0000b721 	.word	0x0000b721
    6424:	00007b99 	.word	0x00007b99
    6428:	0000b738 	.word	0x0000b738

0000642c <sim_task_exist>:

uint8_t sim_task_exist(const uint8_t task)
{
    642c:	2300      	movs	r3, #0
    642e:	b510      	push	{r4, lr}
    int8_t i;
    for(i=0;i<SIM_TASK_QUEUE_LEN;i++) {
        if(sim_task_queue.task[i].id == task) {
    6430:	4a09      	ldr	r2, [pc, #36]	; (6458 <sim_task_exist+0x2c>)
    6432:	5cd1      	ldrb	r1, [r2, r3]
    6434:	4281      	cmp	r1, r0
    6436:	d105      	bne.n	6444 <sim_task_exist+0x18>
            uart_print(0,"sim_task_exist=1\n\r");           
    6438:	2000      	movs	r0, #0
    643a:	4908      	ldr	r1, [pc, #32]	; (645c <sim_task_exist+0x30>)
    643c:	4b08      	ldr	r3, [pc, #32]	; (6460 <sim_task_exist+0x34>)
    643e:	4798      	blx	r3
    6440:	2001      	movs	r0, #1
            return 1; // ok
        }
    }
    uart_print(0,"sim_task_exist=0\n\r");
    return 0;
}
    6442:	bd10      	pop	{r4, pc}
    6444:	3308      	adds	r3, #8
    for(i=0;i<SIM_TASK_QUEUE_LEN;i++) {
    6446:	2b40      	cmp	r3, #64	; 0x40
    6448:	d1f3      	bne.n	6432 <sim_task_exist+0x6>
    uart_print(0,"sim_task_exist=0\n\r");
    644a:	2000      	movs	r0, #0
    644c:	4905      	ldr	r1, [pc, #20]	; (6464 <sim_task_exist+0x38>)
    644e:	4b04      	ldr	r3, [pc, #16]	; (6460 <sim_task_exist+0x34>)
    6450:	4798      	blx	r3
    return 0;
    6452:	2000      	movs	r0, #0
    6454:	e7f5      	b.n	6442 <sim_task_exist+0x16>
    6456:	46c0      	nop			; (mov r8, r8)
    6458:	20000b1c 	.word	0x20000b1c
    645c:	0000b750 	.word	0x0000b750
    6460:	00007b99 	.word	0x00007b99
    6464:	0000b763 	.word	0x0000b763

00006468 <sim_task_done>:

void sim_task_done(void)
{
    //uart_print(0,"sim_task_done %d\n\r",sim_task_queue.task[sim_task_queue.current].id);
    sim_task_queue.task[sim_task_queue.current].id = SIM_TASK_IDLE;
    6468:	4b08      	ldr	r3, [pc, #32]	; (648c <sim_task_done+0x24>)
    646a:	2100      	movs	r1, #0
    646c:	0018      	movs	r0, r3
{
    646e:	b510      	push	{r4, lr}
    sim_task_queue.task[sim_task_queue.current].id = SIM_TASK_IDLE;
    6470:	3040      	adds	r0, #64	; 0x40
    6472:	7802      	ldrb	r2, [r0, #0]
    6474:	00d4      	lsls	r4, r2, #3
    6476:	54e1      	strb	r1, [r4, r3]
    sim_task_queue.task[sim_task_queue.current].state = SIM_TASK_STATE_FINISHED;
    6478:	191b      	adds	r3, r3, r4
    647a:	7159      	strb	r1, [r3, #5]
    sim_task_queue.task[sim_task_queue.current].arg1 = 0;
    647c:	8059      	strh	r1, [r3, #2]
    sim_task_queue.task[sim_task_queue.current].arg2 = 0;
    647e:	7119      	strb	r1, [r3, #4]
    sim_task_queue.task[sim_task_queue.current].retries = 0;
    6480:	7199      	strb	r1, [r3, #6]
    sim_task_queue.current = (sim_task_queue.current+1)&SIM_TASK_QUEUE_MASK; // point to next
    6482:	2307      	movs	r3, #7
    6484:	3201      	adds	r2, #1
    6486:	401a      	ands	r2, r3
    6488:	7002      	strb	r2, [r0, #0]
}
    648a:	bd10      	pop	{r4, pc}
    648c:	20000b1c 	.word	0x20000b1c

00006490 <sim_tasks>:

void sim_tasks(void)
{
    6490:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    6492:	b672      	cpsid	i
    uint8_t tasklist;    
    __disable_irq();
    tasklist=sysval.sim_tasklist;
    sysval.sim_tasklist&=0x7f;
    6494:	227f      	movs	r2, #127	; 0x7f
    tasklist=sysval.sim_tasklist;
    6496:	4c57      	ldr	r4, [pc, #348]	; (65f4 <sim_tasks+0x164>)
    6498:	7ca3      	ldrb	r3, [r4, #18]
    sysval.sim_tasklist&=0x7f;
    649a:	401a      	ands	r2, r3
    649c:	74a2      	strb	r2, [r4, #18]
  __ASM volatile ("cpsie i" : : : "memory");
    649e:	b662      	cpsie	i
    __enable_irq();

    if((tasklist&0x80)==0) return; // not yet allowed to run
    64a0:	b25b      	sxtb	r3, r3
    64a2:	2b00      	cmp	r3, #0
    64a4:	da42      	bge.n	652c <sim_tasks+0x9c>
    
    if(sysval.ringing) {
    64a6:	0023      	movs	r3, r4
    64a8:	33bb      	adds	r3, #187	; 0xbb
    64aa:	781b      	ldrb	r3, [r3, #0]
    64ac:	4d52      	ldr	r5, [pc, #328]	; (65f8 <sim_tasks+0x168>)
    64ae:	2b00      	cmp	r3, #0
    64b0:	d00e      	beq.n	64d0 <sim_tasks+0x40>
        uart_print(0,"RING\n\r");
    64b2:	4952      	ldr	r1, [pc, #328]	; (65fc <sim_tasks+0x16c>)
    64b4:	2000      	movs	r0, #0
    64b6:	47a8      	blx	r5
        if(!sim_task_exist(SIM_TASK_READ_SMS)) {
    64b8:	2006      	movs	r0, #6
    64ba:	4b51      	ldr	r3, [pc, #324]	; (6600 <sim_tasks+0x170>)
    64bc:	4798      	blx	r3
    64be:	1e01      	subs	r1, r0, #0
    64c0:	d103      	bne.n	64ca <sim_tasks+0x3a>
            sim_task_add(SIM_TASK_READ_SMS,0,0);
    64c2:	0002      	movs	r2, r0
    64c4:	4b4f      	ldr	r3, [pc, #316]	; (6604 <sim_tasks+0x174>)
    64c6:	2006      	movs	r0, #6
    64c8:	4798      	blx	r3
        }
        sysval.ringing=0;
    64ca:	2300      	movs	r3, #0
    64cc:	34bb      	adds	r4, #187	; 0xbb
    64ce:	7023      	strb	r3, [r4, #0]
    }
    
    // task allowed to run
    uart_print(0,"sim_task[%d]:\n\r",sim_task_queue.task[sim_task_queue.current].id);
    64d0:	4c4d      	ldr	r4, [pc, #308]	; (6608 <sim_tasks+0x178>)
    64d2:	2000      	movs	r0, #0
    64d4:	0026      	movs	r6, r4
    64d6:	3640      	adds	r6, #64	; 0x40
    64d8:	7833      	ldrb	r3, [r6, #0]
    64da:	494c      	ldr	r1, [pc, #304]	; (660c <sim_tasks+0x17c>)
    64dc:	00db      	lsls	r3, r3, #3
    64de:	5d1a      	ldrb	r2, [r3, r4]
    64e0:	47a8      	blx	r5

    switch(sim_task_queue.task[sim_task_queue.current].id) {
    64e2:	7833      	ldrb	r3, [r6, #0]
    64e4:	00db      	lsls	r3, r3, #3
    64e6:	5d18      	ldrb	r0, [r3, r4]
    64e8:	3801      	subs	r0, #1
    64ea:	2807      	cmp	r0, #7
    64ec:	d80f      	bhi.n	650e <sim_tasks+0x7e>
    64ee:	f001 fd37 	bl	7f60 <__gnu_thumb1_case_uqi>
    64f2:	1e04      	.short	0x1e04
    64f4:	503c3228 	.word	0x503c3228
    64f8:	5a46      	.short	0x5a46
        case SIM_TASK_POWER:
          uart_print(0,"SIM_TASK_POWER\n\r");
    64fa:	2000      	movs	r0, #0
    64fc:	4944      	ldr	r1, [pc, #272]	; (6610 <sim_tasks+0x180>)
    64fe:	47a8      	blx	r5
          sim_power(&sim_task_queue.task[sim_task_queue.current]);
    6500:	0023      	movs	r3, r4
    6502:	3340      	adds	r3, #64	; 0x40
    6504:	7818      	ldrb	r0, [r3, #0]
    6506:	4b43      	ldr	r3, [pc, #268]	; (6614 <sim_tasks+0x184>)
    6508:	00c0      	lsls	r0, r0, #3
    650a:	1820      	adds	r0, r4, r0
          uart_print(0,"SIM_TASK_READ_SMS\n\r");
          sim_receive_sms(&sim_task_queue.task[sim_task_queue.current]);
          break;
        case SIM_TASK_CREG:
          uart_print(0,"SIM_TASK_CREG\n\r");
          sim_check_creg(&sim_task_queue.task[sim_task_queue.current]);
    650c:	4798      	blx	r3
          break;
    }
    if(sim_task_queue.task[sim_task_queue.current].state == SIM_TASK_STATE_FINISHED) {
    650e:	0023      	movs	r3, r4
    6510:	3340      	adds	r3, #64	; 0x40
    6512:	781a      	ldrb	r2, [r3, #0]
    6514:	00d2      	lsls	r2, r2, #3
    6516:	18a3      	adds	r3, r4, r2
    6518:	795d      	ldrb	r5, [r3, #5]
    651a:	2d00      	cmp	r5, #0
    651c:	d106      	bne.n	652c <sim_tasks+0x9c>
        switch(sim_task_queue.task[sim_task_queue.current].id) {
    651e:	5ca2      	ldrb	r2, [r4, r2]
    6520:	2a02      	cmp	r2, #2
    6522:	d04a      	beq.n	65ba <sim_tasks+0x12a>
    6524:	2a08      	cmp	r2, #8
    6526:	d055      	beq.n	65d4 <sim_tasks+0x144>
            }
            break;          
          default:
            break;
        }
        sim_task_done();
    6528:	4b3b      	ldr	r3, [pc, #236]	; (6618 <sim_tasks+0x188>)
    652a:	4798      	blx	r3
    }
}
    652c:	bd70      	pop	{r4, r5, r6, pc}
          uart_print(0,"SIM_TASK_START_2G\n\r");
    652e:	2000      	movs	r0, #0
    6530:	493a      	ldr	r1, [pc, #232]	; (661c <sim_tasks+0x18c>)
    6532:	47a8      	blx	r5
          sim_start_2g(&sim_task_queue.task[sim_task_queue.current]);
    6534:	0023      	movs	r3, r4
    6536:	3340      	adds	r3, #64	; 0x40
    6538:	7818      	ldrb	r0, [r3, #0]
    653a:	4b39      	ldr	r3, [pc, #228]	; (6620 <sim_tasks+0x190>)
    653c:	00c0      	lsls	r0, r0, #3
    653e:	1820      	adds	r0, r4, r0
    6540:	e7e4      	b.n	650c <sim_tasks+0x7c>
          uart_print(0,"SIM_TASK_STOP_2G\n\r");
    6542:	2000      	movs	r0, #0
    6544:	4937      	ldr	r1, [pc, #220]	; (6624 <sim_tasks+0x194>)
    6546:	47a8      	blx	r5
          sim_stop_2g(&sim_task_queue.task[sim_task_queue.current]);
    6548:	0023      	movs	r3, r4
    654a:	3340      	adds	r3, #64	; 0x40
    654c:	7818      	ldrb	r0, [r3, #0]
    654e:	4b36      	ldr	r3, [pc, #216]	; (6628 <sim_tasks+0x198>)
    6550:	00c0      	lsls	r0, r0, #3
    6552:	1820      	adds	r0, r4, r0
    6554:	e7da      	b.n	650c <sim_tasks+0x7c>
          uart_print(0,"SIM_TASK_SEND_2G\n\r");
    6556:	2000      	movs	r0, #0
    6558:	4934      	ldr	r1, [pc, #208]	; (662c <sim_tasks+0x19c>)
    655a:	47a8      	blx	r5
          sim_send_2g_msg(&sim_task_queue.task[sim_task_queue.current]);
    655c:	0023      	movs	r3, r4
    655e:	3340      	adds	r3, #64	; 0x40
    6560:	7818      	ldrb	r0, [r3, #0]
    6562:	4b33      	ldr	r3, [pc, #204]	; (6630 <sim_tasks+0x1a0>)
    6564:	00c0      	lsls	r0, r0, #3
    6566:	1820      	adds	r0, r4, r0
    6568:	e7d0      	b.n	650c <sim_tasks+0x7c>
          uart_print(0,"SIM_TASK_SEND_SMS\n\r");
    656a:	2000      	movs	r0, #0
    656c:	4931      	ldr	r1, [pc, #196]	; (6634 <sim_tasks+0x1a4>)
    656e:	47a8      	blx	r5
          sim_send_sms(&sim_task_queue.task[sim_task_queue.current]);
    6570:	0023      	movs	r3, r4
    6572:	3340      	adds	r3, #64	; 0x40
    6574:	7818      	ldrb	r0, [r3, #0]
    6576:	4b30      	ldr	r3, [pc, #192]	; (6638 <sim_tasks+0x1a8>)
    6578:	00c0      	lsls	r0, r0, #3
    657a:	1820      	adds	r0, r4, r0
    657c:	e7c6      	b.n	650c <sim_tasks+0x7c>
          uart_print(0,"SIM_TASK_WAIT\n\r");
    657e:	2000      	movs	r0, #0
    6580:	492e      	ldr	r1, [pc, #184]	; (663c <sim_tasks+0x1ac>)
    6582:	47a8      	blx	r5
          sim_wait(&sim_task_queue.task[sim_task_queue.current]);
    6584:	0023      	movs	r3, r4
    6586:	3340      	adds	r3, #64	; 0x40
    6588:	7818      	ldrb	r0, [r3, #0]
    658a:	4b2d      	ldr	r3, [pc, #180]	; (6640 <sim_tasks+0x1b0>)
    658c:	00c0      	lsls	r0, r0, #3
    658e:	1820      	adds	r0, r4, r0
    6590:	e7bc      	b.n	650c <sim_tasks+0x7c>
          uart_print(0,"SIM_TASK_READ_SMS\n\r");
    6592:	2000      	movs	r0, #0
    6594:	492b      	ldr	r1, [pc, #172]	; (6644 <sim_tasks+0x1b4>)
    6596:	47a8      	blx	r5
          sim_receive_sms(&sim_task_queue.task[sim_task_queue.current]);
    6598:	0023      	movs	r3, r4
    659a:	3340      	adds	r3, #64	; 0x40
    659c:	7818      	ldrb	r0, [r3, #0]
    659e:	4b2a      	ldr	r3, [pc, #168]	; (6648 <sim_tasks+0x1b8>)
    65a0:	00c0      	lsls	r0, r0, #3
    65a2:	1820      	adds	r0, r4, r0
    65a4:	e7b2      	b.n	650c <sim_tasks+0x7c>
          uart_print(0,"SIM_TASK_CREG\n\r");
    65a6:	2000      	movs	r0, #0
    65a8:	4928      	ldr	r1, [pc, #160]	; (664c <sim_tasks+0x1bc>)
    65aa:	47a8      	blx	r5
          sim_check_creg(&sim_task_queue.task[sim_task_queue.current]);
    65ac:	0023      	movs	r3, r4
    65ae:	3340      	adds	r3, #64	; 0x40
    65b0:	7818      	ldrb	r0, [r3, #0]
    65b2:	4b27      	ldr	r3, [pc, #156]	; (6650 <sim_tasks+0x1c0>)
    65b4:	00c0      	lsls	r0, r0, #3
    65b6:	1820      	adds	r0, r4, r0
    65b8:	e7a8      	b.n	650c <sim_tasks+0x7c>
            if(sim_task_queue.task[sim_task_queue.current].retries < 5) {
    65ba:	799a      	ldrb	r2, [r3, #6]
    65bc:	4c11      	ldr	r4, [pc, #68]	; (6604 <sim_tasks+0x174>)
    65be:	2a04      	cmp	r2, #4
    65c0:	d803      	bhi.n	65ca <sim_tasks+0x13a>
                sim_task_add(SIM_TASK_SEND_2G,
    65c2:	8859      	ldrh	r1, [r3, #2]
    65c4:	002a      	movs	r2, r5
    65c6:	2004      	movs	r0, #4
    65c8:	47a0      	blx	r4
                sim_task_add(SIM_TASK_STOP_2G,0,0);
    65ca:	002a      	movs	r2, r5
    65cc:	0029      	movs	r1, r5
    65ce:	2003      	movs	r0, #3
                sim_task_add(SIM_TASK_POWER,0,1); // then turn on
    65d0:	47a0      	blx	r4
    65d2:	e7a9      	b.n	6528 <sim_tasks+0x98>
            if(sim_task_queue.task[sim_task_queue.current].retries >= 5) {
    65d4:	799b      	ldrb	r3, [r3, #6]
    65d6:	2b04      	cmp	r3, #4
    65d8:	d9a6      	bls.n	6528 <sim_tasks+0x98>
                sim_task_add(SIM_TASK_POWER,0,0); // turn off SIM module
    65da:	002a      	movs	r2, r5
    65dc:	0029      	movs	r1, r5
    65de:	4c09      	ldr	r4, [pc, #36]	; (6604 <sim_tasks+0x174>)
    65e0:	2001      	movs	r0, #1
    65e2:	47a0      	blx	r4
                sim_task_add(SIM_TASK_WAIT,30,0); // wait 30 seconds
    65e4:	002a      	movs	r2, r5
    65e6:	211e      	movs	r1, #30
    65e8:	2007      	movs	r0, #7
    65ea:	47a0      	blx	r4
                sim_task_add(SIM_TASK_POWER,0,1); // then turn on
    65ec:	2201      	movs	r2, #1
    65ee:	0029      	movs	r1, r5
    65f0:	0010      	movs	r0, r2
    65f2:	e7ed      	b.n	65d0 <sim_tasks+0x140>
    65f4:	20000a58 	.word	0x20000a58
    65f8:	00007b99 	.word	0x00007b99
    65fc:	0000b776 	.word	0x0000b776
    6600:	0000642d 	.word	0x0000642d
    6604:	000063cd 	.word	0x000063cd
    6608:	20000b1c 	.word	0x20000b1c
    660c:	0000b77d 	.word	0x0000b77d
    6610:	0000b78d 	.word	0x0000b78d
    6614:	00006221 	.word	0x00006221
    6618:	00006469 	.word	0x00006469
    661c:	0000b79e 	.word	0x0000b79e
    6620:	000057b9 	.word	0x000057b9
    6624:	0000b7b2 	.word	0x0000b7b2
    6628:	00005eb1 	.word	0x00005eb1
    662c:	0000b7c5 	.word	0x0000b7c5
    6630:	00005b81 	.word	0x00005b81
    6634:	0000b7d8 	.word	0x0000b7d8
    6638:	000052c1 	.word	0x000052c1
    663c:	0000b7ec 	.word	0x0000b7ec
    6640:	00005e69 	.word	0x00005e69
    6644:	0000b7fc 	.word	0x0000b7fc
    6648:	00005485 	.word	0x00005485
    664c:	0000b810 	.word	0x0000b810
    6650:	0000601d 	.word	0x0000601d

00006654 <sim_eeprom_set_APN>:
        flash_write_eeprom_sim(&eeprom_sim);
    }
}

void sim_eeprom_set_APN(const char *apn)
{
    6654:	b510      	push	{r4, lr}
    6656:	0001      	movs	r1, r0
    strcpy(eeprom_sim.apn,apn);    
    6658:	4804      	ldr	r0, [pc, #16]	; (666c <sim_eeprom_set_APN+0x18>)
    665a:	4b05      	ldr	r3, [pc, #20]	; (6670 <sim_eeprom_set_APN+0x1c>)
    665c:	1c84      	adds	r4, r0, #2
    665e:	302b      	adds	r0, #43	; 0x2b
    6660:	4798      	blx	r3
    flash_write_eeprom_sim(&eeprom_sim);
    6662:	0020      	movs	r0, r4
    6664:	4b03      	ldr	r3, [pc, #12]	; (6674 <sim_eeprom_set_APN+0x20>)
    6666:	4798      	blx	r3
}
    6668:	bd10      	pop	{r4, pc}
    666a:	46c0      	nop			; (mov r8, r8)
    666c:	20000831 	.word	0x20000831
    6670:	00008a2f 	.word	0x00008a2f
    6674:	000011fd 	.word	0x000011fd

00006678 <sim_eeprom_set_USER>:
void sim_eeprom_set_USER(const char *user)
{
    6678:	b510      	push	{r4, lr}
    667a:	0001      	movs	r1, r0
    strcpy(eeprom_sim.user,user);    
    667c:	4804      	ldr	r0, [pc, #16]	; (6690 <sim_eeprom_set_USER+0x18>)
    667e:	4b05      	ldr	r3, [pc, #20]	; (6694 <sim_eeprom_set_USER+0x1c>)
    6680:	1c84      	adds	r4, r0, #2
    6682:	303b      	adds	r0, #59	; 0x3b
    6684:	4798      	blx	r3
    flash_write_eeprom_sim(&eeprom_sim);
    6686:	0020      	movs	r0, r4
    6688:	4b03      	ldr	r3, [pc, #12]	; (6698 <sim_eeprom_set_USER+0x20>)
    668a:	4798      	blx	r3
}
    668c:	bd10      	pop	{r4, pc}
    668e:	46c0      	nop			; (mov r8, r8)
    6690:	20000831 	.word	0x20000831
    6694:	00008a2f 	.word	0x00008a2f
    6698:	000011fd 	.word	0x000011fd

0000669c <sim_eeprom_set_PWD>:
void sim_eeprom_set_PWD(const char *pwd)
{
    669c:	b510      	push	{r4, lr}
    669e:	0001      	movs	r1, r0
    strcpy(eeprom_sim.pwd,pwd);    
    66a0:	4804      	ldr	r0, [pc, #16]	; (66b4 <sim_eeprom_set_PWD+0x18>)
    66a2:	4b05      	ldr	r3, [pc, #20]	; (66b8 <sim_eeprom_set_PWD+0x1c>)
    66a4:	1c84      	adds	r4, r0, #2
    66a6:	304b      	adds	r0, #75	; 0x4b
    66a8:	4798      	blx	r3
    flash_write_eeprom_sim(&eeprom_sim);
    66aa:	0020      	movs	r0, r4
    66ac:	4b03      	ldr	r3, [pc, #12]	; (66bc <sim_eeprom_set_PWD+0x20>)
    66ae:	4798      	blx	r3
}
    66b0:	bd10      	pop	{r4, pc}
    66b2:	46c0      	nop			; (mov r8, r8)
    66b4:	20000831 	.word	0x20000831
    66b8:	00008a2f 	.word	0x00008a2f
    66bc:	000011fd 	.word	0x000011fd

000066c0 <sim_eeprom_set_HOST>:
void sim_eeprom_set_HOST(const char *host)
{
    66c0:	b510      	push	{r4, lr}
    66c2:	0001      	movs	r1, r0
    strcpy(eeprom_sim.hostname,host);    
    66c4:	4804      	ldr	r0, [pc, #16]	; (66d8 <sim_eeprom_set_HOST+0x18>)
    66c6:	4b05      	ldr	r3, [pc, #20]	; (66dc <sim_eeprom_set_HOST+0x1c>)
    66c8:	1c84      	adds	r4, r0, #2
    66ca:	3003      	adds	r0, #3
    66cc:	4798      	blx	r3
    flash_write_eeprom_sim(&eeprom_sim);
    66ce:	0020      	movs	r0, r4
    66d0:	4b03      	ldr	r3, [pc, #12]	; (66e0 <sim_eeprom_set_HOST+0x20>)
    66d2:	4798      	blx	r3
}
    66d4:	bd10      	pop	{r4, pc}
    66d6:	46c0      	nop			; (mov r8, r8)
    66d8:	20000831 	.word	0x20000831
    66dc:	00008a2f 	.word	0x00008a2f
    66e0:	000011fd 	.word	0x000011fd

000066e4 <sim_init>:
{
    66e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memset((void *)&sim_task_queue,0,sizeof(sim_task_queue_t));
    66e6:	2242      	movs	r2, #66	; 0x42
    66e8:	2100      	movs	r1, #0
    66ea:	4b51      	ldr	r3, [pc, #324]	; (6830 <sim_init+0x14c>)
{
    66ec:	0005      	movs	r5, r0
    memset((void *)&sim_task_queue,0,sizeof(sim_task_queue_t));
    66ee:	4851      	ldr	r0, [pc, #324]	; (6834 <sim_init+0x150>)
    66f0:	4798      	blx	r3
    UART_SIM_RxTail = x;
    66f2:	2300      	movs	r3, #0
    66f4:	4a50      	ldr	r2, [pc, #320]	; (6838 <sim_init+0x154>)
    UART_SIM_TxTail = x;
    66f6:	4c51      	ldr	r4, [pc, #324]	; (683c <sim_init+0x158>)
    UART_SIM_RxTail = x;
    66f8:	7053      	strb	r3, [r2, #1]
    UART_SIM_RxHead = x;
    66fa:	7013      	strb	r3, [r2, #0]
    UART_SIM_TxTail = x;
    66fc:	0022      	movs	r2, r4
    66fe:	325b      	adds	r2, #91	; 0x5b
    6700:	7013      	strb	r3, [r2, #0]
    UART_SIM_TxHead = x;
    6702:	0022      	movs	r2, r4
    6704:	2040      	movs	r0, #64	; 0x40
    6706:	325c      	adds	r2, #92	; 0x5c
    6708:	7013      	strb	r3, [r2, #0]
    670a:	2202      	movs	r2, #2
    670c:	4b4c      	ldr	r3, [pc, #304]	; (6840 <sim_init+0x15c>)
    670e:	4e4d      	ldr	r6, [pc, #308]	; (6844 <sim_init+0x160>)
    6710:	6098      	str	r0, [r3, #8]
    6712:	7831      	ldrb	r1, [r6, #0]
HAL_GPIO_PIN(SIM_CTS_PIN,   A, 3)
    6714:	2708      	movs	r7, #8
HAL_GPIO_PIN(SIM_POWERKEY_PIN, A, 6)
    6716:	4311      	orrs	r1, r2
    6718:	7031      	strb	r1, [r6, #0]
HAL_GPIO_PIN(SIM_ON_PIN, A, 7)
    671a:	2180      	movs	r1, #128	; 0x80
    671c:	468c      	mov	ip, r1
HAL_GPIO_PIN(SIM_POWERKEY_PIN, A, 6)
    671e:	6158      	str	r0, [r3, #20]
HAL_GPIO_PIN(SIM_ON_PIN, A, 7)
    6720:	4849      	ldr	r0, [pc, #292]	; (6848 <sim_init+0x164>)
    6722:	6099      	str	r1, [r3, #8]
    6724:	7801      	ldrb	r1, [r0, #0]
    6726:	4311      	orrs	r1, r2
    6728:	7001      	strb	r1, [r0, #0]
    672a:	4661      	mov	r1, ip
HAL_GPIO_PIN(SIM_CTS_PIN,   A, 3)
    672c:	4847      	ldr	r0, [pc, #284]	; (684c <sim_init+0x168>)
HAL_GPIO_PIN(SIM_ON_PIN, A, 7)
    672e:	6159      	str	r1, [r3, #20]
HAL_GPIO_PIN(SIM_CTS_PIN,   A, 3)
    6730:	605f      	str	r7, [r3, #4]
    6732:	7801      	ldrb	r1, [r0, #0]
    6734:	4311      	orrs	r1, r2
    6736:	7001      	strb	r1, [r0, #0]
    6738:	2104      	movs	r1, #4
    673a:	7806      	ldrb	r6, [r0, #0]
    673c:	438e      	bics	r6, r1
    673e:	7006      	strb	r6, [r0, #0]
    6740:	619f      	str	r7, [r3, #24]
    6742:	7806      	ldrb	r6, [r0, #0]
HAL_GPIO_PIN(SIM_UART_TX,   A, 10)
    6744:	3f07      	subs	r7, #7
HAL_GPIO_PIN(SIM_CTS_PIN,   A, 3)
    6746:	430e      	orrs	r6, r1
    6748:	7006      	strb	r6, [r0, #0]
HAL_GPIO_PIN(SIM_STATUS_PIN,A, 5)
    674a:	2020      	movs	r0, #32
    674c:	6058      	str	r0, [r3, #4]
    674e:	4840      	ldr	r0, [pc, #256]	; (6850 <sim_init+0x16c>)
    6750:	7806      	ldrb	r6, [r0, #0]
    6752:	4316      	orrs	r6, r2
    6754:	7006      	strb	r6, [r0, #0]
    6756:	7806      	ldrb	r6, [r0, #0]
    6758:	438e      	bics	r6, r1
    675a:	7006      	strb	r6, [r0, #0]
    675c:	2620      	movs	r6, #32
    675e:	615e      	str	r6, [r3, #20]
    6760:	7806      	ldrb	r6, [r0, #0]
    6762:	430e      	orrs	r6, r1
    6764:	7006      	strb	r6, [r0, #0]
HAL_GPIO_PIN(SIM_UART_TX,   A, 10)
    6766:	2080      	movs	r0, #128	; 0x80
    6768:	00c0      	lsls	r0, r0, #3
    676a:	6098      	str	r0, [r3, #8]
    676c:	4839      	ldr	r0, [pc, #228]	; (6854 <sim_init+0x170>)
    676e:	7806      	ldrb	r6, [r0, #0]
    6770:	4316      	orrs	r6, r2
    6772:	7006      	strb	r6, [r0, #0]
    6774:	7806      	ldrb	r6, [r0, #0]
    6776:	433e      	orrs	r6, r7
    6778:	7006      	strb	r6, [r0, #0]
    677a:	4e37      	ldr	r6, [pc, #220]	; (6858 <sim_init+0x174>)
    677c:	370e      	adds	r7, #14
    677e:	7830      	ldrb	r0, [r6, #0]
    6780:	43b8      	bics	r0, r7
    6782:	4310      	orrs	r0, r2
    6784:	7030      	strb	r0, [r6, #0]
HAL_GPIO_PIN(SIM_UART_RX,   A, 11)
    6786:	2080      	movs	r0, #128	; 0x80
    6788:	0100      	lsls	r0, r0, #4
    678a:	6058      	str	r0, [r3, #4]
    678c:	4833      	ldr	r0, [pc, #204]	; (685c <sim_init+0x178>)
    678e:	7807      	ldrb	r7, [r0, #0]
    6790:	4317      	orrs	r7, r2
    6792:	7007      	strb	r7, [r0, #0]
    6794:	7807      	ldrb	r7, [r0, #0]
    6796:	438f      	bics	r7, r1
    6798:	7007      	strb	r7, [r0, #0]
    679a:	2780      	movs	r7, #128	; 0x80
    679c:	013f      	lsls	r7, r7, #4
    679e:	619f      	str	r7, [r3, #24]
    67a0:	2701      	movs	r7, #1
    67a2:	7803      	ldrb	r3, [r0, #0]
    67a4:	430b      	orrs	r3, r1
    67a6:	7003      	strb	r3, [r0, #0]
    67a8:	7803      	ldrb	r3, [r0, #0]
    67aa:	433b      	orrs	r3, r7
    67ac:	7003      	strb	r3, [r0, #0]
    67ae:	200f      	movs	r0, #15
    67b0:	7833      	ldrb	r3, [r6, #0]
    67b2:	4003      	ands	r3, r0
    67b4:	3011      	adds	r0, #17
    67b6:	4303      	orrs	r3, r0
    67b8:	7033      	strb	r3, [r6, #0]
    67ba:	4b29      	ldr	r3, [pc, #164]	; (6860 <sim_init+0x17c>)
    if(onoff==0) {
    67bc:	2d00      	cmp	r5, #0
    67be:	d121      	bne.n	6804 <sim_init+0x120>
        PM->APBCMASK.reg &= ~PM_APBCMASK_SERCOM0;
    67c0:	6a1a      	ldr	r2, [r3, #32]
    67c2:	438a      	bics	r2, r1
    67c4:	621a      	str	r2, [r3, #32]
    sim_ri_init(onoff);
    67c6:	0028      	movs	r0, r5
    67c8:	4b26      	ldr	r3, [pc, #152]	; (6864 <sim_init+0x180>)
    67ca:	4798      	blx	r3
    if(onoff==0) return;
    67cc:	2d00      	cmp	r5, #0
    67ce:	d018      	beq.n	6802 <sim_init+0x11e>
    flash_read_eeprom_sim(&eeprom_sim);
    67d0:	1ca5      	adds	r5, r4, #2
    67d2:	4b25      	ldr	r3, [pc, #148]	; (6868 <sim_init+0x184>)
    67d4:	0028      	movs	r0, r5
    67d6:	4798      	blx	r3
    if (eeprom_sim.valid == false) {
    67d8:	78a3      	ldrb	r3, [r4, #2]
    67da:	2b00      	cmp	r3, #0
    67dc:	d111      	bne.n	6802 <sim_init+0x11e>
        sim_eeprom_set_HOST("hanuman-stag.kamworks.com");
    67de:	4823      	ldr	r0, [pc, #140]	; (686c <sim_init+0x188>)
    67e0:	4b23      	ldr	r3, [pc, #140]	; (6870 <sim_init+0x18c>)
    67e2:	4798      	blx	r3
        sim_eeprom_set_APN("CMNET");
    67e4:	4823      	ldr	r0, [pc, #140]	; (6874 <sim_init+0x190>)
    67e6:	4b24      	ldr	r3, [pc, #144]	; (6878 <sim_init+0x194>)
    67e8:	4798      	blx	r3
        sim_eeprom_set_USER("");
    67ea:	4e24      	ldr	r6, [pc, #144]	; (687c <sim_init+0x198>)
    67ec:	4b24      	ldr	r3, [pc, #144]	; (6880 <sim_init+0x19c>)
    67ee:	0030      	movs	r0, r6
    67f0:	4798      	blx	r3
        sim_eeprom_set_PWD("");
    67f2:	0030      	movs	r0, r6
    67f4:	4b23      	ldr	r3, [pc, #140]	; (6884 <sim_init+0x1a0>)
    67f6:	4798      	blx	r3
        eeprom_sim.valid = true;        
    67f8:	2301      	movs	r3, #1
        flash_write_eeprom_sim(&eeprom_sim);
    67fa:	0028      	movs	r0, r5
        eeprom_sim.valid = true;        
    67fc:	70a3      	strb	r3, [r4, #2]
        flash_write_eeprom_sim(&eeprom_sim);
    67fe:	4b22      	ldr	r3, [pc, #136]	; (6888 <sim_init+0x1a4>)
    6800:	4798      	blx	r3
}
    6802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0;
    6804:	6a18      	ldr	r0, [r3, #32]
    6806:	4308      	orrs	r0, r1
    6808:	6218      	str	r0, [r3, #32]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE) |
    680a:	4820      	ldr	r0, [pc, #128]	; (688c <sim_init+0x1a8>)
    680c:	4b20      	ldr	r3, [pc, #128]	; (6890 <sim_init+0x1ac>)
    680e:	8058      	strh	r0, [r3, #2]
        SERCOM0->USART.CTRLA.reg =
    6810:	4b20      	ldr	r3, [pc, #128]	; (6894 <sim_init+0x1b0>)
    6812:	4821      	ldr	r0, [pc, #132]	; (6898 <sim_init+0x1b4>)
    6814:	6018      	str	r0, [r3, #0]
        SERCOM0->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN |
    6816:	20c0      	movs	r0, #192	; 0xc0
    6818:	0280      	lsls	r0, r0, #10
    681a:	6058      	str	r0, [r3, #4]
        SERCOM0->USART.BAUD.reg = (uint16_t)br+1;
    681c:	481f      	ldr	r0, [pc, #124]	; (689c <sim_init+0x1b8>)
    681e:	8158      	strh	r0, [r3, #10]
        SERCOM0->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    6820:	7359      	strb	r1, [r3, #13]
        SERCOM0->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    6822:	6819      	ldr	r1, [r3, #0]
    6824:	430a      	orrs	r2, r1
    6826:	601a      	str	r2, [r3, #0]
    6828:	4662      	mov	r2, ip
    682a:	4b1d      	ldr	r3, [pc, #116]	; (68a0 <sim_init+0x1bc>)
    682c:	601a      	str	r2, [r3, #0]
    682e:	e7ca      	b.n	67c6 <sim_init+0xe2>
    6830:	00008957 	.word	0x00008957
    6834:	20000b1c 	.word	0x20000b1c
    6838:	20000531 	.word	0x20000531
    683c:	20000831 	.word	0x20000831
    6840:	41004400 	.word	0x41004400
    6844:	41004446 	.word	0x41004446
    6848:	41004447 	.word	0x41004447
    684c:	41004443 	.word	0x41004443
    6850:	41004445 	.word	0x41004445
    6854:	4100444a 	.word	0x4100444a
    6858:	41004435 	.word	0x41004435
    685c:	4100444b 	.word	0x4100444b
    6860:	40000400 	.word	0x40000400
    6864:	00004ef9 	.word	0x00004ef9
    6868:	00001031 	.word	0x00001031
    686c:	0000b820 	.word	0x0000b820
    6870:	000066c1 	.word	0x000066c1
    6874:	0000b83a 	.word	0x0000b83a
    6878:	00006655 	.word	0x00006655
    687c:	00009f84 	.word	0x00009f84
    6880:	00006679 	.word	0x00006679
    6884:	0000669d 	.word	0x0000669d
    6888:	000011fd 	.word	0x000011fd
    688c:	0000400d 	.word	0x0000400d
    6890:	40000c00 	.word	0x40000c00
    6894:	42000800 	.word	0x42000800
    6898:	40310004 	.word	0x40310004
    689c:	ffffc505 	.word	0xffffc505
    68a0:	e000e100 	.word	0xe000e100

000068a4 <sysstate2str>:
volatile uint8_t oled_i2c_timeout;


char sysstate2str(uint8_t si)
{
        uint8_t ss = (sysval.sys_state>>(si*2))&3;
    68a4:	4b06      	ldr	r3, [pc, #24]	; (68c0 <sysstate2str+0x1c>)
    68a6:	0040      	lsls	r0, r0, #1
    68a8:	33b8      	adds	r3, #184	; 0xb8
    68aa:	781b      	ldrb	r3, [r3, #0]
    68ac:	2203      	movs	r2, #3
    68ae:	4103      	asrs	r3, r0
    68b0:	2065      	movs	r0, #101	; 0x65
    68b2:	4013      	ands	r3, r2
    68b4:	4293      	cmp	r3, r2
    68b6:	d001      	beq.n	68bc <sysstate2str+0x18>
    68b8:	4a02      	ldr	r2, [pc, #8]	; (68c4 <sysstate2str+0x20>)
    68ba:	5cd0      	ldrb	r0, [r2, r3]
                case 0:  return 'I'; // INIT
                case 1:  return 'W'; // WAIT
                case 2:  return 'C'; // CHARGE
                default: return 'e'; // ERROR
        }
}
    68bc:	4770      	bx	lr
    68be:	46c0      	nop			; (mov r8, r8)
    68c0:	20000a58 	.word	0x20000a58
    68c4:	0000b84c 	.word	0x0000b84c

000068c8 <solarstate2str>:
char solarstate2str(uint8_t si)
{
        uint8_t ss = (sysval.solar_state>>(si*2))&3;
    68c8:	4b06      	ldr	r3, [pc, #24]	; (68e4 <solarstate2str+0x1c>)
    68ca:	0040      	lsls	r0, r0, #1
    68cc:	33b5      	adds	r3, #181	; 0xb5
    68ce:	781b      	ldrb	r3, [r3, #0]
    68d0:	2203      	movs	r2, #3
    68d2:	4103      	asrs	r3, r0
    68d4:	2078      	movs	r0, #120	; 0x78
    68d6:	4013      	ands	r3, r2
    68d8:	4293      	cmp	r3, r2
    68da:	d002      	beq.n	68e2 <solarstate2str+0x1a>
    68dc:	4a02      	ldr	r2, [pc, #8]	; (68e8 <solarstate2str+0x20>)
    68de:	3203      	adds	r2, #3
    68e0:	5cd0      	ldrb	r0, [r2, r3]
                case 0:  return 'O'; // OK
                case 1:  return 'L'; // LOW
                case 2:  return 'H'; // TOO HIGH
                default: return 'x'; // NOT AVAIL
        }
}
    68e2:	4770      	bx	lr
    68e4:	20000a58 	.word	0x20000a58
    68e8:	0000b84c 	.word	0x0000b84c

000068ec <loadstate2str>:

char loadstate2str(uint8_t si)
{
        // fo fo fo fo (status: f=1=FAULT o=1=ON)

        uint8_t ss = (sysval.load_state>>(si*2))&3;
    68ec:	4b06      	ldr	r3, [pc, #24]	; (6908 <loadstate2str+0x1c>)
    68ee:	0040      	lsls	r0, r0, #1
    68f0:	33b6      	adds	r3, #182	; 0xb6
    68f2:	781b      	ldrb	r3, [r3, #0]
    68f4:	2203      	movs	r2, #3
    68f6:	4103      	asrs	r3, r0
    68f8:	2046      	movs	r0, #70	; 0x46
    68fa:	4013      	ands	r3, r2
    68fc:	4293      	cmp	r3, r2
    68fe:	d002      	beq.n	6906 <loadstate2str+0x1a>
    6900:	4a02      	ldr	r2, [pc, #8]	; (690c <loadstate2str+0x20>)
    6902:	3206      	adds	r2, #6
    6904:	5cd0      	ldrb	r0, [r2, r3]
                case 0:  return '0'; // OFF
                case 1:  return '1'; // ON
                case 2:  return 'f'; // FAULT, OFF
                default: return 'F'; // FAULT, ON
        }
}
    6906:	4770      	bx	lr
    6908:	20000a58 	.word	0x20000a58
    690c:	0000b84c 	.word	0x0000b84c

00006910 <daystate2str>:

char daystate2str(uint8_t si)
{
        // dp dp dp dp (status: d=1=DAY p=1=PM)

        uint8_t ss = (sysval.day_state>>(si*2))&3;
    6910:	4b07      	ldr	r3, [pc, #28]	; (6930 <daystate2str+0x20>)
    6912:	0040      	lsls	r0, r0, #1
    6914:	33b9      	adds	r3, #185	; 0xb9
    6916:	781b      	ldrb	r3, [r3, #0]
        switch(ss) {
    6918:	2203      	movs	r2, #3
        uint8_t ss = (sysval.day_state>>(si*2))&3;
    691a:	4103      	asrs	r3, r0
                case 0:  return 'z'; // NIGHT
    691c:	207a      	movs	r0, #122	; 0x7a
        switch(ss) {
    691e:	4013      	ands	r3, r2
    6920:	2b01      	cmp	r3, #1
    6922:	d903      	bls.n	692c <daystate2str+0x1c>
                case 1:  return 'z'; // NIGHT
                case 2:  return 'A'; // DAY, AM
    6924:	3839      	subs	r0, #57	; 0x39
        switch(ss) {
    6926:	2b02      	cmp	r3, #2
    6928:	d000      	beq.n	692c <daystate2str+0x1c>
                default: return 'P'; // DAY, PM
    692a:	300f      	adds	r0, #15
        }
}
    692c:	4770      	bx	lr
    692e:	46c0      	nop			; (mov r8, r8)
    6930:	20000a58 	.word	0x20000a58

00006934 <task_set_load>:
        len+=sprintf(&output_buf[len],"\r\n");
        return len;
}

void task_set_load(uint8_t onoff)
{
    6934:	b510      	push	{r4, lr}
#if (SYSTEM_CCNEO_SCC==1) 
    scc_set_load(onoff);
    6936:	4b01      	ldr	r3, [pc, #4]	; (693c <task_set_load+0x8>)
    6938:	4798      	blx	r3
    mod_ac_set_relay_all(onoff);
#endif
#if (SYSTEM_MODULAR_DC==1) 
    mod_dc_set_relay_all(onoff);
#endif
}
    693a:	bd10      	pop	{r4, pc}
    693c:	00004471 	.word	0x00004471

00006940 <task_every_minute>:
void task_every_5second(void)
{   
}

void task_every_minute(void)
{
    6940:	b510      	push	{r4, lr}
    code_run_update();
    6942:	4b02      	ldr	r3, [pc, #8]	; (694c <task_every_minute+0xc>)
    6944:	4798      	blx	r3
#if (SYSTEM_CCNEO_SCC==1) 
    scc_read_batteries();
    6946:	4b02      	ldr	r3, [pc, #8]	; (6950 <task_every_minute+0x10>)
    6948:	4798      	blx	r3
#endif
}
    694a:	bd10      	pop	{r4, pc}
    694c:	00000c05 	.word	0x00000c05
    6950:	00004ad1 	.word	0x00004ad1

00006954 <task_daily>:
void task_hourly(void)
{
}

void task_daily(void)
{
    6954:	b510      	push	{r4, lr}
    eeprom_shs.interval2G   = sysval.interval2G;
    6956:	4c17      	ldr	r4, [pc, #92]	; (69b4 <task_daily+0x60>)
    6958:	4817      	ldr	r0, [pc, #92]	; (69b8 <task_daily+0x64>)
    695a:	8ae3      	ldrh	r3, [r4, #22]
    695c:	8043      	strh	r3, [r0, #2]
    eeprom_shs.secondsMeter = sysval.seconds;
    695e:	6823      	ldr	r3, [r4, #0]
    6960:	6043      	str	r3, [r0, #4]
    eeprom_shs.Ws_in        = sysval.Ws_in;
    6962:	0023      	movs	r3, r4
    6964:	33a0      	adds	r3, #160	; 0xa0
    6966:	681b      	ldr	r3, [r3, #0]
    6968:	6083      	str	r3, [r0, #8]
    eeprom_shs.Ws_out       = sysval.Ws_out;
    696a:	0023      	movs	r3, r4
    696c:	33a4      	adds	r3, #164	; 0xa4
    696e:	681b      	ldr	r3, [r3, #0]
    6970:	60c3      	str	r3, [r0, #12]
    eeprom_shs.Ws_out_ac    = sysval.Ws_out_ac;
    6972:	0023      	movs	r3, r4
    6974:	33a8      	adds	r3, #168	; 0xa8
    6976:	681b      	ldr	r3, [r3, #0]
    6978:	6103      	str	r3, [r0, #16]
    
    flash_write_eeprom_shs(&eeprom_shs);
    697a:	4b10      	ldr	r3, [pc, #64]	; (69bc <task_daily+0x68>)
    697c:	4798      	blx	r3
    code_daily_flash();
    697e:	4b10      	ldr	r3, [pc, #64]	; (69c0 <task_daily+0x6c>)
    6980:	4798      	blx	r3

    if(sim_is_on()) {
    6982:	4b10      	ldr	r3, [pc, #64]	; (69c4 <task_daily+0x70>)
    6984:	4798      	blx	r3
    6986:	2800      	cmp	r0, #0
    6988:	d012      	beq.n	69b0 <task_daily+0x5c>
        if(sysval.has_bluetooth) { bt_stop_bluetooth(); }
    698a:	34c1      	adds	r4, #193	; 0xc1
    698c:	7823      	ldrb	r3, [r4, #0]
    698e:	2b00      	cmp	r3, #0
    6990:	d001      	beq.n	6996 <task_daily+0x42>
    6992:	4b0d      	ldr	r3, [pc, #52]	; (69c8 <task_daily+0x74>)
    6994:	4798      	blx	r3
        sim_task_add(SIM_TASK_POWER,0,0); // turn off SIM module
    6996:	2200      	movs	r2, #0
    6998:	4c0c      	ldr	r4, [pc, #48]	; (69cc <task_daily+0x78>)
    699a:	0011      	movs	r1, r2
    699c:	2001      	movs	r0, #1
    699e:	47a0      	blx	r4
        sim_task_add(SIM_TASK_WAIT,60,0); // wait 60 seconds
    69a0:	2200      	movs	r2, #0
    69a2:	213c      	movs	r1, #60	; 0x3c
    69a4:	2007      	movs	r0, #7
    69a6:	47a0      	blx	r4
        sim_task_add(SIM_TASK_POWER,0,1); // then turn on
    69a8:	2201      	movs	r2, #1
    69aa:	2100      	movs	r1, #0
    69ac:	0010      	movs	r0, r2
    69ae:	47a0      	blx	r4
    }
}
    69b0:	bd10      	pop	{r4, pc}
    69b2:	46c0      	nop			; (mov r8, r8)
    69b4:	20000a58 	.word	0x20000a58
    69b8:	20000890 	.word	0x20000890
    69bc:	000011c9 	.word	0x000011c9
    69c0:	00000be5 	.word	0x00000be5
    69c4:	000063bd 	.word	0x000063bd
    69c8:	0000053d 	.word	0x0000053d
    69cc:	000063cd 	.word	0x000063cd

000069d0 <addto_data_message>:

uint8_t addto_data_message(uint8_t offset)
{
    69d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    69d2:	b0ab      	sub	sp, #172	; 0xac
    char buf[64];
    uint8_t tmp_ledstate=0;

    sprintf(buf, DATAPACKET_VERSION ";%d.%d;%c%c%c%c;%c%c%c%c;%lu;%c%c%c%c;",
        VERSION,SUBVERSION,
        daystate2str(3),daystate2str(2),daystate2str(1),daystate2str(0),
    69d4:	4c78      	ldr	r4, [pc, #480]	; (6bb8 <addto_data_message+0x1e8>)
{
    69d6:	9010      	str	r0, [sp, #64]	; 0x40
        daystate2str(3),daystate2str(2),daystate2str(1),daystate2str(0),
    69d8:	2003      	movs	r0, #3
    69da:	47a0      	blx	r4
    69dc:	9011      	str	r0, [sp, #68]	; 0x44
    69de:	2002      	movs	r0, #2
    69e0:	47a0      	blx	r4
    69e2:	9012      	str	r0, [sp, #72]	; 0x48
    69e4:	2001      	movs	r0, #1
    69e6:	47a0      	blx	r4
    69e8:	9013      	str	r0, [sp, #76]	; 0x4c
    69ea:	2000      	movs	r0, #0
    69ec:	47a0      	blx	r4
        sysstate2str(3),sysstate2str(2),sysstate2str(1),sysstate2str(0), sysval.seconds,
    69ee:	4c73      	ldr	r4, [pc, #460]	; (6bbc <addto_data_message+0x1ec>)
        daystate2str(3),daystate2str(2),daystate2str(1),daystate2str(0),
    69f0:	9014      	str	r0, [sp, #80]	; 0x50
        sysstate2str(3),sysstate2str(2),sysstate2str(1),sysstate2str(0), sysval.seconds,
    69f2:	2003      	movs	r0, #3
    69f4:	47a0      	blx	r4
    69f6:	9015      	str	r0, [sp, #84]	; 0x54
    69f8:	2002      	movs	r0, #2
    69fa:	47a0      	blx	r4
    69fc:	9016      	str	r0, [sp, #88]	; 0x58
    69fe:	2001      	movs	r0, #1
    6a00:	47a0      	blx	r4
    6a02:	9017      	str	r0, [sp, #92]	; 0x5c
    6a04:	2000      	movs	r0, #0
    6a06:	47a0      	blx	r4
    sprintf(buf, DATAPACKET_VERSION ";%d.%d;%c%c%c%c;%c%c%c%c;%lu;%c%c%c%c;",
    6a08:	4c6d      	ldr	r4, [pc, #436]	; (6bc0 <addto_data_message+0x1f0>)
        loadstate2str(3),loadstate2str(2),loadstate2str(1),loadstate2str(0));
    6a0a:	4d6e      	ldr	r5, [pc, #440]	; (6bc4 <addto_data_message+0x1f4>)
    sprintf(buf, DATAPACKET_VERSION ";%d.%d;%c%c%c%c;%c%c%c%c;%lu;%c%c%c%c;",
    6a0c:	6823      	ldr	r3, [r4, #0]
        sysstate2str(3),sysstate2str(2),sysstate2str(1),sysstate2str(0), sysval.seconds,
    6a0e:	9018      	str	r0, [sp, #96]	; 0x60
        loadstate2str(3),loadstate2str(2),loadstate2str(1),loadstate2str(0));
    6a10:	2003      	movs	r0, #3
    sprintf(buf, DATAPACKET_VERSION ";%d.%d;%c%c%c%c;%c%c%c%c;%lu;%c%c%c%c;",
    6a12:	930f      	str	r3, [sp, #60]	; 0x3c
        loadstate2str(3),loadstate2str(2),loadstate2str(1),loadstate2str(0));
    6a14:	47a8      	blx	r5
    6a16:	9019      	str	r0, [sp, #100]	; 0x64
    6a18:	2002      	movs	r0, #2
    6a1a:	47a8      	blx	r5
    6a1c:	0006      	movs	r6, r0
    6a1e:	2001      	movs	r0, #1
    6a20:	47a8      	blx	r5
    6a22:	0007      	movs	r7, r0
    6a24:	2000      	movs	r0, #0
    6a26:	47a8      	blx	r5
    sprintf(buf, DATAPACKET_VERSION ";%d.%d;%c%c%c%c;%c%c%c%c;%lu;%c%c%c%c;",
    6a28:	9b19      	ldr	r3, [sp, #100]	; 0x64
    6a2a:	900c      	str	r0, [sp, #48]	; 0x30
    6a2c:	9309      	str	r3, [sp, #36]	; 0x24
    6a2e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6a30:	970b      	str	r7, [sp, #44]	; 0x2c
    6a32:	9308      	str	r3, [sp, #32]
    6a34:	9b18      	ldr	r3, [sp, #96]	; 0x60
    6a36:	960a      	str	r6, [sp, #40]	; 0x28
    6a38:	9307      	str	r3, [sp, #28]
    6a3a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    6a3c:	2207      	movs	r2, #7
    6a3e:	9306      	str	r3, [sp, #24]
    6a40:	9b16      	ldr	r3, [sp, #88]	; 0x58
    6a42:	a81a      	add	r0, sp, #104	; 0x68
    6a44:	9305      	str	r3, [sp, #20]
    6a46:	9b15      	ldr	r3, [sp, #84]	; 0x54
    6a48:	9304      	str	r3, [sp, #16]
    6a4a:	9b14      	ldr	r3, [sp, #80]	; 0x50
    6a4c:	495e      	ldr	r1, [pc, #376]	; (6bc8 <addto_data_message+0x1f8>)
    6a4e:	9303      	str	r3, [sp, #12]
    6a50:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    6a52:	4d5e      	ldr	r5, [pc, #376]	; (6bcc <addto_data_message+0x1fc>)
    6a54:	9302      	str	r3, [sp, #8]
    6a56:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6a58:	9301      	str	r3, [sp, #4]
    6a5a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6a5c:	9300      	str	r3, [sp, #0]
    6a5e:	2301      	movs	r3, #1
    6a60:	47a8      	blx	r5
    offset = sim_addto_data_message(offset,buf);
    6a62:	a91a      	add	r1, sp, #104	; 0x68
    6a64:	4f5a      	ldr	r7, [pc, #360]	; (6bd0 <addto_data_message+0x200>)
    6a66:	9810      	ldr	r0, [sp, #64]	; 0x40
    6a68:	47b8      	blx	r7

    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6a6a:	0023      	movs	r3, r4
    6a6c:	33b0      	adds	r3, #176	; 0xb0
    6a6e:	681b      	ldr	r3, [r3, #0]
        sysval.Door_open,sysval.SoC,sysval.SoCC,
        sysval.Ah, sysval.Ws_in/3600, sysval.Ws_out/3600,
        solarstate2str(3),solarstate2str(2),solarstate2str(1),solarstate2str(0));
    6a70:	4d58      	ldr	r5, [pc, #352]	; (6bd4 <addto_data_message+0x204>)
    offset = sim_addto_data_message(offset,buf);
    6a72:	9010      	str	r0, [sp, #64]	; 0x40
        solarstate2str(3),solarstate2str(2),solarstate2str(1),solarstate2str(0));
    6a74:	2003      	movs	r0, #3
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6a76:	930f      	str	r3, [sp, #60]	; 0x3c
        solarstate2str(3),solarstate2str(2),solarstate2str(1),solarstate2str(0));
    6a78:	47a8      	blx	r5
    6a7a:	9011      	str	r0, [sp, #68]	; 0x44
    6a7c:	2002      	movs	r0, #2
    6a7e:	47a8      	blx	r5
    6a80:	9012      	str	r0, [sp, #72]	; 0x48
    6a82:	2001      	movs	r0, #1
    6a84:	47a8      	blx	r5
    6a86:	0006      	movs	r6, r0
    6a88:	2000      	movs	r0, #0
    6a8a:	47a8      	blx	r5
        sysval.Door_open,sysval.SoC,sysval.SoCC,
    6a8c:	0023      	movs	r3, r4
    6a8e:	33ac      	adds	r3, #172	; 0xac
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6a90:	781b      	ldrb	r3, [r3, #0]
    6a92:	21e1      	movs	r1, #225	; 0xe1
    6a94:	9313      	str	r3, [sp, #76]	; 0x4c
        sysval.Door_open,sysval.SoC,sysval.SoCC,
    6a96:	0023      	movs	r3, r4
    6a98:	33ba      	adds	r3, #186	; 0xba
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6a9a:	781d      	ldrb	r5, [r3, #0]
    6a9c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    6a9e:	9606      	str	r6, [sp, #24]
    6aa0:	9305      	str	r3, [sp, #20]
    6aa2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    6aa4:	9007      	str	r0, [sp, #28]
    6aa6:	9304      	str	r3, [sp, #16]
        sysval.Ah, sysval.Ws_in/3600, sysval.Ws_out/3600,
    6aa8:	0023      	movs	r3, r4
    6aaa:	33a4      	adds	r3, #164	; 0xa4
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6aac:	6818      	ldr	r0, [r3, #0]
    6aae:	0109      	lsls	r1, r1, #4
    6ab0:	4b49      	ldr	r3, [pc, #292]	; (6bd8 <addto_data_message+0x208>)
    6ab2:	4798      	blx	r3
        sysval.Ah, sysval.Ws_in/3600, sysval.Ws_out/3600,
    6ab4:	0023      	movs	r3, r4
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6ab6:	21e1      	movs	r1, #225	; 0xe1
    6ab8:	9003      	str	r0, [sp, #12]
        sysval.Ah, sysval.Ws_in/3600, sysval.Ws_out/3600,
    6aba:	33a0      	adds	r3, #160	; 0xa0
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6abc:	6818      	ldr	r0, [r3, #0]
    6abe:	0109      	lsls	r1, r1, #4
    6ac0:	4b45      	ldr	r3, [pc, #276]	; (6bd8 <addto_data_message+0x208>)
    6ac2:	4798      	blx	r3
    6ac4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6ac6:	9002      	str	r0, [sp, #8]
    6ac8:	9301      	str	r3, [sp, #4]
        sysval.Door_open,sysval.SoC,sysval.SoCC,
    6aca:	0023      	movs	r3, r4
    6acc:	33ad      	adds	r3, #173	; 0xad
    sprintf(buf,"%d;%d;%d;%lu;%lu;%lu;%c%c%c%c;",
    6ace:	781b      	ldrb	r3, [r3, #0]
    6ad0:	002a      	movs	r2, r5
    6ad2:	9300      	str	r3, [sp, #0]
    6ad4:	4941      	ldr	r1, [pc, #260]	; (6bdc <addto_data_message+0x20c>)
    6ad6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    6ad8:	a81a      	add	r0, sp, #104	; 0x68
    6ada:	4d3c      	ldr	r5, [pc, #240]	; (6bcc <addto_data_message+0x1fc>)
    6adc:	47a8      	blx	r5
    offset = sim_addto_data_message(offset,buf);
    6ade:	a91a      	add	r1, sp, #104	; 0x68
    6ae0:	9810      	ldr	r0, [sp, #64]	; 0x40
    6ae2:	47b8      	blx	r7
    if(bit_is_set(PORTB,LED_CHARGING)   == 0) tmp_ledstate|=0x10;
    if(bit_is_set(PORTB,LED_100PERCENT) == 0) tmp_ledstate|=0x20;
    if(bit_is_set(PORTB,LED_60PERCENT)  == 0) tmp_ledstate|=0x40;
    if(bit_is_set(PORTB,LED_30PERCENT)  == 0) tmp_ledstate|=0x80;
    */
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",sysval.Vbatt,sysval.Vpv,sysval.I_load,sysval.I_charge,
    6ae4:	0023      	movs	r3, r4
    offset = sim_addto_data_message(offset,buf);
    6ae6:	900f      	str	r0, [sp, #60]	; 0x3c
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",sysval.Vbatt,sysval.Vpv,sysval.I_load,sysval.I_charge,
    6ae8:	338e      	adds	r3, #142	; 0x8e
    6aea:	2200      	movs	r2, #0
    6aec:	5e9b      	ldrsh	r3, [r3, r2]
    6aee:	0022      	movs	r2, r4
    6af0:	3290      	adds	r2, #144	; 0x90
    6af2:	2100      	movs	r1, #0
    6af4:	5e52      	ldrsh	r2, [r2, r1]
                                        sysval.P_out,sysval.P_in,sysval.temp);
    6af6:	0021      	movs	r1, r4
    6af8:	31b4      	adds	r1, #180	; 0xb4
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",sysval.Vbatt,sysval.Vpv,sysval.I_load,sysval.I_charge,
    6afa:	7809      	ldrb	r1, [r1, #0]
    6afc:	4e38      	ldr	r6, [pc, #224]	; (6be0 <addto_data_message+0x210>)
    6afe:	9104      	str	r1, [sp, #16]
                                        sysval.P_out,sysval.P_in,sysval.temp);
    6b00:	0021      	movs	r1, r4
    6b02:	319a      	adds	r1, #154	; 0x9a
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",sysval.Vbatt,sysval.Vpv,sysval.I_load,sysval.I_charge,
    6b04:	2000      	movs	r0, #0
    6b06:	5e09      	ldrsh	r1, [r1, r0]
    6b08:	4d30      	ldr	r5, [pc, #192]	; (6bcc <addto_data_message+0x1fc>)
    6b0a:	9103      	str	r1, [sp, #12]
                                        sysval.P_out,sysval.P_in,sysval.temp);
    6b0c:	0021      	movs	r1, r4
    6b0e:	319c      	adds	r1, #156	; 0x9c
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",sysval.Vbatt,sysval.Vpv,sysval.I_load,sysval.I_charge,
    6b10:	2000      	movs	r0, #0
    6b12:	5e09      	ldrsh	r1, [r1, r0]
    6b14:	9102      	str	r1, [sp, #8]
    6b16:	0021      	movs	r1, r4
    6b18:	3192      	adds	r1, #146	; 0x92
    6b1a:	2000      	movs	r0, #0
    6b1c:	5e09      	ldrsh	r1, [r1, r0]
    6b1e:	9101      	str	r1, [sp, #4]
    6b20:	0021      	movs	r1, r4
    6b22:	3194      	adds	r1, #148	; 0x94
    6b24:	2000      	movs	r0, #0
    6b26:	5e09      	ldrsh	r1, [r1, r0]
    6b28:	a81a      	add	r0, sp, #104	; 0x68
    6b2a:	9100      	str	r1, [sp, #0]
    6b2c:	0031      	movs	r1, r6
    6b2e:	47a8      	blx	r5
                                        
    offset = sim_addto_data_message(offset,buf);
    6b30:	a91a      	add	r1, sp, #104	; 0x68
    6b32:	980f      	ldr	r0, [sp, #60]	; 0x3c
    6b34:	47b8      	blx	r7
            ((tmp_ledstate&0x10)==0x10), // LED_CHARGING
            ((tmp_ledstate&0x20)==0x20), // LED_100PERCENT
            ((tmp_ledstate&0x40)==0x40), // LED_60PERCENT
            ((tmp_ledstate&0x80)==0x80), // LED_30PERCENT
            ((tmp_ledstate&0x08)==0x08), // LED_SHORTFAULT (FIXME: what if it is blinking?)
            sysval.payled_mode);
    6b36:	0023      	movs	r3, r4
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",
    6b38:	2500      	movs	r5, #0
    offset = sim_addto_data_message(offset,buf);
    6b3a:	900f      	str	r0, [sp, #60]	; 0x3c
            sysval.payled_mode);
    6b3c:	33bd      	adds	r3, #189	; 0xbd
    sprintf(buf,"%d;%d;%d;%d;%d;%d;%d;",
    6b3e:	781b      	ldrb	r3, [r3, #0]
    6b40:	8962      	ldrh	r2, [r4, #10]
    6b42:	0031      	movs	r1, r6
    6b44:	9304      	str	r3, [sp, #16]
    6b46:	9503      	str	r5, [sp, #12]
    6b48:	002b      	movs	r3, r5
    6b4a:	9502      	str	r5, [sp, #8]
    6b4c:	9501      	str	r5, [sp, #4]
    6b4e:	9500      	str	r5, [sp, #0]
    6b50:	a81a      	add	r0, sp, #104	; 0x68
    6b52:	4e1e      	ldr	r6, [pc, #120]	; (6bcc <addto_data_message+0x1fc>)
    6b54:	47b0      	blx	r6
    
    offset = sim_addto_data_message(offset,buf);
    6b56:	a91a      	add	r1, sp, #104	; 0x68
    6b58:	980f      	ldr	r0, [sp, #60]	; 0x3c
    6b5a:	47b8      	blx	r7
   
    sprintf(buf,"%d;%d;%d;%d;0;0;",sysval.signalstrength,
    6b5c:	22c0      	movs	r2, #192	; 0xc0
    offset = sim_addto_data_message(offset,buf);
    6b5e:	0006      	movs	r6, r0
    sprintf(buf,"%d;%d;%d;%d;0;0;",sysval.signalstrength,
    6b60:	56a2      	ldrsb	r2, [r4, r2]
    6b62:	002b      	movs	r3, r5
    6b64:	9501      	str	r5, [sp, #4]
    6b66:	9500      	str	r5, [sp, #0]
    6b68:	491e      	ldr	r1, [pc, #120]	; (6be4 <addto_data_message+0x214>)
    6b6a:	a81a      	add	r0, sp, #104	; 0x68
    6b6c:	4d17      	ldr	r5, [pc, #92]	; (6bcc <addto_data_message+0x1fc>)
    6b6e:	47a8      	blx	r5
                                   0,//sysval.scc_icharge[0],
                                   0,//sysval.scc_icharge[1],
                                   0//sysval.scc_icharge[2]
                                   );

    offset = sim_addto_data_message(offset,buf);
    6b70:	a91a      	add	r1, sp, #104	; 0x68
    6b72:	0030      	movs	r0, r6
    6b74:	47b8      	blx	r7

    sprintf(buf,"%d;%d;%d;%lu;",sysval.V_load_ac,
                                sysval.I_load_ac,
    6b76:	0023      	movs	r3, r4
    6b78:	3396      	adds	r3, #150	; 0x96
    sprintf(buf,"%d;%d;%d;%lu;",sysval.V_load_ac,
    6b7a:	2200      	movs	r2, #0
    6b7c:	5e9b      	ldrsh	r3, [r3, r2]
    6b7e:	21e1      	movs	r1, #225	; 0xe1
    6b80:	930f      	str	r3, [sp, #60]	; 0x3c
    6b82:	0023      	movs	r3, r4
    6b84:	3398      	adds	r3, #152	; 0x98
    6b86:	2600      	movs	r6, #0
    6b88:	5f9e      	ldrsh	r6, [r3, r6]
                                sysval.P_out_ac,
                                sysval.Ws_out_ac/3600
    6b8a:	0023      	movs	r3, r4
    6b8c:	33a8      	adds	r3, #168	; 0xa8
    offset = sim_addto_data_message(offset,buf);
    6b8e:	0005      	movs	r5, r0
    sprintf(buf,"%d;%d;%d;%lu;",sysval.V_load_ac,
    6b90:	0109      	lsls	r1, r1, #4
    6b92:	6818      	ldr	r0, [r3, #0]
    6b94:	4b10      	ldr	r3, [pc, #64]	; (6bd8 <addto_data_message+0x208>)
    6b96:	4798      	blx	r3
                                sysval.P_out_ac,
    6b98:	349e      	adds	r4, #158	; 0x9e
    sprintf(buf,"%d;%d;%d;%lu;",sysval.V_load_ac,
    6b9a:	9001      	str	r0, [sp, #4]
    6b9c:	2200      	movs	r2, #0
    6b9e:	5ea3      	ldrsh	r3, [r4, r2]
    6ba0:	4911      	ldr	r1, [pc, #68]	; (6be8 <addto_data_message+0x218>)
    6ba2:	9300      	str	r3, [sp, #0]
    6ba4:	0032      	movs	r2, r6
    6ba6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6ba8:	a81a      	add	r0, sp, #104	; 0x68
    6baa:	4c08      	ldr	r4, [pc, #32]	; (6bcc <addto_data_message+0x1fc>)
    6bac:	47a0      	blx	r4
                                );
    offset = sim_addto_data_message(offset,buf);
    6bae:	a91a      	add	r1, sp, #104	; 0x68
    6bb0:	0028      	movs	r0, r5
    6bb2:	47b8      	blx	r7
    return offset;
}
    6bb4:	b02b      	add	sp, #172	; 0xac
    6bb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6bb8:	00006911 	.word	0x00006911
    6bbc:	000068a5 	.word	0x000068a5
    6bc0:	20000a58 	.word	0x20000a58
    6bc4:	000068ed 	.word	0x000068ed
    6bc8:	0000b8ad 	.word	0x0000b8ad
    6bcc:	00008969 	.word	0x00008969
    6bd0:	000061c1 	.word	0x000061c1
    6bd4:	000068c9 	.word	0x000068c9
    6bd8:	00007f89 	.word	0x00007f89
    6bdc:	0000b8d7 	.word	0x0000b8d7
    6be0:	0000b8f6 	.word	0x0000b8f6
    6be4:	0000b90c 	.word	0x0000b90c
    6be8:	0000b91d 	.word	0x0000b91d

00006bec <task_sms>:

void task_sms(task_t *task)
{
    6bec:	b570      	push	{r4, r5, r6, lr}
    uint8_t next_state=task->state;
    6bee:	0006      	movs	r6, r0
    6bf0:	362a      	adds	r6, #42	; 0x2a
    6bf2:	7835      	ldrb	r5, [r6, #0]
{
    6bf4:	0004      	movs	r4, r0
    6bf6:	4b16      	ldr	r3, [pc, #88]	; (6c50 <task_sms+0x64>)
    switch(task->state) {
    6bf8:	2d01      	cmp	r5, #1
    6bfa:	d125      	bne.n	6c48 <task_sms+0x5c>
        case TASK_STATE_START:
          uart_print(0,"TASK_STATE_START\n\r");
    6bfc:	4915      	ldr	r1, [pc, #84]	; (6c54 <task_sms+0x68>)
    6bfe:	2000      	movs	r0, #0
    6c00:	4798      	blx	r3
          if(sim_is_on()) {
    6c02:	4b15      	ldr	r3, [pc, #84]	; (6c58 <task_sms+0x6c>)
    6c04:	4798      	blx	r3
    6c06:	2800      	cmp	r0, #0
    6c08:	d019      	beq.n	6c3e <task_sms+0x52>
              uint8_t message_len;
              if(sysval.has_bluetooth) { bt_stop_bluetooth(); }
    6c0a:	4b14      	ldr	r3, [pc, #80]	; (6c5c <task_sms+0x70>)
    6c0c:	33c1      	adds	r3, #193	; 0xc1
    6c0e:	781b      	ldrb	r3, [r3, #0]
    6c10:	2b00      	cmp	r3, #0
    6c12:	d001      	beq.n	6c18 <task_sms+0x2c>
    6c14:	4b12      	ldr	r3, [pc, #72]	; (6c60 <task_sms+0x74>)
    6c16:	4798      	blx	r3

              message_len = sim_prepare_data_message(1,get_myid()); // prepare msg with id;
    6c18:	4b12      	ldr	r3, [pc, #72]	; (6c64 <task_sms+0x78>)
    6c1a:	4798      	blx	r3
    6c1c:	4b12      	ldr	r3, [pc, #72]	; (6c68 <task_sms+0x7c>)
    6c1e:	0001      	movs	r1, r0
    6c20:	2001      	movs	r0, #1
    6c22:	4798      	blx	r3
              if(task->buf[0] != 0) {
    6c24:	7863      	ldrb	r3, [r4, #1]
    6c26:	2b00      	cmp	r3, #0
    6c28:	d00b      	beq.n	6c42 <task_sms+0x56>
                  // add msg
                  message_len = sim_addto_data_message(message_len, task->buf);
    6c2a:	1c61      	adds	r1, r4, #1
    6c2c:	4b0f      	ldr	r3, [pc, #60]	; (6c6c <task_sms+0x80>)
    6c2e:	4798      	blx	r3
              } else {
                  // not add msg but full SoC string
                  message_len = addto_data_message(message_len);        
              }
              sim_task_add(SIM_TASK_SEND_SMS,message_len,task->arg1);
    6c30:	3429      	adds	r4, #41	; 0x29
    6c32:	b281      	uxth	r1, r0
    6c34:	7822      	ldrb	r2, [r4, #0]
    6c36:	2005      	movs	r0, #5
    6c38:	4b0d      	ldr	r3, [pc, #52]	; (6c70 <task_sms+0x84>)
    6c3a:	4798      	blx	r3
              next_state = TASK_STATE_FINISHED;
          }
          break;
        default:
          next_state = TASK_STATE_FINISHED;
    6c3c:	2500      	movs	r5, #0
          uart_print(0,"->TASK_STATE_FINISHED\n\r");
          break;
    }
    task->state = next_state;
    6c3e:	7035      	strb	r5, [r6, #0]
    return;
}
    6c40:	bd70      	pop	{r4, r5, r6, pc}
                  message_len = addto_data_message(message_len);        
    6c42:	4b0c      	ldr	r3, [pc, #48]	; (6c74 <task_sms+0x88>)
    6c44:	4798      	blx	r3
    6c46:	e7f3      	b.n	6c30 <task_sms+0x44>
          uart_print(0,"->TASK_STATE_FINISHED\n\r");
    6c48:	490b      	ldr	r1, [pc, #44]	; (6c78 <task_sms+0x8c>)
    6c4a:	2000      	movs	r0, #0
    6c4c:	4798      	blx	r3
    6c4e:	e7f5      	b.n	6c3c <task_sms+0x50>
    6c50:	00007b99 	.word	0x00007b99
    6c54:	00009fc4 	.word	0x00009fc4
    6c58:	000063bd 	.word	0x000063bd
    6c5c:	20000a58 	.word	0x20000a58
    6c60:	0000053d 	.word	0x0000053d
    6c64:	00000c19 	.word	0x00000c19
    6c68:	00006155 	.word	0x00006155
    6c6c:	000061c1 	.word	0x000061c1
    6c70:	000063cd 	.word	0x000063cd
    6c74:	000069d1 	.word	0x000069d1
    6c78:	0000b92b 	.word	0x0000b92b

00006c7c <task_add>:

int8_t task_add(const uint8_t task, const char *buf, const uint8_t arg1)
{
    6c7c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  int8_t i;
  for(i=0;i<TASK_QUEUE_LEN;i++) {
    if(task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].id == TASK_IDLE) {
    6c7e:	4c1e      	ldr	r4, [pc, #120]	; (6cf8 <task_add+0x7c>)
{
    6c80:	0007      	movs	r7, r0
    if(task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].id == TASK_IDLE) {
    6c82:	0023      	movs	r3, r4
    6c84:	2500      	movs	r5, #0
{
    6c86:	9201      	str	r2, [sp, #4]
    if(task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].id == TASK_IDLE) {
    6c88:	33b0      	adds	r3, #176	; 0xb0
    6c8a:	781b      	ldrb	r3, [r3, #0]
    6c8c:	2203      	movs	r2, #3
    6c8e:	1958      	adds	r0, r3, r5
    6c90:	4010      	ands	r0, r2
    6c92:	3229      	adds	r2, #41	; 0x29
    6c94:	4350      	muls	r0, r2
    6c96:	5d06      	ldrb	r6, [r0, r4]
    6c98:	2e00      	cmp	r6, #0
    6c9a:	d122      	bne.n	6ce2 <task_add+0x66>
      // queue entry is available
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].id = task;
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].state = TASK_STATE_START;
    6c9c:	1823      	adds	r3, r4, r0
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].id = task;
    6c9e:	5507      	strb	r7, [r0, r4]
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].state = TASK_STATE_START;
    6ca0:	332a      	adds	r3, #42	; 0x2a
    6ca2:	3a2b      	subs	r2, #43	; 0x2b
      strncpy(task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf,buf,
    6ca4:	3001      	adds	r0, #1
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].state = TASK_STATE_START;
    6ca6:	701a      	strb	r2, [r3, #0]
      strncpy(task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf,buf,
    6ca8:	1900      	adds	r0, r0, r4
    6caa:	2228      	movs	r2, #40	; 0x28
    6cac:	4b13      	ldr	r3, [pc, #76]	; (6cfc <task_add+0x80>)
    6cae:	4798      	blx	r3
              MAX_COMMAND_LEN);
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf[MAX_COMMAND_LEN-1]=0;
    6cb0:	0023      	movs	r3, r4
    6cb2:	2203      	movs	r2, #3
    6cb4:	33b0      	adds	r3, #176	; 0xb0
    6cb6:	781b      	ldrb	r3, [r3, #0]
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].arg1 = arg1;
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].retries = 0;
      uart_print(0,"task_add[%d](%d)\n\r",i,task);
    6cb8:	0030      	movs	r0, r6
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf[MAX_COMMAND_LEN-1]=0;
    6cba:	195b      	adds	r3, r3, r5
    6cbc:	4013      	ands	r3, r2
    6cbe:	3229      	adds	r2, #41	; 0x29
    6cc0:	4353      	muls	r3, r2
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].arg1 = arg1;
    6cc2:	466a      	mov	r2, sp
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf[MAX_COMMAND_LEN-1]=0;
    6cc4:	18e4      	adds	r4, r4, r3
    6cc6:	0023      	movs	r3, r4
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].arg1 = arg1;
    6cc8:	7912      	ldrb	r2, [r2, #4]
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf[MAX_COMMAND_LEN-1]=0;
    6cca:	3328      	adds	r3, #40	; 0x28
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].retries = 0;
    6ccc:	342b      	adds	r4, #43	; 0x2b
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].arg1 = arg1;
    6cce:	705a      	strb	r2, [r3, #1]
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].buf[MAX_COMMAND_LEN-1]=0;
    6cd0:	701e      	strb	r6, [r3, #0]
      task_queue.task[((task_queue.current+i)&TASK_QUEUE_MASK)].retries = 0;
    6cd2:	7026      	strb	r6, [r4, #0]
      uart_print(0,"task_add[%d](%d)\n\r",i,task);
    6cd4:	003b      	movs	r3, r7
    6cd6:	002a      	movs	r2, r5
    6cd8:	4909      	ldr	r1, [pc, #36]	; (6d00 <task_add+0x84>)
    6cda:	4c0a      	ldr	r4, [pc, #40]	; (6d04 <task_add+0x88>)
    6cdc:	47a0      	blx	r4
      return 1; // ok
    6cde:	2001      	movs	r0, #1
    }
  }
  uart_print(0,"task_add(%d) FAIL\n\r",task);
  return 0; // fail
}
    6ce0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    6ce2:	3501      	adds	r5, #1
  for(i=0;i<TASK_QUEUE_LEN;i++) {
    6ce4:	2d04      	cmp	r5, #4
    6ce6:	d1d1      	bne.n	6c8c <task_add+0x10>
  uart_print(0,"task_add(%d) FAIL\n\r",task);
    6ce8:	2000      	movs	r0, #0
    6cea:	003a      	movs	r2, r7
    6cec:	4906      	ldr	r1, [pc, #24]	; (6d08 <task_add+0x8c>)
    6cee:	4b05      	ldr	r3, [pc, #20]	; (6d04 <task_add+0x88>)
    6cf0:	4798      	blx	r3
  return 0; // fail
    6cf2:	2000      	movs	r0, #0
    6cf4:	e7f4      	b.n	6ce0 <task_add+0x64>
    6cf6:	46c0      	nop			; (mov r8, r8)
    6cf8:	20000b5e 	.word	0x20000b5e
    6cfc:	00008ab7 	.word	0x00008ab7
    6d00:	0000a026 	.word	0x0000a026
    6d04:	00007b99 	.word	0x00007b99
    6d08:	0000a03d 	.word	0x0000a03d

00006d0c <task_done>:

void task_done(void)
{
    //uart_print(0,"task_done %d\n\r",task_queue.task[task_queue.current].id);
    task_queue.task[task_queue.current].id = TASK_IDLE;
    6d0c:	4b0b      	ldr	r3, [pc, #44]	; (6d3c <task_done+0x30>)
{
    6d0e:	b510      	push	{r4, lr}
    task_queue.task[task_queue.current].id = TASK_IDLE;
    6d10:	001c      	movs	r4, r3
    6d12:	202c      	movs	r0, #44	; 0x2c
    6d14:	2100      	movs	r1, #0
    6d16:	34b0      	adds	r4, #176	; 0xb0
    6d18:	7822      	ldrb	r2, [r4, #0]
    6d1a:	4350      	muls	r0, r2
    6d1c:	54c1      	strb	r1, [r0, r3]
    task_queue.task[task_queue.current].state = TASK_STATE_FINISHED;
    6d1e:	181b      	adds	r3, r3, r0
    6d20:	0018      	movs	r0, r3
    task_queue.task[task_queue.current].buf[0]=0;
    6d22:	7059      	strb	r1, [r3, #1]
    task_queue.task[task_queue.current].arg1 = 0;
    task_queue.task[task_queue.current].retries = 0;
    6d24:	332b      	adds	r3, #43	; 0x2b
    6d26:	7019      	strb	r1, [r3, #0]
    task_queue.current = (task_queue.current+1)&TASK_QUEUE_MASK; // point to next
    6d28:	2303      	movs	r3, #3
    task_queue.task[task_queue.current].state = TASK_STATE_FINISHED;
    6d2a:	302a      	adds	r0, #42	; 0x2a
    task_queue.current = (task_queue.current+1)&TASK_QUEUE_MASK; // point to next
    6d2c:	3201      	adds	r2, #1
    task_queue.task[task_queue.current].state = TASK_STATE_FINISHED;
    6d2e:	7001      	strb	r1, [r0, #0]
    task_queue.current = (task_queue.current+1)&TASK_QUEUE_MASK; // point to next
    6d30:	401a      	ands	r2, r3
    task_queue.task[task_queue.current].arg1 = 0;
    6d32:	3801      	subs	r0, #1
    6d34:	7001      	strb	r1, [r0, #0]
    task_queue.current = (task_queue.current+1)&TASK_QUEUE_MASK; // point to next
    6d36:	7022      	strb	r2, [r4, #0]
}
    6d38:	bd10      	pop	{r4, pc}
    6d3a:	46c0      	nop			; (mov r8, r8)
    6d3c:	20000b5e 	.word	0x20000b5e

00006d40 <run_tasks>:


void run_tasks(void)
{
    6d40:	b5f0      	push	{r4, r5, r6, r7, lr}
    6d42:	b08b      	sub	sp, #44	; 0x2c
  __ASM volatile ("cpsid i" : : : "memory");
    6d44:	b672      	cpsid	i
    uint16_t tasklist;
    __disable_irq();
    tasklist=sysval.tasklist;
    sysval.tasklist=0;
    6d46:	2600      	movs	r6, #0
    tasklist=sysval.tasklist;
    6d48:	4c83      	ldr	r4, [pc, #524]	; (6f58 <run_tasks+0x218>)
    6d4a:	89a3      	ldrh	r3, [r4, #12]
    sysval.tasklist=0;
    6d4c:	81a6      	strh	r6, [r4, #12]
    tasklist=sysval.tasklist;
    6d4e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsie i" : : : "memory");
    6d50:	b662      	cpsie	i
    __enable_irq();  


    if(tasklist & (1<<TASK_SECOND)) {
    6d52:	9b01      	ldr	r3, [sp, #4]
    6d54:	07db      	lsls	r3, r3, #31
    6d56:	d55b      	bpl.n	6e10 <run_tasks+0xd0>
        
        /* Do all pending tasks first: */
        uart_print(0,"task[%d]:\n\r",task_queue.task[task_queue.current].id);
    6d58:	4d80      	ldr	r5, [pc, #512]	; (6f5c <run_tasks+0x21c>)
    6d5a:	222c      	movs	r2, #44	; 0x2c
    6d5c:	002f      	movs	r7, r5
    6d5e:	37b0      	adds	r7, #176	; 0xb0
    6d60:	783b      	ldrb	r3, [r7, #0]
    6d62:	497f      	ldr	r1, [pc, #508]	; (6f60 <run_tasks+0x220>)
    6d64:	4353      	muls	r3, r2
    6d66:	0030      	movs	r0, r6
    6d68:	5d5a      	ldrb	r2, [r3, r5]
    6d6a:	4b7e      	ldr	r3, [pc, #504]	; (6f64 <run_tasks+0x224>)
    6d6c:	4798      	blx	r3

        switch(task_queue.task[task_queue.current].id) {
    6d6e:	222c      	movs	r2, #44	; 0x2c
    6d70:	783b      	ldrb	r3, [r7, #0]
    6d72:	4353      	muls	r3, r2
    6d74:	5ceb      	ldrb	r3, [r5, r3]
    6d76:	2b07      	cmp	r3, #7
    6d78:	d109      	bne.n	6d8e <run_tasks+0x4e>
            case TASK_SMS:
            uart_print(0,"TASK_SMS\n\r");
    6d7a:	0030      	movs	r0, r6
    6d7c:	4b79      	ldr	r3, [pc, #484]	; (6f64 <run_tasks+0x224>)
    6d7e:	497a      	ldr	r1, [pc, #488]	; (6f68 <run_tasks+0x228>)
    6d80:	4798      	blx	r3
            task_sms(&task_queue.task[task_queue.current]);
    6d82:	232c      	movs	r3, #44	; 0x2c
    6d84:	7838      	ldrb	r0, [r7, #0]
    6d86:	4358      	muls	r0, r3
    6d88:	4b78      	ldr	r3, [pc, #480]	; (6f6c <run_tasks+0x22c>)
    6d8a:	1940      	adds	r0, r0, r5
    6d8c:	4798      	blx	r3
            break;
        }
        if(task_queue.task[task_queue.current].state == TASK_STATE_FINISHED) {
    6d8e:	002b      	movs	r3, r5
    6d90:	33b0      	adds	r3, #176	; 0xb0
    6d92:	781a      	ldrb	r2, [r3, #0]
    6d94:	232c      	movs	r3, #44	; 0x2c
    6d96:	4353      	muls	r3, r2
    6d98:	18ed      	adds	r5, r5, r3
    6d9a:	352a      	adds	r5, #42	; 0x2a
    6d9c:	782b      	ldrb	r3, [r5, #0]
    6d9e:	2b00      	cmp	r3, #0
    6da0:	d101      	bne.n	6da6 <run_tasks+0x66>
            task_done();
    6da2:	4b73      	ldr	r3, [pc, #460]	; (6f70 <run_tasks+0x230>)
    6da4:	4798      	blx	r3
        }
        
                //uart_print(0,"---TASK_SECOND---\n\r");
                task_every_second();

                if(sysval.has_bluetooth) {
    6da6:	0023      	movs	r3, r4
    6da8:	33c1      	adds	r3, #193	; 0xc1
    6daa:	781b      	ldrb	r3, [r3, #0]
    6dac:	2b00      	cmp	r3, #0
    6dae:	d02f      	beq.n	6e10 <run_tasks+0xd0>
                        if(sysval.bluetooth_connected) {
    6db0:	0023      	movs	r3, r4
    6db2:	33c2      	adds	r3, #194	; 0xc2
    6db4:	781b      	ldrb	r3, [r3, #0]
    6db6:	2b00      	cmp	r3, #0
    6db8:	d02a      	beq.n	6e10 <run_tasks+0xd0>
                                char btbuf[32];
                                char *btbuf_ptr=bt_bluetooth_read(btbuf, sizeof(btbuf));
    6dba:	2120      	movs	r1, #32
    6dbc:	a802      	add	r0, sp, #8
    6dbe:	4b6d      	ldr	r3, [pc, #436]	; (6f74 <run_tasks+0x234>)
    6dc0:	4798      	blx	r3
    6dc2:	1e05      	subs	r5, r0, #0
                                if(btbuf_ptr != NULL) {
    6dc4:	d024      	beq.n	6e10 <run_tasks+0xd0>
                                        uint16_t bt_len=0;
                                        uart_print(0,"Bluetooth message received:%s\n\r",btbuf_ptr);
    6dc6:	0002      	movs	r2, r0
    6dc8:	496b      	ldr	r1, [pc, #428]	; (6f78 <run_tasks+0x238>)
    6dca:	2000      	movs	r0, #0
    6dcc:	4b65      	ldr	r3, [pc, #404]	; (6f64 <run_tasks+0x224>)
    6dce:	4798      	blx	r3
                                        if(strncasecmp(btbuf_ptr,"SCC?",4)==0) {
    6dd0:	2204      	movs	r2, #4
    6dd2:	496a      	ldr	r1, [pc, #424]	; (6f7c <run_tasks+0x23c>)
    6dd4:	0028      	movs	r0, r5
    6dd6:	4e6a      	ldr	r6, [pc, #424]	; (6f80 <run_tasks+0x240>)
    6dd8:	47b0      	blx	r6
    6dda:	2800      	cmp	r0, #0
    6ddc:	d018      	beq.n	6e10 <run_tasks+0xd0>
                                            //bt_len=scc_monitor_dump(UART_SIM_TxBuf,0);
                                        } else if(strncasecmp(btbuf_ptr,"SCCD?",5)==0) {
    6dde:	2205      	movs	r2, #5
    6de0:	4968      	ldr	r1, [pc, #416]	; (6f84 <run_tasks+0x244>)
    6de2:	0028      	movs	r0, r5
    6de4:	47b0      	blx	r6
    6de6:	2800      	cmp	r0, #0
    6de8:	d012      	beq.n	6e10 <run_tasks+0xd0>
                                            //bt_len=scc_monitor_dump(UART_SIM_TxBuf,1);
                                        } else if(strncasecmp(btbuf_ptr,"SOC?",4)==0) {
    6dea:	2204      	movs	r2, #4
    6dec:	4966      	ldr	r1, [pc, #408]	; (6f88 <run_tasks+0x248>)
    6dee:	0028      	movs	r0, r5
    6df0:	47b0      	blx	r6
    6df2:	2800      	cmp	r0, #0
    6df4:	d00c      	beq.n	6e10 <run_tasks+0xd0>
                                            //bt_len=task_soc_dump(UART_SIM_TxBuf);
                                        } else if(strncasecmp(btbuf_ptr,"LOAD=",5)==0) { // expect: 0 or 1
    6df6:	2205      	movs	r2, #5
    6df8:	4964      	ldr	r1, [pc, #400]	; (6f8c <run_tasks+0x24c>)
    6dfa:	0028      	movs	r0, r5
    6dfc:	47b0      	blx	r6
    6dfe:	2800      	cmp	r0, #0
    6e00:	d15e      	bne.n	6ec0 <run_tasks+0x180>
                                            char *ptr=&btbuf_ptr[5];
                                            btbuf_ptr[6]=0;
    6e02:	71a8      	strb	r0, [r5, #6]
                                            task_set_load(atoi(ptr));
    6e04:	4b62      	ldr	r3, [pc, #392]	; (6f90 <run_tasks+0x250>)
                                            char *ptr=&btbuf_ptr[5];
    6e06:	1d68      	adds	r0, r5, #5
                                            task_set_load(atoi(ptr));
    6e08:	4798      	blx	r3
    scc_set_load(onoff);
    6e0a:	4b62      	ldr	r3, [pc, #392]	; (6f94 <run_tasks+0x254>)
    6e0c:	b2c0      	uxtb	r0, r0
    scc_cal_temp(temp);
    6e0e:	4798      	blx	r3
                }
    }

    if(tasklist & (1<<TASK_2SECOND)) {
    }
    if(tasklist & (1<<TASK_3SECOND)) {
    6e10:	9b01      	ldr	r3, [sp, #4]
    6e12:	075b      	lsls	r3, r3, #29
    6e14:	d518      	bpl.n	6e48 <run_tasks+0x108>
        //uart_print(0,"---TASK_3SEC---\n\r");
        if(sysval.has_bluetooth) {
    6e16:	0023      	movs	r3, r4
    6e18:	33c1      	adds	r3, #193	; 0xc1
    6e1a:	781b      	ldrb	r3, [r3, #0]
    6e1c:	2b00      	cmp	r3, #0
    6e1e:	d013      	beq.n	6e48 <run_tasks+0x108>
                if(sysval.bluetooth_connected==0) {
    6e20:	0026      	movs	r6, r4
    6e22:	36c2      	adds	r6, #194	; 0xc2
    6e24:	7835      	ldrb	r5, [r6, #0]
    6e26:	2d00      	cmp	r5, #0
    6e28:	d10e      	bne.n	6e48 <run_tasks+0x108>
                        bt_start_bluetooth();
    6e2a:	4b5b      	ldr	r3, [pc, #364]	; (6f98 <run_tasks+0x258>)
    6e2c:	4798      	blx	r3
                        if(sysval.bluetooth_status == 25) {
    6e2e:	0023      	movs	r3, r4
    6e30:	33c3      	adds	r3, #195	; 0xc3
    6e32:	781b      	ldrb	r3, [r3, #0]
    6e34:	2b19      	cmp	r3, #25
    6e36:	d107      	bne.n	6e48 <run_tasks+0x108>
                                bt_bluetooth_connect();
    6e38:	4b58      	ldr	r3, [pc, #352]	; (6f9c <run_tasks+0x25c>)
    6e3a:	4798      	blx	r3
                                sysval.bluetooth_connected = 1;
    6e3c:	2301      	movs	r3, #1
                                uart_print(0,"connect!\n\r");
    6e3e:	4958      	ldr	r1, [pc, #352]	; (6fa0 <run_tasks+0x260>)
                                sysval.bluetooth_connected = 1;
    6e40:	7033      	strb	r3, [r6, #0]
                                uart_print(0,"connect!\n\r");
    6e42:	0028      	movs	r0, r5
    6e44:	4b47      	ldr	r3, [pc, #284]	; (6f64 <run_tasks+0x224>)
    6e46:	4798      	blx	r3
    if(tasklist & (1<<TASK_5SECOND)) {
        //uart_print(0,"---TASK_5SEC---\n\r");
        task_every_5second();
    }

    if(tasklist & (1<<TASK_MINUTE)) {
    6e48:	9b01      	ldr	r3, [sp, #4]
    6e4a:	06db      	lsls	r3, r3, #27
    6e4c:	d505      	bpl.n	6e5a <run_tasks+0x11a>
        uart_print(0,"---TASK_MIN---\n\r");
    6e4e:	4b45      	ldr	r3, [pc, #276]	; (6f64 <run_tasks+0x224>)
    6e50:	4954      	ldr	r1, [pc, #336]	; (6fa4 <run_tasks+0x264>)
    6e52:	2000      	movs	r0, #0
    6e54:	4798      	blx	r3
        task_every_minute();       
    6e56:	4b54      	ldr	r3, [pc, #336]	; (6fa8 <run_tasks+0x268>)
    6e58:	4798      	blx	r3
    }    
    
    /*
     * periodic 2G data sending:
     */
    if( (tasklist & (1<<TASK_2G)) && sysval.interval2G != 0 ) {
    6e5a:	9b01      	ldr	r3, [sp, #4]
    6e5c:	05db      	lsls	r3, r3, #23
    6e5e:	d51d      	bpl.n	6e9c <run_tasks+0x15c>
    6e60:	8ae3      	ldrh	r3, [r4, #22]
    6e62:	2b00      	cmp	r3, #0
    6e64:	d01a      	beq.n	6e9c <run_tasks+0x15c>
        uint16_t message_len;
        
        /* First check if the SIM module is on and how good the network connection is: */    
        uart_print(0,"---TASK_CREG---\n\r");        
    6e66:	4951      	ldr	r1, [pc, #324]	; (6fac <run_tasks+0x26c>)
    6e68:	2000      	movs	r0, #0
    6e6a:	4f3e      	ldr	r7, [pc, #248]	; (6f64 <run_tasks+0x224>)
    6e6c:	47b8      	blx	r7
        if(sim_available()) {
    6e6e:	4b50      	ldr	r3, [pc, #320]	; (6fb0 <run_tasks+0x270>)
    6e70:	4798      	blx	r3
    6e72:	2800      	cmp	r0, #0
    6e74:	d012      	beq.n	6e9c <run_tasks+0x15c>
            if(!sim_is_on()) {
    6e76:	4b4f      	ldr	r3, [pc, #316]	; (6fb4 <run_tasks+0x274>)
    6e78:	4798      	blx	r3
    6e7a:	4e4f      	ldr	r6, [pc, #316]	; (6fb8 <run_tasks+0x278>)
    6e7c:	1e05      	subs	r5, r0, #0
    6e7e:	d151      	bne.n	6f24 <run_tasks+0x1e4>
                uart_print(0,"SIM available but not on\n\r");
    6e80:	494e      	ldr	r1, [pc, #312]	; (6fbc <run_tasks+0x27c>)
    6e82:	47b8      	blx	r7
                sim_task_add(SIM_TASK_POWER,0,0); // turn off SIM module
    6e84:	002a      	movs	r2, r5
    6e86:	0029      	movs	r1, r5
    6e88:	2001      	movs	r0, #1
    6e8a:	47b0      	blx	r6
                sim_task_add(SIM_TASK_WAIT,10,0); // wait 10 seconds
    6e8c:	002a      	movs	r2, r5
    6e8e:	210a      	movs	r1, #10
    6e90:	2007      	movs	r0, #7
    6e92:	47b0      	blx	r6
                sim_task_add(SIM_TASK_POWER,0,1); // then turn on
    6e94:	2201      	movs	r2, #1
    6e96:	0029      	movs	r1, r5
    6e98:	0010      	movs	r0, r2
                if(sysval.has_bluetooth) { bt_stop_bluetooth(); }         
                sim_task_add(SIM_TASK_CREG,0,0); 
                uart_print(0,"---TASK_2G---\n\r");
                message_len = sim_prepare_data_message(0,get_myid());
                message_len = addto_data_message(message_len);        
                sim_task_add(SIM_TASK_START_2G,message_len,0);
    6e9a:	47b0      	blx	r6
            }        
        }
    }

    if(tasklist & (1<<TASK_HOUR)) {
    6e9c:	9b01      	ldr	r3, [sp, #4]
    6e9e:	069b      	lsls	r3, r3, #26
    6ea0:	d503      	bpl.n	6eaa <run_tasks+0x16a>
        uart_print(0,"---TASK_HOUR---\n\r");
    6ea2:	4947      	ldr	r1, [pc, #284]	; (6fc0 <run_tasks+0x280>)
    6ea4:	2000      	movs	r0, #0
    6ea6:	4b2f      	ldr	r3, [pc, #188]	; (6f64 <run_tasks+0x224>)
    6ea8:	4798      	blx	r3
        task_hourly();
    }

    if(tasklist & (1<<TASK_DAY)) {
    6eaa:	9b01      	ldr	r3, [sp, #4]
    6eac:	065b      	lsls	r3, r3, #25
    6eae:	d505      	bpl.n	6ebc <run_tasks+0x17c>
        uart_print(0,"---TASK_DAY---\n\r");
    6eb0:	4b2c      	ldr	r3, [pc, #176]	; (6f64 <run_tasks+0x224>)
    6eb2:	4944      	ldr	r1, [pc, #272]	; (6fc4 <run_tasks+0x284>)
    6eb4:	2000      	movs	r0, #0
    6eb6:	4798      	blx	r3
        task_daily();
    6eb8:	4b43      	ldr	r3, [pc, #268]	; (6fc8 <run_tasks+0x288>)
    6eba:	4798      	blx	r3
    }
}
    6ebc:	b00b      	add	sp, #44	; 0x2c
    6ebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                        } else if(strncasecmp(btbuf_ptr,"TEMP=",5)==0) { // expect: number
    6ec0:	2205      	movs	r2, #5
    6ec2:	4942      	ldr	r1, [pc, #264]	; (6fcc <run_tasks+0x28c>)
    6ec4:	0028      	movs	r0, r5
    6ec6:	47b0      	blx	r6
    6ec8:	2800      	cmp	r0, #0
    6eca:	d106      	bne.n	6eda <run_tasks+0x19a>
                                            btbuf_ptr[7]=0;
    6ecc:	71e8      	strb	r0, [r5, #7]
                                            task_cal_temp(atoi(ptr));
    6ece:	4b30      	ldr	r3, [pc, #192]	; (6f90 <run_tasks+0x250>)
                                            char *ptr=&btbuf_ptr[5];
    6ed0:	1d68      	adds	r0, r5, #5
                                            task_cal_temp(atoi(ptr));
    6ed2:	4798      	blx	r3
    scc_cal_temp(temp);
    6ed4:	4b3e      	ldr	r3, [pc, #248]	; (6fd0 <run_tasks+0x290>)
    6ed6:	b2c0      	uxtb	r0, r0
    6ed8:	e799      	b.n	6e0e <run_tasks+0xce>
                                        } else if(strncasecmp(btbuf_ptr,"BATO=",5)==0) { // expect: number
    6eda:	2205      	movs	r2, #5
    6edc:	493d      	ldr	r1, [pc, #244]	; (6fd4 <run_tasks+0x294>)
    6ede:	0028      	movs	r0, r5
    6ee0:	47b0      	blx	r6
    6ee2:	2800      	cmp	r0, #0
    6ee4:	d106      	bne.n	6ef4 <run_tasks+0x1b4>
                                            btbuf_ptr[7]=0;
    6ee6:	71e8      	strb	r0, [r5, #7]
                                            task_cal_batt(atoi(ptr));
    6ee8:	4b29      	ldr	r3, [pc, #164]	; (6f90 <run_tasks+0x250>)
                                            char *ptr=&btbuf_ptr[5];
    6eea:	1d68      	adds	r0, r5, #5
                                            task_cal_batt(atoi(ptr));
    6eec:	4798      	blx	r3
    scc_cal_batt(offset);
    6eee:	4b3a      	ldr	r3, [pc, #232]	; (6fd8 <run_tasks+0x298>)
    6ef0:	b240      	sxtb	r0, r0
    6ef2:	e78c      	b.n	6e0e <run_tasks+0xce>
                                        } else if(strncasecmp(btbuf_ptr,"AH=",3)==0) { // expect: number
    6ef4:	2203      	movs	r2, #3
    6ef6:	4939      	ldr	r1, [pc, #228]	; (6fdc <run_tasks+0x29c>)
    6ef8:	0028      	movs	r0, r5
    6efa:	47b0      	blx	r6
    6efc:	2800      	cmp	r0, #0
    6efe:	d107      	bne.n	6f10 <run_tasks+0x1d0>
                                            btbuf_ptr[6]=0;
    6f00:	2300      	movs	r3, #0
                                            char *ptr=&btbuf_ptr[3];
    6f02:	1ce8      	adds	r0, r5, #3
                                            btbuf_ptr[6]=0;
    6f04:	71ab      	strb	r3, [r5, #6]
                                            task_set_ah_batt(atoi(ptr));
    6f06:	4b22      	ldr	r3, [pc, #136]	; (6f90 <run_tasks+0x250>)
    6f08:	4798      	blx	r3
    scc_set_ah_batt(ah);
    6f0a:	4b35      	ldr	r3, [pc, #212]	; (6fe0 <run_tasks+0x2a0>)
    6f0c:	b240      	sxtb	r0, r0
    6f0e:	e77e      	b.n	6e0e <run_tasks+0xce>
                                        } else if(strncasecmp(btbuf_ptr,"RUNEQ",5)==0) {
    6f10:	2205      	movs	r2, #5
    6f12:	4934      	ldr	r1, [pc, #208]	; (6fe4 <run_tasks+0x2a4>)
    6f14:	0028      	movs	r0, r5
    6f16:	47b0      	blx	r6
    6f18:	2800      	cmp	r0, #0
    6f1a:	d000      	beq.n	6f1e <run_tasks+0x1de>
    6f1c:	e778      	b.n	6e10 <run_tasks+0xd0>
    scc_start_equalize();
    6f1e:	4b32      	ldr	r3, [pc, #200]	; (6fe8 <run_tasks+0x2a8>)
    6f20:	4798      	blx	r3
    6f22:	e775      	b.n	6e10 <run_tasks+0xd0>
                if(sysval.has_bluetooth) { bt_stop_bluetooth(); }         
    6f24:	34c1      	adds	r4, #193	; 0xc1
    6f26:	7823      	ldrb	r3, [r4, #0]
    6f28:	2b00      	cmp	r3, #0
    6f2a:	d001      	beq.n	6f30 <run_tasks+0x1f0>
    6f2c:	4b2f      	ldr	r3, [pc, #188]	; (6fec <run_tasks+0x2ac>)
    6f2e:	4798      	blx	r3
                sim_task_add(SIM_TASK_CREG,0,0); 
    6f30:	2200      	movs	r2, #0
    6f32:	2008      	movs	r0, #8
    6f34:	0011      	movs	r1, r2
    6f36:	47b0      	blx	r6
                uart_print(0,"---TASK_2G---\n\r");
    6f38:	492d      	ldr	r1, [pc, #180]	; (6ff0 <run_tasks+0x2b0>)
    6f3a:	2000      	movs	r0, #0
    6f3c:	47b8      	blx	r7
                message_len = sim_prepare_data_message(0,get_myid());
    6f3e:	4b2d      	ldr	r3, [pc, #180]	; (6ff4 <run_tasks+0x2b4>)
    6f40:	4798      	blx	r3
    6f42:	4b2d      	ldr	r3, [pc, #180]	; (6ff8 <run_tasks+0x2b8>)
    6f44:	0001      	movs	r1, r0
    6f46:	2000      	movs	r0, #0
    6f48:	4798      	blx	r3
                message_len = addto_data_message(message_len);        
    6f4a:	4b2c      	ldr	r3, [pc, #176]	; (6ffc <run_tasks+0x2bc>)
    6f4c:	4798      	blx	r3
                sim_task_add(SIM_TASK_START_2G,message_len,0);
    6f4e:	2200      	movs	r2, #0
    6f50:	b281      	uxth	r1, r0
    6f52:	2002      	movs	r0, #2
    6f54:	e7a1      	b.n	6e9a <run_tasks+0x15a>
    6f56:	46c0      	nop			; (mov r8, r8)
    6f58:	20000a58 	.word	0x20000a58
    6f5c:	20000b5e 	.word	0x20000b5e
    6f60:	0000a055 	.word	0x0000a055
    6f64:	00007b99 	.word	0x00007b99
    6f68:	0000a065 	.word	0x0000a065
    6f6c:	00006bed 	.word	0x00006bed
    6f70:	00006d0d 	.word	0x00006d0d
    6f74:	00000391 	.word	0x00000391
    6f78:	0000b943 	.word	0x0000b943
    6f7c:	0000b963 	.word	0x0000b963
    6f80:	00008a4d 	.word	0x00008a4d
    6f84:	0000b968 	.word	0x0000b968
    6f88:	00009fd7 	.word	0x00009fd7
    6f8c:	00009fe4 	.word	0x00009fe4
    6f90:	0000889d 	.word	0x0000889d
    6f94:	00004471 	.word	0x00004471
    6f98:	000002e9 	.word	0x000002e9
    6f9c:	00000345 	.word	0x00000345
    6fa0:	00009f13 	.word	0x00009f13
    6fa4:	0000b984 	.word	0x0000b984
    6fa8:	00006941 	.word	0x00006941
    6fac:	0000b995 	.word	0x0000b995
    6fb0:	000061e5 	.word	0x000061e5
    6fb4:	000063bd 	.word	0x000063bd
    6fb8:	000063cd 	.word	0x000063cd
    6fbc:	0000b9a7 	.word	0x0000b9a7
    6fc0:	0000b9d2 	.word	0x0000b9d2
    6fc4:	0000b9e4 	.word	0x0000b9e4
    6fc8:	00006955 	.word	0x00006955
    6fcc:	0000b96e 	.word	0x0000b96e
    6fd0:	00004499 	.word	0x00004499
    6fd4:	0000b974 	.word	0x0000b974
    6fd8:	000044c1 	.word	0x000044c1
    6fdc:	0000b97a 	.word	0x0000b97a
    6fe0:	000044e9 	.word	0x000044e9
    6fe4:	0000b97e 	.word	0x0000b97e
    6fe8:	00004511 	.word	0x00004511
    6fec:	0000053d 	.word	0x0000053d
    6ff0:	0000b9c2 	.word	0x0000b9c2
    6ff4:	00000c19 	.word	0x00000c19
    6ff8:	00006155 	.word	0x00006155
    6ffc:	000069d1 	.word	0x000069d1

00007000 <TC3_Handler>:
        NVIC_EnableIRQ(TC3_IRQn);
    }    
}

void TC3_Handler(void)
{
    7000:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if(TC3->COUNT16.INTFLAG.reg & TC_INTFLAG_MC(1)) {
    7002:	4b54      	ldr	r3, [pc, #336]	; (7154 <TC3_Handler+0x154>)
    7004:	7b9a      	ldrb	r2, [r3, #14]
    7006:	9301      	str	r3, [sp, #4]
    7008:	06d3      	lsls	r3, r2, #27
    700a:	d400      	bmi.n	700e <TC3_Handler+0xe>
    700c:	e096      	b.n	713c <TC3_Handler+0x13c>
        //Update MS Tick
        sysTime.ms++;
    700e:	4d52      	ldr	r5, [pc, #328]	; (7158 <TC3_Handler+0x158>)
    7010:	882b      	ldrh	r3, [r5, #0]
    7012:	3301      	adds	r3, #1
    7014:	802b      	strh	r3, [r5, #0]

//#if (MASTER_PCB_v32==0)
// FIXME: on v32 it does not seem to work in pin-interrupt (sim.c)
            // RI line going low:
            if(sim_is_on() && HAL_GPIO_SIM_RI_PIN_read()==0) {
    7016:	4b51      	ldr	r3, [pc, #324]	; (715c <TC3_Handler+0x15c>)
    7018:	4798      	blx	r3
    701a:	2800      	cmp	r0, #0
    701c:	d007      	beq.n	702e <TC3_Handler+0x2e>
HAL_GPIO_PIN(SIM_RI_PIN,A, 2)
    701e:	4b50      	ldr	r3, [pc, #320]	; (7160 <TC3_Handler+0x160>)
    7020:	6a1b      	ldr	r3, [r3, #32]
    7022:	075b      	lsls	r3, r3, #29
    7024:	d403      	bmi.n	702e <TC3_Handler+0x2e>
                //HAL_GPIO_LED_RED_toggle();
                // URC or SMS message coming in
                sysval.ringing=1;
    7026:	2201      	movs	r2, #1
    7028:	4b4e      	ldr	r3, [pc, #312]	; (7164 <TC3_Handler+0x164>)
    702a:	33bb      	adds	r3, #187	; 0xbb
    702c:	701a      	strb	r2, [r3, #0]
            }
//#endif
    
        if(!(sysTime.ms%100)){ // 1/10 second
    702e:	882c      	ldrh	r4, [r5, #0]
    7030:	4f4d      	ldr	r7, [pc, #308]	; (7168 <TC3_Handler+0x168>)
    7032:	2164      	movs	r1, #100	; 0x64
    7034:	0020      	movs	r0, r4
    7036:	47b8      	blx	r7
    7038:	b289      	uxth	r1, r1
    703a:	2900      	cmp	r1, #0
    703c:	d117      	bne.n	706e <TC3_Handler+0x6e>
            if(i2c_timeout>0) i2c_timeout--;
    703e:	4a4b      	ldr	r2, [pc, #300]	; (716c <TC3_Handler+0x16c>)
    7040:	7813      	ldrb	r3, [r2, #0]
    7042:	2b00      	cmp	r3, #0
    7044:	d003      	beq.n	704e <TC3_Handler+0x4e>
    7046:	7813      	ldrb	r3, [r2, #0]
    7048:	3b01      	subs	r3, #1
    704a:	b2db      	uxtb	r3, r3
    704c:	7013      	strb	r3, [r2, #0]
            if(sim_timeout>0) sim_timeout--;
    704e:	4a48      	ldr	r2, [pc, #288]	; (7170 <TC3_Handler+0x170>)
    7050:	7813      	ldrb	r3, [r2, #0]
    7052:	2b00      	cmp	r3, #0
    7054:	d003      	beq.n	705e <TC3_Handler+0x5e>
    7056:	7813      	ldrb	r3, [r2, #0]
    7058:	3b01      	subs	r3, #1
    705a:	b2db      	uxtb	r3, r3
    705c:	7013      	strb	r3, [r2, #0]
            if(oled_i2c_timeout>0) oled_i2c_timeout--;
    705e:	4a45      	ldr	r2, [pc, #276]	; (7174 <TC3_Handler+0x174>)
    7060:	7813      	ldrb	r3, [r2, #0]
    7062:	2b00      	cmp	r3, #0
    7064:	d003      	beq.n	706e <TC3_Handler+0x6e>
    7066:	7813      	ldrb	r3, [r2, #0]
    7068:	3b01      	subs	r3, #1
    706a:	b2db      	uxtb	r3, r3
    706c:	7013      	strb	r3, [r2, #0]
//#endif
*/
        }
    
        //Update Sec Tick
        if(sysTime.ms >= 1000) {
    706e:	4b42      	ldr	r3, [pc, #264]	; (7178 <TC3_Handler+0x178>)
    7070:	429c      	cmp	r4, r3
    7072:	d933      	bls.n	70dc <TC3_Handler+0xdc>
            sysTime.ms=0;
    7074:	2300      	movs	r3, #0
            sysTime.sec++;
    7076:	78ae      	ldrb	r6, [r5, #2]
            sysval.seconds++;
    7078:	4c3a      	ldr	r4, [pc, #232]	; (7164 <TC3_Handler+0x164>)
            sysTime.ms=0;
    707a:	802b      	strh	r3, [r5, #0]
            sysTime.sec++;
    707c:	3601      	adds	r6, #1
            sysval.seconds++;
    707e:	6823      	ldr	r3, [r4, #0]
            sysTime.sec++;
    7080:	b2f6      	uxtb	r6, r6
    7082:	70ae      	strb	r6, [r5, #2]
            sysval.seconds++;
    7084:	3301      	adds	r3, #1
    7086:	6023      	str	r3, [r4, #0]
            sysval.tasklist |= (1<<TASK_SECOND);
    7088:	89a3      	ldrh	r3, [r4, #12]
    
            if((sysTime.sec % 5)==0) {
    708a:	2105      	movs	r1, #5
            sysval.tasklist |= (1<<TASK_SECOND);
    708c:	9300      	str	r3, [sp, #0]
            if((sysTime.sec % 5)==0) {
    708e:	0030      	movs	r0, r6
    7090:	47b8      	blx	r7
    7092:	b2c9      	uxtb	r1, r1
    7094:	2900      	cmp	r1, #0
    7096:	d055      	beq.n	7144 <TC3_Handler+0x144>
            sysval.tasklist |= (1<<TASK_SECOND);
    7098:	2301      	movs	r3, #1
    709a:	9a00      	ldr	r2, [sp, #0]
    709c:	4313      	orrs	r3, r2
    709e:	81a3      	strh	r3, [r4, #12]
                sysval.tasklist |= (1<<TASK_5SECOND);
                sysval.watchdog++;
            }
            if((sysTime.sec % 2)==0) {
    70a0:	07f3      	lsls	r3, r6, #31
    70a2:	d403      	bmi.n	70ac <TC3_Handler+0xac>
                sysval.tasklist |= (1<<TASK_2SECOND);
    70a4:	2302      	movs	r3, #2
    70a6:	89a2      	ldrh	r2, [r4, #12]
    70a8:	4313      	orrs	r3, r2
    70aa:	81a3      	strh	r3, [r4, #12]
            }
            if((sysTime.sec % 3)==0) {
    70ac:	2103      	movs	r1, #3
    70ae:	0030      	movs	r0, r6
    70b0:	47b8      	blx	r7
    70b2:	b2c9      	uxtb	r1, r1
    70b4:	2900      	cmp	r1, #0
    70b6:	d103      	bne.n	70c0 <TC3_Handler+0xc0>
                sysval.tasklist |= (1<<TASK_3SECOND);
    70b8:	2304      	movs	r3, #4
    70ba:	89a2      	ldrh	r2, [r4, #12]
    70bc:	4313      	orrs	r3, r2
    70be:	81a3      	strh	r3, [r4, #12]
            }           
            
            sysval.scc_tasklist |= 0x80;
    70c0:	2380      	movs	r3, #128	; 0x80
    70c2:	7ba2      	ldrb	r2, [r4, #14]
    70c4:	425b      	negs	r3, r3
    70c6:	431a      	orrs	r2, r3
    70c8:	73a2      	strb	r2, [r4, #14]
            sysval.sim_tasklist |= 0x80;
    70ca:	7ca2      	ldrb	r2, [r4, #18]
    70cc:	431a      	orrs	r2, r3
    70ce:	74a2      	strb	r2, [r4, #18]
            sysval.cmd_tasklist |= 0x80;
    70d0:	7ce2      	ldrb	r2, [r4, #19]
    70d2:	431a      	orrs	r2, r3
    70d4:	74e2      	strb	r2, [r4, #19]
            sysval.mod_tasklist |= 0x80;
    70d6:	7c22      	ldrb	r2, [r4, #16]
    70d8:	4313      	orrs	r3, r2
    70da:	7423      	strb	r3, [r4, #16]
        }

        //Update minutes
        if(sysTime.sec>=60){
    70dc:	78ab      	ldrb	r3, [r5, #2]
    70de:	2b3b      	cmp	r3, #59	; 0x3b
    70e0:	d92c      	bls.n	713c <TC3_Handler+0x13c>
            sysTime.sec=0;
    70e2:	2300      	movs	r3, #0
            sysval.minutes++;
    70e4:	4c1f      	ldr	r4, [pc, #124]	; (7164 <TC3_Handler+0x164>)
            sysTime.sec=0;
    70e6:	70ab      	strb	r3, [r5, #2]
            sysval.minutes++;
    70e8:	8925      	ldrh	r5, [r4, #8]
            sysval.tasklist |= (1<<TASK_MINUTE);
    
            if((sysval.minutes % 60)==0) {
    70ea:	213c      	movs	r1, #60	; 0x3c
            sysval.minutes++;
    70ec:	3501      	adds	r5, #1
    70ee:	b2ad      	uxth	r5, r5
    70f0:	8125      	strh	r5, [r4, #8]
            if((sysval.minutes % 60)==0) {
    70f2:	0028      	movs	r0, r5
    70f4:	47b8      	blx	r7
    70f6:	b289      	uxth	r1, r1
            sysval.tasklist |= (1<<TASK_MINUTE);
    70f8:	89a6      	ldrh	r6, [r4, #12]
    70fa:	2310      	movs	r3, #16
            if((sysval.minutes % 60)==0) {
    70fc:	2900      	cmp	r1, #0
    70fe:	d100      	bne.n	7102 <TC3_Handler+0x102>
                sysval.tasklist |= (1<<TASK_HOUR);
    7100:	2330      	movs	r3, #48	; 0x30
    7102:	431e      	orrs	r6, r3
    7104:	81a6      	strh	r6, [r4, #12]
            }
            if((sysval.minutes % sysval.interval2G)==0) {
    7106:	8ae1      	ldrh	r1, [r4, #22]
    7108:	0028      	movs	r0, r5
    710a:	47b8      	blx	r7
    710c:	b289      	uxth	r1, r1
    710e:	2900      	cmp	r1, #0
    7110:	d104      	bne.n	711c <TC3_Handler+0x11c>
                sysval.tasklist |= (1<<TASK_2G);
    7112:	2380      	movs	r3, #128	; 0x80
    7114:	89a2      	ldrh	r2, [r4, #12]
    7116:	005b      	lsls	r3, r3, #1
    7118:	4313      	orrs	r3, r2
    711a:	81a3      	strh	r3, [r4, #12]
            }
            if(sysval.minutes >= MINUTES_PER_DAY) {
    711c:	4b17      	ldr	r3, [pc, #92]	; (717c <TC3_Handler+0x17c>)
    711e:	429d      	cmp	r5, r3
    7120:	d905      	bls.n	712e <TC3_Handler+0x12e>
                sysval.minutes=0;
    7122:	2300      	movs	r3, #0
                sysval.tasklist |= (1<<TASK_DAY);
    7124:	89a2      	ldrh	r2, [r4, #12]
                sysval.minutes=0;
    7126:	8123      	strh	r3, [r4, #8]
                sysval.tasklist |= (1<<TASK_DAY);
    7128:	3340      	adds	r3, #64	; 0x40
    712a:	4313      	orrs	r3, r2
    712c:	81a3      	strh	r3, [r4, #12]
            }
            // let the SIM poll every minute anyways in case the ring signal is missed
            if(sim_is_on() ) {
    712e:	4b0b      	ldr	r3, [pc, #44]	; (715c <TC3_Handler+0x15c>)
    7130:	4798      	blx	r3
    7132:	2800      	cmp	r0, #0
    7134:	d002      	beq.n	713c <TC3_Handler+0x13c>
                sysval.ringing=1;
    7136:	2301      	movs	r3, #1
    7138:	34bb      	adds	r4, #187	; 0xbb
    713a:	7023      	strb	r3, [r4, #0]
            }
        }
    }
    TC3->COUNT16.INTFLAG.reg = TC_INTFLAG_MC(1);
    713c:	2310      	movs	r3, #16
    713e:	9a01      	ldr	r2, [sp, #4]
    7140:	7393      	strb	r3, [r2, #14]
}
    7142:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
                sysval.tasklist |= (1<<TASK_5SECOND);
    7144:	2309      	movs	r3, #9
    7146:	9a00      	ldr	r2, [sp, #0]
    7148:	4313      	orrs	r3, r2
    714a:	81a3      	strh	r3, [r4, #12]
                sysval.watchdog++;
    714c:	7d23      	ldrb	r3, [r4, #20]
    714e:	3301      	adds	r3, #1
    7150:	7523      	strb	r3, [r4, #20]
    7152:	e7a5      	b.n	70a0 <TC3_Handler+0xa0>
    7154:	42002c00 	.word	0x42002c00
    7158:	20000c10 	.word	0x20000c10
    715c:	000063bd 	.word	0x000063bd
    7160:	41004400 	.word	0x41004400
    7164:	20000a58 	.word	0x20000a58
    7168:	00008095 	.word	0x00008095
    716c:	20000d0c 	.word	0x20000d0c
    7170:	20000d0b 	.word	0x20000d0b
    7174:	20000d0d 	.word	0x20000d0d
    7178:	000003e7 	.word	0x000003e7
    717c:	0000059f 	.word	0x0000059f

00007180 <tasks_init>:

void tasks_init(int8_t onoff)
{
    7180:	b570      	push	{r4, r5, r6, lr}
    i2c_timeout=0;
    7182:	2400      	movs	r4, #0
    7184:	4b29      	ldr	r3, [pc, #164]	; (722c <tasks_init+0xac>)
{
    7186:	0005      	movs	r5, r0
    i2c_timeout=0;
    7188:	701c      	strb	r4, [r3, #0]
    sim_timeout=0;
    718a:	4b29      	ldr	r3, [pc, #164]	; (7230 <tasks_init+0xb0>)

    memset((void *)&task_queue,0,sizeof(task_queue_t));
    718c:	22b1      	movs	r2, #177	; 0xb1
    sim_timeout=0;
    718e:	701c      	strb	r4, [r3, #0]
    memset((void *)&task_queue,0,sizeof(task_queue_t));
    7190:	0021      	movs	r1, r4
    7192:	4b28      	ldr	r3, [pc, #160]	; (7234 <tasks_init+0xb4>)
    7194:	4828      	ldr	r0, [pc, #160]	; (7238 <tasks_init+0xb8>)
    7196:	4798      	blx	r3
    7198:	4b28      	ldr	r3, [pc, #160]	; (723c <tasks_init+0xbc>)
    if(onoff==0) {
    719a:	42a5      	cmp	r5, r4
    719c:	d12b      	bne.n	71f6 <tasks_init+0x76>
        PM->APBCMASK.reg &= ~PM_APBCMASK_TC3;
    719e:	6a1a      	ldr	r2, [r3, #32]
    71a0:	4927      	ldr	r1, [pc, #156]	; (7240 <tasks_init+0xc0>)
    71a2:	400a      	ands	r2, r1
    71a4:	621a      	str	r2, [r3, #32]

    timer3_init(onoff);
#if (MASTER_PCB_v32==0)
    HAL_GPIO_LED_RED_out();
#endif
    flash_read_eeprom_shs(&eeprom_shs);
    71a6:	4c27      	ldr	r4, [pc, #156]	; (7244 <tasks_init+0xc4>)
    71a8:	4b27      	ldr	r3, [pc, #156]	; (7248 <tasks_init+0xc8>)
    71aa:	0020      	movs	r0, r4
    71ac:	4798      	blx	r3
    if (eeprom_shs.valid == false) {
    71ae:	7823      	ldrb	r3, [r4, #0]
    71b0:	2b00      	cmp	r3, #0
    71b2:	d10a      	bne.n	71ca <tasks_init+0x4a>
        eeprom_shs.interval2G   = 20;
    71b4:	2214      	movs	r2, #20
        eeprom_shs.secondsMeter = 0UL;
    71b6:	6063      	str	r3, [r4, #4]
        eeprom_shs.Ws_in        = 0UL;
    71b8:	60a3      	str	r3, [r4, #8]
        eeprom_shs.Ws_out       = 0UL;
    71ba:	60e3      	str	r3, [r4, #12]
        eeprom_shs.Ws_out_ac    = 0UL;
    71bc:	6123      	str	r3, [r4, #16]
        eeprom_shs.valid = true;        
    71be:	3301      	adds	r3, #1
    71c0:	7023      	strb	r3, [r4, #0]
        flash_write_eeprom_shs(&eeprom_shs);
    71c2:	0020      	movs	r0, r4
    71c4:	4b21      	ldr	r3, [pc, #132]	; (724c <tasks_init+0xcc>)
        eeprom_shs.interval2G   = 20;
    71c6:	8062      	strh	r2, [r4, #2]
        flash_write_eeprom_shs(&eeprom_shs);
    71c8:	4798      	blx	r3
        
    }
    sysval.seconds     = eeprom_shs.secondsMeter;
    71ca:	4b21      	ldr	r3, [pc, #132]	; (7250 <tasks_init+0xd0>)
    71cc:	6862      	ldr	r2, [r4, #4]
    sysval.Ws_in       = eeprom_shs.Ws_in;
    71ce:	68a1      	ldr	r1, [r4, #8]
    sysval.seconds     = eeprom_shs.secondsMeter;
    71d0:	601a      	str	r2, [r3, #0]
    sysval.Ws_in       = eeprom_shs.Ws_in;
    71d2:	001a      	movs	r2, r3
    71d4:	32a0      	adds	r2, #160	; 0xa0
    71d6:	6011      	str	r1, [r2, #0]
    sysval.Ws_out      = eeprom_shs.Ws_out;
    71d8:	001a      	movs	r2, r3
    71da:	68e1      	ldr	r1, [r4, #12]
    71dc:	32a4      	adds	r2, #164	; 0xa4
    71de:	6011      	str	r1, [r2, #0]
    sysval.Ws_out_ac   = eeprom_shs.Ws_out_ac;
    71e0:	001a      	movs	r2, r3
    71e2:	6921      	ldr	r1, [r4, #16]
    71e4:	32a8      	adds	r2, #168	; 0xa8
    71e6:	6011      	str	r1, [r2, #0]
    sysval.Door_open   = 0;
    71e8:	001a      	movs	r2, r3
    71ea:	2100      	movs	r1, #0
    71ec:	32ba      	adds	r2, #186	; 0xba
    71ee:	7011      	strb	r1, [r2, #0]
    sysval.interval2G  = eeprom_shs.interval2G;
    71f0:	8862      	ldrh	r2, [r4, #2]
    71f2:	82da      	strh	r2, [r3, #22]
}
    71f4:	bd70      	pop	{r4, r5, r6, pc}
        PM->APBCMASK.reg |= PM_APBCMASK_TC3;
    71f6:	2280      	movs	r2, #128	; 0x80
    71f8:	6a19      	ldr	r1, [r3, #32]
    71fa:	0112      	lsls	r2, r2, #4
    71fc:	430a      	orrs	r2, r1
    71fe:	621a      	str	r2, [r3, #32]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(TC3_GCLK_ID) |
    7200:	4a14      	ldr	r2, [pc, #80]	; (7254 <tasks_init+0xd4>)
    7202:	4b15      	ldr	r3, [pc, #84]	; (7258 <tasks_init+0xd8>)
    7204:	805a      	strh	r2, [r3, #2]
        TC3->COUNT16.CTRLA.reg = TC_CTRLA_MODE_COUNT16 | TC_CTRLA_WAVEGEN_MFRQ |
    7206:	4b15      	ldr	r3, [pc, #84]	; (725c <tasks_init+0xdc>)
    7208:	4a15      	ldr	r2, [pc, #84]	; (7260 <tasks_init+0xe0>)
    720a:	801a      	strh	r2, [r3, #0]
        TC3->COUNT16.CC[0].reg = 125; // 1kHz
    720c:	227d      	movs	r2, #125	; 0x7d
        TC3->COUNT16.COUNT.reg = 0;
    720e:	821c      	strh	r4, [r3, #16]
        TC3->COUNT16.CC[0].reg = 125; // 1kHz
    7210:	831a      	strh	r2, [r3, #24]
        TC3->COUNT16.COUNT.reg = 0;
    7212:	821c      	strh	r4, [r3, #16]
        TC3->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    7214:	8819      	ldrh	r1, [r3, #0]
    7216:	3a7b      	subs	r2, #123	; 0x7b
    7218:	430a      	orrs	r2, r1
    721a:	801a      	strh	r2, [r3, #0]
        TC3->COUNT16.INTENSET.reg = TC_INTENSET_MC(1);
    721c:	2210      	movs	r2, #16
    721e:	735a      	strb	r2, [r3, #13]
    7220:	2280      	movs	r2, #128	; 0x80
    7222:	4b10      	ldr	r3, [pc, #64]	; (7264 <tasks_init+0xe4>)
    7224:	0252      	lsls	r2, r2, #9
    7226:	601a      	str	r2, [r3, #0]
    7228:	e7bd      	b.n	71a6 <tasks_init+0x26>
    722a:	46c0      	nop			; (mov r8, r8)
    722c:	20000d0c 	.word	0x20000d0c
    7230:	20000d0b 	.word	0x20000d0b
    7234:	00008957 	.word	0x00008957
    7238:	20000b5e 	.word	0x20000b5e
    723c:	40000400 	.word	0x40000400
    7240:	fffff7ff 	.word	0xfffff7ff
    7244:	20000890 	.word	0x20000890
    7248:	00001019 	.word	0x00001019
    724c:	000011c9 	.word	0x000011c9
    7250:	20000a58 	.word	0x20000a58
    7254:	00004014 	.word	0x00004014
    7258:	40000c00 	.word	0x40000c00
    725c:	42002c00 	.word	0x42002c00
    7260:	00002520 	.word	0x00002520
    7264:	e000e100 	.word	0xe000e100

00007268 <tasks_eeprom_set_interval2G>:

void tasks_eeprom_set_interval2G(uint16_t t)
{
    7268:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    726a:	b672      	cpsid	i
    __disable_irq();
    if(t>MINUTES_PER_DAY) {
    726c:	22b4      	movs	r2, #180	; 0xb4
    726e:	4b07      	ldr	r3, [pc, #28]	; (728c <tasks_eeprom_set_interval2G+0x24>)
    7270:	00d2      	lsls	r2, r2, #3
    7272:	4290      	cmp	r0, r2
    7274:	d907      	bls.n	7286 <tasks_eeprom_set_interval2G+0x1e>
        sysval.interval2G=MINUTES_PER_DAY;
    7276:	82da      	strh	r2, [r3, #22]
  __ASM volatile ("cpsie i" : : : "memory");
    7278:	b662      	cpsie	i
    } else {
        sysval.interval2G=t;
    }
    __enable_irq();
    eeprom_shs.interval2G = sysval.interval2G;    
    727a:	4805      	ldr	r0, [pc, #20]	; (7290 <tasks_eeprom_set_interval2G+0x28>)
    727c:	8adb      	ldrh	r3, [r3, #22]
    727e:	8043      	strh	r3, [r0, #2]
    flash_write_eeprom_shs(&eeprom_shs);
    7280:	4b04      	ldr	r3, [pc, #16]	; (7294 <tasks_eeprom_set_interval2G+0x2c>)
    7282:	4798      	blx	r3
}
    7284:	bd10      	pop	{r4, pc}
        sysval.interval2G=t;
    7286:	82d8      	strh	r0, [r3, #22]
    7288:	e7f6      	b.n	7278 <tasks_eeprom_set_interval2G+0x10>
    728a:	46c0      	nop			; (mov r8, r8)
    728c:	20000a58 	.word	0x20000a58
    7290:	20000890 	.word	0x20000890
    7294:	000011c9 	.word	0x000011c9

00007298 <resetTC2>:

#define WAIT_TC16_REGS_SYNC(x) while(x->COUNT16.STATUS.bit.SYNCBUSY);
void resetTC2(void)
{
	// Disable TCx
	TC2->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    7298:	2102      	movs	r1, #2
    729a:	4b08      	ldr	r3, [pc, #32]	; (72bc <resetTC2+0x24>)
    729c:	881a      	ldrh	r2, [r3, #0]
    729e:	438a      	bics	r2, r1
    72a0:	801a      	strh	r2, [r3, #0]
	WAIT_TC16_REGS_SYNC(TC2);
    72a2:	7bda      	ldrb	r2, [r3, #15]
    72a4:	09d2      	lsrs	r2, r2, #7
    72a6:	d1fc      	bne.n	72a2 <resetTC2+0xa>
	// Reset TCx
	TC2->COUNT16.CTRLA.reg = TC_CTRLA_SWRST;
    72a8:	3201      	adds	r2, #1
    72aa:	801a      	strh	r2, [r3, #0]
	WAIT_TC16_REGS_SYNC(TC2);
    72ac:	7bda      	ldrb	r2, [r3, #15]
    72ae:	09d2      	lsrs	r2, r2, #7
    72b0:	d1fc      	bne.n	72ac <resetTC2+0x14>
	while (TC2->COUNT16.CTRLA.bit.SWRST);
    72b2:	881a      	ldrh	r2, [r3, #0]
    72b4:	07d2      	lsls	r2, r2, #31
    72b6:	d4fc      	bmi.n	72b2 <resetTC2+0x1a>
}
    72b8:	4770      	bx	lr
    72ba:	46c0      	nop			; (mov r8, r8)
    72bc:	42002800 	.word	0x42002800

000072c0 <noTone>:

void noTone(void)
{
    72c0:	b510      	push	{r4, lr}
	resetTC2();
    72c2:	4b05      	ldr	r3, [pc, #20]	; (72d8 <noTone+0x18>)
    72c4:	4798      	blx	r3
HAL_GPIO_PIN(PIEZO_PIN, A, 17)
    72c6:	2280      	movs	r2, #128	; 0x80
    72c8:	4b04      	ldr	r3, [pc, #16]	; (72dc <noTone+0x1c>)
    72ca:	0292      	lsls	r2, r2, #10
    72cc:	615a      	str	r2, [r3, #20]
	HAL_GPIO_PIEZO_PIN_clr();
	toneIsActive = false;
    72ce:	2200      	movs	r2, #0
    72d0:	4b03      	ldr	r3, [pc, #12]	; (72e0 <noTone+0x20>)
    72d2:	701a      	strb	r2, [r3, #0]
}
    72d4:	bd10      	pop	{r4, pc}
    72d6:	46c0      	nop			; (mov r8, r8)
    72d8:	00007299 	.word	0x00007299
    72dc:	41004400 	.word	0x41004400
    72e0:	200008a4 	.word	0x200008a4

000072e4 <tone.part.0>:

void tone (uint32_t frequency, uint32_t duration)
    72e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    72e6:	2280      	movs	r2, #128	; 0x80
    72e8:	000f      	movs	r7, r1
    72ea:	492f      	ldr	r1, [pc, #188]	; (73a8 <tone.part.0+0xc4>)
    72ec:	0212      	lsls	r2, r2, #8
    72ee:	67ca      	str	r2, [r1, #124]	; 0x7c

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    72f0:	21c0      	movs	r1, #192	; 0xc0
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    72f2:	4b2e      	ldr	r3, [pc, #184]	; (73ac <tone.part.0+0xc8>)
  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    72f4:	0049      	lsls	r1, r1, #1
    72f6:	505a      	str	r2, [r3, r1]
	if(frequency<50) return;
	
	NVIC_DisableIRQ(TC2_IRQn);
	NVIC_ClearPendingIRQ(TC2_IRQn);
	
	if (toneIsActive) noTone();
    72f8:	4a2d      	ldr	r2, [pc, #180]	; (73b0 <tone.part.0+0xcc>)
void tone (uint32_t frequency, uint32_t duration)
    72fa:	0006      	movs	r6, r0
	if (toneIsActive) noTone();
    72fc:	7812      	ldrb	r2, [r2, #0]
    72fe:	9301      	str	r3, [sp, #4]
    7300:	2a00      	cmp	r2, #0
    7302:	d001      	beq.n	7308 <tone.part.0+0x24>
    7304:	4b2b      	ldr	r3, [pc, #172]	; (73b4 <tone.part.0+0xd0>)
    7306:	4798      	blx	r3

	ccValue = toneMaxFrequency / frequency - 1;
    7308:	4b2b      	ldr	r3, [pc, #172]	; (73b8 <tone.part.0+0xd4>)
    730a:	0031      	movs	r1, r6
    730c:	482b      	ldr	r0, [pc, #172]	; (73bc <tone.part.0+0xd8>)
    730e:	4798      	blx	r3
	prescalerConfigBits = TC_CTRLA_PRESCALER_DIV1;
	uint8_t i = 0;
	
	while(ccValue > 0xffff) {
    7310:	4a2b      	ldr	r2, [pc, #172]	; (73c0 <tone.part.0+0xdc>)
	uint8_t i = 0;
    7312:	2300      	movs	r3, #0
	while(ccValue > 0xffff) {
    7314:	4694      	mov	ip, r2
		ccValue = toneMaxFrequency / frequency / (2<<i) - 1;
		i++;
		if(i == 4 || i == 6 || i == 8) //DIV32 DIV128 and DIV512 are not available
    7316:	2504      	movs	r5, #4
	ccValue = toneMaxFrequency / frequency - 1;
    7318:	1e44      	subs	r4, r0, #1
	while(ccValue > 0xffff) {
    731a:	4564      	cmp	r4, ip
    731c:	d831      	bhi.n	7382 <tone.part.0+0x9e>
		i++;
	}	
	switch(i-1)	{
    731e:	3b01      	subs	r3, #1
    7320:	2500      	movs	r5, #0
    7322:	2b09      	cmp	r3, #9
    7324:	d802      	bhi.n	732c <tone.part.0+0x48>
    7326:	4a27      	ldr	r2, [pc, #156]	; (73c4 <tone.part.0+0xe0>)
    7328:	005b      	lsls	r3, r3, #1
    732a:	5a9d      	ldrh	r5, [r3, r2]
		case 5: prescalerConfigBits = TC_CTRLA_PRESCALER_DIV64; break;		
		case 7: prescalerConfigBits = TC_CTRLA_PRESCALER_DIV256; break;		
		case 9: prescalerConfigBits = TC_CTRLA_PRESCALER_DIV1024; break;		
		default: break;
	}
    tone_toggleCount = (duration > 0 ? frequency * duration * 2 / 1000UL : -1);
    732c:	2f00      	cmp	r7, #0
    732e:	d038      	beq.n	73a2 <tone.part.0+0xbe>
    7330:	21fa      	movs	r1, #250	; 0xfa
    7332:	0078      	lsls	r0, r7, #1
    7334:	4370      	muls	r0, r6
    7336:	0089      	lsls	r1, r1, #2
    7338:	4b1f      	ldr	r3, [pc, #124]	; (73b8 <tone.part.0+0xd4>)
    733a:	4798      	blx	r3
    733c:	0002      	movs	r2, r0
    733e:	2300      	movs	r3, #0
    7340:	4921      	ldr	r1, [pc, #132]	; (73c8 <tone.part.0+0xe4>)
    7342:	600a      	str	r2, [r1, #0]
    7344:	604b      	str	r3, [r1, #4]
    resetTC2();
    7346:	4b21      	ldr	r3, [pc, #132]	; (73cc <tone.part.0+0xe8>)
    7348:	4798      	blx	r3
	
	uint16_t tmpReg = 0;
	tmpReg |= TC_CTRLA_MODE_COUNT16;  // Set Timer counter Mode to 16 bits
	tmpReg |= TC_CTRLA_WAVEGEN_MFRQ;  // Set TONE_TC mode as match frequency
	tmpReg |= prescalerConfigBits;
	TC2->COUNT16.CTRLA.reg |= tmpReg;
    734a:	2220      	movs	r2, #32
    734c:	4b20      	ldr	r3, [pc, #128]	; (73d0 <tone.part.0+0xec>)
    734e:	8819      	ldrh	r1, [r3, #0]
    7350:	430a      	orrs	r2, r1
    7352:	4315      	orrs	r5, r2
    7354:	801d      	strh	r5, [r3, #0]
	WAIT_TC16_REGS_SYNC(TC2);
    7356:	7bda      	ldrb	r2, [r3, #15]
    7358:	09d2      	lsrs	r2, r2, #7
    735a:	d1fc      	bne.n	7356 <tone.part.0+0x72>
	TC2->COUNT16.CC[0].reg = (uint16_t) ccValue;
    735c:	b2a4      	uxth	r4, r4
    735e:	831c      	strh	r4, [r3, #24]
	WAIT_TC16_REGS_SYNC(TC2);
    7360:	7bda      	ldrb	r2, [r3, #15]
    7362:	09d2      	lsrs	r2, r2, #7
    7364:	d1fc      	bne.n	7360 <tone.part.0+0x7c>
	TC2->COUNT16.INTENSET.reg = TC_INTENSET_MC(1);
    7366:	3210      	adds	r2, #16
    7368:	735a      	strb	r2, [r3, #13]
    TC2->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    736a:	8819      	ldrh	r1, [r3, #0]
    736c:	3a0e      	subs	r2, #14
    736e:	430a      	orrs	r2, r1
    7370:	801a      	strh	r2, [r3, #0]
    WAIT_TC16_REGS_SYNC(TC2);
    7372:	7bda      	ldrb	r2, [r3, #15]
    7374:	09d2      	lsrs	r2, r2, #7
    7376:	d1fc      	bne.n	7372 <tone.part.0+0x8e>
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    7378:	2380      	movs	r3, #128	; 0x80
    737a:	9a01      	ldr	r2, [sp, #4]
    737c:	021b      	lsls	r3, r3, #8
    737e:	6013      	str	r3, [r2, #0]
	NVIC_EnableIRQ(TC2_IRQn);	
}
    7380:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		ccValue = toneMaxFrequency / frequency / (2<<i) - 1;
    7382:	0004      	movs	r4, r0
		if(i == 4 || i == 6 || i == 8) //DIV32 DIV128 and DIV512 are not available
    7384:	0019      	movs	r1, r3
		ccValue = toneMaxFrequency / frequency / (2<<i) - 1;
    7386:	1c5a      	adds	r2, r3, #1
    7388:	40d4      	lsrs	r4, r2
		if(i == 4 || i == 6 || i == 8) //DIV32 DIV128 and DIV512 are not available
    738a:	43a9      	bics	r1, r5
    738c:	b2c9      	uxtb	r1, r1
		ccValue = toneMaxFrequency / frequency / (2<<i) - 1;
    738e:	3c01      	subs	r4, #1
		if(i == 4 || i == 6 || i == 8) //DIV32 DIV128 and DIV512 are not available
    7390:	2903      	cmp	r1, #3
    7392:	d002      	beq.n	739a <tone.part.0+0xb6>
		i++;
    7394:	b2d2      	uxtb	r2, r2
		if(i == 4 || i == 6 || i == 8) //DIV32 DIV128 and DIV512 are not available
    7396:	2a06      	cmp	r2, #6
    7398:	d101      	bne.n	739e <tone.part.0+0xba>
		i++;
    739a:	3302      	adds	r3, #2
    739c:	b2da      	uxtb	r2, r3
void tone (uint32_t frequency, uint32_t duration)
    739e:	0013      	movs	r3, r2
    73a0:	e7bb      	b.n	731a <tone.part.0+0x36>
    tone_toggleCount = (duration > 0 ? frequency * duration * 2 / 1000UL : -1);
    73a2:	2001      	movs	r0, #1
    73a4:	4240      	negs	r0, r0
    73a6:	e7c9      	b.n	733c <tone.part.0+0x58>
    73a8:	e000e104 	.word	0xe000e104
    73ac:	e000e100 	.word	0xe000e100
    73b0:	200008a4 	.word	0x200008a4
    73b4:	000072c1 	.word	0x000072c1
    73b8:	00007f89 	.word	0x00007f89
    73bc:	003d0900 	.word	0x003d0900
    73c0:	0000ffff 	.word	0x0000ffff
    73c4:	0000b9f6 	.word	0x0000b9f6
    73c8:	20000d10 	.word	0x20000d10
    73cc:	00007299 	.word	0x00007299
    73d0:	42002800 	.word	0x42002800

000073d4 <tone>:
{
    73d4:	b510      	push	{r4, lr}
	if(frequency<50) return;
    73d6:	2831      	cmp	r0, #49	; 0x31
    73d8:	d901      	bls.n	73de <tone+0xa>
    73da:	4b01      	ldr	r3, [pc, #4]	; (73e0 <tone+0xc>)
    73dc:	4798      	blx	r3
}
    73de:	bd10      	pop	{r4, pc}
    73e0:	000072e5 	.word	0x000072e5

000073e4 <play_nof_tones>:

void play_nof_tones(int16_t nof_tones)
{
    73e4:	b570      	push	{r4, r5, r6, lr}
    73e6:	26dc      	movs	r6, #220	; 0xdc
    73e8:	0005      	movs	r5, r0
	for (int16_t n = 0; n < nof_tones; n++) {
    73ea:	2400      	movs	r4, #0
    73ec:	0076      	lsls	r6, r6, #1
    73ee:	42ac      	cmp	r4, r5
    73f0:	db00      	blt.n	73f4 <play_nof_tones+0x10>
		int pauseBetweenNotes = noteDuration * 1.30;
		delay_ms(pauseBetweenNotes);
		// stop the tone playing:
		noTone();
	}
}
    73f2:	bd70      	pop	{r4, r5, r6, pc}
    73f4:	21fa      	movs	r1, #250	; 0xfa
    73f6:	0030      	movs	r0, r6
    73f8:	4b05      	ldr	r3, [pc, #20]	; (7410 <play_nof_tones+0x2c>)
    73fa:	4798      	blx	r3
		delay_ms(pauseBetweenNotes);
    73fc:	2046      	movs	r0, #70	; 0x46
    73fe:	4b05      	ldr	r3, [pc, #20]	; (7414 <play_nof_tones+0x30>)
    7400:	30ff      	adds	r0, #255	; 0xff
    7402:	4798      	blx	r3
    7404:	3401      	adds	r4, #1
		noTone();
    7406:	4b04      	ldr	r3, [pc, #16]	; (7418 <play_nof_tones+0x34>)
    7408:	4798      	blx	r3
    740a:	b224      	sxth	r4, r4
    740c:	e7ef      	b.n	73ee <play_nof_tones+0xa>
    740e:	46c0      	nop			; (mov r8, r8)
    7410:	000072e5 	.word	0x000072e5
    7414:	00007c05 	.word	0x00007c05
    7418:	000072c1 	.word	0x000072c1

0000741c <play_song_success>:
void play_song_success(void)
{
    741c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int thisNote = 0; thisNote < LEN_melody_success; thisNote++) {

		// to calculate the note duration, take one second
		// divided by the note type.
		//e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
		int noteDuration = 1000 / melody_success[thisNote].duration;
    741e:	27fa      	movs	r7, #250	; 0xfa
{
    7420:	2400      	movs	r4, #0
		int noteDuration = 1000 / melody_success[thisNote].duration;
    7422:	00bf      	lsls	r7, r7, #2
    7424:	4e0d      	ldr	r6, [pc, #52]	; (745c <play_song_success+0x40>)
    7426:	0038      	movs	r0, r7
    7428:	1933      	adds	r3, r6, r4
    742a:	6859      	ldr	r1, [r3, #4]
    742c:	4b0c      	ldr	r3, [pc, #48]	; (7460 <play_song_success+0x44>)
    742e:	4798      	blx	r3
    7430:	0005      	movs	r5, r0
		tone(melody_success[thisNote].tone, noteDuration);
    7432:	0001      	movs	r1, r0
    7434:	4b0b      	ldr	r3, [pc, #44]	; (7464 <play_song_success+0x48>)
    7436:	59a0      	ldr	r0, [r4, r6]
    7438:	4798      	blx	r3

		// to distinguish the notes, set a minimum time between them.
		// the note's duration + 30% seems to work well:
		int pauseBetweenNotes = noteDuration * 1.30;
    743a:	4b0b      	ldr	r3, [pc, #44]	; (7468 <play_song_success+0x4c>)
    743c:	0028      	movs	r0, r5
    743e:	4798      	blx	r3
    7440:	4a0a      	ldr	r2, [pc, #40]	; (746c <play_song_success+0x50>)
    7442:	4b0b      	ldr	r3, [pc, #44]	; (7470 <play_song_success+0x54>)
    7444:	4d0b      	ldr	r5, [pc, #44]	; (7474 <play_song_success+0x58>)
    7446:	47a8      	blx	r5
    7448:	4b0b      	ldr	r3, [pc, #44]	; (7478 <play_song_success+0x5c>)
    744a:	4798      	blx	r3
		delay_ms(pauseBetweenNotes);
    744c:	4b0b      	ldr	r3, [pc, #44]	; (747c <play_song_success+0x60>)
    744e:	4798      	blx	r3
    7450:	3408      	adds	r4, #8
		// stop the tone playing:
		noTone();
    7452:	4b0b      	ldr	r3, [pc, #44]	; (7480 <play_song_success+0x64>)
    7454:	4798      	blx	r3
	for (int thisNote = 0; thisNote < LEN_melody_success; thisNote++) {
    7456:	2c38      	cmp	r4, #56	; 0x38
    7458:	d1e4      	bne.n	7424 <play_song_success+0x8>
	}
}
    745a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    745c:	2000008c 	.word	0x2000008c
    7460:	0000809d 	.word	0x0000809d
    7464:	000073d5 	.word	0x000073d5
    7468:	000087dd 	.word	0x000087dd
    746c:	cccccccd 	.word	0xcccccccd
    7470:	3ff4cccc 	.word	0x3ff4cccc
    7474:	00008275 	.word	0x00008275
    7478:	00008775 	.word	0x00008775
    747c:	00007c05 	.word	0x00007c05
    7480:	000072c1 	.word	0x000072c1

00007484 <play_song_expired>:
void play_song_expired(void)
{
    7484:	b570      	push	{r4, r5, r6, lr}
    7486:	2400      	movs	r4, #0
	for (int thisNote = 0; thisNote < LEN_melody_expired; thisNote++) {
		int noteDuration = 1000 / melody_expired[thisNote].duration;
    7488:	4d0e      	ldr	r5, [pc, #56]	; (74c4 <play_song_expired+0x40>)
    748a:	3538      	adds	r5, #56	; 0x38
    748c:	20fa      	movs	r0, #250	; 0xfa
    748e:	192b      	adds	r3, r5, r4
    7490:	6859      	ldr	r1, [r3, #4]
    7492:	0080      	lsls	r0, r0, #2
    7494:	4b0c      	ldr	r3, [pc, #48]	; (74c8 <play_song_expired+0x44>)
    7496:	4798      	blx	r3
    7498:	0006      	movs	r6, r0
		tone(melody_expired[thisNote].tone,noteDuration);
    749a:	0001      	movs	r1, r0
    749c:	4b0b      	ldr	r3, [pc, #44]	; (74cc <play_song_expired+0x48>)
    749e:	5960      	ldr	r0, [r4, r5]
    74a0:	4798      	blx	r3

		int pauseBetweenNotes = noteDuration * 1.30;
    74a2:	4b0b      	ldr	r3, [pc, #44]	; (74d0 <play_song_expired+0x4c>)
    74a4:	0030      	movs	r0, r6
    74a6:	4798      	blx	r3
    74a8:	4a0a      	ldr	r2, [pc, #40]	; (74d4 <play_song_expired+0x50>)
    74aa:	4b0b      	ldr	r3, [pc, #44]	; (74d8 <play_song_expired+0x54>)
    74ac:	4e0b      	ldr	r6, [pc, #44]	; (74dc <play_song_expired+0x58>)
    74ae:	47b0      	blx	r6
    74b0:	4b0b      	ldr	r3, [pc, #44]	; (74e0 <play_song_expired+0x5c>)
    74b2:	4798      	blx	r3
		delay_ms(pauseBetweenNotes);
    74b4:	4b0b      	ldr	r3, [pc, #44]	; (74e4 <play_song_expired+0x60>)
    74b6:	4798      	blx	r3
    74b8:	3408      	adds	r4, #8
		noTone();
    74ba:	4b0b      	ldr	r3, [pc, #44]	; (74e8 <play_song_expired+0x64>)
    74bc:	4798      	blx	r3
	for (int thisNote = 0; thisNote < LEN_melody_expired; thisNote++) {
    74be:	2c40      	cmp	r4, #64	; 0x40
    74c0:	d1e4      	bne.n	748c <play_song_expired+0x8>
	}
}
    74c2:	bd70      	pop	{r4, r5, r6, pc}
    74c4:	2000008c 	.word	0x2000008c
    74c8:	0000809d 	.word	0x0000809d
    74cc:	000073d5 	.word	0x000073d5
    74d0:	000087dd 	.word	0x000087dd
    74d4:	cccccccd 	.word	0xcccccccd
    74d8:	3ff4cccc 	.word	0x3ff4cccc
    74dc:	00008275 	.word	0x00008275
    74e0:	00008775 	.word	0x00008775
    74e4:	00007c05 	.word	0x00007c05
    74e8:	000072c1 	.word	0x000072c1

000074ec <play_song_error>:
void play_song_error(void)
{
    74ec:	b570      	push	{r4, r5, r6, lr}
    74ee:	2400      	movs	r4, #0
	for (int thisNote = 0; thisNote < LEN_melody_error; thisNote++) {
		int noteDuration = 1000 / melody_error[thisNote].duration;
    74f0:	4d0e      	ldr	r5, [pc, #56]	; (752c <play_song_error+0x40>)
    74f2:	3578      	adds	r5, #120	; 0x78
    74f4:	20fa      	movs	r0, #250	; 0xfa
    74f6:	192b      	adds	r3, r5, r4
    74f8:	6859      	ldr	r1, [r3, #4]
    74fa:	0080      	lsls	r0, r0, #2
    74fc:	4b0c      	ldr	r3, [pc, #48]	; (7530 <play_song_error+0x44>)
    74fe:	4798      	blx	r3
    7500:	0006      	movs	r6, r0
		tone(melody_error[thisNote].tone, noteDuration);
    7502:	0001      	movs	r1, r0
    7504:	4b0b      	ldr	r3, [pc, #44]	; (7534 <play_song_error+0x48>)
    7506:	5960      	ldr	r0, [r4, r5]
    7508:	4798      	blx	r3

		int pauseBetweenNotes = noteDuration * 1.30;
    750a:	4b0b      	ldr	r3, [pc, #44]	; (7538 <play_song_error+0x4c>)
    750c:	0030      	movs	r0, r6
    750e:	4798      	blx	r3
    7510:	4a0a      	ldr	r2, [pc, #40]	; (753c <play_song_error+0x50>)
    7512:	4b0b      	ldr	r3, [pc, #44]	; (7540 <play_song_error+0x54>)
    7514:	4e0b      	ldr	r6, [pc, #44]	; (7544 <play_song_error+0x58>)
    7516:	47b0      	blx	r6
    7518:	4b0b      	ldr	r3, [pc, #44]	; (7548 <play_song_error+0x5c>)
    751a:	4798      	blx	r3
		delay_ms(pauseBetweenNotes);
    751c:	4b0b      	ldr	r3, [pc, #44]	; (754c <play_song_error+0x60>)
    751e:	4798      	blx	r3
    7520:	3408      	adds	r4, #8
		noTone();
    7522:	4b0b      	ldr	r3, [pc, #44]	; (7550 <play_song_error+0x64>)
    7524:	4798      	blx	r3
	for (int thisNote = 0; thisNote < LEN_melody_error; thisNote++) {
    7526:	2c10      	cmp	r4, #16
    7528:	d1e4      	bne.n	74f4 <play_song_error+0x8>
	}
}
    752a:	bd70      	pop	{r4, r5, r6, pc}
    752c:	2000008c 	.word	0x2000008c
    7530:	0000809d 	.word	0x0000809d
    7534:	000073d5 	.word	0x000073d5
    7538:	000087dd 	.word	0x000087dd
    753c:	cccccccd 	.word	0xcccccccd
    7540:	3ff4cccc 	.word	0x3ff4cccc
    7544:	00008275 	.word	0x00008275
    7548:	00008775 	.word	0x00008775
    754c:	00007c05 	.word	0x00007c05
    7550:	000072c1 	.word	0x000072c1

00007554 <play_toneC>:
		noTone();
	}
}
*/
void play_toneC(void)
{
    7554:	b510      	push	{r4, lr}
    7556:	21fa      	movs	r1, #250	; 0xfa
    7558:	4801      	ldr	r0, [pc, #4]	; (7560 <play_toneC+0xc>)
    755a:	4b02      	ldr	r3, [pc, #8]	; (7564 <play_toneC+0x10>)
    755c:	4798      	blx	r3
	tone(NOTE_C6, 1000/4);
}
    755e:	bd10      	pop	{r4, pc}
    7560:	00000417 	.word	0x00000417
    7564:	000072e5 	.word	0x000072e5

00007568 <TC2_Handler>:


//void irq_handler_tc2(void){
void TC2_Handler(void){
    7568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (TC2->COUNT16.INTFLAG.reg & TC_INTFLAG_MC(1)) {
    756a:	4d14      	ldr	r5, [pc, #80]	; (75bc <TC2_Handler+0x54>)
    756c:	7bab      	ldrb	r3, [r5, #14]
    756e:	06db      	lsls	r3, r3, #27
    7570:	d51b      	bpl.n	75aa <TC2_Handler+0x42>
		if (tone_toggleCount != 0) {
    7572:	4e13      	ldr	r6, [pc, #76]	; (75c0 <TC2_Handler+0x58>)
    7574:	4c13      	ldr	r4, [pc, #76]	; (75c4 <TC2_Handler+0x5c>)
    7576:	6832      	ldr	r2, [r6, #0]
    7578:	6873      	ldr	r3, [r6, #4]
    757a:	0017      	movs	r7, r2
    757c:	431f      	orrs	r7, r3
    757e:	d015      	beq.n	75ac <TC2_Handler+0x44>
			if (tone_toggleCount > 0) --tone_toggleCount;
    7580:	6832      	ldr	r2, [r6, #0]
    7582:	6873      	ldr	r3, [r6, #4]
    7584:	2b00      	cmp	r3, #0
    7586:	dc02      	bgt.n	758e <TC2_Handler+0x26>
    7588:	d10a      	bne.n	75a0 <TC2_Handler+0x38>
    758a:	2a00      	cmp	r2, #0
    758c:	d008      	beq.n	75a0 <TC2_Handler+0x38>
    758e:	6832      	ldr	r2, [r6, #0]
    7590:	6873      	ldr	r3, [r6, #4]
    7592:	2001      	movs	r0, #1
    7594:	4240      	negs	r0, r0
    7596:	17c1      	asrs	r1, r0, #31
    7598:	1812      	adds	r2, r2, r0
    759a:	414b      	adcs	r3, r1
    759c:	6032      	str	r2, [r6, #0]
    759e:	6073      	str	r3, [r6, #4]
    75a0:	2380      	movs	r3, #128	; 0x80
    75a2:	029b      	lsls	r3, r3, #10
    75a4:	61e3      	str	r3, [r4, #28]
		} else {
			resetTC2();
			HAL_GPIO_PIEZO_PIN_clr();
			toneIsActive = false;
		}		
		TC2->COUNT16.INTFLAG.reg = TC_INTFLAG_MC(1); // clear
    75a6:	2310      	movs	r3, #16
    75a8:	73ab      	strb	r3, [r5, #14]
	}
}
    75aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			resetTC2();
    75ac:	4b06      	ldr	r3, [pc, #24]	; (75c8 <TC2_Handler+0x60>)
    75ae:	4798      	blx	r3
    75b0:	2380      	movs	r3, #128	; 0x80
    75b2:	029b      	lsls	r3, r3, #10
    75b4:	6163      	str	r3, [r4, #20]
			toneIsActive = false;
    75b6:	4b05      	ldr	r3, [pc, #20]	; (75cc <TC2_Handler+0x64>)
    75b8:	701f      	strb	r7, [r3, #0]
    75ba:	e7f4      	b.n	75a6 <TC2_Handler+0x3e>
    75bc:	42002800 	.word	0x42002800
    75c0:	20000d10 	.word	0x20000d10
    75c4:	41004400 	.word	0x41004400
    75c8:	00007299 	.word	0x00007299
    75cc:	200008a4 	.word	0x200008a4

000075d0 <timer2_init>:

void timer2_init(int8_t onoff)
{
    75d0:	4b08      	ldr	r3, [pc, #32]	; (75f4 <timer2_init+0x24>)
    if(onoff == 0) {
    75d2:	2800      	cmp	r0, #0
    75d4:	d104      	bne.n	75e0 <timer2_init+0x10>
        PM->APBCMASK.reg &= ~PM_APBCMASK_TC2;
    75d6:	6a1a      	ldr	r2, [r3, #32]
    75d8:	4907      	ldr	r1, [pc, #28]	; (75f8 <timer2_init+0x28>)
    75da:	400a      	ands	r2, r1
    75dc:	621a      	str	r2, [r3, #32]
    } else {            
	    PM->APBCMASK.reg |= PM_APBCMASK_TC2;
	    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(TC2_GCLK_ID) |
	    GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN(0);
    }    
}
    75de:	4770      	bx	lr
	    PM->APBCMASK.reg |= PM_APBCMASK_TC2;
    75e0:	2280      	movs	r2, #128	; 0x80
    75e2:	6a19      	ldr	r1, [r3, #32]
    75e4:	00d2      	lsls	r2, r2, #3
    75e6:	430a      	orrs	r2, r1
    75e8:	621a      	str	r2, [r3, #32]
	    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(TC2_GCLK_ID) |
    75ea:	4a04      	ldr	r2, [pc, #16]	; (75fc <timer2_init+0x2c>)
    75ec:	4b04      	ldr	r3, [pc, #16]	; (7600 <timer2_init+0x30>)
    75ee:	805a      	strh	r2, [r3, #2]
}
    75f0:	e7f5      	b.n	75de <timer2_init+0xe>
    75f2:	46c0      	nop			; (mov r8, r8)
    75f4:	40000400 	.word	0x40000400
    75f8:	fffffbff 	.word	0xfffffbff
    75fc:	00004014 	.word	0x00004014
    7600:	40000c00 	.word	0x40000c00

00007604 <tone_init>:
    7604:	4b07      	ldr	r3, [pc, #28]	; (7624 <tone_init+0x20>)
    7606:	2180      	movs	r1, #128	; 0x80

void tone_init(int8_t onoff)
{
    7608:	b570      	push	{r4, r5, r6, lr}
    760a:	001c      	movs	r4, r3
    760c:	2202      	movs	r2, #2
    760e:	0289      	lsls	r1, r1, #10
    7610:	6099      	str	r1, [r3, #8]
    7612:	3451      	adds	r4, #81	; 0x51
    7614:	7825      	ldrb	r5, [r4, #0]
    7616:	432a      	orrs	r2, r5
    7618:	7022      	strb	r2, [r4, #0]
    761a:	6159      	str	r1, [r3, #20]
    HAL_GPIO_PIEZO_PIN_out();
    HAL_GPIO_PIEZO_PIN_clr();    
    timer2_init(onoff);    
    761c:	4b02      	ldr	r3, [pc, #8]	; (7628 <tone_init+0x24>)
    761e:	4798      	blx	r3
}
    7620:	bd70      	pop	{r4, r5, r6, pc}
    7622:	46c0      	nop			; (mov r8, r8)
    7624:	41004400 	.word	0x41004400
    7628:	000075d1 	.word	0x000075d1

0000762c <i2c_init.part.0>:

extern uint8_t i2c_timeout;
#define I2C_TIMEOUT 3 //  3/10 second


void i2c_init(int8_t onoff)
    762c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    762e:	2480      	movs	r4, #128	; 0x80
        HAL_GPIO_SCC_SDA_in();
        HAL_GPIO_SCC_SDA_pullup();
        HAL_GPIO_SCC_SCL_out();
        uart_print(0,"i2c: off\n\r");
    } else {    
        uart_print(0,"i2c: on\n\r");
    7630:	4928      	ldr	r1, [pc, #160]	; (76d4 <i2c_init.part.0+0xa8>)
    7632:	2000      	movs	r0, #0
    7634:	4b28      	ldr	r3, [pc, #160]	; (76d8 <i2c_init.part.0+0xac>)
    7636:	4798      	blx	r3
    7638:	2002      	movs	r0, #2
    763a:	2101      	movs	r1, #1
    763c:	4e27      	ldr	r6, [pc, #156]	; (76dc <i2c_init.part.0+0xb0>)
    763e:	4b28      	ldr	r3, [pc, #160]	; (76e0 <i2c_init.part.0+0xb4>)
    7640:	0064      	lsls	r4, r4, #1
    7642:	60b4      	str	r4, [r6, #8]
    7644:	781a      	ldrb	r2, [r3, #0]
    7646:	250f      	movs	r5, #15
    7648:	4302      	orrs	r2, r0
    764a:	701a      	strb	r2, [r3, #0]
    764c:	781a      	ldrb	r2, [r3, #0]
    764e:	430a      	orrs	r2, r1
    7650:	701a      	strb	r2, [r3, #0]
    7652:	2203      	movs	r2, #3
    7654:	4b23      	ldr	r3, [pc, #140]	; (76e4 <i2c_init.part.0+0xb8>)
    7656:	781f      	ldrb	r7, [r3, #0]
    7658:	43af      	bics	r7, r5
    765a:	433a      	orrs	r2, r7
    765c:	701a      	strb	r2, [r3, #0]
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    765e:	2280      	movs	r2, #128	; 0x80
    7660:	0092      	lsls	r2, r2, #2
    7662:	60b2      	str	r2, [r6, #8]
    7664:	4a20      	ldr	r2, [pc, #128]	; (76e8 <i2c_init.part.0+0xbc>)
    7666:	7816      	ldrb	r6, [r2, #0]
    7668:	4330      	orrs	r0, r6
    766a:	7010      	strb	r0, [r2, #0]
    766c:	7810      	ldrb	r0, [r2, #0]
    766e:	4301      	orrs	r1, r0
    7670:	7011      	strb	r1, [r2, #0]
    7672:	781a      	ldrb	r2, [r3, #0]
    7674:	4015      	ands	r5, r2
    7676:	2230      	movs	r2, #48	; 0x30
    7678:	432a      	orrs	r2, r5
    767a:	701a      	strb	r2, [r3, #0]
        HAL_GPIO_SCC_SDA_out();
        HAL_GPIO_SCC_SDA_pmuxen(PORT_PMUX_PMUXE_D_Val); // SDA is PA08 -> pad0
        HAL_GPIO_SCC_SCL_out();
        HAL_GPIO_SCC_SCL_pmuxen(PORT_PMUX_PMUXE_D_Val); // SCL is PA09 -> pad1

        PM->APBCMASK.reg |= PM_APBCMASK_SERCOM2;
    767c:	2310      	movs	r3, #16
    767e:	4a1b      	ldr	r2, [pc, #108]	; (76ec <i2c_init.part.0+0xc0>)
    7680:	6a11      	ldr	r1, [r2, #32]
    7682:	430b      	orrs	r3, r1
    7684:	6213      	str	r3, [r2, #32]
        
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM2_GCLK_ID_CORE) |
    7686:	4a1a      	ldr	r2, [pc, #104]	; (76f0 <i2c_init.part.0+0xc4>)
    7688:	4b1a      	ldr	r3, [pc, #104]	; (76f4 <i2c_init.part.0+0xc8>)
    768a:	805a      	strh	r2, [r3, #2]
        /* By setting the SPEED bit field as 0x01, I2C Master runs at Fast mode + -  1MHz,   
           By setting the SDAHOLD bit field as 0x02, SDA hold time is configured for 300-600ns,    
           By setting the RUNSTDBY bit as 0x01,Generic clock is enabled in all sleep modes,any interrupt can wake up the device,    
           SERCOM2 is configured as an I2C Master by writing the MODE bitfield as 0x5 
         */
        SERCOM2->I2CM.CTRLA.reg = //SERCOM_I2CM_CTRLA_LOWTOUT |
    768c:	4b1a      	ldr	r3, [pc, #104]	; (76f8 <i2c_init.part.0+0xcc>)
    768e:	4a1b      	ldr	r2, [pc, #108]	; (76fc <i2c_init.part.0+0xd0>)
    7690:	601a      	str	r2, [r3, #0]
                                  SERCOM_I2CM_CTRLA_SDAHOLD(3) | 
                                 // SERCOM_I2CM_CTRLA_RUNSTDBY  | 
                                  SERCOM_I2CM_CTRLA_MODE_I2C_MASTER;

        /* smart mode enabled by setting the bit SMEN as 1 */ 
        SERCOM2->I2CM.CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN; 
    7692:	605c      	str	r4, [r3, #4]
        /* synchronization busy */ 
        while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    7694:	8a1a      	ldrh	r2, [r3, #16]
    7696:	0bd2      	lsrs	r2, r2, #15
    7698:	d1fc      	bne.n	7694 <i2c_init.part.0+0x68>
        // assumed Trise=1e-6 s
        //
        // >> 8e6/(10+255+255+8e6*1e-6)
        //ans =    1.5152e+04 

        SERCOM2->I2CM.BAUD.reg = SERCOM_I2CM_BAUD_BAUD(255) | SERCOM_I2CM_BAUD_BAUDLOW(255);//  15kHz
    769a:	3a01      	subs	r2, #1
    769c:	815a      	strh	r2, [r3, #10]
        
        /* synchronization busy */ 
        while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    769e:	8a1a      	ldrh	r2, [r3, #16]
    76a0:	0bd2      	lsrs	r2, r2, #15
    76a2:	d1fc      	bne.n	769e <i2c_init.part.0+0x72>
    
        /* SERCOM2 peripheral enabled by setting the ENABLE bit as 1*/ 
        SERCOM2->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE; 
    76a4:	6819      	ldr	r1, [r3, #0]
    76a6:	3202      	adds	r2, #2
    76a8:	430a      	orrs	r2, r1
    76aa:	601a      	str	r2, [r3, #0]
        /* SERCOM Enable synchronization busy */ 
        while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    76ac:	8a1a      	ldrh	r2, [r3, #16]
    76ae:	0bd2      	lsrs	r2, r2, #15
    76b0:	d1fc      	bne.n	76ac <i2c_init.part.0+0x80>
    
        /* bus state is forced into idle state */ 
        SERCOM2->I2CM.STATUS.bit.BUSSTATE = 0x1; 
    76b2:	2130      	movs	r1, #48	; 0x30
    76b4:	8a1a      	ldrh	r2, [r3, #16]
    76b6:	438a      	bics	r2, r1
    76b8:	0011      	movs	r1, r2
    76ba:	2210      	movs	r2, #16
    76bc:	430a      	orrs	r2, r1
    76be:	821a      	strh	r2, [r3, #16]
        /* synchronization busy */ 
        while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    76c0:	8a1a      	ldrh	r2, [r3, #16]
    76c2:	0bd2      	lsrs	r2, r2, #15
    76c4:	d1fc      	bne.n	76c0 <i2c_init.part.0+0x94>
    
        /* Both master on bus and slave on bus interrupt is enabled */ 
        SERCOM2->I2CM.INTENSET.reg = SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB; 
    76c6:	3203      	adds	r2, #3
    76c8:	735a      	strb	r2, [r3, #13]
    76ca:	4b0d      	ldr	r3, [pc, #52]	; (7700 <i2c_init.part.0+0xd4>)
    76cc:	32fe      	adds	r2, #254	; 0xfe
    76ce:	32ff      	adds	r2, #255	; 0xff
    76d0:	601a      	str	r2, [r3, #0]
        /* SERCOM2 handler enabled */ 
        NVIC_EnableIRQ(SERCOM2_IRQn);
    }    
} 
    76d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    76d4:	0000ba0a 	.word	0x0000ba0a
    76d8:	00007b99 	.word	0x00007b99
    76dc:	41004400 	.word	0x41004400
    76e0:	41004448 	.word	0x41004448
    76e4:	41004434 	.word	0x41004434
    76e8:	41004449 	.word	0x41004449
    76ec:	40000400 	.word	0x40000400
    76f0:	0000400f 	.word	0x0000400f
    76f4:	40000c00 	.word	0x40000c00
    76f8:	42001000 	.word	0x42001000
    76fc:	00300014 	.word	0x00300014
    7700:	e000e100 	.word	0xe000e100

00007704 <i2c_init>:
{
    7704:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7706:	1e05      	subs	r5, r0, #0
    if(onoff==0) {
    7708:	d12d      	bne.n	7766 <i2c_init+0x62>
        uart_print(0,"i2c: stop\n\r");
    770a:	4918      	ldr	r1, [pc, #96]	; (776c <i2c_init+0x68>)
    770c:	4c18      	ldr	r4, [pc, #96]	; (7770 <i2c_init+0x6c>)
    770e:	47a0      	blx	r4
        uart_print(0,"i2c: disable\n\r");
    7710:	4918      	ldr	r1, [pc, #96]	; (7774 <i2c_init+0x70>)
    7712:	0028      	movs	r0, r5
    7714:	47a0      	blx	r4
        SERCOM2->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE; 
    7716:	2102      	movs	r1, #2
    7718:	4b17      	ldr	r3, [pc, #92]	; (7778 <i2c_init+0x74>)
    771a:	681a      	ldr	r2, [r3, #0]
    771c:	438a      	bics	r2, r1
    771e:	601a      	str	r2, [r3, #0]
        while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    7720:	8a18      	ldrh	r0, [r3, #16]
    7722:	0bc0      	lsrs	r0, r0, #15
    7724:	d1fc      	bne.n	7720 <i2c_init+0x1c>
        PM->APBCMASK.reg &= ~PM_APBCMASK_SERCOM2;
    7726:	2110      	movs	r1, #16
    7728:	4a14      	ldr	r2, [pc, #80]	; (777c <i2c_init+0x78>)
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    772a:	2780      	movs	r7, #128	; 0x80
    772c:	6a13      	ldr	r3, [r2, #32]
    772e:	4d14      	ldr	r5, [pc, #80]	; (7780 <i2c_init+0x7c>)
    7730:	438b      	bics	r3, r1
    7732:	6213      	str	r3, [r2, #32]
    7734:	2202      	movs	r2, #2
    7736:	4b13      	ldr	r3, [pc, #76]	; (7784 <i2c_init+0x80>)
    7738:	007f      	lsls	r7, r7, #1
    773a:	606f      	str	r7, [r5, #4]
    773c:	7819      	ldrb	r1, [r3, #0]
    773e:	4311      	orrs	r1, r2
    7740:	7019      	strb	r1, [r3, #0]
    7742:	2104      	movs	r1, #4
    7744:	781e      	ldrb	r6, [r3, #0]
    7746:	438e      	bics	r6, r1
    7748:	701e      	strb	r6, [r3, #0]
    774a:	61af      	str	r7, [r5, #24]
    774c:	781e      	ldrb	r6, [r3, #0]
    774e:	4331      	orrs	r1, r6
    7750:	7019      	strb	r1, [r3, #0]
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    7752:	2380      	movs	r3, #128	; 0x80
    7754:	009b      	lsls	r3, r3, #2
    7756:	60ab      	str	r3, [r5, #8]
    7758:	4b0b      	ldr	r3, [pc, #44]	; (7788 <i2c_init+0x84>)
    775a:	7819      	ldrb	r1, [r3, #0]
    775c:	430a      	orrs	r2, r1
    775e:	701a      	strb	r2, [r3, #0]
        uart_print(0,"i2c: off\n\r");
    7760:	490a      	ldr	r1, [pc, #40]	; (778c <i2c_init+0x88>)
    7762:	47a0      	blx	r4
} 
    7764:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7766:	4b0a      	ldr	r3, [pc, #40]	; (7790 <i2c_init+0x8c>)
    7768:	4798      	blx	r3
    776a:	e7fb      	b.n	7764 <i2c_init+0x60>
    776c:	0000ba14 	.word	0x0000ba14
    7770:	00007b99 	.word	0x00007b99
    7774:	0000ba20 	.word	0x0000ba20
    7778:	42001000 	.word	0x42001000
    777c:	40000400 	.word	0x40000400
    7780:	41004400 	.word	0x41004400
    7784:	41004448 	.word	0x41004448
    7788:	41004449 	.word	0x41004449
    778c:	0000ba2f 	.word	0x0000ba2f
    7790:	0000762d 	.word	0x0000762d

00007794 <i2c_reset>:

void i2c_reset(void)
{
    7794:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7796:	2780      	movs	r7, #128	; 0x80
    int8_t i;
    uint8_t sda;
    uart_print(0,"i2c: reset\n\r");
    7798:	4923      	ldr	r1, [pc, #140]	; (7828 <i2c_reset+0x94>)
    779a:	2000      	movs	r0, #0
    779c:	4b23      	ldr	r3, [pc, #140]	; (782c <i2c_reset+0x98>)
    779e:	4c24      	ldr	r4, [pc, #144]	; (7830 <i2c_reset+0x9c>)
    77a0:	4798      	blx	r3
    77a2:	00bf      	lsls	r7, r7, #2
    i2c_init(0);
    77a4:	4b23      	ldr	r3, [pc, #140]	; (7834 <i2c_reset+0xa0>)
    77a6:	2000      	movs	r0, #0
    77a8:	4798      	blx	r3
    77aa:	61a7      	str	r7, [r4, #24]

    HAL_GPIO_SCC_SCL_set();
    delay_ms(1);
    77ac:	2001      	movs	r0, #1
    77ae:	4e22      	ldr	r6, [pc, #136]	; (7838 <i2c_reset+0xa4>)
    77b0:	47b0      	blx	r6
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    77b2:	2380      	movs	r3, #128	; 0x80
    77b4:	6a25      	ldr	r5, [r4, #32]
    77b6:	005b      	lsls	r3, r3, #1
    77b8:	401d      	ands	r5, r3
    sda = HAL_GPIO_SCC_SDA_read();
    if(sda==0) {
    77ba:	d11b      	bne.n	77f4 <i2c_reset+0x60>
        uart_print(0,"i2c: try release SDA: pulse SCL "); // assuming SDA is input
    77bc:	491f      	ldr	r1, [pc, #124]	; (783c <i2c_reset+0xa8>)
    77be:	0028      	movs	r0, r5
    77c0:	4b1a      	ldr	r3, [pc, #104]	; (782c <i2c_reset+0x98>)
    77c2:	4798      	blx	r3
        for(i=0;i<9;i++) {
            HAL_GPIO_SCC_SCL_clr();
            delay_ms(2);
    77c4:	2002      	movs	r0, #2
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    77c6:	6167      	str	r7, [r4, #20]
    77c8:	47b0      	blx	r6
            HAL_GPIO_SCC_SCL_set();
            delay_ms(1);
    77ca:	2001      	movs	r0, #1
    77cc:	61a7      	str	r7, [r4, #24]
    77ce:	47b0      	blx	r6
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    77d0:	6a23      	ldr	r3, [r4, #32]
            sda = HAL_GPIO_SCC_SDA_read();
            delay_ms(1);
    77d2:	2001      	movs	r0, #1
    77d4:	9301      	str	r3, [sp, #4]
    77d6:	47b0      	blx	r6
            if(sda) break; // slave released SDA
    77d8:	9b01      	ldr	r3, [sp, #4]
    77da:	05db      	lsls	r3, r3, #23
    77dc:	d405      	bmi.n	77ea <i2c_reset+0x56>
    77de:	3501      	adds	r5, #1
    77e0:	b2eb      	uxtb	r3, r5
    77e2:	b25d      	sxtb	r5, r3
        for(i=0;i<9;i++) {
    77e4:	2b09      	cmp	r3, #9
    77e6:	d1ed      	bne.n	77c4 <i2c_reset+0x30>
    77e8:	001d      	movs	r5, r3
        }
        uart_print(0,"%dx\n\r",i);
    77ea:	002a      	movs	r2, r5
    77ec:	4914      	ldr	r1, [pc, #80]	; (7840 <i2c_reset+0xac>)
    77ee:	2000      	movs	r0, #0
    77f0:	4b0e      	ldr	r3, [pc, #56]	; (782c <i2c_reset+0x98>)
    77f2:	4798      	blx	r3
    77f4:	2580      	movs	r5, #128	; 0x80
    }
    // Send STOP:
    uart_print(0,"i2c: STOP\n\r");
    77f6:	4913      	ldr	r1, [pc, #76]	; (7844 <i2c_reset+0xb0>)
    77f8:	2000      	movs	r0, #0
    77fa:	4b0c      	ldr	r3, [pc, #48]	; (782c <i2c_reset+0x98>)
    77fc:	4798      	blx	r3
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    77fe:	2780      	movs	r7, #128	; 0x80
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    7800:	2302      	movs	r3, #2
    7802:	4a11      	ldr	r2, [pc, #68]	; (7848 <i2c_reset+0xb4>)
    7804:	006d      	lsls	r5, r5, #1
    7806:	60a5      	str	r5, [r4, #8]
    7808:	7811      	ldrb	r1, [r2, #0]
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    780a:	00bf      	lsls	r7, r7, #2
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    780c:	430b      	orrs	r3, r1
    780e:	7013      	strb	r3, [r2, #0]
    HAL_GPIO_SCC_SDA_out();
    HAL_GPIO_SCC_SCL_clr();
    HAL_GPIO_SCC_SDA_clr();
    delay_ms(1);
    7810:	2001      	movs	r0, #1
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    7812:	6167      	str	r7, [r4, #20]
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    7814:	6165      	str	r5, [r4, #20]
    7816:	47b0      	blx	r6
HAL_GPIO_PIN(SCC_SCL,   A, 9)
    7818:	61a7      	str	r7, [r4, #24]
    HAL_GPIO_SCC_SCL_set();
    delay_ms(1);
    781a:	2001      	movs	r0, #1
    781c:	47b0      	blx	r6
HAL_GPIO_PIN(SCC_SDA,   A, 8)
    781e:	61a5      	str	r5, [r4, #24]
    7820:	4b0a      	ldr	r3, [pc, #40]	; (784c <i2c_reset+0xb8>)
    7822:	4798      	blx	r3
    HAL_GPIO_SCC_SDA_set();

    i2c_init(1);
}
    7824:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    7826:	46c0      	nop			; (mov r8, r8)
    7828:	0000ba3a 	.word	0x0000ba3a
    782c:	00007b99 	.word	0x00007b99
    7830:	41004400 	.word	0x41004400
    7834:	00007705 	.word	0x00007705
    7838:	00007c05 	.word	0x00007c05
    783c:	0000ba47 	.word	0x0000ba47
    7840:	0000ba68 	.word	0x0000ba68
    7844:	0000ba6e 	.word	0x0000ba6e
    7848:	41004448 	.word	0x41004448
    784c:	0000762d 	.word	0x0000762d

00007850 <SERCOM2_Handler>:
uint8_t i2c_idx;
uint8_t i2c_nof_tx, i2c_nof_rx;
volatile bool i2c_tx_done = false, i2c_rx_done = false; 

void SERCOM2_Handler(void) 
{ 
    7850:	b510      	push	{r4, lr}
    /* Master on bus interrupt checking */ 
    if (SERCOM2->I2CM.INTFLAG.bit.MB) {
    7852:	4b2f      	ldr	r3, [pc, #188]	; (7910 <SERCOM2_Handler+0xc0>)
    7854:	7b9a      	ldrb	r2, [r3, #14]
    7856:	07d2      	lsls	r2, r2, #31
    7858:	d511      	bpl.n	787e <SERCOM2_Handler+0x2e>
        if (i2c_idx == i2c_nof_tx) {   
    785a:	492e      	ldr	r1, [pc, #184]	; (7914 <SERCOM2_Handler+0xc4>)
    785c:	482e      	ldr	r0, [pc, #184]	; (7918 <SERCOM2_Handler+0xc8>)
    785e:	780a      	ldrb	r2, [r1, #0]
    7860:	7800      	ldrb	r0, [r0, #0]
    7862:	4290      	cmp	r0, r2
    7864:	d131      	bne.n	78ca <SERCOM2_Handler+0x7a>
            /* After transferring the last byte stop condition will be sent */
            SERCOM2->I2CM.CTRLB.bit.CMD = 0x3; 
    7866:	22c0      	movs	r2, #192	; 0xc0
    7868:	6858      	ldr	r0, [r3, #4]
    786a:	0292      	lsls	r2, r2, #10
    786c:	4302      	orrs	r2, r0
    786e:	605a      	str	r2, [r3, #4]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    7870:	8a1a      	ldrh	r2, [r3, #16]
    7872:	0bd2      	lsrs	r2, r2, #15
    7874:	d1fc      	bne.n	7870 <SERCOM2_Handler+0x20>
            i2c_tx_done = true; 
    7876:	2401      	movs	r4, #1
    7878:	4828      	ldr	r0, [pc, #160]	; (791c <SERCOM2_Handler+0xcc>)
            i2c_idx = 0; 
    787a:	700a      	strb	r2, [r1, #0]
            i2c_tx_done = true; 
    787c:	7004      	strb	r4, [r0, #0]
            SERCOM2->I2CM.DATA.reg = i2c_tx_buf[i2c_idx++]; 
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
        }
    }
    /* Slave on bus interrupt checking */ 
    if (SERCOM2->I2CM.INTFLAG.bit.SB) {
    787e:	7b9a      	ldrb	r2, [r3, #14]
    7880:	0792      	lsls	r2, r2, #30
    7882:	d521      	bpl.n	78c8 <SERCOM2_Handler+0x78>
        if (i2c_idx == (i2c_nof_rx-1)) { 
    7884:	4826      	ldr	r0, [pc, #152]	; (7920 <SERCOM2_Handler+0xd0>)
    7886:	4923      	ldr	r1, [pc, #140]	; (7914 <SERCOM2_Handler+0xc4>)
    7888:	7800      	ldrb	r0, [r0, #0]
    788a:	780a      	ldrb	r2, [r1, #0]
    788c:	3801      	subs	r0, #1
    788e:	4282      	cmp	r2, r0
    7890:	d124      	bne.n	78dc <SERCOM2_Handler+0x8c>
            /* NACK should be sent before reading the last byte */
            SERCOM2->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    7892:	2080      	movs	r0, #128	; 0x80
    7894:	685c      	ldr	r4, [r3, #4]
    7896:	02c0      	lsls	r0, r0, #11
    7898:	4320      	orrs	r0, r4
    789a:	6058      	str	r0, [r3, #4]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    789c:	8a18      	ldrh	r0, [r3, #16]
    789e:	0bc0      	lsrs	r0, r0, #15
    78a0:	d1fc      	bne.n	789c <SERCOM2_Handler+0x4c>
            
            SERCOM2->I2CM.CTRLB.bit.CMD = 0x3;
    78a2:	20c0      	movs	r0, #192	; 0xc0
    78a4:	685c      	ldr	r4, [r3, #4]
    78a6:	0280      	lsls	r0, r0, #10
    78a8:	4320      	orrs	r0, r4
    78aa:	6058      	str	r0, [r3, #4]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    78ac:	8a18      	ldrh	r0, [r3, #16]
    78ae:	0bc0      	lsrs	r0, r0, #15
    78b0:	d1fc      	bne.n	78ac <SERCOM2_Handler+0x5c>
            
            i2c_rx_buf[i2c_idx++] = SERCOM2->I2CM.DATA.reg; 
    78b2:	1c50      	adds	r0, r2, #1
    78b4:	7008      	strb	r0, [r1, #0]
    78b6:	7e18      	ldrb	r0, [r3, #24]
    78b8:	491a      	ldr	r1, [pc, #104]	; (7924 <SERCOM2_Handler+0xd4>)
    78ba:	5488      	strb	r0, [r1, r2]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    78bc:	8a1a      	ldrh	r2, [r3, #16]
    78be:	0bd2      	lsrs	r2, r2, #15
    78c0:	d1fc      	bne.n	78bc <SERCOM2_Handler+0x6c>
            i2c_rx_done = true;
    78c2:	4b16      	ldr	r3, [pc, #88]	; (791c <SERCOM2_Handler+0xcc>)
    78c4:	3201      	adds	r2, #1
    78c6:	705a      	strb	r2, [r3, #1]
            /* sending ACK after reading each byte */ 
            SERCOM2->I2CM.CTRLB.bit.CMD = 0x2; 
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
        }
    }                   
}
    78c8:	bd10      	pop	{r4, pc}
            SERCOM2->I2CM.DATA.reg = i2c_tx_buf[i2c_idx++]; 
    78ca:	1c50      	adds	r0, r2, #1
    78cc:	7008      	strb	r0, [r1, #0]
    78ce:	4916      	ldr	r1, [pc, #88]	; (7928 <SERCOM2_Handler+0xd8>)
    78d0:	5c8a      	ldrb	r2, [r1, r2]
    78d2:	761a      	strb	r2, [r3, #24]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    78d4:	8a1a      	ldrh	r2, [r3, #16]
    78d6:	0bd2      	lsrs	r2, r2, #15
    78d8:	d1fc      	bne.n	78d4 <SERCOM2_Handler+0x84>
    78da:	e7d0      	b.n	787e <SERCOM2_Handler+0x2e>
            SERCOM2->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT; 
    78dc:	6858      	ldr	r0, [r3, #4]
    78de:	4c13      	ldr	r4, [pc, #76]	; (792c <SERCOM2_Handler+0xdc>)
    78e0:	4020      	ands	r0, r4
    78e2:	6058      	str	r0, [r3, #4]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    78e4:	8a18      	ldrh	r0, [r3, #16]
    78e6:	0bc0      	lsrs	r0, r0, #15
    78e8:	d1fc      	bne.n	78e4 <SERCOM2_Handler+0x94>
            i2c_rx_buf[i2c_idx++] = SERCOM2->I2CM.DATA.reg; 
    78ea:	1c50      	adds	r0, r2, #1
    78ec:	7008      	strb	r0, [r1, #0]
    78ee:	7e18      	ldrb	r0, [r3, #24]
    78f0:	490c      	ldr	r1, [pc, #48]	; (7924 <SERCOM2_Handler+0xd4>)
    78f2:	5488      	strb	r0, [r1, r2]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    78f4:	8a1a      	ldrh	r2, [r3, #16]
    78f6:	0bd2      	lsrs	r2, r2, #15
    78f8:	d1fc      	bne.n	78f4 <SERCOM2_Handler+0xa4>
            SERCOM2->I2CM.CTRLB.bit.CMD = 0x2; 
    78fa:	685a      	ldr	r2, [r3, #4]
    78fc:	490c      	ldr	r1, [pc, #48]	; (7930 <SERCOM2_Handler+0xe0>)
    78fe:	4011      	ands	r1, r2
    7900:	2280      	movs	r2, #128	; 0x80
    7902:	0292      	lsls	r2, r2, #10
    7904:	430a      	orrs	r2, r1
    7906:	605a      	str	r2, [r3, #4]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY); 
    7908:	8a1a      	ldrh	r2, [r3, #16]
    790a:	0bd2      	lsrs	r2, r2, #15
    790c:	d1fc      	bne.n	7908 <SERCOM2_Handler+0xb8>
    790e:	e7db      	b.n	78c8 <SERCOM2_Handler+0x78>
    7910:	42001000 	.word	0x42001000
    7914:	20000d38 	.word	0x20000d38
    7918:	20000d59 	.word	0x20000d59
    791c:	200008a5 	.word	0x200008a5
    7920:	20000d5a 	.word	0x20000d5a
    7924:	20000d18 	.word	0x20000d18
    7928:	20000d39 	.word	0x20000d39
    792c:	fffbffff 	.word	0xfffbffff
    7930:	fffcffff 	.word	0xfffcffff

00007934 <i2c_transact>:
    
int i2c_transact(const uint8_t i2c_slave, const uint8_t *cmd, const uint8_t cmd_len, uint8_t *data, const uint8_t data_len)
{
    7934:	b5f0      	push	{r4, r5, r6, r7, lr}
    7936:	b085      	sub	sp, #20
    7938:	9302      	str	r3, [sp, #8]
    793a:	ab0a      	add	r3, sp, #40	; 0x28
    793c:	781e      	ldrb	r6, [r3, #0]
    i2c_idx = 0;
    793e:	2300      	movs	r3, #0
{
    7940:	0017      	movs	r7, r2
    i2c_idx = 0;
    7942:	4a38      	ldr	r2, [pc, #224]	; (7a24 <i2c_transact+0xf0>)
{
    7944:	9001      	str	r0, [sp, #4]
    i2c_idx = 0;
    7946:	7013      	strb	r3, [r2, #0]
    i2c_tx_done = false;
    7948:	4a37      	ldr	r2, [pc, #220]	; (7a28 <i2c_transact+0xf4>)
    i2c_rx_done = false;
    int ret=data_len;
    794a:	0035      	movs	r5, r6
    i2c_tx_done = false;
    794c:	7013      	strb	r3, [r2, #0]
    i2c_rx_done = false;
    794e:	7053      	strb	r3, [r2, #1]
        
    if(cmd_len > I2C_BUF_SIZE) return -1;
    7950:	2f20      	cmp	r7, #32
    7952:	d833      	bhi.n	79bc <i2c_transact+0x88>
    
    memcpy((void *)i2c_tx_buf,(void *)cmd,cmd_len);
    7954:	003a      	movs	r2, r7
    7956:	4b35      	ldr	r3, [pc, #212]	; (7a2c <i2c_transact+0xf8>)
    7958:	4835      	ldr	r0, [pc, #212]	; (7a30 <i2c_transact+0xfc>)
    795a:	4798      	blx	r3
    i2c_nof_tx = cmd_len;
    795c:	4b35      	ldr	r3, [pc, #212]	; (7a34 <i2c_transact+0x100>)
    i2c_nof_rx = data_len;
    
    /* Both master on bus and slave on bus interrupt is enabled */
    SERCOM2->I2CM.INTENSET.reg = SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB;
    795e:	4c36      	ldr	r4, [pc, #216]	; (7a38 <i2c_transact+0x104>)
    i2c_nof_tx = cmd_len;
    7960:	701f      	strb	r7, [r3, #0]
    i2c_nof_rx = data_len;
    7962:	4b36      	ldr	r3, [pc, #216]	; (7a3c <i2c_transact+0x108>)
    
    /* Acknowledge section is set as ACK signal by writing 0 in ACKACT bit */
    SERCOM2->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    7964:	4a36      	ldr	r2, [pc, #216]	; (7a40 <i2c_transact+0x10c>)
    i2c_nof_rx = data_len;
    7966:	701e      	strb	r6, [r3, #0]
    SERCOM2->I2CM.INTENSET.reg = SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB;
    7968:	2303      	movs	r3, #3
    796a:	7363      	strb	r3, [r4, #13]
    SERCOM2->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    796c:	6863      	ldr	r3, [r4, #4]
    796e:	4013      	ands	r3, r2
    7970:	6063      	str	r3, [r4, #4]
    7972:	9203      	str	r2, [sp, #12]
    while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    7974:	8a23      	ldrh	r3, [r4, #16]
    7976:	0bdb      	lsrs	r3, r3, #15
    7978:	d1fc      	bne.n	7974 <i2c_transact+0x40>
    
    if(cmd_len>0) {          
    797a:	2f00      	cmp	r7, #0
    797c:	d103      	bne.n	7986 <i2c_transact+0x52>
            /*interrupts are cleared */
            SERCOM2->I2CM.INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
            return ret;
        }
    }    
    if(data_len == 0) {
    797e:	2e00      	cmp	r6, #0
    7980:	d11f      	bne.n	79c2 <i2c_transact+0x8e>
    7982:	0035      	movs	r5, r6
    7984:	e04b      	b.n	7a1e <i2c_transact+0xea>
        i2c_timeout = I2C_TIMEOUT;
    7986:	2303      	movs	r3, #3
    7988:	4f2e      	ldr	r7, [pc, #184]	; (7a44 <i2c_transact+0x110>)
    798a:	703b      	strb	r3, [r7, #0]
        SERCOM2->I2CM.ADDR.reg = (i2c_slave << 1) | 0;    
    798c:	9b01      	ldr	r3, [sp, #4]
    798e:	005b      	lsls	r3, r3, #1
    7990:	b2db      	uxtb	r3, r3
    7992:	7523      	strb	r3, [r4, #20]
        while(!i2c_tx_done) {
    7994:	4b24      	ldr	r3, [pc, #144]	; (7a28 <i2c_transact+0xf4>)
    7996:	781b      	ldrb	r3, [r3, #0]
    7998:	2b00      	cmp	r3, #0
    799a:	d1f0      	bne.n	797e <i2c_transact+0x4a>
            delay_ms(1);
    799c:	4b2a      	ldr	r3, [pc, #168]	; (7a48 <i2c_transact+0x114>)
    799e:	2001      	movs	r0, #1
    79a0:	4798      	blx	r3
            if(i2c_timeout==0) {            
    79a2:	783b      	ldrb	r3, [r7, #0]
    79a4:	2b00      	cmp	r3, #0
    79a6:	d1f5      	bne.n	7994 <i2c_transact+0x60>
                SERCOM2->I2CM.CTRLB.bit.CMD = 0x3;
    79a8:	23c0      	movs	r3, #192	; 0xc0
    79aa:	6862      	ldr	r2, [r4, #4]
    79ac:	029b      	lsls	r3, r3, #10
    79ae:	4313      	orrs	r3, r2
    79b0:	6063      	str	r3, [r4, #4]
                while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    79b2:	8a23      	ldrh	r3, [r4, #16]
    79b4:	0bdb      	lsrs	r3, r3, #15
    79b6:	d1fc      	bne.n	79b2 <i2c_transact+0x7e>
            SERCOM2->I2CM.INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
    79b8:	2303      	movs	r3, #3
    79ba:	7323      	strb	r3, [r4, #12]
            return ret;
    79bc:	2501      	movs	r5, #1
    79be:	426d      	negs	r5, r5
    79c0:	e02d      	b.n	7a1e <i2c_transact+0xea>
        return ret; // response is not requested
    }

    i2c_idx = 0;
    79c2:	2200      	movs	r2, #0
    79c4:	4b17      	ldr	r3, [pc, #92]	; (7a24 <i2c_transact+0xf0>)
    79c6:	701a      	strb	r2, [r3, #0]
    /* Acknowledge section is set as ACK signal by writing 0 in ACKACT bit */
    SERCOM2->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    79c8:	6863      	ldr	r3, [r4, #4]
    79ca:	9a03      	ldr	r2, [sp, #12]
    79cc:	4013      	ands	r3, r2
    79ce:	6063      	str	r3, [r4, #4]
    while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    79d0:	8a23      	ldrh	r3, [r4, #16]
    79d2:	0bdb      	lsrs	r3, r3, #15
    79d4:	d1fc      	bne.n	79d0 <i2c_transact+0x9c>
    
    /* slave address with read (1) */
    i2c_timeout = I2C_TIMEOUT;
    79d6:	4f1b      	ldr	r7, [pc, #108]	; (7a44 <i2c_transact+0x110>)
    79d8:	3303      	adds	r3, #3
    79da:	703b      	strb	r3, [r7, #0]
    SERCOM2->I2CM.ADDR.reg = (i2c_slave << 1) | 1;
    79dc:	9b01      	ldr	r3, [sp, #4]
    79de:	005a      	lsls	r2, r3, #1
    79e0:	2301      	movs	r3, #1
    79e2:	4313      	orrs	r3, r2
    79e4:	b2db      	uxtb	r3, r3
    79e6:	7523      	strb	r3, [r4, #20]
    while(!i2c_rx_done) {
    79e8:	4b0f      	ldr	r3, [pc, #60]	; (7a28 <i2c_transact+0xf4>)
    79ea:	785b      	ldrb	r3, [r3, #1]
    79ec:	2b00      	cmp	r3, #0
    79ee:	d10f      	bne.n	7a10 <i2c_transact+0xdc>
        delay_ms(1);
    79f0:	4b15      	ldr	r3, [pc, #84]	; (7a48 <i2c_transact+0x114>)
    79f2:	2001      	movs	r0, #1
    79f4:	4798      	blx	r3
        if(i2c_timeout==0) {
    79f6:	783b      	ldrb	r3, [r7, #0]
    79f8:	2b00      	cmp	r3, #0
    79fa:	d1f5      	bne.n	79e8 <i2c_transact+0xb4>
            ret=-1;
            //uart_print(0,"i2c rx timeout\n\r");
            /* send stop condition */
            SERCOM2->I2CM.CTRLB.bit.CMD = 0x3;
    79fc:	23c0      	movs	r3, #192	; 0xc0
    79fe:	6862      	ldr	r2, [r4, #4]
    7a00:	029b      	lsls	r3, r3, #10
    7a02:	4313      	orrs	r3, r2
    7a04:	6063      	str	r3, [r4, #4]
            while(SERCOM2->I2CM.STATUS.bit.SYNCBUSY);
    7a06:	8a23      	ldrh	r3, [r4, #16]
    7a08:	0bdb      	lsrs	r3, r3, #15
    7a0a:	d1fc      	bne.n	7a06 <i2c_transact+0xd2>
            ret=-1;
    7a0c:	2501      	movs	r5, #1
    7a0e:	426d      	negs	r5, r5
            break;
        }
    }        
    /*interrupts are cleared */
    SERCOM2->I2CM.INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
    7a10:	2303      	movs	r3, #3
    7a12:	7323      	strb	r3, [r4, #12]
    memcpy((void *)data,(void *)i2c_rx_buf,data_len);
    7a14:	0032      	movs	r2, r6
    7a16:	490d      	ldr	r1, [pc, #52]	; (7a4c <i2c_transact+0x118>)
    7a18:	9802      	ldr	r0, [sp, #8]
    7a1a:	4b04      	ldr	r3, [pc, #16]	; (7a2c <i2c_transact+0xf8>)
    7a1c:	4798      	blx	r3
    return ret;
}
    7a1e:	0028      	movs	r0, r5
    7a20:	b005      	add	sp, #20
    7a22:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7a24:	20000d38 	.word	0x20000d38
    7a28:	200008a5 	.word	0x200008a5
    7a2c:	00008945 	.word	0x00008945
    7a30:	20000d39 	.word	0x20000d39
    7a34:	20000d59 	.word	0x20000d59
    7a38:	42001000 	.word	0x42001000
    7a3c:	20000d5a 	.word	0x20000d5a
    7a40:	fffbffff 	.word	0xfffbffff
    7a44:	20000d0c 	.word	0x20000d0c
    7a48:	00007c05 	.word	0x00007c05
    7a4c:	20000d18 	.word	0x20000d18

00007a50 <SERCOM1_Handler>:


void SERCOM1_Handler(void)
{
    uint8_t c;
    if (SERCOM1->USART.INTFLAG.bit.RXC) {
    7a50:	4b05      	ldr	r3, [pc, #20]	; (7a68 <SERCOM1_Handler+0x18>)
    7a52:	7b9a      	ldrb	r2, [r3, #14]
    7a54:	0752      	lsls	r2, r2, #29
    7a56:	d505      	bpl.n	7a64 <SERCOM1_Handler+0x14>
        c = SERCOM1->USART.DATA.bit.DATA;
    7a58:	8b1a      	ldrh	r2, [r3, #24]
        serial_rxbuf = c;
    7a5a:	4b04      	ldr	r3, [pc, #16]	; (7a6c <SERCOM1_Handler+0x1c>)
        c = SERCOM1->USART.DATA.bit.DATA;
    7a5c:	701a      	strb	r2, [r3, #0]
        serial_rxflag = true;
    7a5e:	2201      	movs	r2, #1
    7a60:	4b03      	ldr	r3, [pc, #12]	; (7a70 <SERCOM1_Handler+0x20>)
    7a62:	701a      	strb	r2, [r3, #0]
    }
}
    7a64:	4770      	bx	lr
    7a66:	46c0      	nop			; (mov r8, r8)
    7a68:	42000c00 	.word	0x42000c00
    7a6c:	20000c0f 	.word	0x20000c0f
    7a70:	20000399 	.word	0x20000399

00007a74 <uart_init>:
HAL_GPIO_PIN(UART_TX,   A, 30)
    7a74:	2380      	movs	r3, #128	; 0x80


void uart_init(int8_t onoff)
{
    7a76:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7a78:	2202      	movs	r2, #2
    7a7a:	4d27      	ldr	r5, [pc, #156]	; (7b18 <uart_init+0xa4>)
    7a7c:	05db      	lsls	r3, r3, #23
    7a7e:	9001      	str	r0, [sp, #4]
    7a80:	60ab      	str	r3, [r5, #8]
    7a82:	4b26      	ldr	r3, [pc, #152]	; (7b1c <uart_init+0xa8>)
    7a84:	270f      	movs	r7, #15
    7a86:	7819      	ldrb	r1, [r3, #0]
    7a88:	4311      	orrs	r1, r2
    7a8a:	7019      	strb	r1, [r3, #0]
    7a8c:	2101      	movs	r1, #1
    7a8e:	7818      	ldrb	r0, [r3, #0]
    7a90:	4308      	orrs	r0, r1
    7a92:	7018      	strb	r0, [r3, #0]
    7a94:	2303      	movs	r3, #3
    7a96:	4822      	ldr	r0, [pc, #136]	; (7b20 <uart_init+0xac>)
    7a98:	7804      	ldrb	r4, [r0, #0]
    7a9a:	43bc      	bics	r4, r7
    7a9c:	4323      	orrs	r3, r4
    7a9e:	7003      	strb	r3, [r0, #0]
HAL_GPIO_PIN(UART_RX,   A, 31)
    7aa0:	2380      	movs	r3, #128	; 0x80
    7aa2:	061b      	lsls	r3, r3, #24
    7aa4:	606b      	str	r3, [r5, #4]
    7aa6:	469c      	mov	ip, r3
    7aa8:	4b1e      	ldr	r3, [pc, #120]	; (7b24 <uart_init+0xb0>)
    7aaa:	781c      	ldrb	r4, [r3, #0]
    7aac:	4314      	orrs	r4, r2
    7aae:	701c      	strb	r4, [r3, #0]
    7ab0:	2404      	movs	r4, #4
    7ab2:	781e      	ldrb	r6, [r3, #0]
    7ab4:	43a6      	bics	r6, r4
    7ab6:	701e      	strb	r6, [r3, #0]
    7ab8:	4666      	mov	r6, ip
    7aba:	61ae      	str	r6, [r5, #24]
    7abc:	781d      	ldrb	r5, [r3, #0]
    7abe:	4325      	orrs	r5, r4
    7ac0:	701d      	strb	r5, [r3, #0]
    7ac2:	781d      	ldrb	r5, [r3, #0]
    7ac4:	430d      	orrs	r5, r1
    7ac6:	701d      	strb	r5, [r3, #0]
    7ac8:	7803      	ldrb	r3, [r0, #0]
    7aca:	403b      	ands	r3, r7
    7acc:	3721      	adds	r7, #33	; 0x21
    7ace:	431f      	orrs	r7, r3
    7ad0:	7007      	strb	r7, [r0, #0]
    HAL_GPIO_UART_TX_pmuxen(PORT_PMUX_PMUXE_D_Val);
    HAL_GPIO_UART_RX_in();
    HAL_GPIO_UART_RX_pullup();
    HAL_GPIO_UART_RX_pmuxen(PORT_PMUX_PMUXE_D_Val);
    
    if(onoff==0){
    7ad2:	9d01      	ldr	r5, [sp, #4]
    7ad4:	4b14      	ldr	r3, [pc, #80]	; (7b28 <uart_init+0xb4>)
    7ad6:	2008      	movs	r0, #8
    7ad8:	2d00      	cmp	r5, #0
    7ada:	d103      	bne.n	7ae4 <uart_init+0x70>
        PM->APBCMASK.reg &= ~PM_APBCMASK_SERCOM1;
    7adc:	6a1a      	ldr	r2, [r3, #32]
    7ade:	4382      	bics	r2, r0
    7ae0:	621a      	str	r2, [r3, #32]
#else
        print_info=false;
        print_debug=false;
#endif
    }    
}
    7ae2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        PM->APBCMASK.reg |= PM_APBCMASK_SERCOM1;
    7ae4:	6a1d      	ldr	r5, [r3, #32]
    7ae6:	4328      	orrs	r0, r5
    7ae8:	6218      	str	r0, [r3, #32]
        GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM1_GCLK_ID_CORE) |
    7aea:	4810      	ldr	r0, [pc, #64]	; (7b2c <uart_init+0xb8>)
    7aec:	4b10      	ldr	r3, [pc, #64]	; (7b30 <uart_init+0xbc>)
    7aee:	8058      	strh	r0, [r3, #2]
        SERCOM1->USART.CTRLA.reg =
    7af0:	4b10      	ldr	r3, [pc, #64]	; (7b34 <uart_init+0xc0>)
    7af2:	4811      	ldr	r0, [pc, #68]	; (7b38 <uart_init+0xc4>)
    7af4:	6018      	str	r0, [r3, #0]
        SERCOM1->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | SERCOM_USART_CTRLB_TXEN |
    7af6:	20c0      	movs	r0, #192	; 0xc0
    7af8:	0280      	lsls	r0, r0, #10
    7afa:	6058      	str	r0, [r3, #4]
        SERCOM1->USART.BAUD.reg = (uint16_t)br+1;
    7afc:	480f      	ldr	r0, [pc, #60]	; (7b3c <uart_init+0xc8>)
    7afe:	8158      	strh	r0, [r3, #10]
        SERCOM1->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    7b00:	735c      	strb	r4, [r3, #13]
        SERCOM1->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    7b02:	6818      	ldr	r0, [r3, #0]
    7b04:	4302      	orrs	r2, r0
    7b06:	601a      	str	r2, [r3, #0]
    7b08:	2280      	movs	r2, #128	; 0x80
    7b0a:	4b0d      	ldr	r3, [pc, #52]	; (7b40 <uart_init+0xcc>)
    7b0c:	0052      	lsls	r2, r2, #1
    7b0e:	601a      	str	r2, [r3, #0]
        print_info=true;
    7b10:	4b0c      	ldr	r3, [pc, #48]	; (7b44 <uart_init+0xd0>)
    7b12:	7019      	strb	r1, [r3, #0]
        print_debug=true;
    7b14:	7059      	strb	r1, [r3, #1]
}
    7b16:	e7e4      	b.n	7ae2 <uart_init+0x6e>
    7b18:	41004400 	.word	0x41004400
    7b1c:	4100445e 	.word	0x4100445e
    7b20:	4100443f 	.word	0x4100443f
    7b24:	4100445f 	.word	0x4100445f
    7b28:	40000400 	.word	0x40000400
    7b2c:	0000400e 	.word	0x0000400e
    7b30:	40000c00 	.word	0x40000c00
    7b34:	42000c00 	.word	0x42000c00
    7b38:	40310004 	.word	0x40310004
    7b3c:	ffffc505 	.word	0xffffc505
    7b40:	e000e100 	.word	0xe000e100
    7b44:	200008a7 	.word	0x200008a7

00007b48 <uart_putc>:

//-----------------------------------------------------------------------------
void uart_putc(char c)
{
    while (!(SERCOM1->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE));
    7b48:	2201      	movs	r2, #1
    7b4a:	4b03      	ldr	r3, [pc, #12]	; (7b58 <uart_putc+0x10>)
    7b4c:	7b99      	ldrb	r1, [r3, #14]
    7b4e:	4211      	tst	r1, r2
    7b50:	d0fc      	beq.n	7b4c <uart_putc+0x4>
    SERCOM1->USART.DATA.reg = c;
    7b52:	b280      	uxth	r0, r0
    7b54:	8318      	strh	r0, [r3, #24]
}
    7b56:	4770      	bx	lr
    7b58:	42000c00 	.word	0x42000c00

00007b5c <uart_puts>:

//-----------------------------------------------------------------------------
void uart_puts(char *s)
{
    7b5c:	b510      	push	{r4, lr}
    7b5e:	0004      	movs	r4, r0
    while (*s) uart_putc(*s++);
    7b60:	7820      	ldrb	r0, [r4, #0]
    7b62:	2800      	cmp	r0, #0
    7b64:	d100      	bne.n	7b68 <uart_puts+0xc>
}
    7b66:	bd10      	pop	{r4, pc}
    while (*s) uart_putc(*s++);
    7b68:	4b01      	ldr	r3, [pc, #4]	; (7b70 <uart_puts+0x14>)
    7b6a:	3401      	adds	r4, #1
    7b6c:	4798      	blx	r3
    7b6e:	e7f7      	b.n	7b60 <uart_puts+0x4>
    7b70:	00007b49 	.word	0x00007b49

00007b74 <uart_puts_info>:


void uart_puts_info(char *s)
{
    if(print_info) { while (*s) uart_putc(*s++); }
    7b74:	4b06      	ldr	r3, [pc, #24]	; (7b90 <uart_puts_info+0x1c>)
{
    7b76:	b510      	push	{r4, lr}
    if(print_info) { while (*s) uart_putc(*s++); }
    7b78:	781b      	ldrb	r3, [r3, #0]
{
    7b7a:	0004      	movs	r4, r0
    if(print_info) { while (*s) uart_putc(*s++); }
    7b7c:	2b00      	cmp	r3, #0
    7b7e:	d103      	bne.n	7b88 <uart_puts_info+0x14>
}
    7b80:	bd10      	pop	{r4, pc}
    if(print_info) { while (*s) uart_putc(*s++); }
    7b82:	4b04      	ldr	r3, [pc, #16]	; (7b94 <uart_puts_info+0x20>)
    7b84:	3401      	adds	r4, #1
    7b86:	4798      	blx	r3
    7b88:	7820      	ldrb	r0, [r4, #0]
    7b8a:	2800      	cmp	r0, #0
    7b8c:	d1f9      	bne.n	7b82 <uart_puts_info+0xe>
    7b8e:	e7f7      	b.n	7b80 <uart_puts_info+0xc>
    7b90:	200008a7 	.word	0x200008a7
    7b94:	00007b49 	.word	0x00007b49

00007b98 <uart_print>:

void uart_print(const uint8_t ch, const char *fmt, ...)
{
    7b98:	b40e      	push	{r1, r2, r3}
    7b9a:	b500      	push	{lr}
    7b9c:	b0b4      	sub	sp, #208	; 0xd0
    char buf[200];
    if(ch==MSG_INFO && print_info==false) return;
    7b9e:	2801      	cmp	r0, #1
    7ba0:	d110      	bne.n	7bc4 <uart_print+0x2c>
    7ba2:	4b0b      	ldr	r3, [pc, #44]	; (7bd0 <uart_print+0x38>)
    7ba4:	781b      	ldrb	r3, [r3, #0]
    if(ch==MSG_DEBUG && print_debug==false) return;
    7ba6:	2b00      	cmp	r3, #0
    7ba8:	d008      	beq.n	7bbc <uart_print+0x24>
      
    va_list args;
    va_start(args,fmt);
    7baa:	aa36      	add	r2, sp, #216	; 0xd8
    vsprintf(buf,fmt,args);
    7bac:	4b09      	ldr	r3, [pc, #36]	; (7bd4 <uart_print+0x3c>)
    va_start(args,fmt);
    7bae:	9201      	str	r2, [sp, #4]
    vsprintf(buf,fmt,args);
    7bb0:	9935      	ldr	r1, [sp, #212]	; 0xd4
    7bb2:	a802      	add	r0, sp, #8
    7bb4:	4798      	blx	r3
    uart_puts(buf);
    7bb6:	a802      	add	r0, sp, #8
    7bb8:	4b07      	ldr	r3, [pc, #28]	; (7bd8 <uart_print+0x40>)
    7bba:	4798      	blx	r3
    va_end(args);
}
    7bbc:	b034      	add	sp, #208	; 0xd0
    7bbe:	bc08      	pop	{r3}
    7bc0:	b003      	add	sp, #12
    7bc2:	4718      	bx	r3
    if(ch==MSG_DEBUG && print_debug==false) return;
    7bc4:	2802      	cmp	r0, #2
    7bc6:	d1f0      	bne.n	7baa <uart_print+0x12>
    7bc8:	4b01      	ldr	r3, [pc, #4]	; (7bd0 <uart_print+0x38>)
    7bca:	785b      	ldrb	r3, [r3, #1]
    7bcc:	e7eb      	b.n	7ba6 <uart_print+0xe>
    7bce:	46c0      	nop			; (mov r8, r8)
    7bd0:	200008a7 	.word	0x200008a7
    7bd4:	00008ded 	.word	0x00008ded
    7bd8:	00007b5d 	.word	0x00007b5d

00007bdc <uart_get_print_info>:

bool uart_get_print_info(void)
{
    return print_info;
    7bdc:	4b01      	ldr	r3, [pc, #4]	; (7be4 <uart_get_print_info+0x8>)
    7bde:	7818      	ldrb	r0, [r3, #0]
}
    7be0:	4770      	bx	lr
    7be2:	46c0      	nop			; (mov r8, r8)
    7be4:	200008a7 	.word	0x200008a7

00007be8 <uart_set_print_info>:

void uart_set_print_info(bool b)
{
    print_info=b;
    7be8:	4b01      	ldr	r3, [pc, #4]	; (7bf0 <uart_set_print_info+0x8>)
    7bea:	7018      	strb	r0, [r3, #0]
    7bec:	4770      	bx	lr
    7bee:	46c0      	nop			; (mov r8, r8)
    7bf0:	200008a7 	.word	0x200008a7

00007bf4 <delay_us>:
#include <string.h>

void delay_us(unsigned long us)
{
	unsigned long cnt;
	for(cnt=0;cnt<(us);cnt++) asm volatile ("nop"); // roughly microseconds
    7bf4:	2300      	movs	r3, #0
    7bf6:	4283      	cmp	r3, r0
    7bf8:	d100      	bne.n	7bfc <delay_us+0x8>
}
    7bfa:	4770      	bx	lr
	for(cnt=0;cnt<(us);cnt++) asm volatile ("nop"); // roughly microseconds
    7bfc:	46c0      	nop			; (mov r8, r8)
    7bfe:	3301      	adds	r3, #1
    7c00:	e7f9      	b.n	7bf6 <delay_us+0x2>
	...

00007c04 <delay_ms>:

void delay_ms(unsigned long ms)
{
#define DELAY_1ms (850)  // 1/F_CPU * 850   (F_CPU=8e6) (measured with oscilloscope)
	unsigned long cnt;
	for(cnt=0;cnt<(DELAY_1ms*ms);cnt++) asm volatile ("nop");
    7c04:	4b04      	ldr	r3, [pc, #16]	; (7c18 <delay_ms+0x14>)
    7c06:	4358      	muls	r0, r3
    7c08:	2300      	movs	r3, #0
    7c0a:	4283      	cmp	r3, r0
    7c0c:	d100      	bne.n	7c10 <delay_ms+0xc>
}
    7c0e:	4770      	bx	lr
	for(cnt=0;cnt<(DELAY_1ms*ms);cnt++) asm volatile ("nop");
    7c10:	46c0      	nop			; (mov r8, r8)
    7c12:	3301      	adds	r3, #1
    7c14:	e7f9      	b.n	7c0a <delay_ms+0x6>
    7c16:	46c0      	nop			; (mov r8, r8)
    7c18:	00000352 	.word	0x00000352

00007c1c <is_digit>:

char is_digit(char c)
{
	if(c&0xc0) return 0;
    7c1c:	0001      	movs	r1, r0
{
    7c1e:	0003      	movs	r3, r0
	if(c&0xc0) return 0;
    7c20:	223f      	movs	r2, #63	; 0x3f
    7c22:	2000      	movs	r0, #0
    7c24:	4391      	bics	r1, r2
    7c26:	4281      	cmp	r1, r0
    7c28:	d105      	bne.n	7c36 <is_digit+0x1a>
	if(c<0x30) return 0;
    7c2a:	2209      	movs	r2, #9
    7c2c:	3b30      	subs	r3, #48	; 0x30
    7c2e:	b2db      	uxtb	r3, r3
    7c30:	429a      	cmp	r2, r3
    7c32:	4140      	adcs	r0, r0
    7c34:	b2c0      	uxtb	r0, r0
	if(c>0x39) return 0;
	return 1;
}
    7c36:	4770      	bx	lr

00007c38 <decrypt_digits>:
};

const uint8_t digitlut[] = {1, 7, 2, 6, 4, 0, 9, 8, 5, 3};

void decrypt_digits(char *code_str)
{
    7c38:	b530      	push	{r4, r5, lr}
    7c3a:	0004      	movs	r4, r0
	int i,c;
	for(i=0;i<14;i++) {
		for(c=0;c<10;c++) {
			if(code_str[i] == (digitlut[c]+'0')) break;
    7c3c:	4d08      	ldr	r5, [pc, #32]	; (7c60 <decrypt_digits+0x28>)
    7c3e:	340e      	adds	r4, #14
    7c40:	2300      	movs	r3, #0
    7c42:	7801      	ldrb	r1, [r0, #0]
    7c44:	5d5a      	ldrb	r2, [r3, r5]
    7c46:	3230      	adds	r2, #48	; 0x30
    7c48:	4291      	cmp	r1, r2
    7c4a:	d002      	beq.n	7c52 <decrypt_digits+0x1a>
		for(c=0;c<10;c++) {
    7c4c:	3301      	adds	r3, #1
    7c4e:	2b0a      	cmp	r3, #10
    7c50:	d1f8      	bne.n	7c44 <decrypt_digits+0xc>
		}
		code_str[i]=c+'0';
    7c52:	3330      	adds	r3, #48	; 0x30
    7c54:	7003      	strb	r3, [r0, #0]
    7c56:	3001      	adds	r0, #1
	for(i=0;i<14;i++) {
    7c58:	42a0      	cmp	r0, r4
    7c5a:	d1f1      	bne.n	7c40 <decrypt_digits+0x8>
	}
}
    7c5c:	bd30      	pop	{r4, r5, pc}
    7c5e:	46c0      	nop			; (mov r8, r8)
    7c60:	0000ba7a 	.word	0x0000ba7a

00007c64 <decode_rcode>:
int decode_rcode(char *code_str, uint8_t *seq, uint32_t *id, uint16_t *days)
{
    7c64:	b5f0      	push	{r4, r5, r6, r7, lr}
    7c66:	0005      	movs	r5, r0
    7c68:	b093      	sub	sp, #76	; 0x4c
    7c6a:	9304      	str	r3, [sp, #16]
	int i;
	char str[16];
	char str1[16];
	char str2[16];

	decrypt_digits(code_str);
    7c6c:	4b32      	ldr	r3, [pc, #200]	; (7d38 <decode_rcode+0xd4>)
{
    7c6e:	9102      	str	r1, [sp, #8]
    7c70:	9203      	str	r2, [sp, #12]
	decrypt_digits(code_str);
    7c72:	4798      	blx	r3

	seqcode = strtoul(&code_str[12],NULL,10);
    7c74:	0028      	movs	r0, r5
    7c76:	4b31      	ldr	r3, [pc, #196]	; (7d3c <decode_rcode+0xd8>)
    7c78:	300c      	adds	r0, #12
    7c7a:	220a      	movs	r2, #10
    7c7c:	2100      	movs	r1, #0
    7c7e:	4798      	blx	r3
    7c80:	b2c3      	uxtb	r3, r0
    7c82:	0004      	movs	r4, r0
    7c84:	9301      	str	r3, [sp, #4]
	if(seqcode < 0 || seqcode > 99) {
    7c86:	2b63      	cmp	r3, #99	; 0x63
    7c88:	d852      	bhi.n	7d30 <decode_rcode+0xcc>
		return -1; // bad sequence number
	}
	strcpy(str,code_str);
	str[12]='\0';
    7c8a:	2700      	movs	r7, #0
	strcpy(str,code_str);
    7c8c:	0029      	movs	r1, r5
    7c8e:	a806      	add	r0, sp, #24
    7c90:	4e2b      	ldr	r6, [pc, #172]	; (7d40 <decode_rcode+0xdc>)
    7c92:	47b0      	blx	r6
	str[12]='\0';
    7c94:	ab06      	add	r3, sp, #24
    7c96:	731f      	strb	r7, [r3, #12]
	// rol <<
	for(i=0;i<seqcode;i++) {
    7c98:	b2e3      	uxtb	r3, r4
    7c9a:	9305      	str	r3, [sp, #20]
    7c9c:	9b05      	ldr	r3, [sp, #20]
    7c9e:	429f      	cmp	r7, r3
    7ca0:	db2b      	blt.n	7cfa <decode_rcode+0x96>
    7ca2:	2300      	movs	r3, #0
		strcpy(str,str2);
		strcat(str,str1);
	}
	
	for(seqc=0;seqc<100;seqc++) {
		if(seqcode==seqlut[seqc]) break;
    7ca4:	4a27      	ldr	r2, [pc, #156]	; (7d44 <decode_rcode+0xe0>)
    7ca6:	320a      	adds	r2, #10
    7ca8:	5c98      	ldrb	r0, [r3, r2]
    7caa:	9c01      	ldr	r4, [sp, #4]
    7cac:	b2d9      	uxtb	r1, r3
    7cae:	42a0      	cmp	r0, r4
    7cb0:	d003      	beq.n	7cba <decode_rcode+0x56>
    7cb2:	3301      	adds	r3, #1
	for(seqc=0;seqc<100;seqc++) {
    7cb4:	2b64      	cmp	r3, #100	; 0x64
    7cb6:	d1f7      	bne.n	7ca8 <decode_rcode+0x44>
    7cb8:	0019      	movs	r1, r3
	}
	*seq=seqc;
    7cba:	9b02      	ldr	r3, [sp, #8]

	strcpy(str1,str);
    7cbc:	ac0a      	add	r4, sp, #40	; 0x28
	*seq=seqc;
    7cbe:	7019      	strb	r1, [r3, #0]
	strcpy(str1,str);
    7cc0:	0020      	movs	r0, r4
    7cc2:	a906      	add	r1, sp, #24
	strcpy(str2,str);
    7cc4:	ad0e      	add	r5, sp, #56	; 0x38
	strcpy(str1,str);
    7cc6:	47b0      	blx	r6
	strcpy(str2,str);
    7cc8:	a906      	add	r1, sp, #24
    7cca:	0028      	movs	r0, r5
    7ccc:	47b0      	blx	r6
	// 123456789012
	// 0        9
	str1[9]='\0';
    7cce:	2600      	movs	r6, #0
	str2[8]=' ';
    7cd0:	2320      	movs	r3, #32
	str1[9]='\0';
    7cd2:	7266      	strb	r6, [r4, #9]

	*id = strtoul(str1,NULL,10);
    7cd4:	220a      	movs	r2, #10
    7cd6:	0031      	movs	r1, r6
    7cd8:	0020      	movs	r0, r4
    7cda:	4c18      	ldr	r4, [pc, #96]	; (7d3c <decode_rcode+0xd8>)
	str2[8]=' ';
    7cdc:	722b      	strb	r3, [r5, #8]
	*id = strtoul(str1,NULL,10);
    7cde:	47a0      	blx	r4
    7ce0:	9b03      	ldr	r3, [sp, #12]
	*days = strtoul(&str2[9],NULL,10);
    7ce2:	220a      	movs	r2, #10
	*id = strtoul(str1,NULL,10);
    7ce4:	6018      	str	r0, [r3, #0]
	*days = strtoul(&str2[9],NULL,10);
    7ce6:	2029      	movs	r0, #41	; 0x29
    7ce8:	ab06      	add	r3, sp, #24
    7cea:	18c0      	adds	r0, r0, r3
    7cec:	0031      	movs	r1, r6
    7cee:	47a0      	blx	r4
    7cf0:	9b04      	ldr	r3, [sp, #16]
    7cf2:	8018      	strh	r0, [r3, #0]
	return 1;
    7cf4:	2001      	movs	r0, #1
}
    7cf6:	b013      	add	sp, #76	; 0x4c
    7cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strncpy(str1,str,1); // take most left digit
    7cfa:	ac0a      	add	r4, sp, #40	; 0x28
    7cfc:	2201      	movs	r2, #1
    7cfe:	a906      	add	r1, sp, #24
    7d00:	4b11      	ldr	r3, [pc, #68]	; (7d48 <decode_rcode+0xe4>)
    7d02:	0020      	movs	r0, r4
    7d04:	4798      	blx	r3
		str1[1]='\0';
    7d06:	2300      	movs	r3, #0
		strncpy(str2,&str[1],11); // take other right digits
    7d08:	ad0e      	add	r5, sp, #56	; 0x38
		str1[1]='\0';
    7d0a:	7063      	strb	r3, [r4, #1]
		strncpy(str2,&str[1],11); // take other right digits
    7d0c:	ab06      	add	r3, sp, #24
    7d0e:	220b      	movs	r2, #11
    7d10:	1c59      	adds	r1, r3, #1
    7d12:	0028      	movs	r0, r5
    7d14:	4b0c      	ldr	r3, [pc, #48]	; (7d48 <decode_rcode+0xe4>)
    7d16:	4798      	blx	r3
		str2[11]='\0';
    7d18:	2300      	movs	r3, #0
		strcpy(str,str2);
    7d1a:	0029      	movs	r1, r5
		str2[11]='\0';
    7d1c:	72eb      	strb	r3, [r5, #11]
		strcpy(str,str2);
    7d1e:	a806      	add	r0, sp, #24
    7d20:	4b07      	ldr	r3, [pc, #28]	; (7d40 <decode_rcode+0xdc>)
    7d22:	4798      	blx	r3
		strcat(str,str1);
    7d24:	0021      	movs	r1, r4
    7d26:	a806      	add	r0, sp, #24
    7d28:	4b08      	ldr	r3, [pc, #32]	; (7d4c <decode_rcode+0xe8>)
    7d2a:	4798      	blx	r3
	for(i=0;i<seqcode;i++) {
    7d2c:	3701      	adds	r7, #1
    7d2e:	e7b5      	b.n	7c9c <decode_rcode+0x38>
		return -1; // bad sequence number
    7d30:	2001      	movs	r0, #1
    7d32:	4240      	negs	r0, r0
    7d34:	e7df      	b.n	7cf6 <decode_rcode+0x92>
    7d36:	46c0      	nop			; (mov r8, r8)
    7d38:	00007c39 	.word	0x00007c39
    7d3c:	00008d95 	.word	0x00008d95
    7d40:	00008a2f 	.word	0x00008a2f
    7d44:	0000ba7a 	.word	0x0000ba7a
    7d48:	00008ab7 	.word	0x00008ab7
    7d4c:	00008a01 	.word	0x00008a01

00007d50 <wdt_reset>:
extern uint8_t wdt_wakeup;
 
void wdt_reset() {
    // Write the watchdog clear key value (0xA5) to the watchdog
    // clear register to clear the watchdog timer and reset it.
    WDT->CLEAR.reg = WDT_CLEAR_CLEAR_KEY;
    7d50:	22a5      	movs	r2, #165	; 0xa5
    7d52:	4b03      	ldr	r3, [pc, #12]	; (7d60 <wdt_reset+0x10>)
    7d54:	721a      	strb	r2, [r3, #8]
    while(WDT->STATUS.bit.SYNCBUSY);
    7d56:	79da      	ldrb	r2, [r3, #7]
    7d58:	09d2      	lsrs	r2, r2, #7
    7d5a:	d1fc      	bne.n	7d56 <wdt_reset+0x6>
}
    7d5c:	4770      	bx	lr
    7d5e:	46c0      	nop			; (mov r8, r8)
    7d60:	40001000 	.word	0x40001000

00007d64 <wdt_enable>:
    //   http://www.atmel.com/images/atmel-42181-sam-d21_datasheet.pdf

    int     cycles, actualMS;
    uint8_t bits;

    WDT->CTRL.reg = 0; // Disable watchdog for config
    7d64:	2300      	movs	r3, #0
int wdt_enable(int maxPeriodMS, bool isForSleep) {
    7d66:	b570      	push	{r4, r5, r6, lr}
    7d68:	000d      	movs	r5, r1
    WDT->CTRL.reg = 0; // Disable watchdog for config
    7d6a:	4c48      	ldr	r4, [pc, #288]	; (7e8c <wdt_enable+0x128>)
    7d6c:	7023      	strb	r3, [r4, #0]
    while(WDT->STATUS.bit.SYNCBUSY);
    7d6e:	79e3      	ldrb	r3, [r4, #7]
    7d70:	09db      	lsrs	r3, r3, #7
    7d72:	d1fc      	bne.n	7d6e <wdt_enable+0xa>
    // You'll see some occasional conversion here compensating between
    // milliseconds (1000 Hz) and WDT clock cycles (~1024 Hz).  The low-
    // power oscillator used by the WDT ostensibly runs at 32,768 Hz with
    // a 1:32 prescale, thus 1024 Hz, though probably not super precise.

    if((maxPeriodMS >= 16000) || !maxPeriodMS) {
    7d74:	4b46      	ldr	r3, [pc, #280]	; (7e90 <wdt_enable+0x12c>)
    7d76:	4298      	cmp	r0, r3
    7d78:	dc4f      	bgt.n	7e1a <wdt_enable+0xb6>
    7d7a:	2800      	cmp	r0, #0
    7d7c:	d04d      	beq.n	7e1a <wdt_enable+0xb6>
        cycles = 16384;
        bits   = 0xB;
    } else {
        cycles = (maxPeriodMS * 1024L + 500) / 1000; // ms -> WDT cycles
    7d7e:	21fa      	movs	r1, #250	; 0xfa
    7d80:	0280      	lsls	r0, r0, #10
    7d82:	30f5      	adds	r0, #245	; 0xf5
    7d84:	4b43      	ldr	r3, [pc, #268]	; (7e94 <wdt_enable+0x130>)
    7d86:	30ff      	adds	r0, #255	; 0xff
    7d88:	0089      	lsls	r1, r1, #2
    7d8a:	4798      	blx	r3
        if(cycles >= 8192) {
    7d8c:	4b42      	ldr	r3, [pc, #264]	; (7e98 <wdt_enable+0x134>)
    7d8e:	4298      	cmp	r0, r3
    7d90:	dc47      	bgt.n	7e22 <wdt_enable+0xbe>
            cycles = 8192;
            bits   = 0xA;
        } else if(cycles >= 4096) {
    7d92:	4b42      	ldr	r3, [pc, #264]	; (7e9c <wdt_enable+0x138>)
    7d94:	4298      	cmp	r0, r3
    7d96:	dc48      	bgt.n	7e2a <wdt_enable+0xc6>
            cycles = 4096;
            bits   = 0x9;
        } else if(cycles >= 2048) {
    7d98:	4b41      	ldr	r3, [pc, #260]	; (7ea0 <wdt_enable+0x13c>)
    7d9a:	4298      	cmp	r0, r3
    7d9c:	dc49      	bgt.n	7e32 <wdt_enable+0xce>
            cycles = 2048;
            bits   = 0x8;
        } else if(cycles >= 1024) {
    7d9e:	4b41      	ldr	r3, [pc, #260]	; (7ea4 <wdt_enable+0x140>)
    7da0:	4298      	cmp	r0, r3
    7da2:	dc4a      	bgt.n	7e3a <wdt_enable+0xd6>
            cycles = 1024;
            bits   = 0x7;
        } else if(cycles >= 512) {
    7da4:	4b40      	ldr	r3, [pc, #256]	; (7ea8 <wdt_enable+0x144>)
    7da6:	4298      	cmp	r0, r3
    7da8:	dc4b      	bgt.n	7e42 <wdt_enable+0xde>
            cycles = 512;
            bits   = 0x6;
        } else if(cycles >= 256) {
    7daa:	28ff      	cmp	r0, #255	; 0xff
    7dac:	dc4d      	bgt.n	7e4a <wdt_enable+0xe6>
            cycles = 256;
            bits   = 0x5;
        } else if(cycles >= 128) {
    7dae:	287f      	cmp	r0, #127	; 0x7f
    7db0:	dc4f      	bgt.n	7e52 <wdt_enable+0xee>
            cycles = 128;
            bits   = 0x4;
        } else if(cycles >= 64) {
    7db2:	283f      	cmp	r0, #63	; 0x3f
    7db4:	dc50      	bgt.n	7e58 <wdt_enable+0xf4>
            cycles = 64;
            bits   = 0x3;
        } else if(cycles >= 32) {
    7db6:	281f      	cmp	r0, #31
    7db8:	dc51      	bgt.n	7e5e <wdt_enable+0xfa>
            cycles = 32;
            bits   = 0x2;
        } else if(cycles >= 16) {
    7dba:	280f      	cmp	r0, #15
    7dbc:	dc52      	bgt.n	7e64 <wdt_enable+0x100>
            cycles = 16;
            bits   = 0x1;
        } else {
            cycles = 8;
            bits   = 0x0;
    7dbe:	2300      	movs	r3, #0
            cycles = 8;
    7dc0:	2208      	movs	r2, #8
    7dc2:	2101      	movs	r1, #1
    // this isn't present in the AVR code, just here.  It defaults to
    // 'false' so existing Arduino code works as normal, while the sleep()
    // function (later in this file) explicitly passes 'true' to get the
    // alternate behavior.

    if(isForSleep) {
    7dc4:	2d00      	cmp	r5, #0
    7dc6:	d050      	beq.n	7e6a <wdt_enable+0x106>
        WDT->INTENSET.bit.EW   = 1;      // Enable early warning interrupt
    7dc8:	7960      	ldrb	r0, [r4, #5]
        WDT->CONFIG.bit.PER    = 0xB;    // Period = max
    7dca:	250f      	movs	r5, #15
        WDT->INTENSET.bit.EW   = 1;      // Enable early warning interrupt
    7dcc:	4301      	orrs	r1, r0
    7dce:	7161      	strb	r1, [r4, #5]
        WDT->CONFIG.bit.PER    = 0xB;    // Period = max
    7dd0:	210b      	movs	r1, #11
    7dd2:	7860      	ldrb	r0, [r4, #1]
        WDT->CONFIG.bit.WINDOW = bits;   // Set time of interrupt
    7dd4:	402b      	ands	r3, r5
        WDT->CONFIG.bit.PER    = 0xB;    // Period = max
    7dd6:	43a8      	bics	r0, r5
    7dd8:	4301      	orrs	r1, r0
    7dda:	7061      	strb	r1, [r4, #1]
        WDT->CONFIG.bit.WINDOW = bits;   // Set time of interrupt
    7ddc:	7861      	ldrb	r1, [r4, #1]
    7dde:	0118      	lsls	r0, r3, #4
    7de0:	000b      	movs	r3, r1
    7de2:	402b      	ands	r3, r5
    7de4:	4303      	orrs	r3, r0
    7de6:	7063      	strb	r3, [r4, #1]
        WDT->CTRL.bit.WEN      = 1;      // Enable window mode
    7de8:	2304      	movs	r3, #4
    7dea:	7821      	ldrb	r1, [r4, #0]
    7dec:	430b      	orrs	r3, r1
    7dee:	7023      	strb	r3, [r4, #0]
        while(WDT->STATUS.bit.SYNCBUSY); // Sync CTRL write
    7df0:	79e3      	ldrb	r3, [r4, #7]
    7df2:	09db      	lsrs	r3, r3, #7
    7df4:	d1fc      	bne.n	7df0 <wdt_enable+0x8c>
        WDT->CONFIG.bit.PER    = bits;   // Set period for chip reset
        WDT->CTRL.bit.WEN      = 0;      // Disable window mode
        while(WDT->STATUS.bit.SYNCBUSY); // Sync CTRL write
    }

    actualMS = (cycles * 1000L + 512) / 1024; // WDT cycles -> ms
    7df6:	25fa      	movs	r5, #250	; 0xfa
    7df8:	2380      	movs	r3, #128	; 0x80
    7dfa:	00ad      	lsls	r5, r5, #2
    7dfc:	4355      	muls	r5, r2
    7dfe:	009b      	lsls	r3, r3, #2
    7e00:	18ed      	adds	r5, r5, r3

    wdt_reset();                  // Clear watchdog interval
    7e02:	4b2a      	ldr	r3, [pc, #168]	; (7eac <wdt_enable+0x148>)
    7e04:	4798      	blx	r3
    WDT->CTRL.bit.ENABLE = 1; // Start watchdog now!
    7e06:	2302      	movs	r3, #2
    7e08:	7822      	ldrb	r2, [r4, #0]
    actualMS = (cycles * 1000L + 512) / 1024; // WDT cycles -> ms
    7e0a:	12ad      	asrs	r5, r5, #10
    WDT->CTRL.bit.ENABLE = 1; // Start watchdog now!
    7e0c:	4313      	orrs	r3, r2
    7e0e:	7023      	strb	r3, [r4, #0]
    while(WDT->STATUS.bit.SYNCBUSY);
    7e10:	79e3      	ldrb	r3, [r4, #7]
    7e12:	09db      	lsrs	r3, r3, #7
    7e14:	d1fc      	bne.n	7e10 <wdt_enable+0xac>

    return actualMS;
}
    7e16:	0028      	movs	r0, r5
    7e18:	bd70      	pop	{r4, r5, r6, pc}
        cycles = 16384;
    7e1a:	2280      	movs	r2, #128	; 0x80
        bits   = 0xB;
    7e1c:	230b      	movs	r3, #11
        cycles = 16384;
    7e1e:	01d2      	lsls	r2, r2, #7
    7e20:	e7cf      	b.n	7dc2 <wdt_enable+0x5e>
            cycles = 8192;
    7e22:	2280      	movs	r2, #128	; 0x80
            bits   = 0xA;
    7e24:	230a      	movs	r3, #10
            cycles = 8192;
    7e26:	0192      	lsls	r2, r2, #6
    7e28:	e7cb      	b.n	7dc2 <wdt_enable+0x5e>
            cycles = 4096;
    7e2a:	2280      	movs	r2, #128	; 0x80
            bits   = 0x9;
    7e2c:	2309      	movs	r3, #9
            cycles = 4096;
    7e2e:	0152      	lsls	r2, r2, #5
    7e30:	e7c7      	b.n	7dc2 <wdt_enable+0x5e>
            cycles = 2048;
    7e32:	2280      	movs	r2, #128	; 0x80
            bits   = 0x8;
    7e34:	2308      	movs	r3, #8
            cycles = 2048;
    7e36:	0112      	lsls	r2, r2, #4
    7e38:	e7c3      	b.n	7dc2 <wdt_enable+0x5e>
            cycles = 1024;
    7e3a:	2280      	movs	r2, #128	; 0x80
            bits   = 0x7;
    7e3c:	2307      	movs	r3, #7
            cycles = 1024;
    7e3e:	00d2      	lsls	r2, r2, #3
    7e40:	e7bf      	b.n	7dc2 <wdt_enable+0x5e>
            cycles = 512;
    7e42:	2280      	movs	r2, #128	; 0x80
            bits   = 0x6;
    7e44:	2306      	movs	r3, #6
            cycles = 512;
    7e46:	0092      	lsls	r2, r2, #2
    7e48:	e7bb      	b.n	7dc2 <wdt_enable+0x5e>
            cycles = 256;
    7e4a:	2280      	movs	r2, #128	; 0x80
            bits   = 0x5;
    7e4c:	2305      	movs	r3, #5
            cycles = 256;
    7e4e:	0052      	lsls	r2, r2, #1
    7e50:	e7b7      	b.n	7dc2 <wdt_enable+0x5e>
            bits   = 0x4;
    7e52:	2304      	movs	r3, #4
            cycles = 128;
    7e54:	2280      	movs	r2, #128	; 0x80
    7e56:	e7b4      	b.n	7dc2 <wdt_enable+0x5e>
            bits   = 0x3;
    7e58:	2303      	movs	r3, #3
            cycles = 64;
    7e5a:	2240      	movs	r2, #64	; 0x40
    7e5c:	e7b1      	b.n	7dc2 <wdt_enable+0x5e>
            bits   = 0x2;
    7e5e:	2302      	movs	r3, #2
            cycles = 32;
    7e60:	2220      	movs	r2, #32
    7e62:	e7ae      	b.n	7dc2 <wdt_enable+0x5e>
            bits   = 0x1;
    7e64:	2301      	movs	r3, #1
            cycles = 16;
    7e66:	2210      	movs	r2, #16
    7e68:	e7ab      	b.n	7dc2 <wdt_enable+0x5e>
        WDT->INTENCLR.bit.EW   = 1;      // Disable early warning interrupt
    7e6a:	7920      	ldrb	r0, [r4, #4]
    7e6c:	4301      	orrs	r1, r0
        WDT->CONFIG.bit.PER    = bits;   // Set period for chip reset
    7e6e:	200f      	movs	r0, #15
        WDT->INTENCLR.bit.EW   = 1;      // Disable early warning interrupt
    7e70:	7121      	strb	r1, [r4, #4]
        WDT->CONFIG.bit.PER    = bits;   // Set period for chip reset
    7e72:	7861      	ldrb	r1, [r4, #1]
    7e74:	4003      	ands	r3, r0
    7e76:	4381      	bics	r1, r0
    7e78:	430b      	orrs	r3, r1
        WDT->CTRL.bit.WEN      = 0;      // Disable window mode
    7e7a:	2104      	movs	r1, #4
        WDT->CONFIG.bit.PER    = bits;   // Set period for chip reset
    7e7c:	7063      	strb	r3, [r4, #1]
        WDT->CTRL.bit.WEN      = 0;      // Disable window mode
    7e7e:	7823      	ldrb	r3, [r4, #0]
    7e80:	438b      	bics	r3, r1
    7e82:	7023      	strb	r3, [r4, #0]
        while(WDT->STATUS.bit.SYNCBUSY); // Sync CTRL write
    7e84:	79e3      	ldrb	r3, [r4, #7]
    7e86:	09db      	lsrs	r3, r3, #7
    7e88:	d1fc      	bne.n	7e84 <wdt_enable+0x120>
    7e8a:	e7b4      	b.n	7df6 <wdt_enable+0x92>
    7e8c:	40001000 	.word	0x40001000
    7e90:	00003e7f 	.word	0x00003e7f
    7e94:	0000809d 	.word	0x0000809d
    7e98:	00001fff 	.word	0x00001fff
    7e9c:	00000fff 	.word	0x00000fff
    7ea0:	000007ff 	.word	0x000007ff
    7ea4:	000003ff 	.word	0x000003ff
    7ea8:	000001ff 	.word	0x000001ff
    7eac:	00007d51 	.word	0x00007d51

00007eb0 <wdt_disable>:

void wdt_disable() {
    WDT->CTRL.bit.ENABLE = 0;
    7eb0:	2102      	movs	r1, #2
    7eb2:	4b04      	ldr	r3, [pc, #16]	; (7ec4 <wdt_disable+0x14>)
    7eb4:	781a      	ldrb	r2, [r3, #0]
    7eb6:	438a      	bics	r2, r1
    7eb8:	701a      	strb	r2, [r3, #0]
    while(WDT->STATUS.bit.SYNCBUSY);
    7eba:	79da      	ldrb	r2, [r3, #7]
    7ebc:	09d2      	lsrs	r2, r2, #7
    7ebe:	d1fc      	bne.n	7eba <wdt_disable+0xa>
}
    7ec0:	4770      	bx	lr
    7ec2:	46c0      	nop			; (mov r8, r8)
    7ec4:	40001000 	.word	0x40001000

00007ec8 <WDT_Handler>:

void WDT_Handler(void) {
    // ISR for watchdog early warning, DO NOT RENAME!
    WDT->CTRL.bit.ENABLE = 0;        // Disable watchdog
    7ec8:	2102      	movs	r1, #2
    7eca:	4b06      	ldr	r3, [pc, #24]	; (7ee4 <WDT_Handler+0x1c>)
    7ecc:	781a      	ldrb	r2, [r3, #0]
    7ece:	438a      	bics	r2, r1
    7ed0:	701a      	strb	r2, [r3, #0]
    while(WDT->STATUS.bit.SYNCBUSY); // Sync CTRL write
    7ed2:	79da      	ldrb	r2, [r3, #7]
    7ed4:	09d2      	lsrs	r2, r2, #7
    7ed6:	d1fc      	bne.n	7ed2 <WDT_Handler+0xa>
    WDT->INTFLAG.reg  = 1;        // Clear interrupt flag    
    7ed8:	3201      	adds	r2, #1
    7eda:	719a      	strb	r2, [r3, #6]
    wdt_wakeup=1;
    7edc:	4b02      	ldr	r3, [pc, #8]	; (7ee8 <WDT_Handler+0x20>)
    7ede:	701a      	strb	r2, [r3, #0]
}
    7ee0:	4770      	bx	lr
    7ee2:	46c0      	nop			; (mov r8, r8)
    7ee4:	40001000 	.word	0x40001000
    7ee8:	20000cc5 	.word	0x20000cc5

00007eec <wdt_sleep>:

int wdt_sleep(int maxPeriodMS) {
    7eec:	b510      	push	{r4, lr}

    int actualPeriodMS = wdt_enable(maxPeriodMS, true); // true = for sleep
    7eee:	2101      	movs	r1, #1
    7ef0:	4b05      	ldr	r3, [pc, #20]	; (7f08 <wdt_sleep+0x1c>)
    7ef2:	4798      	blx	r3

    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk; // system_set_sleepmode(SYSTEM_SLEEPMODE_STANDBY); // Deepest sleep
    7ef4:	2304      	movs	r3, #4
    7ef6:	4a05      	ldr	r2, [pc, #20]	; (7f0c <wdt_sleep+0x20>)
    7ef8:	6911      	ldr	r1, [r2, #16]
    7efa:	430b      	orrs	r3, r1
    7efc:	6113      	str	r3, [r2, #16]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
    7efe:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("wfi");
    7f02:	bf30      	wfi
    __DSB(); // (Data Synchronisation Barrier)  -> finish all ongoing memory accesses
    __WFI(); // (Wait For Interrupt)
        
    // Code resumes here on wake (WDT early warning interrupt)
    return actualPeriodMS;
}
    7f04:	bd10      	pop	{r4, pc}
    7f06:	46c0      	nop			; (mov r8, r8)
    7f08:	00007d65 	.word	0x00007d65
    7f0c:	e000ed00 	.word	0xe000ed00

00007f10 <wdt_init>:
void wdt_init(void) {
    // One-time initialization of watchdog timer.
    // Insights from rickrlh and rbrucemtl in Arduino forum!

    // Generic clock generator 2, divisor = 32 (2^(DIV+1))
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(2) | GCLK_GENDIV_DIV(4);
    7f10:	4b0c      	ldr	r3, [pc, #48]	; (7f44 <wdt_init+0x34>)
    7f12:	4a0d      	ldr	r2, [pc, #52]	; (7f48 <wdt_init+0x38>)
void wdt_init(void) {
    7f14:	b510      	push	{r4, lr}
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(2) | GCLK_GENDIV_DIV(4);
    7f16:	609a      	str	r2, [r3, #8]
    // Enable clock generator 2 using low-power 32KHz oscillator.
    // With /32 divisor above, this yields 1024Hz(ish) clock.
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(2) |
    7f18:	4a0c      	ldr	r2, [pc, #48]	; (7f4c <wdt_init+0x3c>)
    7f1a:	605a      	str	r2, [r3, #4]
                        GCLK_GENCTRL_GENEN |
                        GCLK_GENCTRL_SRC_OSCULP32K |
                        GCLK_GENCTRL_DIVSEL;
    while(GCLK->STATUS.bit.SYNCBUSY);
    7f1c:	785a      	ldrb	r2, [r3, #1]
    7f1e:	09d2      	lsrs	r2, r2, #7
    7f20:	d1fc      	bne.n	7f1c <wdt_init+0xc>
    // WDT clock = clock gen 2
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_WDT |
    7f22:	4a0b      	ldr	r2, [pc, #44]	; (7f50 <wdt_init+0x40>)
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    7f24:	490b      	ldr	r1, [pc, #44]	; (7f54 <wdt_init+0x44>)
    7f26:	805a      	strh	r2, [r3, #2]
    7f28:	2204      	movs	r2, #4
    7f2a:	67ca      	str	r2, [r1, #124]	; 0x7c
  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    7f2c:	21c0      	movs	r1, #192	; 0xc0
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
    7f2e:	20c0      	movs	r0, #192	; 0xc0
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    7f30:	4b09      	ldr	r3, [pc, #36]	; (7f58 <wdt_init+0x48>)
  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
    7f32:	0049      	lsls	r1, r1, #1
    7f34:	505a      	str	r2, [r3, r1]
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
    7f36:	0080      	lsls	r0, r0, #2
    7f38:	5819      	ldr	r1, [r3, r0]
    7f3a:	4c08      	ldr	r4, [pc, #32]	; (7f5c <wdt_init+0x4c>)
    7f3c:	4021      	ands	r1, r4
    7f3e:	5019      	str	r1, [r3, r0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    7f40:	601a      	str	r2, [r3, #0]
    // Enable WDT early-warning interrupt
    NVIC_DisableIRQ(WDT_IRQn);
    NVIC_ClearPendingIRQ(WDT_IRQn);
    NVIC_SetPriority(WDT_IRQn, 0); // Top priority
    NVIC_EnableIRQ(WDT_IRQn);
}
    7f42:	bd10      	pop	{r4, pc}
    7f44:	40000c00 	.word	0x40000c00
    7f48:	00000402 	.word	0x00000402
    7f4c:	00110302 	.word	0x00110302
    7f50:	00004201 	.word	0x00004201
    7f54:	e000e104 	.word	0xe000e104
    7f58:	e000e100 	.word	0xe000e100
    7f5c:	ff00ffff 	.word	0xff00ffff

00007f60 <__gnu_thumb1_case_uqi>:
    7f60:	b402      	push	{r1}
    7f62:	4671      	mov	r1, lr
    7f64:	0849      	lsrs	r1, r1, #1
    7f66:	0049      	lsls	r1, r1, #1
    7f68:	5c09      	ldrb	r1, [r1, r0]
    7f6a:	0049      	lsls	r1, r1, #1
    7f6c:	448e      	add	lr, r1
    7f6e:	bc02      	pop	{r1}
    7f70:	4770      	bx	lr
    7f72:	46c0      	nop			; (mov r8, r8)

00007f74 <__gnu_thumb1_case_uhi>:
    7f74:	b403      	push	{r0, r1}
    7f76:	4671      	mov	r1, lr
    7f78:	0849      	lsrs	r1, r1, #1
    7f7a:	0040      	lsls	r0, r0, #1
    7f7c:	0049      	lsls	r1, r1, #1
    7f7e:	5a09      	ldrh	r1, [r1, r0]
    7f80:	0049      	lsls	r1, r1, #1
    7f82:	448e      	add	lr, r1
    7f84:	bc03      	pop	{r0, r1}
    7f86:	4770      	bx	lr

00007f88 <__udivsi3>:
    7f88:	2200      	movs	r2, #0
    7f8a:	0843      	lsrs	r3, r0, #1
    7f8c:	428b      	cmp	r3, r1
    7f8e:	d374      	bcc.n	807a <__udivsi3+0xf2>
    7f90:	0903      	lsrs	r3, r0, #4
    7f92:	428b      	cmp	r3, r1
    7f94:	d35f      	bcc.n	8056 <__udivsi3+0xce>
    7f96:	0a03      	lsrs	r3, r0, #8
    7f98:	428b      	cmp	r3, r1
    7f9a:	d344      	bcc.n	8026 <__udivsi3+0x9e>
    7f9c:	0b03      	lsrs	r3, r0, #12
    7f9e:	428b      	cmp	r3, r1
    7fa0:	d328      	bcc.n	7ff4 <__udivsi3+0x6c>
    7fa2:	0c03      	lsrs	r3, r0, #16
    7fa4:	428b      	cmp	r3, r1
    7fa6:	d30d      	bcc.n	7fc4 <__udivsi3+0x3c>
    7fa8:	22ff      	movs	r2, #255	; 0xff
    7faa:	0209      	lsls	r1, r1, #8
    7fac:	ba12      	rev	r2, r2
    7fae:	0c03      	lsrs	r3, r0, #16
    7fb0:	428b      	cmp	r3, r1
    7fb2:	d302      	bcc.n	7fba <__udivsi3+0x32>
    7fb4:	1212      	asrs	r2, r2, #8
    7fb6:	0209      	lsls	r1, r1, #8
    7fb8:	d065      	beq.n	8086 <__udivsi3+0xfe>
    7fba:	0b03      	lsrs	r3, r0, #12
    7fbc:	428b      	cmp	r3, r1
    7fbe:	d319      	bcc.n	7ff4 <__udivsi3+0x6c>
    7fc0:	e000      	b.n	7fc4 <__udivsi3+0x3c>
    7fc2:	0a09      	lsrs	r1, r1, #8
    7fc4:	0bc3      	lsrs	r3, r0, #15
    7fc6:	428b      	cmp	r3, r1
    7fc8:	d301      	bcc.n	7fce <__udivsi3+0x46>
    7fca:	03cb      	lsls	r3, r1, #15
    7fcc:	1ac0      	subs	r0, r0, r3
    7fce:	4152      	adcs	r2, r2
    7fd0:	0b83      	lsrs	r3, r0, #14
    7fd2:	428b      	cmp	r3, r1
    7fd4:	d301      	bcc.n	7fda <__udivsi3+0x52>
    7fd6:	038b      	lsls	r3, r1, #14
    7fd8:	1ac0      	subs	r0, r0, r3
    7fda:	4152      	adcs	r2, r2
    7fdc:	0b43      	lsrs	r3, r0, #13
    7fde:	428b      	cmp	r3, r1
    7fe0:	d301      	bcc.n	7fe6 <__udivsi3+0x5e>
    7fe2:	034b      	lsls	r3, r1, #13
    7fe4:	1ac0      	subs	r0, r0, r3
    7fe6:	4152      	adcs	r2, r2
    7fe8:	0b03      	lsrs	r3, r0, #12
    7fea:	428b      	cmp	r3, r1
    7fec:	d301      	bcc.n	7ff2 <__udivsi3+0x6a>
    7fee:	030b      	lsls	r3, r1, #12
    7ff0:	1ac0      	subs	r0, r0, r3
    7ff2:	4152      	adcs	r2, r2
    7ff4:	0ac3      	lsrs	r3, r0, #11
    7ff6:	428b      	cmp	r3, r1
    7ff8:	d301      	bcc.n	7ffe <__udivsi3+0x76>
    7ffa:	02cb      	lsls	r3, r1, #11
    7ffc:	1ac0      	subs	r0, r0, r3
    7ffe:	4152      	adcs	r2, r2
    8000:	0a83      	lsrs	r3, r0, #10
    8002:	428b      	cmp	r3, r1
    8004:	d301      	bcc.n	800a <__udivsi3+0x82>
    8006:	028b      	lsls	r3, r1, #10
    8008:	1ac0      	subs	r0, r0, r3
    800a:	4152      	adcs	r2, r2
    800c:	0a43      	lsrs	r3, r0, #9
    800e:	428b      	cmp	r3, r1
    8010:	d301      	bcc.n	8016 <__udivsi3+0x8e>
    8012:	024b      	lsls	r3, r1, #9
    8014:	1ac0      	subs	r0, r0, r3
    8016:	4152      	adcs	r2, r2
    8018:	0a03      	lsrs	r3, r0, #8
    801a:	428b      	cmp	r3, r1
    801c:	d301      	bcc.n	8022 <__udivsi3+0x9a>
    801e:	020b      	lsls	r3, r1, #8
    8020:	1ac0      	subs	r0, r0, r3
    8022:	4152      	adcs	r2, r2
    8024:	d2cd      	bcs.n	7fc2 <__udivsi3+0x3a>
    8026:	09c3      	lsrs	r3, r0, #7
    8028:	428b      	cmp	r3, r1
    802a:	d301      	bcc.n	8030 <__udivsi3+0xa8>
    802c:	01cb      	lsls	r3, r1, #7
    802e:	1ac0      	subs	r0, r0, r3
    8030:	4152      	adcs	r2, r2
    8032:	0983      	lsrs	r3, r0, #6
    8034:	428b      	cmp	r3, r1
    8036:	d301      	bcc.n	803c <__udivsi3+0xb4>
    8038:	018b      	lsls	r3, r1, #6
    803a:	1ac0      	subs	r0, r0, r3
    803c:	4152      	adcs	r2, r2
    803e:	0943      	lsrs	r3, r0, #5
    8040:	428b      	cmp	r3, r1
    8042:	d301      	bcc.n	8048 <__udivsi3+0xc0>
    8044:	014b      	lsls	r3, r1, #5
    8046:	1ac0      	subs	r0, r0, r3
    8048:	4152      	adcs	r2, r2
    804a:	0903      	lsrs	r3, r0, #4
    804c:	428b      	cmp	r3, r1
    804e:	d301      	bcc.n	8054 <__udivsi3+0xcc>
    8050:	010b      	lsls	r3, r1, #4
    8052:	1ac0      	subs	r0, r0, r3
    8054:	4152      	adcs	r2, r2
    8056:	08c3      	lsrs	r3, r0, #3
    8058:	428b      	cmp	r3, r1
    805a:	d301      	bcc.n	8060 <__udivsi3+0xd8>
    805c:	00cb      	lsls	r3, r1, #3
    805e:	1ac0      	subs	r0, r0, r3
    8060:	4152      	adcs	r2, r2
    8062:	0883      	lsrs	r3, r0, #2
    8064:	428b      	cmp	r3, r1
    8066:	d301      	bcc.n	806c <__udivsi3+0xe4>
    8068:	008b      	lsls	r3, r1, #2
    806a:	1ac0      	subs	r0, r0, r3
    806c:	4152      	adcs	r2, r2
    806e:	0843      	lsrs	r3, r0, #1
    8070:	428b      	cmp	r3, r1
    8072:	d301      	bcc.n	8078 <__udivsi3+0xf0>
    8074:	004b      	lsls	r3, r1, #1
    8076:	1ac0      	subs	r0, r0, r3
    8078:	4152      	adcs	r2, r2
    807a:	1a41      	subs	r1, r0, r1
    807c:	d200      	bcs.n	8080 <__udivsi3+0xf8>
    807e:	4601      	mov	r1, r0
    8080:	4152      	adcs	r2, r2
    8082:	4610      	mov	r0, r2
    8084:	4770      	bx	lr
    8086:	e7ff      	b.n	8088 <__udivsi3+0x100>
    8088:	b501      	push	{r0, lr}
    808a:	2000      	movs	r0, #0
    808c:	f000 f8f0 	bl	8270 <__aeabi_idiv0>
    8090:	bd02      	pop	{r1, pc}
    8092:	46c0      	nop			; (mov r8, r8)

00008094 <__aeabi_uidivmod>:
    8094:	2900      	cmp	r1, #0
    8096:	d0f7      	beq.n	8088 <__udivsi3+0x100>
    8098:	e776      	b.n	7f88 <__udivsi3>
    809a:	4770      	bx	lr

0000809c <__divsi3>:
    809c:	4603      	mov	r3, r0
    809e:	430b      	orrs	r3, r1
    80a0:	d47f      	bmi.n	81a2 <__divsi3+0x106>
    80a2:	2200      	movs	r2, #0
    80a4:	0843      	lsrs	r3, r0, #1
    80a6:	428b      	cmp	r3, r1
    80a8:	d374      	bcc.n	8194 <__divsi3+0xf8>
    80aa:	0903      	lsrs	r3, r0, #4
    80ac:	428b      	cmp	r3, r1
    80ae:	d35f      	bcc.n	8170 <__divsi3+0xd4>
    80b0:	0a03      	lsrs	r3, r0, #8
    80b2:	428b      	cmp	r3, r1
    80b4:	d344      	bcc.n	8140 <__divsi3+0xa4>
    80b6:	0b03      	lsrs	r3, r0, #12
    80b8:	428b      	cmp	r3, r1
    80ba:	d328      	bcc.n	810e <__divsi3+0x72>
    80bc:	0c03      	lsrs	r3, r0, #16
    80be:	428b      	cmp	r3, r1
    80c0:	d30d      	bcc.n	80de <__divsi3+0x42>
    80c2:	22ff      	movs	r2, #255	; 0xff
    80c4:	0209      	lsls	r1, r1, #8
    80c6:	ba12      	rev	r2, r2
    80c8:	0c03      	lsrs	r3, r0, #16
    80ca:	428b      	cmp	r3, r1
    80cc:	d302      	bcc.n	80d4 <__divsi3+0x38>
    80ce:	1212      	asrs	r2, r2, #8
    80d0:	0209      	lsls	r1, r1, #8
    80d2:	d065      	beq.n	81a0 <__divsi3+0x104>
    80d4:	0b03      	lsrs	r3, r0, #12
    80d6:	428b      	cmp	r3, r1
    80d8:	d319      	bcc.n	810e <__divsi3+0x72>
    80da:	e000      	b.n	80de <__divsi3+0x42>
    80dc:	0a09      	lsrs	r1, r1, #8
    80de:	0bc3      	lsrs	r3, r0, #15
    80e0:	428b      	cmp	r3, r1
    80e2:	d301      	bcc.n	80e8 <__divsi3+0x4c>
    80e4:	03cb      	lsls	r3, r1, #15
    80e6:	1ac0      	subs	r0, r0, r3
    80e8:	4152      	adcs	r2, r2
    80ea:	0b83      	lsrs	r3, r0, #14
    80ec:	428b      	cmp	r3, r1
    80ee:	d301      	bcc.n	80f4 <__divsi3+0x58>
    80f0:	038b      	lsls	r3, r1, #14
    80f2:	1ac0      	subs	r0, r0, r3
    80f4:	4152      	adcs	r2, r2
    80f6:	0b43      	lsrs	r3, r0, #13
    80f8:	428b      	cmp	r3, r1
    80fa:	d301      	bcc.n	8100 <__divsi3+0x64>
    80fc:	034b      	lsls	r3, r1, #13
    80fe:	1ac0      	subs	r0, r0, r3
    8100:	4152      	adcs	r2, r2
    8102:	0b03      	lsrs	r3, r0, #12
    8104:	428b      	cmp	r3, r1
    8106:	d301      	bcc.n	810c <__divsi3+0x70>
    8108:	030b      	lsls	r3, r1, #12
    810a:	1ac0      	subs	r0, r0, r3
    810c:	4152      	adcs	r2, r2
    810e:	0ac3      	lsrs	r3, r0, #11
    8110:	428b      	cmp	r3, r1
    8112:	d301      	bcc.n	8118 <__divsi3+0x7c>
    8114:	02cb      	lsls	r3, r1, #11
    8116:	1ac0      	subs	r0, r0, r3
    8118:	4152      	adcs	r2, r2
    811a:	0a83      	lsrs	r3, r0, #10
    811c:	428b      	cmp	r3, r1
    811e:	d301      	bcc.n	8124 <__divsi3+0x88>
    8120:	028b      	lsls	r3, r1, #10
    8122:	1ac0      	subs	r0, r0, r3
    8124:	4152      	adcs	r2, r2
    8126:	0a43      	lsrs	r3, r0, #9
    8128:	428b      	cmp	r3, r1
    812a:	d301      	bcc.n	8130 <__divsi3+0x94>
    812c:	024b      	lsls	r3, r1, #9
    812e:	1ac0      	subs	r0, r0, r3
    8130:	4152      	adcs	r2, r2
    8132:	0a03      	lsrs	r3, r0, #8
    8134:	428b      	cmp	r3, r1
    8136:	d301      	bcc.n	813c <__divsi3+0xa0>
    8138:	020b      	lsls	r3, r1, #8
    813a:	1ac0      	subs	r0, r0, r3
    813c:	4152      	adcs	r2, r2
    813e:	d2cd      	bcs.n	80dc <__divsi3+0x40>
    8140:	09c3      	lsrs	r3, r0, #7
    8142:	428b      	cmp	r3, r1
    8144:	d301      	bcc.n	814a <__divsi3+0xae>
    8146:	01cb      	lsls	r3, r1, #7
    8148:	1ac0      	subs	r0, r0, r3
    814a:	4152      	adcs	r2, r2
    814c:	0983      	lsrs	r3, r0, #6
    814e:	428b      	cmp	r3, r1
    8150:	d301      	bcc.n	8156 <__divsi3+0xba>
    8152:	018b      	lsls	r3, r1, #6
    8154:	1ac0      	subs	r0, r0, r3
    8156:	4152      	adcs	r2, r2
    8158:	0943      	lsrs	r3, r0, #5
    815a:	428b      	cmp	r3, r1
    815c:	d301      	bcc.n	8162 <__divsi3+0xc6>
    815e:	014b      	lsls	r3, r1, #5
    8160:	1ac0      	subs	r0, r0, r3
    8162:	4152      	adcs	r2, r2
    8164:	0903      	lsrs	r3, r0, #4
    8166:	428b      	cmp	r3, r1
    8168:	d301      	bcc.n	816e <__divsi3+0xd2>
    816a:	010b      	lsls	r3, r1, #4
    816c:	1ac0      	subs	r0, r0, r3
    816e:	4152      	adcs	r2, r2
    8170:	08c3      	lsrs	r3, r0, #3
    8172:	428b      	cmp	r3, r1
    8174:	d301      	bcc.n	817a <__divsi3+0xde>
    8176:	00cb      	lsls	r3, r1, #3
    8178:	1ac0      	subs	r0, r0, r3
    817a:	4152      	adcs	r2, r2
    817c:	0883      	lsrs	r3, r0, #2
    817e:	428b      	cmp	r3, r1
    8180:	d301      	bcc.n	8186 <__divsi3+0xea>
    8182:	008b      	lsls	r3, r1, #2
    8184:	1ac0      	subs	r0, r0, r3
    8186:	4152      	adcs	r2, r2
    8188:	0843      	lsrs	r3, r0, #1
    818a:	428b      	cmp	r3, r1
    818c:	d301      	bcc.n	8192 <__divsi3+0xf6>
    818e:	004b      	lsls	r3, r1, #1
    8190:	1ac0      	subs	r0, r0, r3
    8192:	4152      	adcs	r2, r2
    8194:	1a41      	subs	r1, r0, r1
    8196:	d200      	bcs.n	819a <__divsi3+0xfe>
    8198:	4601      	mov	r1, r0
    819a:	4152      	adcs	r2, r2
    819c:	4610      	mov	r0, r2
    819e:	4770      	bx	lr
    81a0:	e05d      	b.n	825e <__divsi3+0x1c2>
    81a2:	0fca      	lsrs	r2, r1, #31
    81a4:	d000      	beq.n	81a8 <__divsi3+0x10c>
    81a6:	4249      	negs	r1, r1
    81a8:	1003      	asrs	r3, r0, #32
    81aa:	d300      	bcc.n	81ae <__divsi3+0x112>
    81ac:	4240      	negs	r0, r0
    81ae:	4053      	eors	r3, r2
    81b0:	2200      	movs	r2, #0
    81b2:	469c      	mov	ip, r3
    81b4:	0903      	lsrs	r3, r0, #4
    81b6:	428b      	cmp	r3, r1
    81b8:	d32d      	bcc.n	8216 <__divsi3+0x17a>
    81ba:	0a03      	lsrs	r3, r0, #8
    81bc:	428b      	cmp	r3, r1
    81be:	d312      	bcc.n	81e6 <__divsi3+0x14a>
    81c0:	22fc      	movs	r2, #252	; 0xfc
    81c2:	0189      	lsls	r1, r1, #6
    81c4:	ba12      	rev	r2, r2
    81c6:	0a03      	lsrs	r3, r0, #8
    81c8:	428b      	cmp	r3, r1
    81ca:	d30c      	bcc.n	81e6 <__divsi3+0x14a>
    81cc:	0189      	lsls	r1, r1, #6
    81ce:	1192      	asrs	r2, r2, #6
    81d0:	428b      	cmp	r3, r1
    81d2:	d308      	bcc.n	81e6 <__divsi3+0x14a>
    81d4:	0189      	lsls	r1, r1, #6
    81d6:	1192      	asrs	r2, r2, #6
    81d8:	428b      	cmp	r3, r1
    81da:	d304      	bcc.n	81e6 <__divsi3+0x14a>
    81dc:	0189      	lsls	r1, r1, #6
    81de:	d03a      	beq.n	8256 <__divsi3+0x1ba>
    81e0:	1192      	asrs	r2, r2, #6
    81e2:	e000      	b.n	81e6 <__divsi3+0x14a>
    81e4:	0989      	lsrs	r1, r1, #6
    81e6:	09c3      	lsrs	r3, r0, #7
    81e8:	428b      	cmp	r3, r1
    81ea:	d301      	bcc.n	81f0 <__divsi3+0x154>
    81ec:	01cb      	lsls	r3, r1, #7
    81ee:	1ac0      	subs	r0, r0, r3
    81f0:	4152      	adcs	r2, r2
    81f2:	0983      	lsrs	r3, r0, #6
    81f4:	428b      	cmp	r3, r1
    81f6:	d301      	bcc.n	81fc <__divsi3+0x160>
    81f8:	018b      	lsls	r3, r1, #6
    81fa:	1ac0      	subs	r0, r0, r3
    81fc:	4152      	adcs	r2, r2
    81fe:	0943      	lsrs	r3, r0, #5
    8200:	428b      	cmp	r3, r1
    8202:	d301      	bcc.n	8208 <__divsi3+0x16c>
    8204:	014b      	lsls	r3, r1, #5
    8206:	1ac0      	subs	r0, r0, r3
    8208:	4152      	adcs	r2, r2
    820a:	0903      	lsrs	r3, r0, #4
    820c:	428b      	cmp	r3, r1
    820e:	d301      	bcc.n	8214 <__divsi3+0x178>
    8210:	010b      	lsls	r3, r1, #4
    8212:	1ac0      	subs	r0, r0, r3
    8214:	4152      	adcs	r2, r2
    8216:	08c3      	lsrs	r3, r0, #3
    8218:	428b      	cmp	r3, r1
    821a:	d301      	bcc.n	8220 <__divsi3+0x184>
    821c:	00cb      	lsls	r3, r1, #3
    821e:	1ac0      	subs	r0, r0, r3
    8220:	4152      	adcs	r2, r2
    8222:	0883      	lsrs	r3, r0, #2
    8224:	428b      	cmp	r3, r1
    8226:	d301      	bcc.n	822c <__divsi3+0x190>
    8228:	008b      	lsls	r3, r1, #2
    822a:	1ac0      	subs	r0, r0, r3
    822c:	4152      	adcs	r2, r2
    822e:	d2d9      	bcs.n	81e4 <__divsi3+0x148>
    8230:	0843      	lsrs	r3, r0, #1
    8232:	428b      	cmp	r3, r1
    8234:	d301      	bcc.n	823a <__divsi3+0x19e>
    8236:	004b      	lsls	r3, r1, #1
    8238:	1ac0      	subs	r0, r0, r3
    823a:	4152      	adcs	r2, r2
    823c:	1a41      	subs	r1, r0, r1
    823e:	d200      	bcs.n	8242 <__divsi3+0x1a6>
    8240:	4601      	mov	r1, r0
    8242:	4663      	mov	r3, ip
    8244:	4152      	adcs	r2, r2
    8246:	105b      	asrs	r3, r3, #1
    8248:	4610      	mov	r0, r2
    824a:	d301      	bcc.n	8250 <__divsi3+0x1b4>
    824c:	4240      	negs	r0, r0
    824e:	2b00      	cmp	r3, #0
    8250:	d500      	bpl.n	8254 <__divsi3+0x1b8>
    8252:	4249      	negs	r1, r1
    8254:	4770      	bx	lr
    8256:	4663      	mov	r3, ip
    8258:	105b      	asrs	r3, r3, #1
    825a:	d300      	bcc.n	825e <__divsi3+0x1c2>
    825c:	4240      	negs	r0, r0
    825e:	b501      	push	{r0, lr}
    8260:	2000      	movs	r0, #0
    8262:	f000 f805 	bl	8270 <__aeabi_idiv0>
    8266:	bd02      	pop	{r1, pc}

00008268 <__aeabi_idivmod>:
    8268:	2900      	cmp	r1, #0
    826a:	d0f8      	beq.n	825e <__divsi3+0x1c2>
    826c:	e716      	b.n	809c <__divsi3>
    826e:	4770      	bx	lr

00008270 <__aeabi_idiv0>:
    8270:	4770      	bx	lr
    8272:	46c0      	nop			; (mov r8, r8)

00008274 <__aeabi_dmul>:
    8274:	b5f0      	push	{r4, r5, r6, r7, lr}
    8276:	4657      	mov	r7, sl
    8278:	4645      	mov	r5, r8
    827a:	46de      	mov	lr, fp
    827c:	464e      	mov	r6, r9
    827e:	b5e0      	push	{r5, r6, r7, lr}
    8280:	030c      	lsls	r4, r1, #12
    8282:	4698      	mov	r8, r3
    8284:	004e      	lsls	r6, r1, #1
    8286:	0b23      	lsrs	r3, r4, #12
    8288:	b087      	sub	sp, #28
    828a:	0007      	movs	r7, r0
    828c:	4692      	mov	sl, r2
    828e:	469b      	mov	fp, r3
    8290:	0d76      	lsrs	r6, r6, #21
    8292:	0fcd      	lsrs	r5, r1, #31
    8294:	2e00      	cmp	r6, #0
    8296:	d06b      	beq.n	8370 <__aeabi_dmul+0xfc>
    8298:	4b6d      	ldr	r3, [pc, #436]	; (8450 <__aeabi_dmul+0x1dc>)
    829a:	429e      	cmp	r6, r3
    829c:	d035      	beq.n	830a <__aeabi_dmul+0x96>
    829e:	2480      	movs	r4, #128	; 0x80
    82a0:	465b      	mov	r3, fp
    82a2:	0f42      	lsrs	r2, r0, #29
    82a4:	0424      	lsls	r4, r4, #16
    82a6:	00db      	lsls	r3, r3, #3
    82a8:	4314      	orrs	r4, r2
    82aa:	431c      	orrs	r4, r3
    82ac:	00c3      	lsls	r3, r0, #3
    82ae:	4699      	mov	r9, r3
    82b0:	4b68      	ldr	r3, [pc, #416]	; (8454 <__aeabi_dmul+0x1e0>)
    82b2:	46a3      	mov	fp, r4
    82b4:	469c      	mov	ip, r3
    82b6:	2300      	movs	r3, #0
    82b8:	2700      	movs	r7, #0
    82ba:	4466      	add	r6, ip
    82bc:	9302      	str	r3, [sp, #8]
    82be:	4643      	mov	r3, r8
    82c0:	031c      	lsls	r4, r3, #12
    82c2:	005a      	lsls	r2, r3, #1
    82c4:	0fdb      	lsrs	r3, r3, #31
    82c6:	4650      	mov	r0, sl
    82c8:	0b24      	lsrs	r4, r4, #12
    82ca:	0d52      	lsrs	r2, r2, #21
    82cc:	4698      	mov	r8, r3
    82ce:	d100      	bne.n	82d2 <__aeabi_dmul+0x5e>
    82d0:	e076      	b.n	83c0 <__aeabi_dmul+0x14c>
    82d2:	4b5f      	ldr	r3, [pc, #380]	; (8450 <__aeabi_dmul+0x1dc>)
    82d4:	429a      	cmp	r2, r3
    82d6:	d06d      	beq.n	83b4 <__aeabi_dmul+0x140>
    82d8:	2380      	movs	r3, #128	; 0x80
    82da:	0f41      	lsrs	r1, r0, #29
    82dc:	041b      	lsls	r3, r3, #16
    82de:	430b      	orrs	r3, r1
    82e0:	495c      	ldr	r1, [pc, #368]	; (8454 <__aeabi_dmul+0x1e0>)
    82e2:	00e4      	lsls	r4, r4, #3
    82e4:	468c      	mov	ip, r1
    82e6:	431c      	orrs	r4, r3
    82e8:	00c3      	lsls	r3, r0, #3
    82ea:	2000      	movs	r0, #0
    82ec:	4462      	add	r2, ip
    82ee:	4641      	mov	r1, r8
    82f0:	18b6      	adds	r6, r6, r2
    82f2:	4069      	eors	r1, r5
    82f4:	1c72      	adds	r2, r6, #1
    82f6:	9101      	str	r1, [sp, #4]
    82f8:	4694      	mov	ip, r2
    82fa:	4307      	orrs	r7, r0
    82fc:	2f0f      	cmp	r7, #15
    82fe:	d900      	bls.n	8302 <__aeabi_dmul+0x8e>
    8300:	e0b0      	b.n	8464 <__aeabi_dmul+0x1f0>
    8302:	4a55      	ldr	r2, [pc, #340]	; (8458 <__aeabi_dmul+0x1e4>)
    8304:	00bf      	lsls	r7, r7, #2
    8306:	59d2      	ldr	r2, [r2, r7]
    8308:	4697      	mov	pc, r2
    830a:	465b      	mov	r3, fp
    830c:	4303      	orrs	r3, r0
    830e:	4699      	mov	r9, r3
    8310:	d000      	beq.n	8314 <__aeabi_dmul+0xa0>
    8312:	e087      	b.n	8424 <__aeabi_dmul+0x1b0>
    8314:	2300      	movs	r3, #0
    8316:	469b      	mov	fp, r3
    8318:	3302      	adds	r3, #2
    831a:	2708      	movs	r7, #8
    831c:	9302      	str	r3, [sp, #8]
    831e:	e7ce      	b.n	82be <__aeabi_dmul+0x4a>
    8320:	4642      	mov	r2, r8
    8322:	9201      	str	r2, [sp, #4]
    8324:	2802      	cmp	r0, #2
    8326:	d067      	beq.n	83f8 <__aeabi_dmul+0x184>
    8328:	2803      	cmp	r0, #3
    832a:	d100      	bne.n	832e <__aeabi_dmul+0xba>
    832c:	e20e      	b.n	874c <__aeabi_dmul+0x4d8>
    832e:	2801      	cmp	r0, #1
    8330:	d000      	beq.n	8334 <__aeabi_dmul+0xc0>
    8332:	e162      	b.n	85fa <__aeabi_dmul+0x386>
    8334:	2300      	movs	r3, #0
    8336:	2400      	movs	r4, #0
    8338:	2200      	movs	r2, #0
    833a:	4699      	mov	r9, r3
    833c:	9901      	ldr	r1, [sp, #4]
    833e:	4001      	ands	r1, r0
    8340:	b2cd      	uxtb	r5, r1
    8342:	2100      	movs	r1, #0
    8344:	0312      	lsls	r2, r2, #12
    8346:	0d0b      	lsrs	r3, r1, #20
    8348:	0b12      	lsrs	r2, r2, #12
    834a:	051b      	lsls	r3, r3, #20
    834c:	4313      	orrs	r3, r2
    834e:	4a43      	ldr	r2, [pc, #268]	; (845c <__aeabi_dmul+0x1e8>)
    8350:	0524      	lsls	r4, r4, #20
    8352:	4013      	ands	r3, r2
    8354:	431c      	orrs	r4, r3
    8356:	0064      	lsls	r4, r4, #1
    8358:	07ed      	lsls	r5, r5, #31
    835a:	0864      	lsrs	r4, r4, #1
    835c:	432c      	orrs	r4, r5
    835e:	4648      	mov	r0, r9
    8360:	0021      	movs	r1, r4
    8362:	b007      	add	sp, #28
    8364:	bc3c      	pop	{r2, r3, r4, r5}
    8366:	4690      	mov	r8, r2
    8368:	4699      	mov	r9, r3
    836a:	46a2      	mov	sl, r4
    836c:	46ab      	mov	fp, r5
    836e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8370:	4303      	orrs	r3, r0
    8372:	4699      	mov	r9, r3
    8374:	d04f      	beq.n	8416 <__aeabi_dmul+0x1a2>
    8376:	465b      	mov	r3, fp
    8378:	2b00      	cmp	r3, #0
    837a:	d100      	bne.n	837e <__aeabi_dmul+0x10a>
    837c:	e189      	b.n	8692 <__aeabi_dmul+0x41e>
    837e:	4658      	mov	r0, fp
    8380:	f000 fa6e 	bl	8860 <__clzsi2>
    8384:	0003      	movs	r3, r0
    8386:	3b0b      	subs	r3, #11
    8388:	2b1c      	cmp	r3, #28
    838a:	dd00      	ble.n	838e <__aeabi_dmul+0x11a>
    838c:	e17a      	b.n	8684 <__aeabi_dmul+0x410>
    838e:	221d      	movs	r2, #29
    8390:	1ad3      	subs	r3, r2, r3
    8392:	003a      	movs	r2, r7
    8394:	0001      	movs	r1, r0
    8396:	465c      	mov	r4, fp
    8398:	40da      	lsrs	r2, r3
    839a:	3908      	subs	r1, #8
    839c:	408c      	lsls	r4, r1
    839e:	0013      	movs	r3, r2
    83a0:	408f      	lsls	r7, r1
    83a2:	4323      	orrs	r3, r4
    83a4:	469b      	mov	fp, r3
    83a6:	46b9      	mov	r9, r7
    83a8:	2300      	movs	r3, #0
    83aa:	4e2d      	ldr	r6, [pc, #180]	; (8460 <__aeabi_dmul+0x1ec>)
    83ac:	2700      	movs	r7, #0
    83ae:	1a36      	subs	r6, r6, r0
    83b0:	9302      	str	r3, [sp, #8]
    83b2:	e784      	b.n	82be <__aeabi_dmul+0x4a>
    83b4:	4653      	mov	r3, sl
    83b6:	4323      	orrs	r3, r4
    83b8:	d12a      	bne.n	8410 <__aeabi_dmul+0x19c>
    83ba:	2400      	movs	r4, #0
    83bc:	2002      	movs	r0, #2
    83be:	e796      	b.n	82ee <__aeabi_dmul+0x7a>
    83c0:	4653      	mov	r3, sl
    83c2:	4323      	orrs	r3, r4
    83c4:	d020      	beq.n	8408 <__aeabi_dmul+0x194>
    83c6:	2c00      	cmp	r4, #0
    83c8:	d100      	bne.n	83cc <__aeabi_dmul+0x158>
    83ca:	e157      	b.n	867c <__aeabi_dmul+0x408>
    83cc:	0020      	movs	r0, r4
    83ce:	f000 fa47 	bl	8860 <__clzsi2>
    83d2:	0003      	movs	r3, r0
    83d4:	3b0b      	subs	r3, #11
    83d6:	2b1c      	cmp	r3, #28
    83d8:	dd00      	ble.n	83dc <__aeabi_dmul+0x168>
    83da:	e149      	b.n	8670 <__aeabi_dmul+0x3fc>
    83dc:	211d      	movs	r1, #29
    83de:	1acb      	subs	r3, r1, r3
    83e0:	4651      	mov	r1, sl
    83e2:	0002      	movs	r2, r0
    83e4:	40d9      	lsrs	r1, r3
    83e6:	4653      	mov	r3, sl
    83e8:	3a08      	subs	r2, #8
    83ea:	4094      	lsls	r4, r2
    83ec:	4093      	lsls	r3, r2
    83ee:	430c      	orrs	r4, r1
    83f0:	4a1b      	ldr	r2, [pc, #108]	; (8460 <__aeabi_dmul+0x1ec>)
    83f2:	1a12      	subs	r2, r2, r0
    83f4:	2000      	movs	r0, #0
    83f6:	e77a      	b.n	82ee <__aeabi_dmul+0x7a>
    83f8:	2501      	movs	r5, #1
    83fa:	9b01      	ldr	r3, [sp, #4]
    83fc:	4c14      	ldr	r4, [pc, #80]	; (8450 <__aeabi_dmul+0x1dc>)
    83fe:	401d      	ands	r5, r3
    8400:	2300      	movs	r3, #0
    8402:	2200      	movs	r2, #0
    8404:	4699      	mov	r9, r3
    8406:	e79c      	b.n	8342 <__aeabi_dmul+0xce>
    8408:	2400      	movs	r4, #0
    840a:	2200      	movs	r2, #0
    840c:	2001      	movs	r0, #1
    840e:	e76e      	b.n	82ee <__aeabi_dmul+0x7a>
    8410:	4653      	mov	r3, sl
    8412:	2003      	movs	r0, #3
    8414:	e76b      	b.n	82ee <__aeabi_dmul+0x7a>
    8416:	2300      	movs	r3, #0
    8418:	469b      	mov	fp, r3
    841a:	3301      	adds	r3, #1
    841c:	2704      	movs	r7, #4
    841e:	2600      	movs	r6, #0
    8420:	9302      	str	r3, [sp, #8]
    8422:	e74c      	b.n	82be <__aeabi_dmul+0x4a>
    8424:	2303      	movs	r3, #3
    8426:	4681      	mov	r9, r0
    8428:	270c      	movs	r7, #12
    842a:	9302      	str	r3, [sp, #8]
    842c:	e747      	b.n	82be <__aeabi_dmul+0x4a>
    842e:	2280      	movs	r2, #128	; 0x80
    8430:	2300      	movs	r3, #0
    8432:	2500      	movs	r5, #0
    8434:	0312      	lsls	r2, r2, #12
    8436:	4699      	mov	r9, r3
    8438:	4c05      	ldr	r4, [pc, #20]	; (8450 <__aeabi_dmul+0x1dc>)
    843a:	e782      	b.n	8342 <__aeabi_dmul+0xce>
    843c:	465c      	mov	r4, fp
    843e:	464b      	mov	r3, r9
    8440:	9802      	ldr	r0, [sp, #8]
    8442:	e76f      	b.n	8324 <__aeabi_dmul+0xb0>
    8444:	465c      	mov	r4, fp
    8446:	464b      	mov	r3, r9
    8448:	9501      	str	r5, [sp, #4]
    844a:	9802      	ldr	r0, [sp, #8]
    844c:	e76a      	b.n	8324 <__aeabi_dmul+0xb0>
    844e:	46c0      	nop			; (mov r8, r8)
    8450:	000007ff 	.word	0x000007ff
    8454:	fffffc01 	.word	0xfffffc01
    8458:	0000bae8 	.word	0x0000bae8
    845c:	800fffff 	.word	0x800fffff
    8460:	fffffc0d 	.word	0xfffffc0d
    8464:	464a      	mov	r2, r9
    8466:	4649      	mov	r1, r9
    8468:	0c17      	lsrs	r7, r2, #16
    846a:	0c1a      	lsrs	r2, r3, #16
    846c:	041b      	lsls	r3, r3, #16
    846e:	0c1b      	lsrs	r3, r3, #16
    8470:	0408      	lsls	r0, r1, #16
    8472:	0019      	movs	r1, r3
    8474:	0c00      	lsrs	r0, r0, #16
    8476:	4341      	muls	r1, r0
    8478:	0015      	movs	r5, r2
    847a:	4688      	mov	r8, r1
    847c:	0019      	movs	r1, r3
    847e:	437d      	muls	r5, r7
    8480:	4379      	muls	r1, r7
    8482:	9503      	str	r5, [sp, #12]
    8484:	4689      	mov	r9, r1
    8486:	0029      	movs	r1, r5
    8488:	0015      	movs	r5, r2
    848a:	4345      	muls	r5, r0
    848c:	444d      	add	r5, r9
    848e:	9502      	str	r5, [sp, #8]
    8490:	4645      	mov	r5, r8
    8492:	0c2d      	lsrs	r5, r5, #16
    8494:	46aa      	mov	sl, r5
    8496:	9d02      	ldr	r5, [sp, #8]
    8498:	4455      	add	r5, sl
    849a:	45a9      	cmp	r9, r5
    849c:	d906      	bls.n	84ac <__aeabi_dmul+0x238>
    849e:	468a      	mov	sl, r1
    84a0:	2180      	movs	r1, #128	; 0x80
    84a2:	0249      	lsls	r1, r1, #9
    84a4:	4689      	mov	r9, r1
    84a6:	44ca      	add	sl, r9
    84a8:	4651      	mov	r1, sl
    84aa:	9103      	str	r1, [sp, #12]
    84ac:	0c29      	lsrs	r1, r5, #16
    84ae:	9104      	str	r1, [sp, #16]
    84b0:	4641      	mov	r1, r8
    84b2:	0409      	lsls	r1, r1, #16
    84b4:	042d      	lsls	r5, r5, #16
    84b6:	0c09      	lsrs	r1, r1, #16
    84b8:	4688      	mov	r8, r1
    84ba:	0029      	movs	r1, r5
    84bc:	0c25      	lsrs	r5, r4, #16
    84be:	0424      	lsls	r4, r4, #16
    84c0:	4441      	add	r1, r8
    84c2:	0c24      	lsrs	r4, r4, #16
    84c4:	9105      	str	r1, [sp, #20]
    84c6:	0021      	movs	r1, r4
    84c8:	4341      	muls	r1, r0
    84ca:	4688      	mov	r8, r1
    84cc:	0021      	movs	r1, r4
    84ce:	4379      	muls	r1, r7
    84d0:	468a      	mov	sl, r1
    84d2:	4368      	muls	r0, r5
    84d4:	4641      	mov	r1, r8
    84d6:	4450      	add	r0, sl
    84d8:	4681      	mov	r9, r0
    84da:	0c08      	lsrs	r0, r1, #16
    84dc:	4448      	add	r0, r9
    84de:	436f      	muls	r7, r5
    84e0:	4582      	cmp	sl, r0
    84e2:	d903      	bls.n	84ec <__aeabi_dmul+0x278>
    84e4:	2180      	movs	r1, #128	; 0x80
    84e6:	0249      	lsls	r1, r1, #9
    84e8:	4689      	mov	r9, r1
    84ea:	444f      	add	r7, r9
    84ec:	0c01      	lsrs	r1, r0, #16
    84ee:	4689      	mov	r9, r1
    84f0:	0039      	movs	r1, r7
    84f2:	4449      	add	r1, r9
    84f4:	9102      	str	r1, [sp, #8]
    84f6:	4641      	mov	r1, r8
    84f8:	040f      	lsls	r7, r1, #16
    84fa:	9904      	ldr	r1, [sp, #16]
    84fc:	0c3f      	lsrs	r7, r7, #16
    84fe:	4688      	mov	r8, r1
    8500:	0400      	lsls	r0, r0, #16
    8502:	19c0      	adds	r0, r0, r7
    8504:	4480      	add	r8, r0
    8506:	4641      	mov	r1, r8
    8508:	9104      	str	r1, [sp, #16]
    850a:	4659      	mov	r1, fp
    850c:	0c0f      	lsrs	r7, r1, #16
    850e:	0409      	lsls	r1, r1, #16
    8510:	0c09      	lsrs	r1, r1, #16
    8512:	4688      	mov	r8, r1
    8514:	4359      	muls	r1, r3
    8516:	468a      	mov	sl, r1
    8518:	0039      	movs	r1, r7
    851a:	4351      	muls	r1, r2
    851c:	4689      	mov	r9, r1
    851e:	4641      	mov	r1, r8
    8520:	434a      	muls	r2, r1
    8522:	4651      	mov	r1, sl
    8524:	0c09      	lsrs	r1, r1, #16
    8526:	468b      	mov	fp, r1
    8528:	437b      	muls	r3, r7
    852a:	18d2      	adds	r2, r2, r3
    852c:	445a      	add	r2, fp
    852e:	4293      	cmp	r3, r2
    8530:	d903      	bls.n	853a <__aeabi_dmul+0x2c6>
    8532:	2380      	movs	r3, #128	; 0x80
    8534:	025b      	lsls	r3, r3, #9
    8536:	469b      	mov	fp, r3
    8538:	44d9      	add	r9, fp
    853a:	4651      	mov	r1, sl
    853c:	0409      	lsls	r1, r1, #16
    853e:	0c09      	lsrs	r1, r1, #16
    8540:	468a      	mov	sl, r1
    8542:	4641      	mov	r1, r8
    8544:	4361      	muls	r1, r4
    8546:	437c      	muls	r4, r7
    8548:	0c13      	lsrs	r3, r2, #16
    854a:	0412      	lsls	r2, r2, #16
    854c:	444b      	add	r3, r9
    854e:	4452      	add	r2, sl
    8550:	46a1      	mov	r9, r4
    8552:	468a      	mov	sl, r1
    8554:	003c      	movs	r4, r7
    8556:	4641      	mov	r1, r8
    8558:	436c      	muls	r4, r5
    855a:	434d      	muls	r5, r1
    855c:	4651      	mov	r1, sl
    855e:	444d      	add	r5, r9
    8560:	0c0f      	lsrs	r7, r1, #16
    8562:	197d      	adds	r5, r7, r5
    8564:	45a9      	cmp	r9, r5
    8566:	d903      	bls.n	8570 <__aeabi_dmul+0x2fc>
    8568:	2180      	movs	r1, #128	; 0x80
    856a:	0249      	lsls	r1, r1, #9
    856c:	4688      	mov	r8, r1
    856e:	4444      	add	r4, r8
    8570:	9f04      	ldr	r7, [sp, #16]
    8572:	9903      	ldr	r1, [sp, #12]
    8574:	46b8      	mov	r8, r7
    8576:	4441      	add	r1, r8
    8578:	468b      	mov	fp, r1
    857a:	4583      	cmp	fp, r0
    857c:	4180      	sbcs	r0, r0
    857e:	4241      	negs	r1, r0
    8580:	4688      	mov	r8, r1
    8582:	4651      	mov	r1, sl
    8584:	0408      	lsls	r0, r1, #16
    8586:	042f      	lsls	r7, r5, #16
    8588:	0c00      	lsrs	r0, r0, #16
    858a:	183f      	adds	r7, r7, r0
    858c:	4658      	mov	r0, fp
    858e:	9902      	ldr	r1, [sp, #8]
    8590:	1810      	adds	r0, r2, r0
    8592:	4689      	mov	r9, r1
    8594:	4290      	cmp	r0, r2
    8596:	4192      	sbcs	r2, r2
    8598:	444f      	add	r7, r9
    859a:	46ba      	mov	sl, r7
    859c:	4252      	negs	r2, r2
    859e:	4699      	mov	r9, r3
    85a0:	4693      	mov	fp, r2
    85a2:	44c2      	add	sl, r8
    85a4:	44d1      	add	r9, sl
    85a6:	44cb      	add	fp, r9
    85a8:	428f      	cmp	r7, r1
    85aa:	41bf      	sbcs	r7, r7
    85ac:	45c2      	cmp	sl, r8
    85ae:	4189      	sbcs	r1, r1
    85b0:	4599      	cmp	r9, r3
    85b2:	419b      	sbcs	r3, r3
    85b4:	4593      	cmp	fp, r2
    85b6:	4192      	sbcs	r2, r2
    85b8:	427f      	negs	r7, r7
    85ba:	4249      	negs	r1, r1
    85bc:	0c2d      	lsrs	r5, r5, #16
    85be:	4252      	negs	r2, r2
    85c0:	430f      	orrs	r7, r1
    85c2:	425b      	negs	r3, r3
    85c4:	4313      	orrs	r3, r2
    85c6:	197f      	adds	r7, r7, r5
    85c8:	18ff      	adds	r7, r7, r3
    85ca:	465b      	mov	r3, fp
    85cc:	193c      	adds	r4, r7, r4
    85ce:	0ddb      	lsrs	r3, r3, #23
    85d0:	9a05      	ldr	r2, [sp, #20]
    85d2:	0264      	lsls	r4, r4, #9
    85d4:	431c      	orrs	r4, r3
    85d6:	0243      	lsls	r3, r0, #9
    85d8:	4313      	orrs	r3, r2
    85da:	1e5d      	subs	r5, r3, #1
    85dc:	41ab      	sbcs	r3, r5
    85de:	465a      	mov	r2, fp
    85e0:	0dc0      	lsrs	r0, r0, #23
    85e2:	4303      	orrs	r3, r0
    85e4:	0252      	lsls	r2, r2, #9
    85e6:	4313      	orrs	r3, r2
    85e8:	01e2      	lsls	r2, r4, #7
    85ea:	d556      	bpl.n	869a <__aeabi_dmul+0x426>
    85ec:	2001      	movs	r0, #1
    85ee:	085a      	lsrs	r2, r3, #1
    85f0:	4003      	ands	r3, r0
    85f2:	4313      	orrs	r3, r2
    85f4:	07e2      	lsls	r2, r4, #31
    85f6:	4313      	orrs	r3, r2
    85f8:	0864      	lsrs	r4, r4, #1
    85fa:	485a      	ldr	r0, [pc, #360]	; (8764 <__aeabi_dmul+0x4f0>)
    85fc:	4460      	add	r0, ip
    85fe:	2800      	cmp	r0, #0
    8600:	dd4d      	ble.n	869e <__aeabi_dmul+0x42a>
    8602:	075a      	lsls	r2, r3, #29
    8604:	d009      	beq.n	861a <__aeabi_dmul+0x3a6>
    8606:	220f      	movs	r2, #15
    8608:	401a      	ands	r2, r3
    860a:	2a04      	cmp	r2, #4
    860c:	d005      	beq.n	861a <__aeabi_dmul+0x3a6>
    860e:	1d1a      	adds	r2, r3, #4
    8610:	429a      	cmp	r2, r3
    8612:	419b      	sbcs	r3, r3
    8614:	425b      	negs	r3, r3
    8616:	18e4      	adds	r4, r4, r3
    8618:	0013      	movs	r3, r2
    861a:	01e2      	lsls	r2, r4, #7
    861c:	d504      	bpl.n	8628 <__aeabi_dmul+0x3b4>
    861e:	2080      	movs	r0, #128	; 0x80
    8620:	4a51      	ldr	r2, [pc, #324]	; (8768 <__aeabi_dmul+0x4f4>)
    8622:	00c0      	lsls	r0, r0, #3
    8624:	4014      	ands	r4, r2
    8626:	4460      	add	r0, ip
    8628:	4a50      	ldr	r2, [pc, #320]	; (876c <__aeabi_dmul+0x4f8>)
    862a:	4290      	cmp	r0, r2
    862c:	dd00      	ble.n	8630 <__aeabi_dmul+0x3bc>
    862e:	e6e3      	b.n	83f8 <__aeabi_dmul+0x184>
    8630:	2501      	movs	r5, #1
    8632:	08db      	lsrs	r3, r3, #3
    8634:	0762      	lsls	r2, r4, #29
    8636:	431a      	orrs	r2, r3
    8638:	0264      	lsls	r4, r4, #9
    863a:	9b01      	ldr	r3, [sp, #4]
    863c:	4691      	mov	r9, r2
    863e:	0b22      	lsrs	r2, r4, #12
    8640:	0544      	lsls	r4, r0, #21
    8642:	0d64      	lsrs	r4, r4, #21
    8644:	401d      	ands	r5, r3
    8646:	e67c      	b.n	8342 <__aeabi_dmul+0xce>
    8648:	2280      	movs	r2, #128	; 0x80
    864a:	4659      	mov	r1, fp
    864c:	0312      	lsls	r2, r2, #12
    864e:	4211      	tst	r1, r2
    8650:	d008      	beq.n	8664 <__aeabi_dmul+0x3f0>
    8652:	4214      	tst	r4, r2
    8654:	d106      	bne.n	8664 <__aeabi_dmul+0x3f0>
    8656:	4322      	orrs	r2, r4
    8658:	0312      	lsls	r2, r2, #12
    865a:	0b12      	lsrs	r2, r2, #12
    865c:	4645      	mov	r5, r8
    865e:	4699      	mov	r9, r3
    8660:	4c43      	ldr	r4, [pc, #268]	; (8770 <__aeabi_dmul+0x4fc>)
    8662:	e66e      	b.n	8342 <__aeabi_dmul+0xce>
    8664:	465b      	mov	r3, fp
    8666:	431a      	orrs	r2, r3
    8668:	0312      	lsls	r2, r2, #12
    866a:	0b12      	lsrs	r2, r2, #12
    866c:	4c40      	ldr	r4, [pc, #256]	; (8770 <__aeabi_dmul+0x4fc>)
    866e:	e668      	b.n	8342 <__aeabi_dmul+0xce>
    8670:	0003      	movs	r3, r0
    8672:	4654      	mov	r4, sl
    8674:	3b28      	subs	r3, #40	; 0x28
    8676:	409c      	lsls	r4, r3
    8678:	2300      	movs	r3, #0
    867a:	e6b9      	b.n	83f0 <__aeabi_dmul+0x17c>
    867c:	f000 f8f0 	bl	8860 <__clzsi2>
    8680:	3020      	adds	r0, #32
    8682:	e6a6      	b.n	83d2 <__aeabi_dmul+0x15e>
    8684:	0003      	movs	r3, r0
    8686:	3b28      	subs	r3, #40	; 0x28
    8688:	409f      	lsls	r7, r3
    868a:	2300      	movs	r3, #0
    868c:	46bb      	mov	fp, r7
    868e:	4699      	mov	r9, r3
    8690:	e68a      	b.n	83a8 <__aeabi_dmul+0x134>
    8692:	f000 f8e5 	bl	8860 <__clzsi2>
    8696:	3020      	adds	r0, #32
    8698:	e674      	b.n	8384 <__aeabi_dmul+0x110>
    869a:	46b4      	mov	ip, r6
    869c:	e7ad      	b.n	85fa <__aeabi_dmul+0x386>
    869e:	2501      	movs	r5, #1
    86a0:	1a2a      	subs	r2, r5, r0
    86a2:	2a38      	cmp	r2, #56	; 0x38
    86a4:	dd06      	ble.n	86b4 <__aeabi_dmul+0x440>
    86a6:	9b01      	ldr	r3, [sp, #4]
    86a8:	2400      	movs	r4, #0
    86aa:	401d      	ands	r5, r3
    86ac:	2300      	movs	r3, #0
    86ae:	2200      	movs	r2, #0
    86b0:	4699      	mov	r9, r3
    86b2:	e646      	b.n	8342 <__aeabi_dmul+0xce>
    86b4:	2a1f      	cmp	r2, #31
    86b6:	dc21      	bgt.n	86fc <__aeabi_dmul+0x488>
    86b8:	2520      	movs	r5, #32
    86ba:	0020      	movs	r0, r4
    86bc:	1aad      	subs	r5, r5, r2
    86be:	001e      	movs	r6, r3
    86c0:	40ab      	lsls	r3, r5
    86c2:	40a8      	lsls	r0, r5
    86c4:	40d6      	lsrs	r6, r2
    86c6:	1e5d      	subs	r5, r3, #1
    86c8:	41ab      	sbcs	r3, r5
    86ca:	4330      	orrs	r0, r6
    86cc:	4318      	orrs	r0, r3
    86ce:	40d4      	lsrs	r4, r2
    86d0:	0743      	lsls	r3, r0, #29
    86d2:	d009      	beq.n	86e8 <__aeabi_dmul+0x474>
    86d4:	230f      	movs	r3, #15
    86d6:	4003      	ands	r3, r0
    86d8:	2b04      	cmp	r3, #4
    86da:	d005      	beq.n	86e8 <__aeabi_dmul+0x474>
    86dc:	0003      	movs	r3, r0
    86de:	1d18      	adds	r0, r3, #4
    86e0:	4298      	cmp	r0, r3
    86e2:	419b      	sbcs	r3, r3
    86e4:	425b      	negs	r3, r3
    86e6:	18e4      	adds	r4, r4, r3
    86e8:	0223      	lsls	r3, r4, #8
    86ea:	d521      	bpl.n	8730 <__aeabi_dmul+0x4bc>
    86ec:	2501      	movs	r5, #1
    86ee:	9b01      	ldr	r3, [sp, #4]
    86f0:	2401      	movs	r4, #1
    86f2:	401d      	ands	r5, r3
    86f4:	2300      	movs	r3, #0
    86f6:	2200      	movs	r2, #0
    86f8:	4699      	mov	r9, r3
    86fa:	e622      	b.n	8342 <__aeabi_dmul+0xce>
    86fc:	251f      	movs	r5, #31
    86fe:	0021      	movs	r1, r4
    8700:	426d      	negs	r5, r5
    8702:	1a28      	subs	r0, r5, r0
    8704:	40c1      	lsrs	r1, r0
    8706:	0008      	movs	r0, r1
    8708:	2a20      	cmp	r2, #32
    870a:	d01d      	beq.n	8748 <__aeabi_dmul+0x4d4>
    870c:	355f      	adds	r5, #95	; 0x5f
    870e:	1aaa      	subs	r2, r5, r2
    8710:	4094      	lsls	r4, r2
    8712:	4323      	orrs	r3, r4
    8714:	1e5c      	subs	r4, r3, #1
    8716:	41a3      	sbcs	r3, r4
    8718:	2507      	movs	r5, #7
    871a:	4303      	orrs	r3, r0
    871c:	401d      	ands	r5, r3
    871e:	2200      	movs	r2, #0
    8720:	2d00      	cmp	r5, #0
    8722:	d009      	beq.n	8738 <__aeabi_dmul+0x4c4>
    8724:	220f      	movs	r2, #15
    8726:	2400      	movs	r4, #0
    8728:	401a      	ands	r2, r3
    872a:	0018      	movs	r0, r3
    872c:	2a04      	cmp	r2, #4
    872e:	d1d6      	bne.n	86de <__aeabi_dmul+0x46a>
    8730:	0003      	movs	r3, r0
    8732:	0765      	lsls	r5, r4, #29
    8734:	0264      	lsls	r4, r4, #9
    8736:	0b22      	lsrs	r2, r4, #12
    8738:	08db      	lsrs	r3, r3, #3
    873a:	432b      	orrs	r3, r5
    873c:	2501      	movs	r5, #1
    873e:	4699      	mov	r9, r3
    8740:	9b01      	ldr	r3, [sp, #4]
    8742:	2400      	movs	r4, #0
    8744:	401d      	ands	r5, r3
    8746:	e5fc      	b.n	8342 <__aeabi_dmul+0xce>
    8748:	2400      	movs	r4, #0
    874a:	e7e2      	b.n	8712 <__aeabi_dmul+0x49e>
    874c:	2280      	movs	r2, #128	; 0x80
    874e:	2501      	movs	r5, #1
    8750:	0312      	lsls	r2, r2, #12
    8752:	4322      	orrs	r2, r4
    8754:	9901      	ldr	r1, [sp, #4]
    8756:	0312      	lsls	r2, r2, #12
    8758:	0b12      	lsrs	r2, r2, #12
    875a:	400d      	ands	r5, r1
    875c:	4699      	mov	r9, r3
    875e:	4c04      	ldr	r4, [pc, #16]	; (8770 <__aeabi_dmul+0x4fc>)
    8760:	e5ef      	b.n	8342 <__aeabi_dmul+0xce>
    8762:	46c0      	nop			; (mov r8, r8)
    8764:	000003ff 	.word	0x000003ff
    8768:	feffffff 	.word	0xfeffffff
    876c:	000007fe 	.word	0x000007fe
    8770:	000007ff 	.word	0x000007ff

00008774 <__aeabi_d2iz>:
    8774:	b530      	push	{r4, r5, lr}
    8776:	4d13      	ldr	r5, [pc, #76]	; (87c4 <__aeabi_d2iz+0x50>)
    8778:	030a      	lsls	r2, r1, #12
    877a:	004b      	lsls	r3, r1, #1
    877c:	0b12      	lsrs	r2, r2, #12
    877e:	0d5b      	lsrs	r3, r3, #21
    8780:	0fc9      	lsrs	r1, r1, #31
    8782:	2400      	movs	r4, #0
    8784:	42ab      	cmp	r3, r5
    8786:	dd10      	ble.n	87aa <__aeabi_d2iz+0x36>
    8788:	4c0f      	ldr	r4, [pc, #60]	; (87c8 <__aeabi_d2iz+0x54>)
    878a:	42a3      	cmp	r3, r4
    878c:	dc0f      	bgt.n	87ae <__aeabi_d2iz+0x3a>
    878e:	2480      	movs	r4, #128	; 0x80
    8790:	4d0e      	ldr	r5, [pc, #56]	; (87cc <__aeabi_d2iz+0x58>)
    8792:	0364      	lsls	r4, r4, #13
    8794:	4322      	orrs	r2, r4
    8796:	1aed      	subs	r5, r5, r3
    8798:	2d1f      	cmp	r5, #31
    879a:	dd0b      	ble.n	87b4 <__aeabi_d2iz+0x40>
    879c:	480c      	ldr	r0, [pc, #48]	; (87d0 <__aeabi_d2iz+0x5c>)
    879e:	1ac3      	subs	r3, r0, r3
    87a0:	40da      	lsrs	r2, r3
    87a2:	4254      	negs	r4, r2
    87a4:	2900      	cmp	r1, #0
    87a6:	d100      	bne.n	87aa <__aeabi_d2iz+0x36>
    87a8:	0014      	movs	r4, r2
    87aa:	0020      	movs	r0, r4
    87ac:	bd30      	pop	{r4, r5, pc}
    87ae:	4b09      	ldr	r3, [pc, #36]	; (87d4 <__aeabi_d2iz+0x60>)
    87b0:	18cc      	adds	r4, r1, r3
    87b2:	e7fa      	b.n	87aa <__aeabi_d2iz+0x36>
    87b4:	4c08      	ldr	r4, [pc, #32]	; (87d8 <__aeabi_d2iz+0x64>)
    87b6:	40e8      	lsrs	r0, r5
    87b8:	46a4      	mov	ip, r4
    87ba:	4463      	add	r3, ip
    87bc:	409a      	lsls	r2, r3
    87be:	4302      	orrs	r2, r0
    87c0:	e7ef      	b.n	87a2 <__aeabi_d2iz+0x2e>
    87c2:	46c0      	nop			; (mov r8, r8)
    87c4:	000003fe 	.word	0x000003fe
    87c8:	0000041d 	.word	0x0000041d
    87cc:	00000433 	.word	0x00000433
    87d0:	00000413 	.word	0x00000413
    87d4:	7fffffff 	.word	0x7fffffff
    87d8:	fffffbed 	.word	0xfffffbed

000087dc <__aeabi_i2d>:
    87dc:	b570      	push	{r4, r5, r6, lr}
    87de:	2800      	cmp	r0, #0
    87e0:	d030      	beq.n	8844 <__aeabi_i2d+0x68>
    87e2:	17c3      	asrs	r3, r0, #31
    87e4:	18c4      	adds	r4, r0, r3
    87e6:	405c      	eors	r4, r3
    87e8:	0fc5      	lsrs	r5, r0, #31
    87ea:	0020      	movs	r0, r4
    87ec:	f000 f838 	bl	8860 <__clzsi2>
    87f0:	4b17      	ldr	r3, [pc, #92]	; (8850 <__aeabi_i2d+0x74>)
    87f2:	4a18      	ldr	r2, [pc, #96]	; (8854 <__aeabi_i2d+0x78>)
    87f4:	1a1b      	subs	r3, r3, r0
    87f6:	1ad2      	subs	r2, r2, r3
    87f8:	2a1f      	cmp	r2, #31
    87fa:	dd18      	ble.n	882e <__aeabi_i2d+0x52>
    87fc:	4a16      	ldr	r2, [pc, #88]	; (8858 <__aeabi_i2d+0x7c>)
    87fe:	1ad2      	subs	r2, r2, r3
    8800:	4094      	lsls	r4, r2
    8802:	2200      	movs	r2, #0
    8804:	0324      	lsls	r4, r4, #12
    8806:	055b      	lsls	r3, r3, #21
    8808:	0b24      	lsrs	r4, r4, #12
    880a:	0d5b      	lsrs	r3, r3, #21
    880c:	2100      	movs	r1, #0
    880e:	0010      	movs	r0, r2
    8810:	0324      	lsls	r4, r4, #12
    8812:	0d0a      	lsrs	r2, r1, #20
    8814:	0b24      	lsrs	r4, r4, #12
    8816:	0512      	lsls	r2, r2, #20
    8818:	4322      	orrs	r2, r4
    881a:	4c10      	ldr	r4, [pc, #64]	; (885c <__aeabi_i2d+0x80>)
    881c:	051b      	lsls	r3, r3, #20
    881e:	4022      	ands	r2, r4
    8820:	4313      	orrs	r3, r2
    8822:	005b      	lsls	r3, r3, #1
    8824:	07ed      	lsls	r5, r5, #31
    8826:	085b      	lsrs	r3, r3, #1
    8828:	432b      	orrs	r3, r5
    882a:	0019      	movs	r1, r3
    882c:	bd70      	pop	{r4, r5, r6, pc}
    882e:	0021      	movs	r1, r4
    8830:	4091      	lsls	r1, r2
    8832:	000a      	movs	r2, r1
    8834:	210b      	movs	r1, #11
    8836:	1a08      	subs	r0, r1, r0
    8838:	40c4      	lsrs	r4, r0
    883a:	055b      	lsls	r3, r3, #21
    883c:	0324      	lsls	r4, r4, #12
    883e:	0b24      	lsrs	r4, r4, #12
    8840:	0d5b      	lsrs	r3, r3, #21
    8842:	e7e3      	b.n	880c <__aeabi_i2d+0x30>
    8844:	2500      	movs	r5, #0
    8846:	2300      	movs	r3, #0
    8848:	2400      	movs	r4, #0
    884a:	2200      	movs	r2, #0
    884c:	e7de      	b.n	880c <__aeabi_i2d+0x30>
    884e:	46c0      	nop			; (mov r8, r8)
    8850:	0000041e 	.word	0x0000041e
    8854:	00000433 	.word	0x00000433
    8858:	00000413 	.word	0x00000413
    885c:	800fffff 	.word	0x800fffff

00008860 <__clzsi2>:
    8860:	211c      	movs	r1, #28
    8862:	2301      	movs	r3, #1
    8864:	041b      	lsls	r3, r3, #16
    8866:	4298      	cmp	r0, r3
    8868:	d301      	bcc.n	886e <__clzsi2+0xe>
    886a:	0c00      	lsrs	r0, r0, #16
    886c:	3910      	subs	r1, #16
    886e:	0a1b      	lsrs	r3, r3, #8
    8870:	4298      	cmp	r0, r3
    8872:	d301      	bcc.n	8878 <__clzsi2+0x18>
    8874:	0a00      	lsrs	r0, r0, #8
    8876:	3908      	subs	r1, #8
    8878:	091b      	lsrs	r3, r3, #4
    887a:	4298      	cmp	r0, r3
    887c:	d301      	bcc.n	8882 <__clzsi2+0x22>
    887e:	0900      	lsrs	r0, r0, #4
    8880:	3904      	subs	r1, #4
    8882:	a202      	add	r2, pc, #8	; (adr r2, 888c <__clzsi2+0x2c>)
    8884:	5c10      	ldrb	r0, [r2, r0]
    8886:	1840      	adds	r0, r0, r1
    8888:	4770      	bx	lr
    888a:	46c0      	nop			; (mov r8, r8)
    888c:	02020304 	.word	0x02020304
    8890:	01010101 	.word	0x01010101
	...

0000889c <atoi>:
    889c:	b510      	push	{r4, lr}
    889e:	220a      	movs	r2, #10
    88a0:	2100      	movs	r1, #0
    88a2:	f000 f9cb 	bl	8c3c <strtol>
    88a6:	bd10      	pop	{r4, pc}

000088a8 <atol>:
    88a8:	b510      	push	{r4, lr}
    88aa:	220a      	movs	r2, #10
    88ac:	2100      	movs	r1, #0
    88ae:	f000 f9c5 	bl	8c3c <strtol>
    88b2:	bd10      	pop	{r4, pc}

000088b4 <__libc_init_array>:
    88b4:	b570      	push	{r4, r5, r6, lr}
    88b6:	2600      	movs	r6, #0
    88b8:	4d0c      	ldr	r5, [pc, #48]	; (88ec <__libc_init_array+0x38>)
    88ba:	4c0d      	ldr	r4, [pc, #52]	; (88f0 <__libc_init_array+0x3c>)
    88bc:	1b64      	subs	r4, r4, r5
    88be:	10a4      	asrs	r4, r4, #2
    88c0:	42a6      	cmp	r6, r4
    88c2:	d109      	bne.n	88d8 <__libc_init_array+0x24>
    88c4:	2600      	movs	r6, #0
    88c6:	f003 fa13 	bl	bcf0 <_init>
    88ca:	4d0a      	ldr	r5, [pc, #40]	; (88f4 <__libc_init_array+0x40>)
    88cc:	4c0a      	ldr	r4, [pc, #40]	; (88f8 <__libc_init_array+0x44>)
    88ce:	1b64      	subs	r4, r4, r5
    88d0:	10a4      	asrs	r4, r4, #2
    88d2:	42a6      	cmp	r6, r4
    88d4:	d105      	bne.n	88e2 <__libc_init_array+0x2e>
    88d6:	bd70      	pop	{r4, r5, r6, pc}
    88d8:	00b3      	lsls	r3, r6, #2
    88da:	58eb      	ldr	r3, [r5, r3]
    88dc:	4798      	blx	r3
    88de:	3601      	adds	r6, #1
    88e0:	e7ee      	b.n	88c0 <__libc_init_array+0xc>
    88e2:	00b3      	lsls	r3, r6, #2
    88e4:	58eb      	ldr	r3, [r5, r3]
    88e6:	4798      	blx	r3
    88e8:	3601      	adds	r6, #1
    88ea:	e7f2      	b.n	88d2 <__libc_init_array+0x1e>
    88ec:	0000bcfc 	.word	0x0000bcfc
    88f0:	0000bcfc 	.word	0x0000bcfc
    88f4:	0000bcfc 	.word	0x0000bcfc
    88f8:	0000bd00 	.word	0x0000bd00

000088fc <__locale_ctype_ptr_l>:
    88fc:	30ec      	adds	r0, #236	; 0xec
    88fe:	6800      	ldr	r0, [r0, #0]
    8900:	4770      	bx	lr
	...

00008904 <__locale_ctype_ptr>:
    8904:	4b04      	ldr	r3, [pc, #16]	; (8918 <__locale_ctype_ptr+0x14>)
    8906:	681b      	ldr	r3, [r3, #0]
    8908:	6a1b      	ldr	r3, [r3, #32]
    890a:	2b00      	cmp	r3, #0
    890c:	d100      	bne.n	8910 <__locale_ctype_ptr+0xc>
    890e:	4b03      	ldr	r3, [pc, #12]	; (891c <__locale_ctype_ptr+0x18>)
    8910:	33ec      	adds	r3, #236	; 0xec
    8912:	6818      	ldr	r0, [r3, #0]
    8914:	4770      	bx	lr
    8916:	46c0      	nop			; (mov r8, r8)
    8918:	20000114 	.word	0x20000114
    891c:	20000178 	.word	0x20000178

00008920 <__ascii_mbtowc>:
    8920:	b082      	sub	sp, #8
    8922:	2900      	cmp	r1, #0
    8924:	d100      	bne.n	8928 <__ascii_mbtowc+0x8>
    8926:	a901      	add	r1, sp, #4
    8928:	1e10      	subs	r0, r2, #0
    892a:	d006      	beq.n	893a <__ascii_mbtowc+0x1a>
    892c:	2b00      	cmp	r3, #0
    892e:	d006      	beq.n	893e <__ascii_mbtowc+0x1e>
    8930:	7813      	ldrb	r3, [r2, #0]
    8932:	600b      	str	r3, [r1, #0]
    8934:	7810      	ldrb	r0, [r2, #0]
    8936:	1e43      	subs	r3, r0, #1
    8938:	4198      	sbcs	r0, r3
    893a:	b002      	add	sp, #8
    893c:	4770      	bx	lr
    893e:	2002      	movs	r0, #2
    8940:	4240      	negs	r0, r0
    8942:	e7fa      	b.n	893a <__ascii_mbtowc+0x1a>

00008944 <memcpy>:
    8944:	2300      	movs	r3, #0
    8946:	b510      	push	{r4, lr}
    8948:	429a      	cmp	r2, r3
    894a:	d100      	bne.n	894e <memcpy+0xa>
    894c:	bd10      	pop	{r4, pc}
    894e:	5ccc      	ldrb	r4, [r1, r3]
    8950:	54c4      	strb	r4, [r0, r3]
    8952:	3301      	adds	r3, #1
    8954:	e7f8      	b.n	8948 <memcpy+0x4>

00008956 <memset>:
    8956:	0003      	movs	r3, r0
    8958:	1882      	adds	r2, r0, r2
    895a:	4293      	cmp	r3, r2
    895c:	d100      	bne.n	8960 <memset+0xa>
    895e:	4770      	bx	lr
    8960:	7019      	strb	r1, [r3, #0]
    8962:	3301      	adds	r3, #1
    8964:	e7f9      	b.n	895a <memset+0x4>
	...

00008968 <siprintf>:
    8968:	b40e      	push	{r1, r2, r3}
    896a:	b510      	push	{r4, lr}
    896c:	b09d      	sub	sp, #116	; 0x74
    896e:	a902      	add	r1, sp, #8
    8970:	9002      	str	r0, [sp, #8]
    8972:	6108      	str	r0, [r1, #16]
    8974:	480b      	ldr	r0, [pc, #44]	; (89a4 <siprintf+0x3c>)
    8976:	2482      	movs	r4, #130	; 0x82
    8978:	6088      	str	r0, [r1, #8]
    897a:	6148      	str	r0, [r1, #20]
    897c:	2001      	movs	r0, #1
    897e:	4240      	negs	r0, r0
    8980:	ab1f      	add	r3, sp, #124	; 0x7c
    8982:	81c8      	strh	r0, [r1, #14]
    8984:	4808      	ldr	r0, [pc, #32]	; (89a8 <siprintf+0x40>)
    8986:	cb04      	ldmia	r3!, {r2}
    8988:	00a4      	lsls	r4, r4, #2
    898a:	6800      	ldr	r0, [r0, #0]
    898c:	9301      	str	r3, [sp, #4]
    898e:	818c      	strh	r4, [r1, #12]
    8990:	f000 fb04 	bl	8f9c <_svfiprintf_r>
    8994:	2300      	movs	r3, #0
    8996:	9a02      	ldr	r2, [sp, #8]
    8998:	7013      	strb	r3, [r2, #0]
    899a:	b01d      	add	sp, #116	; 0x74
    899c:	bc10      	pop	{r4}
    899e:	bc08      	pop	{r3}
    89a0:	b003      	add	sp, #12
    89a2:	4718      	bx	r3
    89a4:	7fffffff 	.word	0x7fffffff
    89a8:	20000114 	.word	0x20000114

000089ac <siscanf>:
    89ac:	b40e      	push	{r1, r2, r3}
    89ae:	2381      	movs	r3, #129	; 0x81
    89b0:	b570      	push	{r4, r5, r6, lr}
    89b2:	b09d      	sub	sp, #116	; 0x74
    89b4:	ac02      	add	r4, sp, #8
    89b6:	ad21      	add	r5, sp, #132	; 0x84
    89b8:	009b      	lsls	r3, r3, #2
    89ba:	cd40      	ldmia	r5!, {r6}
    89bc:	81a3      	strh	r3, [r4, #12]
    89be:	9002      	str	r0, [sp, #8]
    89c0:	9006      	str	r0, [sp, #24]
    89c2:	f000 f83c 	bl	8a3e <strlen>
    89c6:	4b0b      	ldr	r3, [pc, #44]	; (89f4 <siscanf+0x48>)
    89c8:	6060      	str	r0, [r4, #4]
    89ca:	6263      	str	r3, [r4, #36]	; 0x24
    89cc:	2300      	movs	r3, #0
    89ce:	6160      	str	r0, [r4, #20]
    89d0:	4809      	ldr	r0, [pc, #36]	; (89f8 <siscanf+0x4c>)
    89d2:	6363      	str	r3, [r4, #52]	; 0x34
    89d4:	64a3      	str	r3, [r4, #72]	; 0x48
    89d6:	3b01      	subs	r3, #1
    89d8:	81e3      	strh	r3, [r4, #14]
    89da:	0032      	movs	r2, r6
    89dc:	002b      	movs	r3, r5
    89de:	0021      	movs	r1, r4
    89e0:	6800      	ldr	r0, [r0, #0]
    89e2:	9501      	str	r5, [sp, #4]
    89e4:	f000 fc3a 	bl	925c <__ssvfiscanf_r>
    89e8:	b01d      	add	sp, #116	; 0x74
    89ea:	bc70      	pop	{r4, r5, r6}
    89ec:	bc08      	pop	{r3}
    89ee:	b003      	add	sp, #12
    89f0:	4718      	bx	r3
    89f2:	46c0      	nop			; (mov r8, r8)
    89f4:	000089fd 	.word	0x000089fd
    89f8:	20000114 	.word	0x20000114

000089fc <__seofread>:
    89fc:	2000      	movs	r0, #0
    89fe:	4770      	bx	lr

00008a00 <strcat>:
    8a00:	0002      	movs	r2, r0
    8a02:	b510      	push	{r4, lr}
    8a04:	7813      	ldrb	r3, [r2, #0]
    8a06:	2b00      	cmp	r3, #0
    8a08:	d105      	bne.n	8a16 <strcat+0x16>
    8a0a:	5ccc      	ldrb	r4, [r1, r3]
    8a0c:	54d4      	strb	r4, [r2, r3]
    8a0e:	3301      	adds	r3, #1
    8a10:	2c00      	cmp	r4, #0
    8a12:	d1fa      	bne.n	8a0a <strcat+0xa>
    8a14:	bd10      	pop	{r4, pc}
    8a16:	3201      	adds	r2, #1
    8a18:	e7f4      	b.n	8a04 <strcat+0x4>

00008a1a <strcmp>:
    8a1a:	7802      	ldrb	r2, [r0, #0]
    8a1c:	780b      	ldrb	r3, [r1, #0]
    8a1e:	2a00      	cmp	r2, #0
    8a20:	d003      	beq.n	8a2a <strcmp+0x10>
    8a22:	3001      	adds	r0, #1
    8a24:	3101      	adds	r1, #1
    8a26:	429a      	cmp	r2, r3
    8a28:	d0f7      	beq.n	8a1a <strcmp>
    8a2a:	1ad0      	subs	r0, r2, r3
    8a2c:	4770      	bx	lr

00008a2e <strcpy>:
    8a2e:	1c03      	adds	r3, r0, #0
    8a30:	780a      	ldrb	r2, [r1, #0]
    8a32:	3101      	adds	r1, #1
    8a34:	701a      	strb	r2, [r3, #0]
    8a36:	3301      	adds	r3, #1
    8a38:	2a00      	cmp	r2, #0
    8a3a:	d1f9      	bne.n	8a30 <strcpy+0x2>
    8a3c:	4770      	bx	lr

00008a3e <strlen>:
    8a3e:	2300      	movs	r3, #0
    8a40:	5cc2      	ldrb	r2, [r0, r3]
    8a42:	3301      	adds	r3, #1
    8a44:	2a00      	cmp	r2, #0
    8a46:	d1fb      	bne.n	8a40 <strlen+0x2>
    8a48:	1e58      	subs	r0, r3, #1
    8a4a:	4770      	bx	lr

00008a4c <strncasecmp>:
    8a4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8a4e:	0005      	movs	r5, r0
    8a50:	000f      	movs	r7, r1
    8a52:	1883      	adds	r3, r0, r2
    8a54:	9301      	str	r3, [sp, #4]
    8a56:	9b01      	ldr	r3, [sp, #4]
    8a58:	429d      	cmp	r5, r3
    8a5a:	d019      	beq.n	8a90 <strncasecmp+0x44>
    8a5c:	782c      	ldrb	r4, [r5, #0]
    8a5e:	f7ff ff51 	bl	8904 <__locale_ctype_ptr>
    8a62:	2203      	movs	r2, #3
    8a64:	1900      	adds	r0, r0, r4
    8a66:	7843      	ldrb	r3, [r0, #1]
    8a68:	4013      	ands	r3, r2
    8a6a:	2b01      	cmp	r3, #1
    8a6c:	d100      	bne.n	8a70 <strncasecmp+0x24>
    8a6e:	3420      	adds	r4, #32
    8a70:	783e      	ldrb	r6, [r7, #0]
    8a72:	f7ff ff47 	bl	8904 <__locale_ctype_ptr>
    8a76:	2203      	movs	r2, #3
    8a78:	1980      	adds	r0, r0, r6
    8a7a:	7843      	ldrb	r3, [r0, #1]
    8a7c:	4013      	ands	r3, r2
    8a7e:	2b01      	cmp	r3, #1
    8a80:	d100      	bne.n	8a84 <strncasecmp+0x38>
    8a82:	3620      	adds	r6, #32
    8a84:	1ba0      	subs	r0, r4, r6
    8a86:	d104      	bne.n	8a92 <strncasecmp+0x46>
    8a88:	3501      	adds	r5, #1
    8a8a:	3701      	adds	r7, #1
    8a8c:	2e00      	cmp	r6, #0
    8a8e:	d1e2      	bne.n	8a56 <strncasecmp+0xa>
    8a90:	2000      	movs	r0, #0
    8a92:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00008a94 <strncmp>:
    8a94:	2300      	movs	r3, #0
    8a96:	b530      	push	{r4, r5, lr}
    8a98:	429a      	cmp	r2, r3
    8a9a:	d00a      	beq.n	8ab2 <strncmp+0x1e>
    8a9c:	3a01      	subs	r2, #1
    8a9e:	5cc4      	ldrb	r4, [r0, r3]
    8aa0:	5ccd      	ldrb	r5, [r1, r3]
    8aa2:	42ac      	cmp	r4, r5
    8aa4:	d104      	bne.n	8ab0 <strncmp+0x1c>
    8aa6:	429a      	cmp	r2, r3
    8aa8:	d002      	beq.n	8ab0 <strncmp+0x1c>
    8aaa:	3301      	adds	r3, #1
    8aac:	2c00      	cmp	r4, #0
    8aae:	d1f6      	bne.n	8a9e <strncmp+0xa>
    8ab0:	1b63      	subs	r3, r4, r5
    8ab2:	0018      	movs	r0, r3
    8ab4:	bd30      	pop	{r4, r5, pc}

00008ab6 <strncpy>:
    8ab6:	b570      	push	{r4, r5, r6, lr}
    8ab8:	0004      	movs	r4, r0
    8aba:	2a00      	cmp	r2, #0
    8abc:	d100      	bne.n	8ac0 <strncpy+0xa>
    8abe:	bd70      	pop	{r4, r5, r6, pc}
    8ac0:	780d      	ldrb	r5, [r1, #0]
    8ac2:	1e56      	subs	r6, r2, #1
    8ac4:	1c63      	adds	r3, r4, #1
    8ac6:	7025      	strb	r5, [r4, #0]
    8ac8:	3101      	adds	r1, #1
    8aca:	2d00      	cmp	r5, #0
    8acc:	d105      	bne.n	8ada <strncpy+0x24>
    8ace:	18a4      	adds	r4, r4, r2
    8ad0:	429c      	cmp	r4, r3
    8ad2:	d0f4      	beq.n	8abe <strncpy+0x8>
    8ad4:	701d      	strb	r5, [r3, #0]
    8ad6:	3301      	adds	r3, #1
    8ad8:	e7fa      	b.n	8ad0 <strncpy+0x1a>
    8ada:	001c      	movs	r4, r3
    8adc:	0032      	movs	r2, r6
    8ade:	e7ec      	b.n	8aba <strncpy+0x4>

00008ae0 <strstr>:
    8ae0:	b510      	push	{r4, lr}
    8ae2:	0002      	movs	r2, r0
    8ae4:	7800      	ldrb	r0, [r0, #0]
    8ae6:	2800      	cmp	r0, #0
    8ae8:	d104      	bne.n	8af4 <strstr+0x14>
    8aea:	7809      	ldrb	r1, [r1, #0]
    8aec:	2900      	cmp	r1, #0
    8aee:	d00d      	beq.n	8b0c <strstr+0x2c>
    8af0:	bd10      	pop	{r4, pc}
    8af2:	3201      	adds	r2, #1
    8af4:	7810      	ldrb	r0, [r2, #0]
    8af6:	2800      	cmp	r0, #0
    8af8:	d0fa      	beq.n	8af0 <strstr+0x10>
    8afa:	2300      	movs	r3, #0
    8afc:	5cc8      	ldrb	r0, [r1, r3]
    8afe:	2800      	cmp	r0, #0
    8b00:	d004      	beq.n	8b0c <strstr+0x2c>
    8b02:	5cd4      	ldrb	r4, [r2, r3]
    8b04:	4284      	cmp	r4, r0
    8b06:	d1f4      	bne.n	8af2 <strstr+0x12>
    8b08:	3301      	adds	r3, #1
    8b0a:	e7f7      	b.n	8afc <strstr+0x1c>
    8b0c:	0010      	movs	r0, r2
    8b0e:	e7ef      	b.n	8af0 <strstr+0x10>

00008b10 <_strtol_l.isra.0>:
    8b10:	b5f0      	push	{r4, r5, r6, r7, lr}
    8b12:	001f      	movs	r7, r3
    8b14:	000e      	movs	r6, r1
    8b16:	b087      	sub	sp, #28
    8b18:	9005      	str	r0, [sp, #20]
    8b1a:	9103      	str	r1, [sp, #12]
    8b1c:	9202      	str	r2, [sp, #8]
    8b1e:	980c      	ldr	r0, [sp, #48]	; 0x30
    8b20:	7834      	ldrb	r4, [r6, #0]
    8b22:	f7ff feeb 	bl	88fc <__locale_ctype_ptr_l>
    8b26:	2208      	movs	r2, #8
    8b28:	1900      	adds	r0, r0, r4
    8b2a:	7843      	ldrb	r3, [r0, #1]
    8b2c:	1c75      	adds	r5, r6, #1
    8b2e:	4013      	ands	r3, r2
    8b30:	d10c      	bne.n	8b4c <_strtol_l.isra.0+0x3c>
    8b32:	2c2d      	cmp	r4, #45	; 0x2d
    8b34:	d10c      	bne.n	8b50 <_strtol_l.isra.0+0x40>
    8b36:	3301      	adds	r3, #1
    8b38:	782c      	ldrb	r4, [r5, #0]
    8b3a:	9301      	str	r3, [sp, #4]
    8b3c:	1cb5      	adds	r5, r6, #2
    8b3e:	2f00      	cmp	r7, #0
    8b40:	d00c      	beq.n	8b5c <_strtol_l.isra.0+0x4c>
    8b42:	2f10      	cmp	r7, #16
    8b44:	d114      	bne.n	8b70 <_strtol_l.isra.0+0x60>
    8b46:	2c30      	cmp	r4, #48	; 0x30
    8b48:	d00a      	beq.n	8b60 <_strtol_l.isra.0+0x50>
    8b4a:	e011      	b.n	8b70 <_strtol_l.isra.0+0x60>
    8b4c:	002e      	movs	r6, r5
    8b4e:	e7e6      	b.n	8b1e <_strtol_l.isra.0+0xe>
    8b50:	9301      	str	r3, [sp, #4]
    8b52:	2c2b      	cmp	r4, #43	; 0x2b
    8b54:	d1f3      	bne.n	8b3e <_strtol_l.isra.0+0x2e>
    8b56:	782c      	ldrb	r4, [r5, #0]
    8b58:	1cb5      	adds	r5, r6, #2
    8b5a:	e7f0      	b.n	8b3e <_strtol_l.isra.0+0x2e>
    8b5c:	2c30      	cmp	r4, #48	; 0x30
    8b5e:	d12f      	bne.n	8bc0 <_strtol_l.isra.0+0xb0>
    8b60:	2220      	movs	r2, #32
    8b62:	782b      	ldrb	r3, [r5, #0]
    8b64:	4393      	bics	r3, r2
    8b66:	2b58      	cmp	r3, #88	; 0x58
    8b68:	d151      	bne.n	8c0e <_strtol_l.isra.0+0xfe>
    8b6a:	2710      	movs	r7, #16
    8b6c:	786c      	ldrb	r4, [r5, #1]
    8b6e:	3502      	adds	r5, #2
    8b70:	9b01      	ldr	r3, [sp, #4]
    8b72:	4a29      	ldr	r2, [pc, #164]	; (8c18 <_strtol_l.isra.0+0x108>)
    8b74:	0039      	movs	r1, r7
    8b76:	189e      	adds	r6, r3, r2
    8b78:	0030      	movs	r0, r6
    8b7a:	f7ff fa8b 	bl	8094 <__aeabi_uidivmod>
    8b7e:	0030      	movs	r0, r6
    8b80:	9104      	str	r1, [sp, #16]
    8b82:	0039      	movs	r1, r7
    8b84:	f7ff fa00 	bl	7f88 <__udivsi3>
    8b88:	2101      	movs	r1, #1
    8b8a:	2300      	movs	r3, #0
    8b8c:	4249      	negs	r1, r1
    8b8e:	0002      	movs	r2, r0
    8b90:	468c      	mov	ip, r1
    8b92:	0018      	movs	r0, r3
    8b94:	0021      	movs	r1, r4
    8b96:	3930      	subs	r1, #48	; 0x30
    8b98:	2909      	cmp	r1, #9
    8b9a:	d813      	bhi.n	8bc4 <_strtol_l.isra.0+0xb4>
    8b9c:	000c      	movs	r4, r1
    8b9e:	42a7      	cmp	r7, r4
    8ba0:	dd1c      	ble.n	8bdc <_strtol_l.isra.0+0xcc>
    8ba2:	1c59      	adds	r1, r3, #1
    8ba4:	d009      	beq.n	8bba <_strtol_l.isra.0+0xaa>
    8ba6:	4663      	mov	r3, ip
    8ba8:	4282      	cmp	r2, r0
    8baa:	d306      	bcc.n	8bba <_strtol_l.isra.0+0xaa>
    8bac:	d102      	bne.n	8bb4 <_strtol_l.isra.0+0xa4>
    8bae:	9904      	ldr	r1, [sp, #16]
    8bb0:	42a1      	cmp	r1, r4
    8bb2:	db02      	blt.n	8bba <_strtol_l.isra.0+0xaa>
    8bb4:	2301      	movs	r3, #1
    8bb6:	4378      	muls	r0, r7
    8bb8:	1820      	adds	r0, r4, r0
    8bba:	782c      	ldrb	r4, [r5, #0]
    8bbc:	3501      	adds	r5, #1
    8bbe:	e7e9      	b.n	8b94 <_strtol_l.isra.0+0x84>
    8bc0:	270a      	movs	r7, #10
    8bc2:	e7d5      	b.n	8b70 <_strtol_l.isra.0+0x60>
    8bc4:	0021      	movs	r1, r4
    8bc6:	3941      	subs	r1, #65	; 0x41
    8bc8:	2919      	cmp	r1, #25
    8bca:	d801      	bhi.n	8bd0 <_strtol_l.isra.0+0xc0>
    8bcc:	3c37      	subs	r4, #55	; 0x37
    8bce:	e7e6      	b.n	8b9e <_strtol_l.isra.0+0x8e>
    8bd0:	0021      	movs	r1, r4
    8bd2:	3961      	subs	r1, #97	; 0x61
    8bd4:	2919      	cmp	r1, #25
    8bd6:	d801      	bhi.n	8bdc <_strtol_l.isra.0+0xcc>
    8bd8:	3c57      	subs	r4, #87	; 0x57
    8bda:	e7e0      	b.n	8b9e <_strtol_l.isra.0+0x8e>
    8bdc:	1c5a      	adds	r2, r3, #1
    8bde:	d108      	bne.n	8bf2 <_strtol_l.isra.0+0xe2>
    8be0:	9a05      	ldr	r2, [sp, #20]
    8be2:	3323      	adds	r3, #35	; 0x23
    8be4:	6013      	str	r3, [r2, #0]
    8be6:	9b02      	ldr	r3, [sp, #8]
    8be8:	0030      	movs	r0, r6
    8bea:	2b00      	cmp	r3, #0
    8bec:	d10b      	bne.n	8c06 <_strtol_l.isra.0+0xf6>
    8bee:	b007      	add	sp, #28
    8bf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8bf2:	9a01      	ldr	r2, [sp, #4]
    8bf4:	2a00      	cmp	r2, #0
    8bf6:	d000      	beq.n	8bfa <_strtol_l.isra.0+0xea>
    8bf8:	4240      	negs	r0, r0
    8bfa:	9a02      	ldr	r2, [sp, #8]
    8bfc:	2a00      	cmp	r2, #0
    8bfe:	d0f6      	beq.n	8bee <_strtol_l.isra.0+0xde>
    8c00:	9a03      	ldr	r2, [sp, #12]
    8c02:	2b00      	cmp	r3, #0
    8c04:	d000      	beq.n	8c08 <_strtol_l.isra.0+0xf8>
    8c06:	1e6a      	subs	r2, r5, #1
    8c08:	9b02      	ldr	r3, [sp, #8]
    8c0a:	601a      	str	r2, [r3, #0]
    8c0c:	e7ef      	b.n	8bee <_strtol_l.isra.0+0xde>
    8c0e:	2430      	movs	r4, #48	; 0x30
    8c10:	2f00      	cmp	r7, #0
    8c12:	d1ad      	bne.n	8b70 <_strtol_l.isra.0+0x60>
    8c14:	3708      	adds	r7, #8
    8c16:	e7ab      	b.n	8b70 <_strtol_l.isra.0+0x60>
    8c18:	7fffffff 	.word	0x7fffffff

00008c1c <_strtol_r>:
    8c1c:	b513      	push	{r0, r1, r4, lr}
    8c1e:	4c05      	ldr	r4, [pc, #20]	; (8c34 <_strtol_r+0x18>)
    8c20:	6824      	ldr	r4, [r4, #0]
    8c22:	6a24      	ldr	r4, [r4, #32]
    8c24:	2c00      	cmp	r4, #0
    8c26:	d100      	bne.n	8c2a <_strtol_r+0xe>
    8c28:	4c03      	ldr	r4, [pc, #12]	; (8c38 <_strtol_r+0x1c>)
    8c2a:	9400      	str	r4, [sp, #0]
    8c2c:	f7ff ff70 	bl	8b10 <_strtol_l.isra.0>
    8c30:	bd16      	pop	{r1, r2, r4, pc}
    8c32:	46c0      	nop			; (mov r8, r8)
    8c34:	20000114 	.word	0x20000114
    8c38:	20000178 	.word	0x20000178

00008c3c <strtol>:
    8c3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8c3e:	0013      	movs	r3, r2
    8c40:	4a06      	ldr	r2, [pc, #24]	; (8c5c <strtol+0x20>)
    8c42:	0005      	movs	r5, r0
    8c44:	6810      	ldr	r0, [r2, #0]
    8c46:	6a04      	ldr	r4, [r0, #32]
    8c48:	2c00      	cmp	r4, #0
    8c4a:	d100      	bne.n	8c4e <strtol+0x12>
    8c4c:	4c04      	ldr	r4, [pc, #16]	; (8c60 <strtol+0x24>)
    8c4e:	000a      	movs	r2, r1
    8c50:	9400      	str	r4, [sp, #0]
    8c52:	0029      	movs	r1, r5
    8c54:	f7ff ff5c 	bl	8b10 <_strtol_l.isra.0>
    8c58:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    8c5a:	46c0      	nop			; (mov r8, r8)
    8c5c:	20000114 	.word	0x20000114
    8c60:	20000178 	.word	0x20000178

00008c64 <_strtoul_l.isra.0>:
    8c64:	b5f0      	push	{r4, r5, r6, r7, lr}
    8c66:	001f      	movs	r7, r3
    8c68:	000e      	movs	r6, r1
    8c6a:	b087      	sub	sp, #28
    8c6c:	9005      	str	r0, [sp, #20]
    8c6e:	9103      	str	r1, [sp, #12]
    8c70:	9201      	str	r2, [sp, #4]
    8c72:	980c      	ldr	r0, [sp, #48]	; 0x30
    8c74:	7834      	ldrb	r4, [r6, #0]
    8c76:	f7ff fe41 	bl	88fc <__locale_ctype_ptr_l>
    8c7a:	2208      	movs	r2, #8
    8c7c:	1900      	adds	r0, r0, r4
    8c7e:	7843      	ldrb	r3, [r0, #1]
    8c80:	1c75      	adds	r5, r6, #1
    8c82:	4013      	ands	r3, r2
    8c84:	d10c      	bne.n	8ca0 <_strtoul_l.isra.0+0x3c>
    8c86:	2c2d      	cmp	r4, #45	; 0x2d
    8c88:	d10c      	bne.n	8ca4 <_strtoul_l.isra.0+0x40>
    8c8a:	3301      	adds	r3, #1
    8c8c:	782c      	ldrb	r4, [r5, #0]
    8c8e:	9302      	str	r3, [sp, #8]
    8c90:	1cb5      	adds	r5, r6, #2
    8c92:	2f00      	cmp	r7, #0
    8c94:	d00c      	beq.n	8cb0 <_strtoul_l.isra.0+0x4c>
    8c96:	2f10      	cmp	r7, #16
    8c98:	d114      	bne.n	8cc4 <_strtoul_l.isra.0+0x60>
    8c9a:	2c30      	cmp	r4, #48	; 0x30
    8c9c:	d00a      	beq.n	8cb4 <_strtoul_l.isra.0+0x50>
    8c9e:	e011      	b.n	8cc4 <_strtoul_l.isra.0+0x60>
    8ca0:	002e      	movs	r6, r5
    8ca2:	e7e6      	b.n	8c72 <_strtoul_l.isra.0+0xe>
    8ca4:	9302      	str	r3, [sp, #8]
    8ca6:	2c2b      	cmp	r4, #43	; 0x2b
    8ca8:	d1f3      	bne.n	8c92 <_strtoul_l.isra.0+0x2e>
    8caa:	782c      	ldrb	r4, [r5, #0]
    8cac:	1cb5      	adds	r5, r6, #2
    8cae:	e7f0      	b.n	8c92 <_strtoul_l.isra.0+0x2e>
    8cb0:	2c30      	cmp	r4, #48	; 0x30
    8cb2:	d12f      	bne.n	8d14 <_strtoul_l.isra.0+0xb0>
    8cb4:	2220      	movs	r2, #32
    8cb6:	782b      	ldrb	r3, [r5, #0]
    8cb8:	4393      	bics	r3, r2
    8cba:	2b58      	cmp	r3, #88	; 0x58
    8cbc:	d154      	bne.n	8d68 <_strtoul_l.isra.0+0x104>
    8cbe:	2710      	movs	r7, #16
    8cc0:	786c      	ldrb	r4, [r5, #1]
    8cc2:	3502      	adds	r5, #2
    8cc4:	2001      	movs	r0, #1
    8cc6:	0039      	movs	r1, r7
    8cc8:	4240      	negs	r0, r0
    8cca:	f7ff f95d 	bl	7f88 <__udivsi3>
    8cce:	0006      	movs	r6, r0
    8cd0:	2001      	movs	r0, #1
    8cd2:	0039      	movs	r1, r7
    8cd4:	4240      	negs	r0, r0
    8cd6:	f7ff f9dd 	bl	8094 <__aeabi_uidivmod>
    8cda:	2300      	movs	r3, #0
    8cdc:	9104      	str	r1, [sp, #16]
    8cde:	2101      	movs	r1, #1
    8ce0:	2201      	movs	r2, #1
    8ce2:	0018      	movs	r0, r3
    8ce4:	468c      	mov	ip, r1
    8ce6:	4252      	negs	r2, r2
    8ce8:	0021      	movs	r1, r4
    8cea:	3930      	subs	r1, #48	; 0x30
    8cec:	2909      	cmp	r1, #9
    8cee:	d813      	bhi.n	8d18 <_strtoul_l.isra.0+0xb4>
    8cf0:	000c      	movs	r4, r1
    8cf2:	42a7      	cmp	r7, r4
    8cf4:	dd1e      	ble.n	8d34 <_strtoul_l.isra.0+0xd0>
    8cf6:	2b00      	cmp	r3, #0
    8cf8:	db1a      	blt.n	8d30 <_strtoul_l.isra.0+0xcc>
    8cfa:	0013      	movs	r3, r2
    8cfc:	4286      	cmp	r6, r0
    8cfe:	d306      	bcc.n	8d0e <_strtoul_l.isra.0+0xaa>
    8d00:	d102      	bne.n	8d08 <_strtoul_l.isra.0+0xa4>
    8d02:	9904      	ldr	r1, [sp, #16]
    8d04:	42a1      	cmp	r1, r4
    8d06:	db02      	blt.n	8d0e <_strtoul_l.isra.0+0xaa>
    8d08:	4663      	mov	r3, ip
    8d0a:	4378      	muls	r0, r7
    8d0c:	1820      	adds	r0, r4, r0
    8d0e:	782c      	ldrb	r4, [r5, #0]
    8d10:	3501      	adds	r5, #1
    8d12:	e7e9      	b.n	8ce8 <_strtoul_l.isra.0+0x84>
    8d14:	270a      	movs	r7, #10
    8d16:	e7d5      	b.n	8cc4 <_strtoul_l.isra.0+0x60>
    8d18:	0021      	movs	r1, r4
    8d1a:	3941      	subs	r1, #65	; 0x41
    8d1c:	2919      	cmp	r1, #25
    8d1e:	d801      	bhi.n	8d24 <_strtoul_l.isra.0+0xc0>
    8d20:	3c37      	subs	r4, #55	; 0x37
    8d22:	e7e6      	b.n	8cf2 <_strtoul_l.isra.0+0x8e>
    8d24:	0021      	movs	r1, r4
    8d26:	3961      	subs	r1, #97	; 0x61
    8d28:	2919      	cmp	r1, #25
    8d2a:	d803      	bhi.n	8d34 <_strtoul_l.isra.0+0xd0>
    8d2c:	3c57      	subs	r4, #87	; 0x57
    8d2e:	e7e0      	b.n	8cf2 <_strtoul_l.isra.0+0x8e>
    8d30:	0013      	movs	r3, r2
    8d32:	e7ec      	b.n	8d0e <_strtoul_l.isra.0+0xaa>
    8d34:	2b00      	cmp	r3, #0
    8d36:	da09      	bge.n	8d4c <_strtoul_l.isra.0+0xe8>
    8d38:	2322      	movs	r3, #34	; 0x22
    8d3a:	2001      	movs	r0, #1
    8d3c:	9a05      	ldr	r2, [sp, #20]
    8d3e:	4240      	negs	r0, r0
    8d40:	6013      	str	r3, [r2, #0]
    8d42:	9b01      	ldr	r3, [sp, #4]
    8d44:	2b00      	cmp	r3, #0
    8d46:	d10b      	bne.n	8d60 <_strtoul_l.isra.0+0xfc>
    8d48:	b007      	add	sp, #28
    8d4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d4c:	9a02      	ldr	r2, [sp, #8]
    8d4e:	2a00      	cmp	r2, #0
    8d50:	d000      	beq.n	8d54 <_strtoul_l.isra.0+0xf0>
    8d52:	4240      	negs	r0, r0
    8d54:	9a01      	ldr	r2, [sp, #4]
    8d56:	2a00      	cmp	r2, #0
    8d58:	d0f6      	beq.n	8d48 <_strtoul_l.isra.0+0xe4>
    8d5a:	9a03      	ldr	r2, [sp, #12]
    8d5c:	2b00      	cmp	r3, #0
    8d5e:	d000      	beq.n	8d62 <_strtoul_l.isra.0+0xfe>
    8d60:	1e6a      	subs	r2, r5, #1
    8d62:	9b01      	ldr	r3, [sp, #4]
    8d64:	601a      	str	r2, [r3, #0]
    8d66:	e7ef      	b.n	8d48 <_strtoul_l.isra.0+0xe4>
    8d68:	2430      	movs	r4, #48	; 0x30
    8d6a:	2f00      	cmp	r7, #0
    8d6c:	d1aa      	bne.n	8cc4 <_strtoul_l.isra.0+0x60>
    8d6e:	3708      	adds	r7, #8
    8d70:	e7a8      	b.n	8cc4 <_strtoul_l.isra.0+0x60>
	...

00008d74 <_strtoul_r>:
    8d74:	b513      	push	{r0, r1, r4, lr}
    8d76:	4c05      	ldr	r4, [pc, #20]	; (8d8c <_strtoul_r+0x18>)
    8d78:	6824      	ldr	r4, [r4, #0]
    8d7a:	6a24      	ldr	r4, [r4, #32]
    8d7c:	2c00      	cmp	r4, #0
    8d7e:	d100      	bne.n	8d82 <_strtoul_r+0xe>
    8d80:	4c03      	ldr	r4, [pc, #12]	; (8d90 <_strtoul_r+0x1c>)
    8d82:	9400      	str	r4, [sp, #0]
    8d84:	f7ff ff6e 	bl	8c64 <_strtoul_l.isra.0>
    8d88:	bd16      	pop	{r1, r2, r4, pc}
    8d8a:	46c0      	nop			; (mov r8, r8)
    8d8c:	20000114 	.word	0x20000114
    8d90:	20000178 	.word	0x20000178

00008d94 <strtoul>:
    8d94:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8d96:	0013      	movs	r3, r2
    8d98:	4a06      	ldr	r2, [pc, #24]	; (8db4 <strtoul+0x20>)
    8d9a:	0005      	movs	r5, r0
    8d9c:	6810      	ldr	r0, [r2, #0]
    8d9e:	6a04      	ldr	r4, [r0, #32]
    8da0:	2c00      	cmp	r4, #0
    8da2:	d100      	bne.n	8da6 <strtoul+0x12>
    8da4:	4c04      	ldr	r4, [pc, #16]	; (8db8 <strtoul+0x24>)
    8da6:	000a      	movs	r2, r1
    8da8:	9400      	str	r4, [sp, #0]
    8daa:	0029      	movs	r1, r5
    8dac:	f7ff ff5a 	bl	8c64 <_strtoul_l.isra.0>
    8db0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    8db2:	46c0      	nop			; (mov r8, r8)
    8db4:	20000114 	.word	0x20000114
    8db8:	20000178 	.word	0x20000178

00008dbc <_vsiprintf_r>:
    8dbc:	b530      	push	{r4, r5, lr}
    8dbe:	b09b      	sub	sp, #108	; 0x6c
    8dc0:	9100      	str	r1, [sp, #0]
    8dc2:	9104      	str	r1, [sp, #16]
    8dc4:	4908      	ldr	r1, [pc, #32]	; (8de8 <_vsiprintf_r+0x2c>)
    8dc6:	466d      	mov	r5, sp
    8dc8:	9102      	str	r1, [sp, #8]
    8dca:	9105      	str	r1, [sp, #20]
    8dcc:	2101      	movs	r1, #1
    8dce:	2482      	movs	r4, #130	; 0x82
    8dd0:	4249      	negs	r1, r1
    8dd2:	81e9      	strh	r1, [r5, #14]
    8dd4:	00a4      	lsls	r4, r4, #2
    8dd6:	4669      	mov	r1, sp
    8dd8:	81ac      	strh	r4, [r5, #12]
    8dda:	f000 f8df 	bl	8f9c <_svfiprintf_r>
    8dde:	2300      	movs	r3, #0
    8de0:	9a00      	ldr	r2, [sp, #0]
    8de2:	7013      	strb	r3, [r2, #0]
    8de4:	b01b      	add	sp, #108	; 0x6c
    8de6:	bd30      	pop	{r4, r5, pc}
    8de8:	7fffffff 	.word	0x7fffffff

00008dec <vsiprintf>:
    8dec:	b510      	push	{r4, lr}
    8dee:	0013      	movs	r3, r2
    8df0:	000a      	movs	r2, r1
    8df2:	0001      	movs	r1, r0
    8df4:	4802      	ldr	r0, [pc, #8]	; (8e00 <vsiprintf+0x14>)
    8df6:	6800      	ldr	r0, [r0, #0]
    8df8:	f7ff ffe0 	bl	8dbc <_vsiprintf_r>
    8dfc:	bd10      	pop	{r4, pc}
    8dfe:	46c0      	nop			; (mov r8, r8)
    8e00:	20000114 	.word	0x20000114

00008e04 <__ascii_wctomb>:
    8e04:	1e0b      	subs	r3, r1, #0
    8e06:	d004      	beq.n	8e12 <__ascii_wctomb+0xe>
    8e08:	2aff      	cmp	r2, #255	; 0xff
    8e0a:	d904      	bls.n	8e16 <__ascii_wctomb+0x12>
    8e0c:	238a      	movs	r3, #138	; 0x8a
    8e0e:	6003      	str	r3, [r0, #0]
    8e10:	3b8b      	subs	r3, #139	; 0x8b
    8e12:	0018      	movs	r0, r3
    8e14:	4770      	bx	lr
    8e16:	700a      	strb	r2, [r1, #0]
    8e18:	2301      	movs	r3, #1
    8e1a:	e7fa      	b.n	8e12 <__ascii_wctomb+0xe>

00008e1c <_malloc_r>:
    8e1c:	2303      	movs	r3, #3
    8e1e:	b570      	push	{r4, r5, r6, lr}
    8e20:	1ccd      	adds	r5, r1, #3
    8e22:	439d      	bics	r5, r3
    8e24:	3508      	adds	r5, #8
    8e26:	0006      	movs	r6, r0
    8e28:	2d0c      	cmp	r5, #12
    8e2a:	d21e      	bcs.n	8e6a <_malloc_r+0x4e>
    8e2c:	250c      	movs	r5, #12
    8e2e:	42a9      	cmp	r1, r5
    8e30:	d81d      	bhi.n	8e6e <_malloc_r+0x52>
    8e32:	0030      	movs	r0, r6
    8e34:	f000 ff23 	bl	9c7e <__malloc_lock>
    8e38:	4a25      	ldr	r2, [pc, #148]	; (8ed0 <_malloc_r+0xb4>)
    8e3a:	6814      	ldr	r4, [r2, #0]
    8e3c:	0021      	movs	r1, r4
    8e3e:	2900      	cmp	r1, #0
    8e40:	d119      	bne.n	8e76 <_malloc_r+0x5a>
    8e42:	4c24      	ldr	r4, [pc, #144]	; (8ed4 <_malloc_r+0xb8>)
    8e44:	6823      	ldr	r3, [r4, #0]
    8e46:	2b00      	cmp	r3, #0
    8e48:	d103      	bne.n	8e52 <_malloc_r+0x36>
    8e4a:	0030      	movs	r0, r6
    8e4c:	f000 fe78 	bl	9b40 <_sbrk_r>
    8e50:	6020      	str	r0, [r4, #0]
    8e52:	0029      	movs	r1, r5
    8e54:	0030      	movs	r0, r6
    8e56:	f000 fe73 	bl	9b40 <_sbrk_r>
    8e5a:	1c43      	adds	r3, r0, #1
    8e5c:	d12c      	bne.n	8eb8 <_malloc_r+0x9c>
    8e5e:	230c      	movs	r3, #12
    8e60:	0030      	movs	r0, r6
    8e62:	6033      	str	r3, [r6, #0]
    8e64:	f000 ff0c 	bl	9c80 <__malloc_unlock>
    8e68:	e003      	b.n	8e72 <_malloc_r+0x56>
    8e6a:	2d00      	cmp	r5, #0
    8e6c:	dadf      	bge.n	8e2e <_malloc_r+0x12>
    8e6e:	230c      	movs	r3, #12
    8e70:	6033      	str	r3, [r6, #0]
    8e72:	2000      	movs	r0, #0
    8e74:	bd70      	pop	{r4, r5, r6, pc}
    8e76:	680b      	ldr	r3, [r1, #0]
    8e78:	1b5b      	subs	r3, r3, r5
    8e7a:	d41a      	bmi.n	8eb2 <_malloc_r+0x96>
    8e7c:	2b0b      	cmp	r3, #11
    8e7e:	d903      	bls.n	8e88 <_malloc_r+0x6c>
    8e80:	600b      	str	r3, [r1, #0]
    8e82:	18cc      	adds	r4, r1, r3
    8e84:	6025      	str	r5, [r4, #0]
    8e86:	e003      	b.n	8e90 <_malloc_r+0x74>
    8e88:	428c      	cmp	r4, r1
    8e8a:	d10e      	bne.n	8eaa <_malloc_r+0x8e>
    8e8c:	6863      	ldr	r3, [r4, #4]
    8e8e:	6013      	str	r3, [r2, #0]
    8e90:	0030      	movs	r0, r6
    8e92:	f000 fef5 	bl	9c80 <__malloc_unlock>
    8e96:	0020      	movs	r0, r4
    8e98:	2207      	movs	r2, #7
    8e9a:	300b      	adds	r0, #11
    8e9c:	1d23      	adds	r3, r4, #4
    8e9e:	4390      	bics	r0, r2
    8ea0:	1ac3      	subs	r3, r0, r3
    8ea2:	d0e7      	beq.n	8e74 <_malloc_r+0x58>
    8ea4:	425a      	negs	r2, r3
    8ea6:	50e2      	str	r2, [r4, r3]
    8ea8:	e7e4      	b.n	8e74 <_malloc_r+0x58>
    8eaa:	684b      	ldr	r3, [r1, #4]
    8eac:	6063      	str	r3, [r4, #4]
    8eae:	000c      	movs	r4, r1
    8eb0:	e7ee      	b.n	8e90 <_malloc_r+0x74>
    8eb2:	000c      	movs	r4, r1
    8eb4:	6849      	ldr	r1, [r1, #4]
    8eb6:	e7c2      	b.n	8e3e <_malloc_r+0x22>
    8eb8:	2303      	movs	r3, #3
    8eba:	1cc4      	adds	r4, r0, #3
    8ebc:	439c      	bics	r4, r3
    8ebe:	42a0      	cmp	r0, r4
    8ec0:	d0e0      	beq.n	8e84 <_malloc_r+0x68>
    8ec2:	1a21      	subs	r1, r4, r0
    8ec4:	0030      	movs	r0, r6
    8ec6:	f000 fe3b 	bl	9b40 <_sbrk_r>
    8eca:	1c43      	adds	r3, r0, #1
    8ecc:	d1da      	bne.n	8e84 <_malloc_r+0x68>
    8ece:	e7c6      	b.n	8e5e <_malloc_r+0x42>
    8ed0:	200008ac 	.word	0x200008ac
    8ed4:	200008b0 	.word	0x200008b0

00008ed8 <__ssputs_r>:
    8ed8:	b5f0      	push	{r4, r5, r6, r7, lr}
    8eda:	688e      	ldr	r6, [r1, #8]
    8edc:	b085      	sub	sp, #20
    8ede:	0007      	movs	r7, r0
    8ee0:	000c      	movs	r4, r1
    8ee2:	9203      	str	r2, [sp, #12]
    8ee4:	9301      	str	r3, [sp, #4]
    8ee6:	429e      	cmp	r6, r3
    8ee8:	d839      	bhi.n	8f5e <__ssputs_r+0x86>
    8eea:	2390      	movs	r3, #144	; 0x90
    8eec:	898a      	ldrh	r2, [r1, #12]
    8eee:	00db      	lsls	r3, r3, #3
    8ef0:	421a      	tst	r2, r3
    8ef2:	d034      	beq.n	8f5e <__ssputs_r+0x86>
    8ef4:	2503      	movs	r5, #3
    8ef6:	6909      	ldr	r1, [r1, #16]
    8ef8:	6823      	ldr	r3, [r4, #0]
    8efa:	1a5b      	subs	r3, r3, r1
    8efc:	9302      	str	r3, [sp, #8]
    8efe:	6963      	ldr	r3, [r4, #20]
    8f00:	9802      	ldr	r0, [sp, #8]
    8f02:	435d      	muls	r5, r3
    8f04:	0feb      	lsrs	r3, r5, #31
    8f06:	195d      	adds	r5, r3, r5
    8f08:	9b01      	ldr	r3, [sp, #4]
    8f0a:	106d      	asrs	r5, r5, #1
    8f0c:	3301      	adds	r3, #1
    8f0e:	181b      	adds	r3, r3, r0
    8f10:	42ab      	cmp	r3, r5
    8f12:	d900      	bls.n	8f16 <__ssputs_r+0x3e>
    8f14:	001d      	movs	r5, r3
    8f16:	0553      	lsls	r3, r2, #21
    8f18:	d532      	bpl.n	8f80 <__ssputs_r+0xa8>
    8f1a:	0029      	movs	r1, r5
    8f1c:	0038      	movs	r0, r7
    8f1e:	f7ff ff7d 	bl	8e1c <_malloc_r>
    8f22:	1e06      	subs	r6, r0, #0
    8f24:	d109      	bne.n	8f3a <__ssputs_r+0x62>
    8f26:	230c      	movs	r3, #12
    8f28:	603b      	str	r3, [r7, #0]
    8f2a:	2340      	movs	r3, #64	; 0x40
    8f2c:	2001      	movs	r0, #1
    8f2e:	89a2      	ldrh	r2, [r4, #12]
    8f30:	4240      	negs	r0, r0
    8f32:	4313      	orrs	r3, r2
    8f34:	81a3      	strh	r3, [r4, #12]
    8f36:	b005      	add	sp, #20
    8f38:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8f3a:	9a02      	ldr	r2, [sp, #8]
    8f3c:	6921      	ldr	r1, [r4, #16]
    8f3e:	f7ff fd01 	bl	8944 <memcpy>
    8f42:	89a3      	ldrh	r3, [r4, #12]
    8f44:	4a14      	ldr	r2, [pc, #80]	; (8f98 <__ssputs_r+0xc0>)
    8f46:	401a      	ands	r2, r3
    8f48:	2380      	movs	r3, #128	; 0x80
    8f4a:	4313      	orrs	r3, r2
    8f4c:	81a3      	strh	r3, [r4, #12]
    8f4e:	9b02      	ldr	r3, [sp, #8]
    8f50:	6126      	str	r6, [r4, #16]
    8f52:	18f6      	adds	r6, r6, r3
    8f54:	6026      	str	r6, [r4, #0]
    8f56:	6165      	str	r5, [r4, #20]
    8f58:	9e01      	ldr	r6, [sp, #4]
    8f5a:	1aed      	subs	r5, r5, r3
    8f5c:	60a5      	str	r5, [r4, #8]
    8f5e:	9b01      	ldr	r3, [sp, #4]
    8f60:	42b3      	cmp	r3, r6
    8f62:	d200      	bcs.n	8f66 <__ssputs_r+0x8e>
    8f64:	001e      	movs	r6, r3
    8f66:	0032      	movs	r2, r6
    8f68:	9903      	ldr	r1, [sp, #12]
    8f6a:	6820      	ldr	r0, [r4, #0]
    8f6c:	f000 fe75 	bl	9c5a <memmove>
    8f70:	68a3      	ldr	r3, [r4, #8]
    8f72:	2000      	movs	r0, #0
    8f74:	1b9b      	subs	r3, r3, r6
    8f76:	60a3      	str	r3, [r4, #8]
    8f78:	6823      	ldr	r3, [r4, #0]
    8f7a:	199e      	adds	r6, r3, r6
    8f7c:	6026      	str	r6, [r4, #0]
    8f7e:	e7da      	b.n	8f36 <__ssputs_r+0x5e>
    8f80:	002a      	movs	r2, r5
    8f82:	0038      	movs	r0, r7
    8f84:	f000 fec8 	bl	9d18 <_realloc_r>
    8f88:	1e06      	subs	r6, r0, #0
    8f8a:	d1e0      	bne.n	8f4e <__ssputs_r+0x76>
    8f8c:	6921      	ldr	r1, [r4, #16]
    8f8e:	0038      	movs	r0, r7
    8f90:	f000 fe78 	bl	9c84 <_free_r>
    8f94:	e7c7      	b.n	8f26 <__ssputs_r+0x4e>
    8f96:	46c0      	nop			; (mov r8, r8)
    8f98:	fffffb7f 	.word	0xfffffb7f

00008f9c <_svfiprintf_r>:
    8f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8f9e:	b09f      	sub	sp, #124	; 0x7c
    8fa0:	9002      	str	r0, [sp, #8]
    8fa2:	9305      	str	r3, [sp, #20]
    8fa4:	898b      	ldrh	r3, [r1, #12]
    8fa6:	000f      	movs	r7, r1
    8fa8:	0016      	movs	r6, r2
    8faa:	061b      	lsls	r3, r3, #24
    8fac:	d511      	bpl.n	8fd2 <_svfiprintf_r+0x36>
    8fae:	690b      	ldr	r3, [r1, #16]
    8fb0:	2b00      	cmp	r3, #0
    8fb2:	d10e      	bne.n	8fd2 <_svfiprintf_r+0x36>
    8fb4:	2140      	movs	r1, #64	; 0x40
    8fb6:	f7ff ff31 	bl	8e1c <_malloc_r>
    8fba:	6038      	str	r0, [r7, #0]
    8fbc:	6138      	str	r0, [r7, #16]
    8fbe:	2800      	cmp	r0, #0
    8fc0:	d105      	bne.n	8fce <_svfiprintf_r+0x32>
    8fc2:	230c      	movs	r3, #12
    8fc4:	9a02      	ldr	r2, [sp, #8]
    8fc6:	3801      	subs	r0, #1
    8fc8:	6013      	str	r3, [r2, #0]
    8fca:	b01f      	add	sp, #124	; 0x7c
    8fcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8fce:	2340      	movs	r3, #64	; 0x40
    8fd0:	617b      	str	r3, [r7, #20]
    8fd2:	2300      	movs	r3, #0
    8fd4:	ad06      	add	r5, sp, #24
    8fd6:	616b      	str	r3, [r5, #20]
    8fd8:	3320      	adds	r3, #32
    8fda:	766b      	strb	r3, [r5, #25]
    8fdc:	3310      	adds	r3, #16
    8fde:	76ab      	strb	r3, [r5, #26]
    8fe0:	0034      	movs	r4, r6
    8fe2:	7823      	ldrb	r3, [r4, #0]
    8fe4:	2b00      	cmp	r3, #0
    8fe6:	d147      	bne.n	9078 <_svfiprintf_r+0xdc>
    8fe8:	1ba3      	subs	r3, r4, r6
    8fea:	9304      	str	r3, [sp, #16]
    8fec:	d00d      	beq.n	900a <_svfiprintf_r+0x6e>
    8fee:	1ba3      	subs	r3, r4, r6
    8ff0:	0032      	movs	r2, r6
    8ff2:	0039      	movs	r1, r7
    8ff4:	9802      	ldr	r0, [sp, #8]
    8ff6:	f7ff ff6f 	bl	8ed8 <__ssputs_r>
    8ffa:	1c43      	adds	r3, r0, #1
    8ffc:	d100      	bne.n	9000 <_svfiprintf_r+0x64>
    8ffe:	e0b5      	b.n	916c <_svfiprintf_r+0x1d0>
    9000:	696a      	ldr	r2, [r5, #20]
    9002:	9b04      	ldr	r3, [sp, #16]
    9004:	4694      	mov	ip, r2
    9006:	4463      	add	r3, ip
    9008:	616b      	str	r3, [r5, #20]
    900a:	7823      	ldrb	r3, [r4, #0]
    900c:	2b00      	cmp	r3, #0
    900e:	d100      	bne.n	9012 <_svfiprintf_r+0x76>
    9010:	e0ac      	b.n	916c <_svfiprintf_r+0x1d0>
    9012:	2201      	movs	r2, #1
    9014:	2300      	movs	r3, #0
    9016:	4252      	negs	r2, r2
    9018:	606a      	str	r2, [r5, #4]
    901a:	a902      	add	r1, sp, #8
    901c:	3254      	adds	r2, #84	; 0x54
    901e:	1852      	adds	r2, r2, r1
    9020:	3401      	adds	r4, #1
    9022:	602b      	str	r3, [r5, #0]
    9024:	60eb      	str	r3, [r5, #12]
    9026:	60ab      	str	r3, [r5, #8]
    9028:	7013      	strb	r3, [r2, #0]
    902a:	65ab      	str	r3, [r5, #88]	; 0x58
    902c:	4e58      	ldr	r6, [pc, #352]	; (9190 <_svfiprintf_r+0x1f4>)
    902e:	2205      	movs	r2, #5
    9030:	7821      	ldrb	r1, [r4, #0]
    9032:	0030      	movs	r0, r6
    9034:	f000 fe06 	bl	9c44 <memchr>
    9038:	1c62      	adds	r2, r4, #1
    903a:	2800      	cmp	r0, #0
    903c:	d120      	bne.n	9080 <_svfiprintf_r+0xe4>
    903e:	6829      	ldr	r1, [r5, #0]
    9040:	06cb      	lsls	r3, r1, #27
    9042:	d504      	bpl.n	904e <_svfiprintf_r+0xb2>
    9044:	2353      	movs	r3, #83	; 0x53
    9046:	ae02      	add	r6, sp, #8
    9048:	3020      	adds	r0, #32
    904a:	199b      	adds	r3, r3, r6
    904c:	7018      	strb	r0, [r3, #0]
    904e:	070b      	lsls	r3, r1, #28
    9050:	d504      	bpl.n	905c <_svfiprintf_r+0xc0>
    9052:	2353      	movs	r3, #83	; 0x53
    9054:	202b      	movs	r0, #43	; 0x2b
    9056:	ae02      	add	r6, sp, #8
    9058:	199b      	adds	r3, r3, r6
    905a:	7018      	strb	r0, [r3, #0]
    905c:	7823      	ldrb	r3, [r4, #0]
    905e:	2b2a      	cmp	r3, #42	; 0x2a
    9060:	d016      	beq.n	9090 <_svfiprintf_r+0xf4>
    9062:	2000      	movs	r0, #0
    9064:	210a      	movs	r1, #10
    9066:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9068:	7822      	ldrb	r2, [r4, #0]
    906a:	3a30      	subs	r2, #48	; 0x30
    906c:	2a09      	cmp	r2, #9
    906e:	d955      	bls.n	911c <_svfiprintf_r+0x180>
    9070:	2800      	cmp	r0, #0
    9072:	d015      	beq.n	90a0 <_svfiprintf_r+0x104>
    9074:	9309      	str	r3, [sp, #36]	; 0x24
    9076:	e013      	b.n	90a0 <_svfiprintf_r+0x104>
    9078:	2b25      	cmp	r3, #37	; 0x25
    907a:	d0b5      	beq.n	8fe8 <_svfiprintf_r+0x4c>
    907c:	3401      	adds	r4, #1
    907e:	e7b0      	b.n	8fe2 <_svfiprintf_r+0x46>
    9080:	2301      	movs	r3, #1
    9082:	1b80      	subs	r0, r0, r6
    9084:	4083      	lsls	r3, r0
    9086:	6829      	ldr	r1, [r5, #0]
    9088:	0014      	movs	r4, r2
    908a:	430b      	orrs	r3, r1
    908c:	602b      	str	r3, [r5, #0]
    908e:	e7cd      	b.n	902c <_svfiprintf_r+0x90>
    9090:	9b05      	ldr	r3, [sp, #20]
    9092:	1d18      	adds	r0, r3, #4
    9094:	681b      	ldr	r3, [r3, #0]
    9096:	9005      	str	r0, [sp, #20]
    9098:	2b00      	cmp	r3, #0
    909a:	db39      	blt.n	9110 <_svfiprintf_r+0x174>
    909c:	9309      	str	r3, [sp, #36]	; 0x24
    909e:	0014      	movs	r4, r2
    90a0:	7823      	ldrb	r3, [r4, #0]
    90a2:	2b2e      	cmp	r3, #46	; 0x2e
    90a4:	d10b      	bne.n	90be <_svfiprintf_r+0x122>
    90a6:	7863      	ldrb	r3, [r4, #1]
    90a8:	1c62      	adds	r2, r4, #1
    90aa:	2b2a      	cmp	r3, #42	; 0x2a
    90ac:	d13e      	bne.n	912c <_svfiprintf_r+0x190>
    90ae:	9b05      	ldr	r3, [sp, #20]
    90b0:	3402      	adds	r4, #2
    90b2:	1d1a      	adds	r2, r3, #4
    90b4:	681b      	ldr	r3, [r3, #0]
    90b6:	9205      	str	r2, [sp, #20]
    90b8:	2b00      	cmp	r3, #0
    90ba:	db34      	blt.n	9126 <_svfiprintf_r+0x18a>
    90bc:	9307      	str	r3, [sp, #28]
    90be:	4e35      	ldr	r6, [pc, #212]	; (9194 <_svfiprintf_r+0x1f8>)
    90c0:	7821      	ldrb	r1, [r4, #0]
    90c2:	2203      	movs	r2, #3
    90c4:	0030      	movs	r0, r6
    90c6:	f000 fdbd 	bl	9c44 <memchr>
    90ca:	2800      	cmp	r0, #0
    90cc:	d006      	beq.n	90dc <_svfiprintf_r+0x140>
    90ce:	2340      	movs	r3, #64	; 0x40
    90d0:	1b80      	subs	r0, r0, r6
    90d2:	4083      	lsls	r3, r0
    90d4:	682a      	ldr	r2, [r5, #0]
    90d6:	3401      	adds	r4, #1
    90d8:	4313      	orrs	r3, r2
    90da:	602b      	str	r3, [r5, #0]
    90dc:	7821      	ldrb	r1, [r4, #0]
    90de:	2206      	movs	r2, #6
    90e0:	482d      	ldr	r0, [pc, #180]	; (9198 <_svfiprintf_r+0x1fc>)
    90e2:	1c66      	adds	r6, r4, #1
    90e4:	7629      	strb	r1, [r5, #24]
    90e6:	f000 fdad 	bl	9c44 <memchr>
    90ea:	2800      	cmp	r0, #0
    90ec:	d046      	beq.n	917c <_svfiprintf_r+0x1e0>
    90ee:	4b2b      	ldr	r3, [pc, #172]	; (919c <_svfiprintf_r+0x200>)
    90f0:	2b00      	cmp	r3, #0
    90f2:	d12f      	bne.n	9154 <_svfiprintf_r+0x1b8>
    90f4:	6829      	ldr	r1, [r5, #0]
    90f6:	9b05      	ldr	r3, [sp, #20]
    90f8:	2207      	movs	r2, #7
    90fa:	05c9      	lsls	r1, r1, #23
    90fc:	d528      	bpl.n	9150 <_svfiprintf_r+0x1b4>
    90fe:	189b      	adds	r3, r3, r2
    9100:	4393      	bics	r3, r2
    9102:	3308      	adds	r3, #8
    9104:	9305      	str	r3, [sp, #20]
    9106:	696b      	ldr	r3, [r5, #20]
    9108:	9a03      	ldr	r2, [sp, #12]
    910a:	189b      	adds	r3, r3, r2
    910c:	616b      	str	r3, [r5, #20]
    910e:	e767      	b.n	8fe0 <_svfiprintf_r+0x44>
    9110:	425b      	negs	r3, r3
    9112:	60eb      	str	r3, [r5, #12]
    9114:	2302      	movs	r3, #2
    9116:	430b      	orrs	r3, r1
    9118:	602b      	str	r3, [r5, #0]
    911a:	e7c0      	b.n	909e <_svfiprintf_r+0x102>
    911c:	434b      	muls	r3, r1
    911e:	3401      	adds	r4, #1
    9120:	189b      	adds	r3, r3, r2
    9122:	2001      	movs	r0, #1
    9124:	e7a0      	b.n	9068 <_svfiprintf_r+0xcc>
    9126:	2301      	movs	r3, #1
    9128:	425b      	negs	r3, r3
    912a:	e7c7      	b.n	90bc <_svfiprintf_r+0x120>
    912c:	2300      	movs	r3, #0
    912e:	0014      	movs	r4, r2
    9130:	200a      	movs	r0, #10
    9132:	001a      	movs	r2, r3
    9134:	606b      	str	r3, [r5, #4]
    9136:	7821      	ldrb	r1, [r4, #0]
    9138:	3930      	subs	r1, #48	; 0x30
    913a:	2909      	cmp	r1, #9
    913c:	d903      	bls.n	9146 <_svfiprintf_r+0x1aa>
    913e:	2b00      	cmp	r3, #0
    9140:	d0bd      	beq.n	90be <_svfiprintf_r+0x122>
    9142:	9207      	str	r2, [sp, #28]
    9144:	e7bb      	b.n	90be <_svfiprintf_r+0x122>
    9146:	4342      	muls	r2, r0
    9148:	3401      	adds	r4, #1
    914a:	1852      	adds	r2, r2, r1
    914c:	2301      	movs	r3, #1
    914e:	e7f2      	b.n	9136 <_svfiprintf_r+0x19a>
    9150:	3307      	adds	r3, #7
    9152:	e7d5      	b.n	9100 <_svfiprintf_r+0x164>
    9154:	ab05      	add	r3, sp, #20
    9156:	9300      	str	r3, [sp, #0]
    9158:	003a      	movs	r2, r7
    915a:	4b11      	ldr	r3, [pc, #68]	; (91a0 <_svfiprintf_r+0x204>)
    915c:	0029      	movs	r1, r5
    915e:	9802      	ldr	r0, [sp, #8]
    9160:	e000      	b.n	9164 <_svfiprintf_r+0x1c8>
    9162:	bf00      	nop
    9164:	9003      	str	r0, [sp, #12]
    9166:	9b03      	ldr	r3, [sp, #12]
    9168:	3301      	adds	r3, #1
    916a:	d1cc      	bne.n	9106 <_svfiprintf_r+0x16a>
    916c:	89bb      	ldrh	r3, [r7, #12]
    916e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    9170:	065b      	lsls	r3, r3, #25
    9172:	d400      	bmi.n	9176 <_svfiprintf_r+0x1da>
    9174:	e729      	b.n	8fca <_svfiprintf_r+0x2e>
    9176:	2001      	movs	r0, #1
    9178:	4240      	negs	r0, r0
    917a:	e726      	b.n	8fca <_svfiprintf_r+0x2e>
    917c:	ab05      	add	r3, sp, #20
    917e:	9300      	str	r3, [sp, #0]
    9180:	003a      	movs	r2, r7
    9182:	4b07      	ldr	r3, [pc, #28]	; (91a0 <_svfiprintf_r+0x204>)
    9184:	0029      	movs	r1, r5
    9186:	9802      	ldr	r0, [sp, #8]
    9188:	f000 fa5c 	bl	9644 <_printf_i>
    918c:	e7ea      	b.n	9164 <_svfiprintf_r+0x1c8>
    918e:	46c0      	nop			; (mov r8, r8)
    9190:	0000bc94 	.word	0x0000bc94
    9194:	0000bc9a 	.word	0x0000bc9a
    9198:	0000bc9e 	.word	0x0000bc9e
    919c:	00000000 	.word	0x00000000
    91a0:	00008ed9 	.word	0x00008ed9

000091a4 <_sungetc_r>:
    91a4:	b570      	push	{r4, r5, r6, lr}
    91a6:	0014      	movs	r4, r2
    91a8:	1c4b      	adds	r3, r1, #1
    91aa:	d103      	bne.n	91b4 <_sungetc_r+0x10>
    91ac:	2501      	movs	r5, #1
    91ae:	426d      	negs	r5, r5
    91b0:	0028      	movs	r0, r5
    91b2:	bd70      	pop	{r4, r5, r6, pc}
    91b4:	8993      	ldrh	r3, [r2, #12]
    91b6:	2220      	movs	r2, #32
    91b8:	4393      	bics	r3, r2
    91ba:	6b62      	ldr	r2, [r4, #52]	; 0x34
    91bc:	81a3      	strh	r3, [r4, #12]
    91be:	b2ce      	uxtb	r6, r1
    91c0:	b2cd      	uxtb	r5, r1
    91c2:	6863      	ldr	r3, [r4, #4]
    91c4:	2a00      	cmp	r2, #0
    91c6:	d010      	beq.n	91ea <_sungetc_r+0x46>
    91c8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    91ca:	4293      	cmp	r3, r2
    91cc:	da07      	bge.n	91de <_sungetc_r+0x3a>
    91ce:	6823      	ldr	r3, [r4, #0]
    91d0:	3b01      	subs	r3, #1
    91d2:	6023      	str	r3, [r4, #0]
    91d4:	701e      	strb	r6, [r3, #0]
    91d6:	6863      	ldr	r3, [r4, #4]
    91d8:	3301      	adds	r3, #1
    91da:	6063      	str	r3, [r4, #4]
    91dc:	e7e8      	b.n	91b0 <_sungetc_r+0xc>
    91de:	0021      	movs	r1, r4
    91e0:	f000 fcf2 	bl	9bc8 <__submore>
    91e4:	2800      	cmp	r0, #0
    91e6:	d0f2      	beq.n	91ce <_sungetc_r+0x2a>
    91e8:	e7e0      	b.n	91ac <_sungetc_r+0x8>
    91ea:	6921      	ldr	r1, [r4, #16]
    91ec:	6822      	ldr	r2, [r4, #0]
    91ee:	2900      	cmp	r1, #0
    91f0:	d007      	beq.n	9202 <_sungetc_r+0x5e>
    91f2:	4291      	cmp	r1, r2
    91f4:	d205      	bcs.n	9202 <_sungetc_r+0x5e>
    91f6:	1e51      	subs	r1, r2, #1
    91f8:	7808      	ldrb	r0, [r1, #0]
    91fa:	4285      	cmp	r5, r0
    91fc:	d101      	bne.n	9202 <_sungetc_r+0x5e>
    91fe:	6021      	str	r1, [r4, #0]
    9200:	e7ea      	b.n	91d8 <_sungetc_r+0x34>
    9202:	6423      	str	r3, [r4, #64]	; 0x40
    9204:	0023      	movs	r3, r4
    9206:	3344      	adds	r3, #68	; 0x44
    9208:	6363      	str	r3, [r4, #52]	; 0x34
    920a:	2303      	movs	r3, #3
    920c:	63a3      	str	r3, [r4, #56]	; 0x38
    920e:	0023      	movs	r3, r4
    9210:	3346      	adds	r3, #70	; 0x46
    9212:	63e2      	str	r2, [r4, #60]	; 0x3c
    9214:	701e      	strb	r6, [r3, #0]
    9216:	6023      	str	r3, [r4, #0]
    9218:	2301      	movs	r3, #1
    921a:	e7de      	b.n	91da <_sungetc_r+0x36>

0000921c <__ssrefill_r>:
    921c:	b510      	push	{r4, lr}
    921e:	000c      	movs	r4, r1
    9220:	6b49      	ldr	r1, [r1, #52]	; 0x34
    9222:	2900      	cmp	r1, #0
    9224:	d00e      	beq.n	9244 <__ssrefill_r+0x28>
    9226:	0023      	movs	r3, r4
    9228:	3344      	adds	r3, #68	; 0x44
    922a:	4299      	cmp	r1, r3
    922c:	d001      	beq.n	9232 <__ssrefill_r+0x16>
    922e:	f000 fd29 	bl	9c84 <_free_r>
    9232:	2000      	movs	r0, #0
    9234:	6c23      	ldr	r3, [r4, #64]	; 0x40
    9236:	6360      	str	r0, [r4, #52]	; 0x34
    9238:	6063      	str	r3, [r4, #4]
    923a:	4283      	cmp	r3, r0
    923c:	d002      	beq.n	9244 <__ssrefill_r+0x28>
    923e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    9240:	6023      	str	r3, [r4, #0]
    9242:	bd10      	pop	{r4, pc}
    9244:	6923      	ldr	r3, [r4, #16]
    9246:	2001      	movs	r0, #1
    9248:	6023      	str	r3, [r4, #0]
    924a:	2300      	movs	r3, #0
    924c:	89a2      	ldrh	r2, [r4, #12]
    924e:	6063      	str	r3, [r4, #4]
    9250:	3320      	adds	r3, #32
    9252:	4313      	orrs	r3, r2
    9254:	81a3      	strh	r3, [r4, #12]
    9256:	4240      	negs	r0, r0
    9258:	e7f3      	b.n	9242 <__ssrefill_r+0x26>
	...

0000925c <__ssvfiscanf_r>:
    925c:	b5f0      	push	{r4, r5, r6, r7, lr}
    925e:	4cbd      	ldr	r4, [pc, #756]	; (9554 <__ssvfiscanf_r+0x2f8>)
    9260:	2586      	movs	r5, #134	; 0x86
    9262:	44a5      	add	sp, r4
    9264:	9303      	str	r3, [sp, #12]
    9266:	2300      	movs	r3, #0
    9268:	9348      	str	r3, [sp, #288]	; 0x120
    926a:	9349      	str	r3, [sp, #292]	; 0x124
    926c:	ab05      	add	r3, sp, #20
    926e:	934a      	str	r3, [sp, #296]	; 0x128
    9270:	23be      	movs	r3, #190	; 0xbe
    9272:	006d      	lsls	r5, r5, #1
    9274:	9000      	str	r0, [sp, #0]
    9276:	000c      	movs	r4, r1
    9278:	a802      	add	r0, sp, #8
    927a:	49b7      	ldr	r1, [pc, #732]	; (9558 <__ssvfiscanf_r+0x2fc>)
    927c:	005b      	lsls	r3, r3, #1
    927e:	1940      	adds	r0, r0, r5
    9280:	27c0      	movs	r7, #192	; 0xc0
    9282:	50c1      	str	r1, [r0, r3]
    9284:	ab02      	add	r3, sp, #8
    9286:	195b      	adds	r3, r3, r5
    9288:	0015      	movs	r5, r2
    928a:	49b4      	ldr	r1, [pc, #720]	; (955c <__ssvfiscanf_r+0x300>)
    928c:	007f      	lsls	r7, r7, #1
    928e:	51d9      	str	r1, [r3, r7]
    9290:	782b      	ldrb	r3, [r5, #0]
    9292:	2b00      	cmp	r3, #0
    9294:	d100      	bne.n	9298 <__ssvfiscanf_r+0x3c>
    9296:	e15b      	b.n	9550 <__ssvfiscanf_r+0x2f4>
    9298:	f7ff fb34 	bl	8904 <__locale_ctype_ptr>
    929c:	2208      	movs	r2, #8
    929e:	782b      	ldrb	r3, [r5, #0]
    92a0:	18c0      	adds	r0, r0, r3
    92a2:	9301      	str	r3, [sp, #4]
    92a4:	7843      	ldrb	r3, [r0, #1]
    92a6:	4013      	ands	r3, r2
    92a8:	d141      	bne.n	932e <__ssvfiscanf_r+0xd2>
    92aa:	9a01      	ldr	r2, [sp, #4]
    92ac:	1c6e      	adds	r6, r5, #1
    92ae:	2a25      	cmp	r2, #37	; 0x25
    92b0:	d000      	beq.n	92b4 <__ssvfiscanf_r+0x58>
    92b2:	e0a8      	b.n	9406 <__ssvfiscanf_r+0x1aa>
    92b4:	9347      	str	r3, [sp, #284]	; 0x11c
    92b6:	9345      	str	r3, [sp, #276]	; 0x114
    92b8:	786b      	ldrb	r3, [r5, #1]
    92ba:	2b2a      	cmp	r3, #42	; 0x2a
    92bc:	d102      	bne.n	92c4 <__ssvfiscanf_r+0x68>
    92be:	3b1a      	subs	r3, #26
    92c0:	9345      	str	r3, [sp, #276]	; 0x114
    92c2:	1cae      	adds	r6, r5, #2
    92c4:	0035      	movs	r5, r6
    92c6:	220a      	movs	r2, #10
    92c8:	7829      	ldrb	r1, [r5, #0]
    92ca:	000b      	movs	r3, r1
    92cc:	3b30      	subs	r3, #48	; 0x30
    92ce:	2b09      	cmp	r3, #9
    92d0:	d948      	bls.n	9364 <__ssvfiscanf_r+0x108>
    92d2:	4ea3      	ldr	r6, [pc, #652]	; (9560 <__ssvfiscanf_r+0x304>)
    92d4:	2203      	movs	r2, #3
    92d6:	0030      	movs	r0, r6
    92d8:	f000 fcb4 	bl	9c44 <memchr>
    92dc:	2800      	cmp	r0, #0
    92de:	d007      	beq.n	92f0 <__ssvfiscanf_r+0x94>
    92e0:	2301      	movs	r3, #1
    92e2:	1b80      	subs	r0, r0, r6
    92e4:	4083      	lsls	r3, r0
    92e6:	9a45      	ldr	r2, [sp, #276]	; 0x114
    92e8:	3501      	adds	r5, #1
    92ea:	4313      	orrs	r3, r2
    92ec:	9202      	str	r2, [sp, #8]
    92ee:	9345      	str	r3, [sp, #276]	; 0x114
    92f0:	782b      	ldrb	r3, [r5, #0]
    92f2:	1c6e      	adds	r6, r5, #1
    92f4:	2b67      	cmp	r3, #103	; 0x67
    92f6:	d858      	bhi.n	93aa <__ssvfiscanf_r+0x14e>
    92f8:	2b65      	cmp	r3, #101	; 0x65
    92fa:	d300      	bcc.n	92fe <__ssvfiscanf_r+0xa2>
    92fc:	e0dd      	b.n	94ba <__ssvfiscanf_r+0x25e>
    92fe:	2b47      	cmp	r3, #71	; 0x47
    9300:	d838      	bhi.n	9374 <__ssvfiscanf_r+0x118>
    9302:	2b45      	cmp	r3, #69	; 0x45
    9304:	d300      	bcc.n	9308 <__ssvfiscanf_r+0xac>
    9306:	e0d8      	b.n	94ba <__ssvfiscanf_r+0x25e>
    9308:	2b00      	cmp	r3, #0
    930a:	d100      	bne.n	930e <__ssvfiscanf_r+0xb2>
    930c:	e11d      	b.n	954a <__ssvfiscanf_r+0x2ee>
    930e:	2b25      	cmp	r3, #37	; 0x25
    9310:	d079      	beq.n	9406 <__ssvfiscanf_r+0x1aa>
    9312:	2303      	movs	r3, #3
    9314:	934b      	str	r3, [sp, #300]	; 0x12c
    9316:	3307      	adds	r3, #7
    9318:	9346      	str	r3, [sp, #280]	; 0x118
    931a:	e053      	b.n	93c4 <__ssvfiscanf_r+0x168>
    931c:	9a49      	ldr	r2, [sp, #292]	; 0x124
    931e:	3301      	adds	r3, #1
    9320:	9201      	str	r2, [sp, #4]
    9322:	3201      	adds	r2, #1
    9324:	9249      	str	r2, [sp, #292]	; 0x124
    9326:	6862      	ldr	r2, [r4, #4]
    9328:	6023      	str	r3, [r4, #0]
    932a:	3a01      	subs	r2, #1
    932c:	6062      	str	r2, [r4, #4]
    932e:	6863      	ldr	r3, [r4, #4]
    9330:	2b00      	cmp	r3, #0
    9332:	dd0b      	ble.n	934c <__ssvfiscanf_r+0xf0>
    9334:	f7ff fae6 	bl	8904 <__locale_ctype_ptr>
    9338:	2108      	movs	r1, #8
    933a:	6823      	ldr	r3, [r4, #0]
    933c:	781a      	ldrb	r2, [r3, #0]
    933e:	1880      	adds	r0, r0, r2
    9340:	7842      	ldrb	r2, [r0, #1]
    9342:	420a      	tst	r2, r1
    9344:	d1ea      	bne.n	931c <__ssvfiscanf_r+0xc0>
    9346:	1c6e      	adds	r6, r5, #1
    9348:	0035      	movs	r5, r6
    934a:	e7a1      	b.n	9290 <__ssvfiscanf_r+0x34>
    934c:	2286      	movs	r2, #134	; 0x86
    934e:	ab02      	add	r3, sp, #8
    9350:	0052      	lsls	r2, r2, #1
    9352:	189b      	adds	r3, r3, r2
    9354:	59db      	ldr	r3, [r3, r7]
    9356:	0021      	movs	r1, r4
    9358:	9800      	ldr	r0, [sp, #0]
    935a:	9301      	str	r3, [sp, #4]
    935c:	4798      	blx	r3
    935e:	2800      	cmp	r0, #0
    9360:	d0e8      	beq.n	9334 <__ssvfiscanf_r+0xd8>
    9362:	e7f0      	b.n	9346 <__ssvfiscanf_r+0xea>
    9364:	9b47      	ldr	r3, [sp, #284]	; 0x11c
    9366:	3501      	adds	r5, #1
    9368:	9302      	str	r3, [sp, #8]
    936a:	4353      	muls	r3, r2
    936c:	3b30      	subs	r3, #48	; 0x30
    936e:	1859      	adds	r1, r3, r1
    9370:	9147      	str	r1, [sp, #284]	; 0x11c
    9372:	e7a9      	b.n	92c8 <__ssvfiscanf_r+0x6c>
    9374:	2b5b      	cmp	r3, #91	; 0x5b
    9376:	d100      	bne.n	937a <__ssvfiscanf_r+0x11e>
    9378:	e077      	b.n	946a <__ssvfiscanf_r+0x20e>
    937a:	d80f      	bhi.n	939c <__ssvfiscanf_r+0x140>
    937c:	2b58      	cmp	r3, #88	; 0x58
    937e:	d1c8      	bne.n	9312 <__ssvfiscanf_r+0xb6>
    9380:	9a45      	ldr	r2, [sp, #276]	; 0x114
    9382:	9201      	str	r2, [sp, #4]
    9384:	2280      	movs	r2, #128	; 0x80
    9386:	9901      	ldr	r1, [sp, #4]
    9388:	0092      	lsls	r2, r2, #2
    938a:	430a      	orrs	r2, r1
    938c:	9245      	str	r2, [sp, #276]	; 0x114
    938e:	2210      	movs	r2, #16
    9390:	9246      	str	r2, [sp, #280]	; 0x118
    9392:	2203      	movs	r2, #3
    9394:	2b6e      	cmp	r3, #110	; 0x6e
    9396:	dd14      	ble.n	93c2 <__ssvfiscanf_r+0x166>
    9398:	3201      	adds	r2, #1
    939a:	e012      	b.n	93c2 <__ssvfiscanf_r+0x166>
    939c:	2b63      	cmp	r3, #99	; 0x63
    939e:	d100      	bne.n	93a2 <__ssvfiscanf_r+0x146>
    93a0:	e071      	b.n	9486 <__ssvfiscanf_r+0x22a>
    93a2:	2b64      	cmp	r3, #100	; 0x64
    93a4:	d1b5      	bne.n	9312 <__ssvfiscanf_r+0xb6>
    93a6:	220a      	movs	r2, #10
    93a8:	e7f2      	b.n	9390 <__ssvfiscanf_r+0x134>
    93aa:	2b70      	cmp	r3, #112	; 0x70
    93ac:	d052      	beq.n	9454 <__ssvfiscanf_r+0x1f8>
    93ae:	d822      	bhi.n	93f6 <__ssvfiscanf_r+0x19a>
    93b0:	2b6e      	cmp	r3, #110	; 0x6e
    93b2:	d100      	bne.n	93b6 <__ssvfiscanf_r+0x15a>
    93b4:	e06f      	b.n	9496 <__ssvfiscanf_r+0x23a>
    93b6:	d854      	bhi.n	9462 <__ssvfiscanf_r+0x206>
    93b8:	2b69      	cmp	r3, #105	; 0x69
    93ba:	d1aa      	bne.n	9312 <__ssvfiscanf_r+0xb6>
    93bc:	2300      	movs	r3, #0
    93be:	2203      	movs	r2, #3
    93c0:	9346      	str	r3, [sp, #280]	; 0x118
    93c2:	924b      	str	r2, [sp, #300]	; 0x12c
    93c4:	6863      	ldr	r3, [r4, #4]
    93c6:	2b00      	cmp	r3, #0
    93c8:	dc00      	bgt.n	93cc <__ssvfiscanf_r+0x170>
    93ca:	e078      	b.n	94be <__ssvfiscanf_r+0x262>
    93cc:	9b45      	ldr	r3, [sp, #276]	; 0x114
    93ce:	9301      	str	r3, [sp, #4]
    93d0:	065b      	lsls	r3, r3, #25
    93d2:	d400      	bmi.n	93d6 <__ssvfiscanf_r+0x17a>
    93d4:	e08b      	b.n	94ee <__ssvfiscanf_r+0x292>
    93d6:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
    93d8:	2b02      	cmp	r3, #2
    93da:	dd00      	ble.n	93de <__ssvfiscanf_r+0x182>
    93dc:	e09d      	b.n	951a <__ssvfiscanf_r+0x2be>
    93de:	ab03      	add	r3, sp, #12
    93e0:	0022      	movs	r2, r4
    93e2:	a945      	add	r1, sp, #276	; 0x114
    93e4:	9800      	ldr	r0, [sp, #0]
    93e6:	f000 fa47 	bl	9878 <_scanf_chars>
    93ea:	2801      	cmp	r0, #1
    93ec:	d100      	bne.n	93f0 <__ssvfiscanf_r+0x194>
    93ee:	e0af      	b.n	9550 <__ssvfiscanf_r+0x2f4>
    93f0:	2802      	cmp	r0, #2
    93f2:	d1a9      	bne.n	9348 <__ssvfiscanf_r+0xec>
    93f4:	e025      	b.n	9442 <__ssvfiscanf_r+0x1e6>
    93f6:	2b75      	cmp	r3, #117	; 0x75
    93f8:	d0d5      	beq.n	93a6 <__ssvfiscanf_r+0x14a>
    93fa:	2b78      	cmp	r3, #120	; 0x78
    93fc:	d0c0      	beq.n	9380 <__ssvfiscanf_r+0x124>
    93fe:	2b73      	cmp	r3, #115	; 0x73
    9400:	d187      	bne.n	9312 <__ssvfiscanf_r+0xb6>
    9402:	2302      	movs	r3, #2
    9404:	e03d      	b.n	9482 <__ssvfiscanf_r+0x226>
    9406:	6863      	ldr	r3, [r4, #4]
    9408:	2b00      	cmp	r3, #0
    940a:	dd0f      	ble.n	942c <__ssvfiscanf_r+0x1d0>
    940c:	6823      	ldr	r3, [r4, #0]
    940e:	9901      	ldr	r1, [sp, #4]
    9410:	781a      	ldrb	r2, [r3, #0]
    9412:	4291      	cmp	r1, r2
    9414:	d000      	beq.n	9418 <__ssvfiscanf_r+0x1bc>
    9416:	e09b      	b.n	9550 <__ssvfiscanf_r+0x2f4>
    9418:	3301      	adds	r3, #1
    941a:	6862      	ldr	r2, [r4, #4]
    941c:	6023      	str	r3, [r4, #0]
    941e:	9b49      	ldr	r3, [sp, #292]	; 0x124
    9420:	3a01      	subs	r2, #1
    9422:	9301      	str	r3, [sp, #4]
    9424:	3301      	adds	r3, #1
    9426:	6062      	str	r2, [r4, #4]
    9428:	9349      	str	r3, [sp, #292]	; 0x124
    942a:	e78d      	b.n	9348 <__ssvfiscanf_r+0xec>
    942c:	2286      	movs	r2, #134	; 0x86
    942e:	ab02      	add	r3, sp, #8
    9430:	0052      	lsls	r2, r2, #1
    9432:	189b      	adds	r3, r3, r2
    9434:	59db      	ldr	r3, [r3, r7]
    9436:	0021      	movs	r1, r4
    9438:	9800      	ldr	r0, [sp, #0]
    943a:	9302      	str	r3, [sp, #8]
    943c:	4798      	blx	r3
    943e:	2800      	cmp	r0, #0
    9440:	d0e4      	beq.n	940c <__ssvfiscanf_r+0x1b0>
    9442:	9848      	ldr	r0, [sp, #288]	; 0x120
    9444:	2800      	cmp	r0, #0
    9446:	d000      	beq.n	944a <__ssvfiscanf_r+0x1ee>
    9448:	e07b      	b.n	9542 <__ssvfiscanf_r+0x2e6>
    944a:	3801      	subs	r0, #1
    944c:	23a7      	movs	r3, #167	; 0xa7
    944e:	009b      	lsls	r3, r3, #2
    9450:	449d      	add	sp, r3
    9452:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9454:	9a45      	ldr	r2, [sp, #276]	; 0x114
    9456:	9201      	str	r2, [sp, #4]
    9458:	2220      	movs	r2, #32
    945a:	9901      	ldr	r1, [sp, #4]
    945c:	430a      	orrs	r2, r1
    945e:	9245      	str	r2, [sp, #276]	; 0x114
    9460:	e78e      	b.n	9380 <__ssvfiscanf_r+0x124>
    9462:	2308      	movs	r3, #8
    9464:	2204      	movs	r2, #4
    9466:	9346      	str	r3, [sp, #280]	; 0x118
    9468:	e7ab      	b.n	93c2 <__ssvfiscanf_r+0x166>
    946a:	0031      	movs	r1, r6
    946c:	a805      	add	r0, sp, #20
    946e:	f000 fb79 	bl	9b64 <__sccl>
    9472:	9b45      	ldr	r3, [sp, #276]	; 0x114
    9474:	0006      	movs	r6, r0
    9476:	9301      	str	r3, [sp, #4]
    9478:	2340      	movs	r3, #64	; 0x40
    947a:	9a01      	ldr	r2, [sp, #4]
    947c:	4313      	orrs	r3, r2
    947e:	9345      	str	r3, [sp, #276]	; 0x114
    9480:	2301      	movs	r3, #1
    9482:	934b      	str	r3, [sp, #300]	; 0x12c
    9484:	e79e      	b.n	93c4 <__ssvfiscanf_r+0x168>
    9486:	9b45      	ldr	r3, [sp, #276]	; 0x114
    9488:	9301      	str	r3, [sp, #4]
    948a:	2340      	movs	r3, #64	; 0x40
    948c:	9a01      	ldr	r2, [sp, #4]
    948e:	4313      	orrs	r3, r2
    9490:	9345      	str	r3, [sp, #276]	; 0x114
    9492:	2300      	movs	r3, #0
    9494:	e7f5      	b.n	9482 <__ssvfiscanf_r+0x226>
    9496:	9945      	ldr	r1, [sp, #276]	; 0x114
    9498:	06cb      	lsls	r3, r1, #27
    949a:	d500      	bpl.n	949e <__ssvfiscanf_r+0x242>
    949c:	e754      	b.n	9348 <__ssvfiscanf_r+0xec>
    949e:	9b03      	ldr	r3, [sp, #12]
    94a0:	9a49      	ldr	r2, [sp, #292]	; 0x124
    94a2:	07c8      	lsls	r0, r1, #31
    94a4:	d504      	bpl.n	94b0 <__ssvfiscanf_r+0x254>
    94a6:	1d19      	adds	r1, r3, #4
    94a8:	9103      	str	r1, [sp, #12]
    94aa:	681b      	ldr	r3, [r3, #0]
    94ac:	801a      	strh	r2, [r3, #0]
    94ae:	e74b      	b.n	9348 <__ssvfiscanf_r+0xec>
    94b0:	1d19      	adds	r1, r3, #4
    94b2:	9103      	str	r1, [sp, #12]
    94b4:	681b      	ldr	r3, [r3, #0]
    94b6:	601a      	str	r2, [r3, #0]
    94b8:	e746      	b.n	9348 <__ssvfiscanf_r+0xec>
    94ba:	2305      	movs	r3, #5
    94bc:	e7e1      	b.n	9482 <__ssvfiscanf_r+0x226>
    94be:	2286      	movs	r2, #134	; 0x86
    94c0:	ab02      	add	r3, sp, #8
    94c2:	0052      	lsls	r2, r2, #1
    94c4:	189b      	adds	r3, r3, r2
    94c6:	59db      	ldr	r3, [r3, r7]
    94c8:	0021      	movs	r1, r4
    94ca:	9800      	ldr	r0, [sp, #0]
    94cc:	9301      	str	r3, [sp, #4]
    94ce:	4798      	blx	r3
    94d0:	2800      	cmp	r0, #0
    94d2:	d100      	bne.n	94d6 <__ssvfiscanf_r+0x27a>
    94d4:	e77a      	b.n	93cc <__ssvfiscanf_r+0x170>
    94d6:	e7b4      	b.n	9442 <__ssvfiscanf_r+0x1e6>
    94d8:	9a49      	ldr	r2, [sp, #292]	; 0x124
    94da:	9201      	str	r2, [sp, #4]
    94dc:	3201      	adds	r2, #1
    94de:	9249      	str	r2, [sp, #292]	; 0x124
    94e0:	6862      	ldr	r2, [r4, #4]
    94e2:	3a01      	subs	r2, #1
    94e4:	6062      	str	r2, [r4, #4]
    94e6:	2a00      	cmp	r2, #0
    94e8:	dd0b      	ble.n	9502 <__ssvfiscanf_r+0x2a6>
    94ea:	3301      	adds	r3, #1
    94ec:	6023      	str	r3, [r4, #0]
    94ee:	f7ff fa09 	bl	8904 <__locale_ctype_ptr>
    94f2:	2108      	movs	r1, #8
    94f4:	6823      	ldr	r3, [r4, #0]
    94f6:	781a      	ldrb	r2, [r3, #0]
    94f8:	1880      	adds	r0, r0, r2
    94fa:	7842      	ldrb	r2, [r0, #1]
    94fc:	420a      	tst	r2, r1
    94fe:	d1eb      	bne.n	94d8 <__ssvfiscanf_r+0x27c>
    9500:	e769      	b.n	93d6 <__ssvfiscanf_r+0x17a>
    9502:	2286      	movs	r2, #134	; 0x86
    9504:	ab02      	add	r3, sp, #8
    9506:	0052      	lsls	r2, r2, #1
    9508:	189b      	adds	r3, r3, r2
    950a:	59db      	ldr	r3, [r3, r7]
    950c:	0021      	movs	r1, r4
    950e:	9800      	ldr	r0, [sp, #0]
    9510:	9301      	str	r3, [sp, #4]
    9512:	4798      	blx	r3
    9514:	2800      	cmp	r0, #0
    9516:	d0ea      	beq.n	94ee <__ssvfiscanf_r+0x292>
    9518:	e793      	b.n	9442 <__ssvfiscanf_r+0x1e6>
    951a:	2b04      	cmp	r3, #4
    951c:	dc06      	bgt.n	952c <__ssvfiscanf_r+0x2d0>
    951e:	ab03      	add	r3, sp, #12
    9520:	0022      	movs	r2, r4
    9522:	a945      	add	r1, sp, #276	; 0x114
    9524:	9800      	ldr	r0, [sp, #0]
    9526:	f000 fa0b 	bl	9940 <_scanf_i>
    952a:	e75e      	b.n	93ea <__ssvfiscanf_r+0x18e>
    952c:	4b0d      	ldr	r3, [pc, #52]	; (9564 <__ssvfiscanf_r+0x308>)
    952e:	2b00      	cmp	r3, #0
    9530:	d100      	bne.n	9534 <__ssvfiscanf_r+0x2d8>
    9532:	e709      	b.n	9348 <__ssvfiscanf_r+0xec>
    9534:	ab03      	add	r3, sp, #12
    9536:	0022      	movs	r2, r4
    9538:	a945      	add	r1, sp, #276	; 0x114
    953a:	9800      	ldr	r0, [sp, #0]
    953c:	e000      	b.n	9540 <__ssvfiscanf_r+0x2e4>
    953e:	bf00      	nop
    9540:	e753      	b.n	93ea <__ssvfiscanf_r+0x18e>
    9542:	89a3      	ldrh	r3, [r4, #12]
    9544:	065b      	lsls	r3, r3, #25
    9546:	d400      	bmi.n	954a <__ssvfiscanf_r+0x2ee>
    9548:	e780      	b.n	944c <__ssvfiscanf_r+0x1f0>
    954a:	2001      	movs	r0, #1
    954c:	4240      	negs	r0, r0
    954e:	e77d      	b.n	944c <__ssvfiscanf_r+0x1f0>
    9550:	9848      	ldr	r0, [sp, #288]	; 0x120
    9552:	e77b      	b.n	944c <__ssvfiscanf_r+0x1f0>
    9554:	fffffd64 	.word	0xfffffd64
    9558:	000091a5 	.word	0x000091a5
    955c:	0000921d 	.word	0x0000921d
    9560:	0000bc9a 	.word	0x0000bc9a
    9564:	00000000 	.word	0x00000000

00009568 <_printf_common>:
    9568:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    956a:	0015      	movs	r5, r2
    956c:	9301      	str	r3, [sp, #4]
    956e:	688a      	ldr	r2, [r1, #8]
    9570:	690b      	ldr	r3, [r1, #16]
    9572:	9000      	str	r0, [sp, #0]
    9574:	000c      	movs	r4, r1
    9576:	4293      	cmp	r3, r2
    9578:	da00      	bge.n	957c <_printf_common+0x14>
    957a:	0013      	movs	r3, r2
    957c:	0022      	movs	r2, r4
    957e:	602b      	str	r3, [r5, #0]
    9580:	3243      	adds	r2, #67	; 0x43
    9582:	7812      	ldrb	r2, [r2, #0]
    9584:	2a00      	cmp	r2, #0
    9586:	d001      	beq.n	958c <_printf_common+0x24>
    9588:	3301      	adds	r3, #1
    958a:	602b      	str	r3, [r5, #0]
    958c:	6823      	ldr	r3, [r4, #0]
    958e:	069b      	lsls	r3, r3, #26
    9590:	d502      	bpl.n	9598 <_printf_common+0x30>
    9592:	682b      	ldr	r3, [r5, #0]
    9594:	3302      	adds	r3, #2
    9596:	602b      	str	r3, [r5, #0]
    9598:	2706      	movs	r7, #6
    959a:	6823      	ldr	r3, [r4, #0]
    959c:	401f      	ands	r7, r3
    959e:	d027      	beq.n	95f0 <_printf_common+0x88>
    95a0:	0023      	movs	r3, r4
    95a2:	3343      	adds	r3, #67	; 0x43
    95a4:	781b      	ldrb	r3, [r3, #0]
    95a6:	1e5a      	subs	r2, r3, #1
    95a8:	4193      	sbcs	r3, r2
    95aa:	6822      	ldr	r2, [r4, #0]
    95ac:	0692      	lsls	r2, r2, #26
    95ae:	d430      	bmi.n	9612 <_printf_common+0xaa>
    95b0:	0022      	movs	r2, r4
    95b2:	9901      	ldr	r1, [sp, #4]
    95b4:	3243      	adds	r2, #67	; 0x43
    95b6:	9800      	ldr	r0, [sp, #0]
    95b8:	9e08      	ldr	r6, [sp, #32]
    95ba:	47b0      	blx	r6
    95bc:	1c43      	adds	r3, r0, #1
    95be:	d025      	beq.n	960c <_printf_common+0xa4>
    95c0:	2306      	movs	r3, #6
    95c2:	6820      	ldr	r0, [r4, #0]
    95c4:	682a      	ldr	r2, [r5, #0]
    95c6:	68e1      	ldr	r1, [r4, #12]
    95c8:	4003      	ands	r3, r0
    95ca:	2500      	movs	r5, #0
    95cc:	2b04      	cmp	r3, #4
    95ce:	d103      	bne.n	95d8 <_printf_common+0x70>
    95d0:	1a8d      	subs	r5, r1, r2
    95d2:	43eb      	mvns	r3, r5
    95d4:	17db      	asrs	r3, r3, #31
    95d6:	401d      	ands	r5, r3
    95d8:	68a3      	ldr	r3, [r4, #8]
    95da:	6922      	ldr	r2, [r4, #16]
    95dc:	4293      	cmp	r3, r2
    95de:	dd01      	ble.n	95e4 <_printf_common+0x7c>
    95e0:	1a9b      	subs	r3, r3, r2
    95e2:	18ed      	adds	r5, r5, r3
    95e4:	2700      	movs	r7, #0
    95e6:	42bd      	cmp	r5, r7
    95e8:	d120      	bne.n	962c <_printf_common+0xc4>
    95ea:	2000      	movs	r0, #0
    95ec:	e010      	b.n	9610 <_printf_common+0xa8>
    95ee:	3701      	adds	r7, #1
    95f0:	68e3      	ldr	r3, [r4, #12]
    95f2:	682a      	ldr	r2, [r5, #0]
    95f4:	1a9b      	subs	r3, r3, r2
    95f6:	429f      	cmp	r7, r3
    95f8:	dad2      	bge.n	95a0 <_printf_common+0x38>
    95fa:	0022      	movs	r2, r4
    95fc:	2301      	movs	r3, #1
    95fe:	3219      	adds	r2, #25
    9600:	9901      	ldr	r1, [sp, #4]
    9602:	9800      	ldr	r0, [sp, #0]
    9604:	9e08      	ldr	r6, [sp, #32]
    9606:	47b0      	blx	r6
    9608:	1c43      	adds	r3, r0, #1
    960a:	d1f0      	bne.n	95ee <_printf_common+0x86>
    960c:	2001      	movs	r0, #1
    960e:	4240      	negs	r0, r0
    9610:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    9612:	2030      	movs	r0, #48	; 0x30
    9614:	18e1      	adds	r1, r4, r3
    9616:	3143      	adds	r1, #67	; 0x43
    9618:	7008      	strb	r0, [r1, #0]
    961a:	0021      	movs	r1, r4
    961c:	1c5a      	adds	r2, r3, #1
    961e:	3145      	adds	r1, #69	; 0x45
    9620:	7809      	ldrb	r1, [r1, #0]
    9622:	18a2      	adds	r2, r4, r2
    9624:	3243      	adds	r2, #67	; 0x43
    9626:	3302      	adds	r3, #2
    9628:	7011      	strb	r1, [r2, #0]
    962a:	e7c1      	b.n	95b0 <_printf_common+0x48>
    962c:	0022      	movs	r2, r4
    962e:	2301      	movs	r3, #1
    9630:	321a      	adds	r2, #26
    9632:	9901      	ldr	r1, [sp, #4]
    9634:	9800      	ldr	r0, [sp, #0]
    9636:	9e08      	ldr	r6, [sp, #32]
    9638:	47b0      	blx	r6
    963a:	1c43      	adds	r3, r0, #1
    963c:	d0e6      	beq.n	960c <_printf_common+0xa4>
    963e:	3701      	adds	r7, #1
    9640:	e7d1      	b.n	95e6 <_printf_common+0x7e>
	...

00009644 <_printf_i>:
    9644:	b5f0      	push	{r4, r5, r6, r7, lr}
    9646:	b08b      	sub	sp, #44	; 0x2c
    9648:	9206      	str	r2, [sp, #24]
    964a:	000a      	movs	r2, r1
    964c:	3243      	adds	r2, #67	; 0x43
    964e:	9307      	str	r3, [sp, #28]
    9650:	9005      	str	r0, [sp, #20]
    9652:	9204      	str	r2, [sp, #16]
    9654:	7e0a      	ldrb	r2, [r1, #24]
    9656:	000c      	movs	r4, r1
    9658:	9b10      	ldr	r3, [sp, #64]	; 0x40
    965a:	2a6e      	cmp	r2, #110	; 0x6e
    965c:	d100      	bne.n	9660 <_printf_i+0x1c>
    965e:	e08f      	b.n	9780 <_printf_i+0x13c>
    9660:	d817      	bhi.n	9692 <_printf_i+0x4e>
    9662:	2a63      	cmp	r2, #99	; 0x63
    9664:	d02c      	beq.n	96c0 <_printf_i+0x7c>
    9666:	d808      	bhi.n	967a <_printf_i+0x36>
    9668:	2a00      	cmp	r2, #0
    966a:	d100      	bne.n	966e <_printf_i+0x2a>
    966c:	e099      	b.n	97a2 <_printf_i+0x15e>
    966e:	2a58      	cmp	r2, #88	; 0x58
    9670:	d054      	beq.n	971c <_printf_i+0xd8>
    9672:	0026      	movs	r6, r4
    9674:	3642      	adds	r6, #66	; 0x42
    9676:	7032      	strb	r2, [r6, #0]
    9678:	e029      	b.n	96ce <_printf_i+0x8a>
    967a:	2a64      	cmp	r2, #100	; 0x64
    967c:	d001      	beq.n	9682 <_printf_i+0x3e>
    967e:	2a69      	cmp	r2, #105	; 0x69
    9680:	d1f7      	bne.n	9672 <_printf_i+0x2e>
    9682:	6821      	ldr	r1, [r4, #0]
    9684:	681a      	ldr	r2, [r3, #0]
    9686:	0608      	lsls	r0, r1, #24
    9688:	d523      	bpl.n	96d2 <_printf_i+0x8e>
    968a:	1d11      	adds	r1, r2, #4
    968c:	6019      	str	r1, [r3, #0]
    968e:	6815      	ldr	r5, [r2, #0]
    9690:	e025      	b.n	96de <_printf_i+0x9a>
    9692:	2a73      	cmp	r2, #115	; 0x73
    9694:	d100      	bne.n	9698 <_printf_i+0x54>
    9696:	e088      	b.n	97aa <_printf_i+0x166>
    9698:	d808      	bhi.n	96ac <_printf_i+0x68>
    969a:	2a6f      	cmp	r2, #111	; 0x6f
    969c:	d029      	beq.n	96f2 <_printf_i+0xae>
    969e:	2a70      	cmp	r2, #112	; 0x70
    96a0:	d1e7      	bne.n	9672 <_printf_i+0x2e>
    96a2:	2220      	movs	r2, #32
    96a4:	6809      	ldr	r1, [r1, #0]
    96a6:	430a      	orrs	r2, r1
    96a8:	6022      	str	r2, [r4, #0]
    96aa:	e003      	b.n	96b4 <_printf_i+0x70>
    96ac:	2a75      	cmp	r2, #117	; 0x75
    96ae:	d020      	beq.n	96f2 <_printf_i+0xae>
    96b0:	2a78      	cmp	r2, #120	; 0x78
    96b2:	d1de      	bne.n	9672 <_printf_i+0x2e>
    96b4:	0022      	movs	r2, r4
    96b6:	2178      	movs	r1, #120	; 0x78
    96b8:	3245      	adds	r2, #69	; 0x45
    96ba:	7011      	strb	r1, [r2, #0]
    96bc:	4a6c      	ldr	r2, [pc, #432]	; (9870 <_printf_i+0x22c>)
    96be:	e030      	b.n	9722 <_printf_i+0xde>
    96c0:	000e      	movs	r6, r1
    96c2:	681a      	ldr	r2, [r3, #0]
    96c4:	3642      	adds	r6, #66	; 0x42
    96c6:	1d11      	adds	r1, r2, #4
    96c8:	6019      	str	r1, [r3, #0]
    96ca:	6813      	ldr	r3, [r2, #0]
    96cc:	7033      	strb	r3, [r6, #0]
    96ce:	2301      	movs	r3, #1
    96d0:	e079      	b.n	97c6 <_printf_i+0x182>
    96d2:	0649      	lsls	r1, r1, #25
    96d4:	d5d9      	bpl.n	968a <_printf_i+0x46>
    96d6:	1d11      	adds	r1, r2, #4
    96d8:	6019      	str	r1, [r3, #0]
    96da:	2300      	movs	r3, #0
    96dc:	5ed5      	ldrsh	r5, [r2, r3]
    96de:	2d00      	cmp	r5, #0
    96e0:	da03      	bge.n	96ea <_printf_i+0xa6>
    96e2:	232d      	movs	r3, #45	; 0x2d
    96e4:	9a04      	ldr	r2, [sp, #16]
    96e6:	426d      	negs	r5, r5
    96e8:	7013      	strb	r3, [r2, #0]
    96ea:	4b62      	ldr	r3, [pc, #392]	; (9874 <_printf_i+0x230>)
    96ec:	270a      	movs	r7, #10
    96ee:	9303      	str	r3, [sp, #12]
    96f0:	e02f      	b.n	9752 <_printf_i+0x10e>
    96f2:	6820      	ldr	r0, [r4, #0]
    96f4:	6819      	ldr	r1, [r3, #0]
    96f6:	0605      	lsls	r5, r0, #24
    96f8:	d503      	bpl.n	9702 <_printf_i+0xbe>
    96fa:	1d08      	adds	r0, r1, #4
    96fc:	6018      	str	r0, [r3, #0]
    96fe:	680d      	ldr	r5, [r1, #0]
    9700:	e005      	b.n	970e <_printf_i+0xca>
    9702:	0640      	lsls	r0, r0, #25
    9704:	d5f9      	bpl.n	96fa <_printf_i+0xb6>
    9706:	680d      	ldr	r5, [r1, #0]
    9708:	1d08      	adds	r0, r1, #4
    970a:	6018      	str	r0, [r3, #0]
    970c:	b2ad      	uxth	r5, r5
    970e:	4b59      	ldr	r3, [pc, #356]	; (9874 <_printf_i+0x230>)
    9710:	2708      	movs	r7, #8
    9712:	9303      	str	r3, [sp, #12]
    9714:	2a6f      	cmp	r2, #111	; 0x6f
    9716:	d018      	beq.n	974a <_printf_i+0x106>
    9718:	270a      	movs	r7, #10
    971a:	e016      	b.n	974a <_printf_i+0x106>
    971c:	3145      	adds	r1, #69	; 0x45
    971e:	700a      	strb	r2, [r1, #0]
    9720:	4a54      	ldr	r2, [pc, #336]	; (9874 <_printf_i+0x230>)
    9722:	9203      	str	r2, [sp, #12]
    9724:	681a      	ldr	r2, [r3, #0]
    9726:	6821      	ldr	r1, [r4, #0]
    9728:	1d10      	adds	r0, r2, #4
    972a:	6018      	str	r0, [r3, #0]
    972c:	6815      	ldr	r5, [r2, #0]
    972e:	0608      	lsls	r0, r1, #24
    9730:	d522      	bpl.n	9778 <_printf_i+0x134>
    9732:	07cb      	lsls	r3, r1, #31
    9734:	d502      	bpl.n	973c <_printf_i+0xf8>
    9736:	2320      	movs	r3, #32
    9738:	4319      	orrs	r1, r3
    973a:	6021      	str	r1, [r4, #0]
    973c:	2710      	movs	r7, #16
    973e:	2d00      	cmp	r5, #0
    9740:	d103      	bne.n	974a <_printf_i+0x106>
    9742:	2320      	movs	r3, #32
    9744:	6822      	ldr	r2, [r4, #0]
    9746:	439a      	bics	r2, r3
    9748:	6022      	str	r2, [r4, #0]
    974a:	0023      	movs	r3, r4
    974c:	2200      	movs	r2, #0
    974e:	3343      	adds	r3, #67	; 0x43
    9750:	701a      	strb	r2, [r3, #0]
    9752:	6863      	ldr	r3, [r4, #4]
    9754:	60a3      	str	r3, [r4, #8]
    9756:	2b00      	cmp	r3, #0
    9758:	db5c      	blt.n	9814 <_printf_i+0x1d0>
    975a:	2204      	movs	r2, #4
    975c:	6821      	ldr	r1, [r4, #0]
    975e:	4391      	bics	r1, r2
    9760:	6021      	str	r1, [r4, #0]
    9762:	2d00      	cmp	r5, #0
    9764:	d158      	bne.n	9818 <_printf_i+0x1d4>
    9766:	9e04      	ldr	r6, [sp, #16]
    9768:	2b00      	cmp	r3, #0
    976a:	d064      	beq.n	9836 <_printf_i+0x1f2>
    976c:	0026      	movs	r6, r4
    976e:	9b03      	ldr	r3, [sp, #12]
    9770:	3642      	adds	r6, #66	; 0x42
    9772:	781b      	ldrb	r3, [r3, #0]
    9774:	7033      	strb	r3, [r6, #0]
    9776:	e05e      	b.n	9836 <_printf_i+0x1f2>
    9778:	0648      	lsls	r0, r1, #25
    977a:	d5da      	bpl.n	9732 <_printf_i+0xee>
    977c:	b2ad      	uxth	r5, r5
    977e:	e7d8      	b.n	9732 <_printf_i+0xee>
    9780:	6809      	ldr	r1, [r1, #0]
    9782:	681a      	ldr	r2, [r3, #0]
    9784:	0608      	lsls	r0, r1, #24
    9786:	d505      	bpl.n	9794 <_printf_i+0x150>
    9788:	1d11      	adds	r1, r2, #4
    978a:	6019      	str	r1, [r3, #0]
    978c:	6813      	ldr	r3, [r2, #0]
    978e:	6962      	ldr	r2, [r4, #20]
    9790:	601a      	str	r2, [r3, #0]
    9792:	e006      	b.n	97a2 <_printf_i+0x15e>
    9794:	0649      	lsls	r1, r1, #25
    9796:	d5f7      	bpl.n	9788 <_printf_i+0x144>
    9798:	1d11      	adds	r1, r2, #4
    979a:	6019      	str	r1, [r3, #0]
    979c:	6813      	ldr	r3, [r2, #0]
    979e:	8aa2      	ldrh	r2, [r4, #20]
    97a0:	801a      	strh	r2, [r3, #0]
    97a2:	2300      	movs	r3, #0
    97a4:	9e04      	ldr	r6, [sp, #16]
    97a6:	6123      	str	r3, [r4, #16]
    97a8:	e054      	b.n	9854 <_printf_i+0x210>
    97aa:	681a      	ldr	r2, [r3, #0]
    97ac:	1d11      	adds	r1, r2, #4
    97ae:	6019      	str	r1, [r3, #0]
    97b0:	6816      	ldr	r6, [r2, #0]
    97b2:	2100      	movs	r1, #0
    97b4:	6862      	ldr	r2, [r4, #4]
    97b6:	0030      	movs	r0, r6
    97b8:	f000 fa44 	bl	9c44 <memchr>
    97bc:	2800      	cmp	r0, #0
    97be:	d001      	beq.n	97c4 <_printf_i+0x180>
    97c0:	1b80      	subs	r0, r0, r6
    97c2:	6060      	str	r0, [r4, #4]
    97c4:	6863      	ldr	r3, [r4, #4]
    97c6:	6123      	str	r3, [r4, #16]
    97c8:	2300      	movs	r3, #0
    97ca:	9a04      	ldr	r2, [sp, #16]
    97cc:	7013      	strb	r3, [r2, #0]
    97ce:	e041      	b.n	9854 <_printf_i+0x210>
    97d0:	6923      	ldr	r3, [r4, #16]
    97d2:	0032      	movs	r2, r6
    97d4:	9906      	ldr	r1, [sp, #24]
    97d6:	9805      	ldr	r0, [sp, #20]
    97d8:	9d07      	ldr	r5, [sp, #28]
    97da:	47a8      	blx	r5
    97dc:	1c43      	adds	r3, r0, #1
    97de:	d043      	beq.n	9868 <_printf_i+0x224>
    97e0:	6823      	ldr	r3, [r4, #0]
    97e2:	2500      	movs	r5, #0
    97e4:	079b      	lsls	r3, r3, #30
    97e6:	d40f      	bmi.n	9808 <_printf_i+0x1c4>
    97e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    97ea:	68e0      	ldr	r0, [r4, #12]
    97ec:	4298      	cmp	r0, r3
    97ee:	da3d      	bge.n	986c <_printf_i+0x228>
    97f0:	0018      	movs	r0, r3
    97f2:	e03b      	b.n	986c <_printf_i+0x228>
    97f4:	0022      	movs	r2, r4
    97f6:	2301      	movs	r3, #1
    97f8:	3219      	adds	r2, #25
    97fa:	9906      	ldr	r1, [sp, #24]
    97fc:	9805      	ldr	r0, [sp, #20]
    97fe:	9e07      	ldr	r6, [sp, #28]
    9800:	47b0      	blx	r6
    9802:	1c43      	adds	r3, r0, #1
    9804:	d030      	beq.n	9868 <_printf_i+0x224>
    9806:	3501      	adds	r5, #1
    9808:	68e3      	ldr	r3, [r4, #12]
    980a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    980c:	1a9b      	subs	r3, r3, r2
    980e:	429d      	cmp	r5, r3
    9810:	dbf0      	blt.n	97f4 <_printf_i+0x1b0>
    9812:	e7e9      	b.n	97e8 <_printf_i+0x1a4>
    9814:	2d00      	cmp	r5, #0
    9816:	d0a9      	beq.n	976c <_printf_i+0x128>
    9818:	9e04      	ldr	r6, [sp, #16]
    981a:	0028      	movs	r0, r5
    981c:	0039      	movs	r1, r7
    981e:	f7fe fc39 	bl	8094 <__aeabi_uidivmod>
    9822:	9b03      	ldr	r3, [sp, #12]
    9824:	3e01      	subs	r6, #1
    9826:	5c5b      	ldrb	r3, [r3, r1]
    9828:	0028      	movs	r0, r5
    982a:	7033      	strb	r3, [r6, #0]
    982c:	0039      	movs	r1, r7
    982e:	f7fe fbab 	bl	7f88 <__udivsi3>
    9832:	1e05      	subs	r5, r0, #0
    9834:	d1f1      	bne.n	981a <_printf_i+0x1d6>
    9836:	2f08      	cmp	r7, #8
    9838:	d109      	bne.n	984e <_printf_i+0x20a>
    983a:	6823      	ldr	r3, [r4, #0]
    983c:	07db      	lsls	r3, r3, #31
    983e:	d506      	bpl.n	984e <_printf_i+0x20a>
    9840:	6863      	ldr	r3, [r4, #4]
    9842:	6922      	ldr	r2, [r4, #16]
    9844:	4293      	cmp	r3, r2
    9846:	dc02      	bgt.n	984e <_printf_i+0x20a>
    9848:	2330      	movs	r3, #48	; 0x30
    984a:	3e01      	subs	r6, #1
    984c:	7033      	strb	r3, [r6, #0]
    984e:	9b04      	ldr	r3, [sp, #16]
    9850:	1b9b      	subs	r3, r3, r6
    9852:	6123      	str	r3, [r4, #16]
    9854:	9b07      	ldr	r3, [sp, #28]
    9856:	aa09      	add	r2, sp, #36	; 0x24
    9858:	9300      	str	r3, [sp, #0]
    985a:	0021      	movs	r1, r4
    985c:	9b06      	ldr	r3, [sp, #24]
    985e:	9805      	ldr	r0, [sp, #20]
    9860:	f7ff fe82 	bl	9568 <_printf_common>
    9864:	1c43      	adds	r3, r0, #1
    9866:	d1b3      	bne.n	97d0 <_printf_i+0x18c>
    9868:	2001      	movs	r0, #1
    986a:	4240      	negs	r0, r0
    986c:	b00b      	add	sp, #44	; 0x2c
    986e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9870:	0000bcb6 	.word	0x0000bcb6
    9874:	0000bca5 	.word	0x0000bca5

00009878 <_scanf_chars>:
    9878:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    987a:	0015      	movs	r5, r2
    987c:	688a      	ldr	r2, [r1, #8]
    987e:	9001      	str	r0, [sp, #4]
    9880:	000c      	movs	r4, r1
    9882:	2a00      	cmp	r2, #0
    9884:	d106      	bne.n	9894 <_scanf_chars+0x1c>
    9886:	698a      	ldr	r2, [r1, #24]
    9888:	1e51      	subs	r1, r2, #1
    988a:	418a      	sbcs	r2, r1
    988c:	2101      	movs	r1, #1
    988e:	4252      	negs	r2, r2
    9890:	430a      	orrs	r2, r1
    9892:	60a2      	str	r2, [r4, #8]
    9894:	6822      	ldr	r2, [r4, #0]
    9896:	06d2      	lsls	r2, r2, #27
    9898:	d403      	bmi.n	98a2 <_scanf_chars+0x2a>
    989a:	681a      	ldr	r2, [r3, #0]
    989c:	1d11      	adds	r1, r2, #4
    989e:	6019      	str	r1, [r3, #0]
    98a0:	6817      	ldr	r7, [r2, #0]
    98a2:	2600      	movs	r6, #0
    98a4:	69a3      	ldr	r3, [r4, #24]
    98a6:	2b00      	cmp	r3, #0
    98a8:	d01c      	beq.n	98e4 <_scanf_chars+0x6c>
    98aa:	2b01      	cmp	r3, #1
    98ac:	d108      	bne.n	98c0 <_scanf_chars+0x48>
    98ae:	682b      	ldr	r3, [r5, #0]
    98b0:	6962      	ldr	r2, [r4, #20]
    98b2:	781b      	ldrb	r3, [r3, #0]
    98b4:	5cd3      	ldrb	r3, [r2, r3]
    98b6:	2b00      	cmp	r3, #0
    98b8:	d114      	bne.n	98e4 <_scanf_chars+0x6c>
    98ba:	2e00      	cmp	r6, #0
    98bc:	d130      	bne.n	9920 <_scanf_chars+0xa8>
    98be:	e006      	b.n	98ce <_scanf_chars+0x56>
    98c0:	2b02      	cmp	r3, #2
    98c2:	d006      	beq.n	98d2 <_scanf_chars+0x5a>
    98c4:	2e00      	cmp	r6, #0
    98c6:	d12b      	bne.n	9920 <_scanf_chars+0xa8>
    98c8:	69a3      	ldr	r3, [r4, #24]
    98ca:	2b01      	cmp	r3, #1
    98cc:	d128      	bne.n	9920 <_scanf_chars+0xa8>
    98ce:	2001      	movs	r0, #1
    98d0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    98d2:	f7ff f817 	bl	8904 <__locale_ctype_ptr>
    98d6:	2208      	movs	r2, #8
    98d8:	682b      	ldr	r3, [r5, #0]
    98da:	781b      	ldrb	r3, [r3, #0]
    98dc:	18c0      	adds	r0, r0, r3
    98de:	7843      	ldrb	r3, [r0, #1]
    98e0:	4213      	tst	r3, r2
    98e2:	d1ef      	bne.n	98c4 <_scanf_chars+0x4c>
    98e4:	2210      	movs	r2, #16
    98e6:	6823      	ldr	r3, [r4, #0]
    98e8:	3601      	adds	r6, #1
    98ea:	4213      	tst	r3, r2
    98ec:	d103      	bne.n	98f6 <_scanf_chars+0x7e>
    98ee:	682b      	ldr	r3, [r5, #0]
    98f0:	781b      	ldrb	r3, [r3, #0]
    98f2:	703b      	strb	r3, [r7, #0]
    98f4:	3701      	adds	r7, #1
    98f6:	682a      	ldr	r2, [r5, #0]
    98f8:	686b      	ldr	r3, [r5, #4]
    98fa:	3201      	adds	r2, #1
    98fc:	602a      	str	r2, [r5, #0]
    98fe:	68a2      	ldr	r2, [r4, #8]
    9900:	3b01      	subs	r3, #1
    9902:	3a01      	subs	r2, #1
    9904:	606b      	str	r3, [r5, #4]
    9906:	60a2      	str	r2, [r4, #8]
    9908:	2a00      	cmp	r2, #0
    990a:	d009      	beq.n	9920 <_scanf_chars+0xa8>
    990c:	2b00      	cmp	r3, #0
    990e:	dcc9      	bgt.n	98a4 <_scanf_chars+0x2c>
    9910:	23c0      	movs	r3, #192	; 0xc0
    9912:	005b      	lsls	r3, r3, #1
    9914:	58e3      	ldr	r3, [r4, r3]
    9916:	0029      	movs	r1, r5
    9918:	9801      	ldr	r0, [sp, #4]
    991a:	4798      	blx	r3
    991c:	2800      	cmp	r0, #0
    991e:	d0c1      	beq.n	98a4 <_scanf_chars+0x2c>
    9920:	2310      	movs	r3, #16
    9922:	6822      	ldr	r2, [r4, #0]
    9924:	4013      	ands	r3, r2
    9926:	d106      	bne.n	9936 <_scanf_chars+0xbe>
    9928:	68e2      	ldr	r2, [r4, #12]
    992a:	3201      	adds	r2, #1
    992c:	60e2      	str	r2, [r4, #12]
    992e:	69a2      	ldr	r2, [r4, #24]
    9930:	2a00      	cmp	r2, #0
    9932:	d000      	beq.n	9936 <_scanf_chars+0xbe>
    9934:	703b      	strb	r3, [r7, #0]
    9936:	6923      	ldr	r3, [r4, #16]
    9938:	2000      	movs	r0, #0
    993a:	199e      	adds	r6, r3, r6
    993c:	6126      	str	r6, [r4, #16]
    993e:	e7c7      	b.n	98d0 <_scanf_chars+0x58>

00009940 <_scanf_i>:
    9940:	b5f0      	push	{r4, r5, r6, r7, lr}
    9942:	000c      	movs	r4, r1
    9944:	b08d      	sub	sp, #52	; 0x34
    9946:	9302      	str	r3, [sp, #8]
    9948:	4b77      	ldr	r3, [pc, #476]	; (9b28 <_scanf_i+0x1e8>)
    994a:	9005      	str	r0, [sp, #20]
    994c:	0016      	movs	r6, r2
    994e:	aa09      	add	r2, sp, #36	; 0x24
    9950:	cb23      	ldmia	r3!, {r0, r1, r5}
    9952:	c223      	stmia	r2!, {r0, r1, r5}
    9954:	4b75      	ldr	r3, [pc, #468]	; (9b2c <_scanf_i+0x1ec>)
    9956:	9306      	str	r3, [sp, #24]
    9958:	69a3      	ldr	r3, [r4, #24]
    995a:	2b03      	cmp	r3, #3
    995c:	d001      	beq.n	9962 <_scanf_i+0x22>
    995e:	4b74      	ldr	r3, [pc, #464]	; (9b30 <_scanf_i+0x1f0>)
    9960:	9306      	str	r3, [sp, #24]
    9962:	22ae      	movs	r2, #174	; 0xae
    9964:	2000      	movs	r0, #0
    9966:	68a3      	ldr	r3, [r4, #8]
    9968:	0052      	lsls	r2, r2, #1
    996a:	1e59      	subs	r1, r3, #1
    996c:	9004      	str	r0, [sp, #16]
    996e:	4291      	cmp	r1, r2
    9970:	d905      	bls.n	997e <_scanf_i+0x3e>
    9972:	3b5e      	subs	r3, #94	; 0x5e
    9974:	3bff      	subs	r3, #255	; 0xff
    9976:	9304      	str	r3, [sp, #16]
    9978:	235e      	movs	r3, #94	; 0x5e
    997a:	33ff      	adds	r3, #255	; 0xff
    997c:	60a3      	str	r3, [r4, #8]
    997e:	0023      	movs	r3, r4
    9980:	331c      	adds	r3, #28
    9982:	9301      	str	r3, [sp, #4]
    9984:	23d0      	movs	r3, #208	; 0xd0
    9986:	2700      	movs	r7, #0
    9988:	6822      	ldr	r2, [r4, #0]
    998a:	011b      	lsls	r3, r3, #4
    998c:	4313      	orrs	r3, r2
    998e:	6023      	str	r3, [r4, #0]
    9990:	9b01      	ldr	r3, [sp, #4]
    9992:	9303      	str	r3, [sp, #12]
    9994:	6833      	ldr	r3, [r6, #0]
    9996:	a809      	add	r0, sp, #36	; 0x24
    9998:	7819      	ldrb	r1, [r3, #0]
    999a:	00bb      	lsls	r3, r7, #2
    999c:	2202      	movs	r2, #2
    999e:	5818      	ldr	r0, [r3, r0]
    99a0:	f000 f950 	bl	9c44 <memchr>
    99a4:	2800      	cmp	r0, #0
    99a6:	d02b      	beq.n	9a00 <_scanf_i+0xc0>
    99a8:	2f01      	cmp	r7, #1
    99aa:	d15f      	bne.n	9a6c <_scanf_i+0x12c>
    99ac:	6863      	ldr	r3, [r4, #4]
    99ae:	2b00      	cmp	r3, #0
    99b0:	d106      	bne.n	99c0 <_scanf_i+0x80>
    99b2:	3308      	adds	r3, #8
    99b4:	6822      	ldr	r2, [r4, #0]
    99b6:	6063      	str	r3, [r4, #4]
    99b8:	33f9      	adds	r3, #249	; 0xf9
    99ba:	33ff      	adds	r3, #255	; 0xff
    99bc:	4313      	orrs	r3, r2
    99be:	6023      	str	r3, [r4, #0]
    99c0:	4b5c      	ldr	r3, [pc, #368]	; (9b34 <_scanf_i+0x1f4>)
    99c2:	6822      	ldr	r2, [r4, #0]
    99c4:	4013      	ands	r3, r2
    99c6:	6023      	str	r3, [r4, #0]
    99c8:	68a3      	ldr	r3, [r4, #8]
    99ca:	1e5a      	subs	r2, r3, #1
    99cc:	60a2      	str	r2, [r4, #8]
    99ce:	2b00      	cmp	r3, #0
    99d0:	d016      	beq.n	9a00 <_scanf_i+0xc0>
    99d2:	9b03      	ldr	r3, [sp, #12]
    99d4:	1c5d      	adds	r5, r3, #1
    99d6:	6833      	ldr	r3, [r6, #0]
    99d8:	1c5a      	adds	r2, r3, #1
    99da:	6032      	str	r2, [r6, #0]
    99dc:	781b      	ldrb	r3, [r3, #0]
    99de:	9a03      	ldr	r2, [sp, #12]
    99e0:	9503      	str	r5, [sp, #12]
    99e2:	7013      	strb	r3, [r2, #0]
    99e4:	6873      	ldr	r3, [r6, #4]
    99e6:	3b01      	subs	r3, #1
    99e8:	6073      	str	r3, [r6, #4]
    99ea:	2b00      	cmp	r3, #0
    99ec:	dc08      	bgt.n	9a00 <_scanf_i+0xc0>
    99ee:	23c0      	movs	r3, #192	; 0xc0
    99f0:	005b      	lsls	r3, r3, #1
    99f2:	58e3      	ldr	r3, [r4, r3]
    99f4:	0031      	movs	r1, r6
    99f6:	9805      	ldr	r0, [sp, #20]
    99f8:	9307      	str	r3, [sp, #28]
    99fa:	4798      	blx	r3
    99fc:	2800      	cmp	r0, #0
    99fe:	d17d      	bne.n	9afc <_scanf_i+0x1bc>
    9a00:	3701      	adds	r7, #1
    9a02:	2f03      	cmp	r7, #3
    9a04:	d1c6      	bne.n	9994 <_scanf_i+0x54>
    9a06:	6863      	ldr	r3, [r4, #4]
    9a08:	2b00      	cmp	r3, #0
    9a0a:	d101      	bne.n	9a10 <_scanf_i+0xd0>
    9a0c:	330a      	adds	r3, #10
    9a0e:	6063      	str	r3, [r4, #4]
    9a10:	2110      	movs	r1, #16
    9a12:	2700      	movs	r7, #0
    9a14:	6863      	ldr	r3, [r4, #4]
    9a16:	6960      	ldr	r0, [r4, #20]
    9a18:	1ac9      	subs	r1, r1, r3
    9a1a:	4b47      	ldr	r3, [pc, #284]	; (9b38 <_scanf_i+0x1f8>)
    9a1c:	18c9      	adds	r1, r1, r3
    9a1e:	f000 f8a1 	bl	9b64 <__sccl>
    9a22:	9d03      	ldr	r5, [sp, #12]
    9a24:	68a3      	ldr	r3, [r4, #8]
    9a26:	2b00      	cmp	r3, #0
    9a28:	d041      	beq.n	9aae <_scanf_i+0x16e>
    9a2a:	6832      	ldr	r2, [r6, #0]
    9a2c:	6960      	ldr	r0, [r4, #20]
    9a2e:	7811      	ldrb	r1, [r2, #0]
    9a30:	5c40      	ldrb	r0, [r0, r1]
    9a32:	2800      	cmp	r0, #0
    9a34:	d03b      	beq.n	9aae <_scanf_i+0x16e>
    9a36:	2930      	cmp	r1, #48	; 0x30
    9a38:	d128      	bne.n	9a8c <_scanf_i+0x14c>
    9a3a:	2080      	movs	r0, #128	; 0x80
    9a3c:	6821      	ldr	r1, [r4, #0]
    9a3e:	0100      	lsls	r0, r0, #4
    9a40:	4201      	tst	r1, r0
    9a42:	d023      	beq.n	9a8c <_scanf_i+0x14c>
    9a44:	9a04      	ldr	r2, [sp, #16]
    9a46:	3701      	adds	r7, #1
    9a48:	2a00      	cmp	r2, #0
    9a4a:	d003      	beq.n	9a54 <_scanf_i+0x114>
    9a4c:	3a01      	subs	r2, #1
    9a4e:	3301      	adds	r3, #1
    9a50:	9204      	str	r2, [sp, #16]
    9a52:	60a3      	str	r3, [r4, #8]
    9a54:	6873      	ldr	r3, [r6, #4]
    9a56:	3b01      	subs	r3, #1
    9a58:	6073      	str	r3, [r6, #4]
    9a5a:	2b00      	cmp	r3, #0
    9a5c:	dd1e      	ble.n	9a9c <_scanf_i+0x15c>
    9a5e:	6833      	ldr	r3, [r6, #0]
    9a60:	3301      	adds	r3, #1
    9a62:	6033      	str	r3, [r6, #0]
    9a64:	68a3      	ldr	r3, [r4, #8]
    9a66:	3b01      	subs	r3, #1
    9a68:	60a3      	str	r3, [r4, #8]
    9a6a:	e7db      	b.n	9a24 <_scanf_i+0xe4>
    9a6c:	2f02      	cmp	r7, #2
    9a6e:	d1ab      	bne.n	99c8 <_scanf_i+0x88>
    9a70:	21c0      	movs	r1, #192	; 0xc0
    9a72:	2380      	movs	r3, #128	; 0x80
    9a74:	6822      	ldr	r2, [r4, #0]
    9a76:	00c9      	lsls	r1, r1, #3
    9a78:	4011      	ands	r1, r2
    9a7a:	009b      	lsls	r3, r3, #2
    9a7c:	4299      	cmp	r1, r3
    9a7e:	d1c2      	bne.n	9a06 <_scanf_i+0xc6>
    9a80:	3bf1      	subs	r3, #241	; 0xf1
    9a82:	3bff      	subs	r3, #255	; 0xff
    9a84:	6063      	str	r3, [r4, #4]
    9a86:	33f0      	adds	r3, #240	; 0xf0
    9a88:	4313      	orrs	r3, r2
    9a8a:	e79c      	b.n	99c6 <_scanf_i+0x86>
    9a8c:	6821      	ldr	r1, [r4, #0]
    9a8e:	4b2b      	ldr	r3, [pc, #172]	; (9b3c <_scanf_i+0x1fc>)
    9a90:	400b      	ands	r3, r1
    9a92:	6023      	str	r3, [r4, #0]
    9a94:	7813      	ldrb	r3, [r2, #0]
    9a96:	702b      	strb	r3, [r5, #0]
    9a98:	3501      	adds	r5, #1
    9a9a:	e7db      	b.n	9a54 <_scanf_i+0x114>
    9a9c:	23c0      	movs	r3, #192	; 0xc0
    9a9e:	005b      	lsls	r3, r3, #1
    9aa0:	58e3      	ldr	r3, [r4, r3]
    9aa2:	0031      	movs	r1, r6
    9aa4:	9805      	ldr	r0, [sp, #20]
    9aa6:	9303      	str	r3, [sp, #12]
    9aa8:	4798      	blx	r3
    9aaa:	2800      	cmp	r0, #0
    9aac:	d0da      	beq.n	9a64 <_scanf_i+0x124>
    9aae:	6823      	ldr	r3, [r4, #0]
    9ab0:	05db      	lsls	r3, r3, #23
    9ab2:	d50e      	bpl.n	9ad2 <_scanf_i+0x192>
    9ab4:	9b01      	ldr	r3, [sp, #4]
    9ab6:	429d      	cmp	r5, r3
    9ab8:	d907      	bls.n	9aca <_scanf_i+0x18a>
    9aba:	23be      	movs	r3, #190	; 0xbe
    9abc:	3d01      	subs	r5, #1
    9abe:	005b      	lsls	r3, r3, #1
    9ac0:	7829      	ldrb	r1, [r5, #0]
    9ac2:	58e3      	ldr	r3, [r4, r3]
    9ac4:	0032      	movs	r2, r6
    9ac6:	9805      	ldr	r0, [sp, #20]
    9ac8:	4798      	blx	r3
    9aca:	9b01      	ldr	r3, [sp, #4]
    9acc:	2001      	movs	r0, #1
    9ace:	429d      	cmp	r5, r3
    9ad0:	d027      	beq.n	9b22 <_scanf_i+0x1e2>
    9ad2:	2210      	movs	r2, #16
    9ad4:	6823      	ldr	r3, [r4, #0]
    9ad6:	401a      	ands	r2, r3
    9ad8:	d11c      	bne.n	9b14 <_scanf_i+0x1d4>
    9ada:	702a      	strb	r2, [r5, #0]
    9adc:	6863      	ldr	r3, [r4, #4]
    9ade:	9901      	ldr	r1, [sp, #4]
    9ae0:	9805      	ldr	r0, [sp, #20]
    9ae2:	9e06      	ldr	r6, [sp, #24]
    9ae4:	47b0      	blx	r6
    9ae6:	9b02      	ldr	r3, [sp, #8]
    9ae8:	6822      	ldr	r2, [r4, #0]
    9aea:	681b      	ldr	r3, [r3, #0]
    9aec:	0691      	lsls	r1, r2, #26
    9aee:	d507      	bpl.n	9b00 <_scanf_i+0x1c0>
    9af0:	9902      	ldr	r1, [sp, #8]
    9af2:	1d1a      	adds	r2, r3, #4
    9af4:	600a      	str	r2, [r1, #0]
    9af6:	681b      	ldr	r3, [r3, #0]
    9af8:	6018      	str	r0, [r3, #0]
    9afa:	e008      	b.n	9b0e <_scanf_i+0x1ce>
    9afc:	2700      	movs	r7, #0
    9afe:	e7d6      	b.n	9aae <_scanf_i+0x16e>
    9b00:	07d1      	lsls	r1, r2, #31
    9b02:	d5f5      	bpl.n	9af0 <_scanf_i+0x1b0>
    9b04:	9902      	ldr	r1, [sp, #8]
    9b06:	1d1a      	adds	r2, r3, #4
    9b08:	600a      	str	r2, [r1, #0]
    9b0a:	681b      	ldr	r3, [r3, #0]
    9b0c:	8018      	strh	r0, [r3, #0]
    9b0e:	68e3      	ldr	r3, [r4, #12]
    9b10:	3301      	adds	r3, #1
    9b12:	60e3      	str	r3, [r4, #12]
    9b14:	2000      	movs	r0, #0
    9b16:	9b01      	ldr	r3, [sp, #4]
    9b18:	1aed      	subs	r5, r5, r3
    9b1a:	6923      	ldr	r3, [r4, #16]
    9b1c:	19ef      	adds	r7, r5, r7
    9b1e:	19df      	adds	r7, r3, r7
    9b20:	6127      	str	r7, [r4, #16]
    9b22:	b00d      	add	sp, #52	; 0x34
    9b24:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9b26:	46c0      	nop			; (mov r8, r8)
    9b28:	0000bcc8 	.word	0x0000bcc8
    9b2c:	00008c1d 	.word	0x00008c1d
    9b30:	00008d75 	.word	0x00008d75
    9b34:	fffffaff 	.word	0xfffffaff
    9b38:	0000bcd4 	.word	0x0000bcd4
    9b3c:	fffff6ff 	.word	0xfffff6ff

00009b40 <_sbrk_r>:
    9b40:	2300      	movs	r3, #0
    9b42:	b570      	push	{r4, r5, r6, lr}
    9b44:	4c06      	ldr	r4, [pc, #24]	; (9b60 <_sbrk_r+0x20>)
    9b46:	0005      	movs	r5, r0
    9b48:	0008      	movs	r0, r1
    9b4a:	6023      	str	r3, [r4, #0]
    9b4c:	f7f8 f942 	bl	1dd4 <_sbrk>
    9b50:	1c43      	adds	r3, r0, #1
    9b52:	d103      	bne.n	9b5c <_sbrk_r+0x1c>
    9b54:	6823      	ldr	r3, [r4, #0]
    9b56:	2b00      	cmp	r3, #0
    9b58:	d000      	beq.n	9b5c <_sbrk_r+0x1c>
    9b5a:	602b      	str	r3, [r5, #0]
    9b5c:	bd70      	pop	{r4, r5, r6, pc}
    9b5e:	46c0      	nop			; (mov r8, r8)
    9b60:	20000d5c 	.word	0x20000d5c

00009b64 <__sccl>:
    9b64:	b570      	push	{r4, r5, r6, lr}
    9b66:	780b      	ldrb	r3, [r1, #0]
    9b68:	2b5e      	cmp	r3, #94	; 0x5e
    9b6a:	d00d      	beq.n	9b88 <__sccl+0x24>
    9b6c:	1c4a      	adds	r2, r1, #1
    9b6e:	2100      	movs	r1, #0
    9b70:	0004      	movs	r4, r0
    9b72:	1c45      	adds	r5, r0, #1
    9b74:	35ff      	adds	r5, #255	; 0xff
    9b76:	7021      	strb	r1, [r4, #0]
    9b78:	3401      	adds	r4, #1
    9b7a:	42a5      	cmp	r5, r4
    9b7c:	d1fb      	bne.n	9b76 <__sccl+0x12>
    9b7e:	2b00      	cmp	r3, #0
    9b80:	d106      	bne.n	9b90 <__sccl+0x2c>
    9b82:	3a01      	subs	r2, #1
    9b84:	0010      	movs	r0, r2
    9b86:	bd70      	pop	{r4, r5, r6, pc}
    9b88:	1c8a      	adds	r2, r1, #2
    9b8a:	784b      	ldrb	r3, [r1, #1]
    9b8c:	2101      	movs	r1, #1
    9b8e:	e7ef      	b.n	9b70 <__sccl+0xc>
    9b90:	2401      	movs	r4, #1
    9b92:	404c      	eors	r4, r1
    9b94:	0011      	movs	r1, r2
    9b96:	54c4      	strb	r4, [r0, r3]
    9b98:	780d      	ldrb	r5, [r1, #0]
    9b9a:	1c4a      	adds	r2, r1, #1
    9b9c:	2d2d      	cmp	r5, #45	; 0x2d
    9b9e:	d007      	beq.n	9bb0 <__sccl+0x4c>
    9ba0:	2d5d      	cmp	r5, #93	; 0x5d
    9ba2:	d0ef      	beq.n	9b84 <__sccl+0x20>
    9ba4:	2d00      	cmp	r5, #0
    9ba6:	d101      	bne.n	9bac <__sccl+0x48>
    9ba8:	000a      	movs	r2, r1
    9baa:	e7eb      	b.n	9b84 <__sccl+0x20>
    9bac:	002b      	movs	r3, r5
    9bae:	e7f1      	b.n	9b94 <__sccl+0x30>
    9bb0:	784e      	ldrb	r6, [r1, #1]
    9bb2:	2e5d      	cmp	r6, #93	; 0x5d
    9bb4:	d0fa      	beq.n	9bac <__sccl+0x48>
    9bb6:	42b3      	cmp	r3, r6
    9bb8:	dcf8      	bgt.n	9bac <__sccl+0x48>
    9bba:	3102      	adds	r1, #2
    9bbc:	3301      	adds	r3, #1
    9bbe:	54c4      	strb	r4, [r0, r3]
    9bc0:	429e      	cmp	r6, r3
    9bc2:	dcfb      	bgt.n	9bbc <__sccl+0x58>
    9bc4:	e7e8      	b.n	9b98 <__sccl+0x34>
	...

00009bc8 <__submore>:
    9bc8:	000b      	movs	r3, r1
    9bca:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9bcc:	6b4d      	ldr	r5, [r1, #52]	; 0x34
    9bce:	3344      	adds	r3, #68	; 0x44
    9bd0:	000c      	movs	r4, r1
    9bd2:	429d      	cmp	r5, r3
    9bd4:	d11c      	bne.n	9c10 <__submore+0x48>
    9bd6:	2680      	movs	r6, #128	; 0x80
    9bd8:	00f6      	lsls	r6, r6, #3
    9bda:	0031      	movs	r1, r6
    9bdc:	f7ff f91e 	bl	8e1c <_malloc_r>
    9be0:	2800      	cmp	r0, #0
    9be2:	d102      	bne.n	9bea <__submore+0x22>
    9be4:	2001      	movs	r0, #1
    9be6:	4240      	negs	r0, r0
    9be8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    9bea:	0023      	movs	r3, r4
    9bec:	6360      	str	r0, [r4, #52]	; 0x34
    9bee:	63a6      	str	r6, [r4, #56]	; 0x38
    9bf0:	3346      	adds	r3, #70	; 0x46
    9bf2:	781a      	ldrb	r2, [r3, #0]
    9bf4:	4b10      	ldr	r3, [pc, #64]	; (9c38 <__submore+0x70>)
    9bf6:	54c2      	strb	r2, [r0, r3]
    9bf8:	0023      	movs	r3, r4
    9bfa:	3345      	adds	r3, #69	; 0x45
    9bfc:	781a      	ldrb	r2, [r3, #0]
    9bfe:	4b0f      	ldr	r3, [pc, #60]	; (9c3c <__submore+0x74>)
    9c00:	54c2      	strb	r2, [r0, r3]
    9c02:	782a      	ldrb	r2, [r5, #0]
    9c04:	4b0e      	ldr	r3, [pc, #56]	; (9c40 <__submore+0x78>)
    9c06:	54c2      	strb	r2, [r0, r3]
    9c08:	18c0      	adds	r0, r0, r3
    9c0a:	6020      	str	r0, [r4, #0]
    9c0c:	2000      	movs	r0, #0
    9c0e:	e7eb      	b.n	9be8 <__submore+0x20>
    9c10:	6b8e      	ldr	r6, [r1, #56]	; 0x38
    9c12:	0029      	movs	r1, r5
    9c14:	0073      	lsls	r3, r6, #1
    9c16:	001a      	movs	r2, r3
    9c18:	9301      	str	r3, [sp, #4]
    9c1a:	f000 f87d 	bl	9d18 <_realloc_r>
    9c1e:	1e05      	subs	r5, r0, #0
    9c20:	d0e0      	beq.n	9be4 <__submore+0x1c>
    9c22:	1987      	adds	r7, r0, r6
    9c24:	0001      	movs	r1, r0
    9c26:	0032      	movs	r2, r6
    9c28:	0038      	movs	r0, r7
    9c2a:	f7fe fe8b 	bl	8944 <memcpy>
    9c2e:	9b01      	ldr	r3, [sp, #4]
    9c30:	6027      	str	r7, [r4, #0]
    9c32:	6365      	str	r5, [r4, #52]	; 0x34
    9c34:	63a3      	str	r3, [r4, #56]	; 0x38
    9c36:	e7e9      	b.n	9c0c <__submore+0x44>
    9c38:	000003ff 	.word	0x000003ff
    9c3c:	000003fe 	.word	0x000003fe
    9c40:	000003fd 	.word	0x000003fd

00009c44 <memchr>:
    9c44:	b2c9      	uxtb	r1, r1
    9c46:	1882      	adds	r2, r0, r2
    9c48:	4290      	cmp	r0, r2
    9c4a:	d101      	bne.n	9c50 <memchr+0xc>
    9c4c:	2000      	movs	r0, #0
    9c4e:	4770      	bx	lr
    9c50:	7803      	ldrb	r3, [r0, #0]
    9c52:	428b      	cmp	r3, r1
    9c54:	d0fb      	beq.n	9c4e <memchr+0xa>
    9c56:	3001      	adds	r0, #1
    9c58:	e7f6      	b.n	9c48 <memchr+0x4>

00009c5a <memmove>:
    9c5a:	b510      	push	{r4, lr}
    9c5c:	4288      	cmp	r0, r1
    9c5e:	d902      	bls.n	9c66 <memmove+0xc>
    9c60:	188b      	adds	r3, r1, r2
    9c62:	4298      	cmp	r0, r3
    9c64:	d308      	bcc.n	9c78 <memmove+0x1e>
    9c66:	2300      	movs	r3, #0
    9c68:	429a      	cmp	r2, r3
    9c6a:	d007      	beq.n	9c7c <memmove+0x22>
    9c6c:	5ccc      	ldrb	r4, [r1, r3]
    9c6e:	54c4      	strb	r4, [r0, r3]
    9c70:	3301      	adds	r3, #1
    9c72:	e7f9      	b.n	9c68 <memmove+0xe>
    9c74:	5c8b      	ldrb	r3, [r1, r2]
    9c76:	5483      	strb	r3, [r0, r2]
    9c78:	3a01      	subs	r2, #1
    9c7a:	d2fb      	bcs.n	9c74 <memmove+0x1a>
    9c7c:	bd10      	pop	{r4, pc}

00009c7e <__malloc_lock>:
    9c7e:	4770      	bx	lr

00009c80 <__malloc_unlock>:
    9c80:	4770      	bx	lr
	...

00009c84 <_free_r>:
    9c84:	b570      	push	{r4, r5, r6, lr}
    9c86:	0005      	movs	r5, r0
    9c88:	2900      	cmp	r1, #0
    9c8a:	d010      	beq.n	9cae <_free_r+0x2a>
    9c8c:	1f0c      	subs	r4, r1, #4
    9c8e:	6823      	ldr	r3, [r4, #0]
    9c90:	2b00      	cmp	r3, #0
    9c92:	da00      	bge.n	9c96 <_free_r+0x12>
    9c94:	18e4      	adds	r4, r4, r3
    9c96:	0028      	movs	r0, r5
    9c98:	f7ff fff1 	bl	9c7e <__malloc_lock>
    9c9c:	4a1d      	ldr	r2, [pc, #116]	; (9d14 <_free_r+0x90>)
    9c9e:	6813      	ldr	r3, [r2, #0]
    9ca0:	2b00      	cmp	r3, #0
    9ca2:	d105      	bne.n	9cb0 <_free_r+0x2c>
    9ca4:	6063      	str	r3, [r4, #4]
    9ca6:	6014      	str	r4, [r2, #0]
    9ca8:	0028      	movs	r0, r5
    9caa:	f7ff ffe9 	bl	9c80 <__malloc_unlock>
    9cae:	bd70      	pop	{r4, r5, r6, pc}
    9cb0:	42a3      	cmp	r3, r4
    9cb2:	d909      	bls.n	9cc8 <_free_r+0x44>
    9cb4:	6821      	ldr	r1, [r4, #0]
    9cb6:	1860      	adds	r0, r4, r1
    9cb8:	4283      	cmp	r3, r0
    9cba:	d1f3      	bne.n	9ca4 <_free_r+0x20>
    9cbc:	6818      	ldr	r0, [r3, #0]
    9cbe:	685b      	ldr	r3, [r3, #4]
    9cc0:	1841      	adds	r1, r0, r1
    9cc2:	6021      	str	r1, [r4, #0]
    9cc4:	e7ee      	b.n	9ca4 <_free_r+0x20>
    9cc6:	0013      	movs	r3, r2
    9cc8:	685a      	ldr	r2, [r3, #4]
    9cca:	2a00      	cmp	r2, #0
    9ccc:	d001      	beq.n	9cd2 <_free_r+0x4e>
    9cce:	42a2      	cmp	r2, r4
    9cd0:	d9f9      	bls.n	9cc6 <_free_r+0x42>
    9cd2:	6819      	ldr	r1, [r3, #0]
    9cd4:	1858      	adds	r0, r3, r1
    9cd6:	42a0      	cmp	r0, r4
    9cd8:	d10b      	bne.n	9cf2 <_free_r+0x6e>
    9cda:	6820      	ldr	r0, [r4, #0]
    9cdc:	1809      	adds	r1, r1, r0
    9cde:	1858      	adds	r0, r3, r1
    9ce0:	6019      	str	r1, [r3, #0]
    9ce2:	4282      	cmp	r2, r0
    9ce4:	d1e0      	bne.n	9ca8 <_free_r+0x24>
    9ce6:	6810      	ldr	r0, [r2, #0]
    9ce8:	6852      	ldr	r2, [r2, #4]
    9cea:	1841      	adds	r1, r0, r1
    9cec:	6019      	str	r1, [r3, #0]
    9cee:	605a      	str	r2, [r3, #4]
    9cf0:	e7da      	b.n	9ca8 <_free_r+0x24>
    9cf2:	42a0      	cmp	r0, r4
    9cf4:	d902      	bls.n	9cfc <_free_r+0x78>
    9cf6:	230c      	movs	r3, #12
    9cf8:	602b      	str	r3, [r5, #0]
    9cfa:	e7d5      	b.n	9ca8 <_free_r+0x24>
    9cfc:	6821      	ldr	r1, [r4, #0]
    9cfe:	1860      	adds	r0, r4, r1
    9d00:	4282      	cmp	r2, r0
    9d02:	d103      	bne.n	9d0c <_free_r+0x88>
    9d04:	6810      	ldr	r0, [r2, #0]
    9d06:	6852      	ldr	r2, [r2, #4]
    9d08:	1841      	adds	r1, r0, r1
    9d0a:	6021      	str	r1, [r4, #0]
    9d0c:	6062      	str	r2, [r4, #4]
    9d0e:	605c      	str	r4, [r3, #4]
    9d10:	e7ca      	b.n	9ca8 <_free_r+0x24>
    9d12:	46c0      	nop			; (mov r8, r8)
    9d14:	200008ac 	.word	0x200008ac

00009d18 <_realloc_r>:
    9d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9d1a:	0007      	movs	r7, r0
    9d1c:	000d      	movs	r5, r1
    9d1e:	0016      	movs	r6, r2
    9d20:	2900      	cmp	r1, #0
    9d22:	d105      	bne.n	9d30 <_realloc_r+0x18>
    9d24:	0011      	movs	r1, r2
    9d26:	f7ff f879 	bl	8e1c <_malloc_r>
    9d2a:	0004      	movs	r4, r0
    9d2c:	0020      	movs	r0, r4
    9d2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9d30:	2a00      	cmp	r2, #0
    9d32:	d103      	bne.n	9d3c <_realloc_r+0x24>
    9d34:	f7ff ffa6 	bl	9c84 <_free_r>
    9d38:	0034      	movs	r4, r6
    9d3a:	e7f7      	b.n	9d2c <_realloc_r+0x14>
    9d3c:	f000 f812 	bl	9d64 <_malloc_usable_size_r>
    9d40:	002c      	movs	r4, r5
    9d42:	4286      	cmp	r6, r0
    9d44:	d9f2      	bls.n	9d2c <_realloc_r+0x14>
    9d46:	0031      	movs	r1, r6
    9d48:	0038      	movs	r0, r7
    9d4a:	f7ff f867 	bl	8e1c <_malloc_r>
    9d4e:	1e04      	subs	r4, r0, #0
    9d50:	d0ec      	beq.n	9d2c <_realloc_r+0x14>
    9d52:	0029      	movs	r1, r5
    9d54:	0032      	movs	r2, r6
    9d56:	f7fe fdf5 	bl	8944 <memcpy>
    9d5a:	0029      	movs	r1, r5
    9d5c:	0038      	movs	r0, r7
    9d5e:	f7ff ff91 	bl	9c84 <_free_r>
    9d62:	e7e3      	b.n	9d2c <_realloc_r+0x14>

00009d64 <_malloc_usable_size_r>:
    9d64:	1f0b      	subs	r3, r1, #4
    9d66:	681b      	ldr	r3, [r3, #0]
    9d68:	1f18      	subs	r0, r3, #4
    9d6a:	2b00      	cmp	r3, #0
    9d6c:	da01      	bge.n	9d72 <_malloc_usable_size_r+0xe>
    9d6e:	580b      	ldr	r3, [r1, r0]
    9d70:	18c0      	adds	r0, r0, r3
    9d72:	4770      	bx	lr
    9d74:	00009f9d 	.word	0x00009f9d
    9d78:	00009fa9 	.word	0x00009fa9
    9d7c:	00009fb5 	.word	0x00009fb5
    9d80:	422b5441 	.word	0x422b5441
    9d84:	41545354 	.word	0x41545354
    9d88:	3f535554 	.word	0x3f535554
    9d8c:	0a0d000d 	.word	0x0a0d000d
    9d90:	5354422b 	.word	0x5354422b
    9d94:	55544154 	.word	0x55544154
    9d98:	25203a53 	.word	0x25203a53
    9d9c:	54420064 	.word	0x54420064
    9da0:	54415453 	.word	0x54415453
    9da4:	253a5355 	.word	0x253a5355
    9da8:	000d0a64 	.word	0x000d0a64
    9dac:	5f6d6973 	.word	0x5f6d6973
    9db0:	65756c62 	.word	0x65756c62
    9db4:	746f6f74 	.word	0x746f6f74
    9db8:	6f705f68 	.word	0x6f705f68
    9dbc:	5f726577 	.word	0x5f726577
    9dc0:	0d0a6e6f 	.word	0x0d0a6e6f
    9dc4:	2b544100 	.word	0x2b544100
    9dc8:	4f505442 	.word	0x4f505442
    9dcc:	3d524557 	.word	0x3d524557
    9dd0:	73000d31 	.word	0x73000d31
    9dd4:	735f6d69 	.word	0x735f6d69
    9dd8:	5f706f74 	.word	0x5f706f74
    9ddc:	65756c62 	.word	0x65756c62
    9de0:	746f6f74 	.word	0x746f6f74
    9de4:	000d0a68 	.word	0x000d0a68
    9de8:	422b5441 	.word	0x422b5441
    9dec:	574f5054 	.word	0x574f5054
    9df0:	303d5245 	.word	0x303d5245
    9df4:	5441000d 	.word	0x5441000d
    9df8:	4854422b 	.word	0x4854422b
    9dfc:	3f54534f 	.word	0x3f54534f
    9e00:	614b000d 	.word	0x614b000d
    9e04:	726f776d 	.word	0x726f776d
    9e08:	535f736b 	.word	0x535f736b
    9e0c:	73005348 	.word	0x73005348
    9e10:	735f6d69 	.word	0x735f6d69
    9e14:	625f7465 	.word	0x625f7465
    9e18:	7465756c 	.word	0x7465756c
    9e1c:	68746f6f 	.word	0x68746f6f
    9e20:	7462203a 	.word	0x7462203a
    9e24:	74736f68 	.word	0x74736f68
    9e28:	726c6120 	.word	0x726c6120
    9e2c:	79646165 	.word	0x79646165
    9e30:	74657320 	.word	0x74657320
    9e34:	73000d0a 	.word	0x73000d0a
    9e38:	735f6d69 	.word	0x735f6d69
    9e3c:	625f7465 	.word	0x625f7465
    9e40:	7465756c 	.word	0x7465756c
    9e44:	68746f6f 	.word	0x68746f6f
    9e48:	6573203a 	.word	0x6573203a
    9e4c:	6e697474 	.word	0x6e697474
    9e50:	70752067 	.word	0x70752067
    9e54:	41000d0a 	.word	0x41000d0a
    9e58:	54422b54 	.word	0x54422b54
    9e5c:	54534f48 	.word	0x54534f48
    9e60:	6d614b3d 	.word	0x6d614b3d
    9e64:	6b726f77 	.word	0x6b726f77
    9e68:	48535f73 	.word	0x48535f73
    9e6c:	41000d53 	.word	0x41000d53
    9e70:	54422b54 	.word	0x54422b54
    9e74:	43505053 	.word	0x43505053
    9e78:	4d3d4746 	.word	0x4d3d4746
    9e7c:	0d302c43 	.word	0x0d302c43
    9e80:	2b544100 	.word	0x2b544100
    9e84:	41505442 	.word	0x41505442
    9e88:	46435249 	.word	0x46435249
    9e8c:	2c313d47 	.word	0x2c313d47
    9e90:	30303030 	.word	0x30303030
    9e94:	6973000d 	.word	0x6973000d
    9e98:	74735f6d 	.word	0x74735f6d
    9e9c:	5f747261 	.word	0x5f747261
    9ea0:	65756c62 	.word	0x65756c62
    9ea4:	746f6f74 	.word	0x746f6f74
    9ea8:	000d0a68 	.word	0x000d0a68
    9eac:	65756c42 	.word	0x65756c42
    9eb0:	746f6f74 	.word	0x746f6f74
    9eb4:	74732068 	.word	0x74732068
    9eb8:	73757461 	.word	0x73757461
    9ebc:	0a64253d 	.word	0x0a64253d
    9ec0:	6973000d 	.word	0x6973000d
    9ec4:	6c625f6d 	.word	0x6c625f6d
    9ec8:	6f746575 	.word	0x6f746575
    9ecc:	5f68746f 	.word	0x5f68746f
    9ed0:	6e6e6f63 	.word	0x6e6e6f63
    9ed4:	0a746365 	.word	0x0a746365
    9ed8:	5441000d 	.word	0x5441000d
    9edc:	4154422b 	.word	0x4154422b
    9ee0:	3d545043 	.word	0x3d545043
    9ee4:	73000d31 	.word	0x73000d31
    9ee8:	625f6d69 	.word	0x625f6d69
    9eec:	7465756c 	.word	0x7465756c
    9ef0:	68746f6f 	.word	0x68746f6f
    9ef4:	6165725f 	.word	0x6165725f
    9ef8:	73253a64 	.word	0x73253a64
    9efc:	73000d0a 	.word	0x73000d0a
    9f00:	625f6d69 	.word	0x625f6d69
    9f04:	7465756c 	.word	0x7465756c
    9f08:	68746f6f 	.word	0x68746f6f
    9f0c:	6165725f 	.word	0x6165725f
    9f10:	63203a64 	.word	0x63203a64
    9f14:	656e6e6f 	.word	0x656e6e6f
    9f18:	0a217463 	.word	0x0a217463
    9f1c:	6973000d 	.word	0x6973000d
    9f20:	6c625f6d 	.word	0x6c625f6d
    9f24:	6f746575 	.word	0x6f746575
    9f28:	5f68746f 	.word	0x5f68746f
    9f2c:	64616572 	.word	0x64616572
    9f30:	6964203a 	.word	0x6964203a
    9f34:	6e6f6373 	.word	0x6e6f6373
    9f38:	7463656e 	.word	0x7463656e
    9f3c:	000d0a21 	.word	0x000d0a21
    9f40:	422b5441 	.word	0x422b5441
    9f44:	50505354 	.word	0x50505354
    9f48:	444e4553 	.word	0x444e4553
    9f4c:	0d64253d 	.word	0x0d64253d
    9f50:	6d697300 	.word	0x6d697300
    9f54:	756c625f 	.word	0x756c625f
    9f58:	6f6f7465 	.word	0x6f6f7465
    9f5c:	775f6874 	.word	0x775f6874
    9f60:	65746972 	.word	0x65746972
    9f64:	53000d0a 	.word	0x53000d0a
    9f68:	20444e45 	.word	0x20444e45
    9f6c:	0a0d4b4f 	.word	0x0a0d4b4f
    9f70:	65796200 	.word	0x65796200
    9f74:	6228202c 	.word	0x6228202c
    9f78:	20797375 	.word	0x20797375
    9f7c:	65733531 	.word	0x65733531
    9f80:	0a0d2963 	.word	0x0a0d2963
    9f84:	756c4200 	.word	0x756c4200
    9f88:	6f6f7465 	.word	0x6f6f7465
    9f8c:	61206874 	.word	0x61206874
    9f90:	6165726c 	.word	0x6165726c
    9f94:	6f207964 	.word	0x6f207964
    9f98:	0d0a6666 	.word	0x0d0a6666
    9f9c:	54422b00 	.word	0x54422b00
    9fa0:	44505053 	.word	0x44505053
    9fa4:	3a415441 	.word	0x3a415441
    9fa8:	54422b00 	.word	0x54422b00
    9fac:	43534944 	.word	0x43534944
    9fb0:	3a4e4e4f 	.word	0x3a4e4e4f
    9fb4:	54422b00 	.word	0x54422b00
    9fb8:	4e4e4f43 	.word	0x4e4e4f43
    9fbc:	00544345 	.word	0x00544345
    9fc0:	5f444d43 	.word	0x5f444d43
    9fc4:	4b534154 	.word	0x4b534154
    9fc8:	4154535f 	.word	0x4154535f
    9fcc:	535f4554 	.word	0x535f4554
    9fd0:	54524154 	.word	0x54524154
    9fd4:	53000d0a 	.word	0x53000d0a
    9fd8:	003f434f 	.word	0x003f434f
    9fdc:	0023312a 	.word	0x0023312a
    9fe0:	0023322a 	.word	0x0023322a
    9fe4:	44414f4c 	.word	0x44414f4c
    9fe8:	7061003d 	.word	0x7061003d
    9fec:	75003d6e 	.word	0x75003d6e
    9ff0:	3d726573 	.word	0x3d726573
    9ff4:	64777000 	.word	0x64777000
    9ff8:	6f68003d 	.word	0x6f68003d
    9ffc:	003d7473 	.word	0x003d7473
    a000:	47325f54 	.word	0x47325f54
    a004:	3e2d003d 	.word	0x3e2d003d
    a008:	5f444d43 	.word	0x5f444d43
    a00c:	4b534154 	.word	0x4b534154
    a010:	4154535f 	.word	0x4154535f
    a014:	465f4554 	.word	0x465f4554
    a018:	53494e49 	.word	0x53494e49
    a01c:	0a444548 	.word	0x0a444548
    a020:	6d63000d 	.word	0x6d63000d
    a024:	61745f64 	.word	0x61745f64
    a028:	615f6b73 	.word	0x615f6b73
    a02c:	255b6464 	.word	0x255b6464
    a030:	25285d64 	.word	0x25285d64
    a034:	0d0a2964 	.word	0x0d0a2964
    a038:	646d6300 	.word	0x646d6300
    a03c:	7361745f 	.word	0x7361745f
    a040:	64615f6b 	.word	0x64615f6b
    a044:	64252864 	.word	0x64252864
    a048:	41462029 	.word	0x41462029
    a04c:	0d0a4c49 	.word	0x0d0a4c49
    a050:	646d6300 	.word	0x646d6300
    a054:	7361745f 	.word	0x7361745f
    a058:	64255b6b 	.word	0x64255b6b
    a05c:	0d0a3a5d 	.word	0x0d0a3a5d
    a060:	444d4300 	.word	0x444d4300
    a064:	5341545f 	.word	0x5341545f
    a068:	4d535f4b 	.word	0x4d535f4b
    a06c:	000d0a53 	.word	0x000d0a53
    a070:	72756f68 	.word	0x72756f68
    a074:	61640073 	.word	0x61640073
    a078:	0a007379 	.word	0x0a007379
    a07c:	2020200d 	.word	0x2020200d
    a080:	59202020 	.word	0x59202020
    a084:	4d4d2d59 	.word	0x4d4d2d59
    a088:	2044442d 	.word	0x2044442d
    a08c:	6d3a6868 	.word	0x6d3a6868
    a090:	000d0a6d 	.word	0x000d0a6d
    a094:	6d697420 	.word	0x6d697420
    a098:	30253a65 	.word	0x30253a65
    a09c:	252d6432 	.word	0x252d6432
    a0a0:	2d643230 	.word	0x2d643230
    a0a4:	64323025 	.word	0x64323025
    a0a8:	32302520 	.word	0x32302520
    a0ac:	30253a64 	.word	0x30253a64
    a0b0:	0d0a6432 	.word	0x0d0a6432
    a0b4:	616c6100 	.word	0x616c6100
    a0b8:	253a6d72 	.word	0x253a6d72
    a0bc:	2d643230 	.word	0x2d643230
    a0c0:	64323025 	.word	0x64323025
    a0c4:	3230252d 	.word	0x3230252d
    a0c8:	30252064 	.word	0x30252064
    a0cc:	253a6432 	.word	0x253a6432
    a0d0:	0a643230 	.word	0x0a643230
    a0d4:	7263000d 	.word	0x7263000d
    a0d8:	74696465 	.word	0x74696465
    a0dc:	2064253d 	.word	0x2064253d
    a0e0:	6c207325 	.word	0x6c207325
    a0e4:	0a746665 	.word	0x0a746665
    a0e8:	255b000d 	.word	0x255b000d
    a0ec:	73726864 	.word	0x73726864
    a0f0:	255b005d 	.word	0x255b005d
    a0f4:	79616464 	.word	0x79616464
    a0f8:	6565005d 	.word	0x6565005d
    a0fc:	6d6f7270 	.word	0x6d6f7270
    a100:	706d6520 	.word	0x706d6520
    a104:	203a7974 	.word	0x203a7974
    a108:	66736f6d 	.word	0x66736f6d
    a10c:	6f207465 	.word	0x6f207465
    a110:	0d0a6666 	.word	0x0d0a6666
    a114:	70656500 	.word	0x70656500
    a118:	206d6f72 	.word	0x206d6f72
    a11c:	203a6b6f 	.word	0x203a6b6f
    a120:	64616572 	.word	0x64616572
    a124:	6c617620 	.word	0x6c617620
    a128:	0a736575 	.word	0x0a736575
    a12c:	6428000d 	.word	0x6428000d
    a130:	3d737961 	.word	0x3d737961
    a134:	20296425 	.word	0x20296425
    a138:	71657328 	.word	0x71657328
    a13c:	2964253d 	.word	0x2964253d
    a140:	66000d0a 	.word	0x66000d0a
    a144:	20656572 	.word	0x20656572
    a148:	65646f6d 	.word	0x65646f6d
    a14c:	6f6e202c 	.word	0x6f6e202c
    a150:	616c6120 	.word	0x616c6120
    a154:	203a6d72 	.word	0x203a6d72
    a158:	66736f6d 	.word	0x66736f6d
    a15c:	6f207465 	.word	0x6f207465
    a160:	000d0a6e 	.word	0x000d0a6e
    a164:	65726c61 	.word	0x65726c61
    a168:	20796461 	.word	0x20796461
    a16c:	69707865 	.word	0x69707865
    a170:	2c646572 	.word	0x2c646572
    a174:	736f6d20 	.word	0x736f6d20
    a178:	20746566 	.word	0x20746566
    a17c:	0a66666f 	.word	0x0a66666f
    a180:	6e65000d 	.word	0x6e65000d
    a184:	656c6261 	.word	0x656c6261
    a188:	616c6120 	.word	0x616c6120
    a18c:	202c6d72 	.word	0x202c6d72
    a190:	66736f6d 	.word	0x66736f6d
    a194:	6f207465 	.word	0x6f207465
    a198:	000d0a6e 	.word	0x000d0a6e
    a19c:	20646461 	.word	0x20646461
    a1a0:	6e206f74 	.word	0x6e206f74
    a1a4:	0d0a776f 	.word	0x0d0a776f
    a1a8:	64646100 	.word	0x64646100
    a1ac:	206f7420 	.word	0x206f7420
    a1b0:	72616c61 	.word	0x72616c61
    a1b4:	000d0a6d 	.word	0x000d0a6d
    a1b8:	30250d0a 	.word	0x30250d0a
    a1bc:	0a646c39 	.word	0x0a646c39
    a1c0:	3231000d 	.word	0x3231000d
    a1c4:	36353433 	.word	0x36353433
    a1c8:	00393837 	.word	0x00393837
    a1cc:	36373839 	.word	0x36373839
    a1d0:	32333435 	.word	0x32333435
    a1d4:	63200031 	.word	0x63200031
    a1d8:	3d65646f 	.word	0x3d65646f
    a1dc:	20756c25 	.word	0x20756c25
    a1e0:	25783028 	.word	0x25783028
    a1e4:	3a29786c 	.word	0x3a29786c
    a1e8:	65735b00 	.word	0x65735b00
    a1ec:	6e697474 	.word	0x6e697474
    a1f0:	6c612067 	.word	0x6c612067
    a1f4:	5d6d7261 	.word	0x5d6d7261
    a1f8:	735b2000 	.word	0x735b2000
    a1fc:	253d7165 	.word	0x253d7165
    a200:	61642064 	.word	0x61642064
    a204:	253d7379 	.word	0x253d7379
    a208:	64692064 	.word	0x64692064
    a20c:	646c253d 	.word	0x646c253d
    a210:	655b005d 	.word	0x655b005d
    a214:	6f727065 	.word	0x6f727065
    a218:	6573206d 	.word	0x6573206d
    a21c:	64253d71 	.word	0x64253d71
    a220:	695b005d 	.word	0x695b005d
    a224:	616d2064 	.word	0x616d2064
    a228:	5d686374 	.word	0x5d686374
    a22c:	69645b00 	.word	0x69645b00
    a230:	6c626173 	.word	0x6c626173
    a234:	6c612065 	.word	0x6c612065
    a238:	5d6d7261 	.word	0x5d6d7261
    a23c:	6c615b00 	.word	0x6c615b00
    a240:	64616572 	.word	0x64616572
    a244:	73752079 	.word	0x73752079
    a248:	005d6465 	.word	0x005d6465
    a24c:	6573755b 	.word	0x6573755b
    a250:	796d2c64 	.word	0x796d2c64
    a254:	3d716573 	.word	0x3d716573
    a258:	005d6425 	.word	0x005d6425
    a25c:	2064695b 	.word	0x2064695b
    a260:	20746f6e 	.word	0x20746f6e
    a264:	6374616d 	.word	0x6374616d
    a268:	5b005d68 	.word	0x5b005d68
    a26c:	5d646921 	.word	0x5d646921
    a270:	65645b00 	.word	0x65645b00
    a274:	65646f63 	.word	0x65646f63
    a278:	72726520 	.word	0x72726520
    a27c:	005d726f 	.word	0x005d726f
    a280:	6564215b 	.word	0x6564215b
    a284:	65646f63 	.word	0x65646f63
    a288:	312a005d 	.word	0x312a005d
    a28c:	23343332 	.word	0x23343332
	...

0000a300 <pageSizes>:
    a300:	00000008 00000010 00000020 00000040     ........ ...@...
    a310:	00000080 00000100 00000200 00000400     ................
	...

0000a400 <_datamy_flash_addr.9380>:
	...
    a500:	6972775b 66206574 6873616c 6d697420     [write flash tim
    a510:	5b005d65 74697277 6c662065 20687361     e].[write flash 
    a520:	5d736873 72775b00 20657469 73616c66     shs].[write flas
    a530:	69732068 0a005d6d 444d430d 4b00203e     h sim]...CMD> .K
    a540:	6f776d61 20736b72 20534853 7473614d     amworks SHS Mast
    a550:	0d0a7265 73726556 3d6e6f69 252e6425     er..Version=%d.%
    a560:	0a643230 4352000d 45535541 2578303d     02d...RCAUSE=0x%
    a570:	000d0a78 54534554 0a474e49 0d0a000d     x...TESTING.....
    a580:	70696843 003a4449 6c65480a 2a203a70     ChipID:..Help: *
    a590:	65646f63 630d0a23 3d65646f 72203a31     code#..code=1: r
    a5a0:	20646165 0d0a6469 65646f63 203a323d     ead id..code=2: 
    a5b0:	616d6572 6e696e69 61642067 0d0a7379     remaining days..
    a5c0:	65646f63 203a353d 64616572 43545220     code=5: read RTC
    a5d0:	63000d0a 3d65646f 203a3031 6f666e69     ...code=10: info
    a5e0:	46464f20 6f63202c 313d6564 69203a31      OFF, code=11: i
    a5f0:	206f666e 0d0a4e4f 646f6300 32313d65     nfo ON...code=12
    a600:	6964203a 616c7073 75732079 72657662     : display subver
    a610:	6e6f6973 63000d0a 3d65646f 6d203a33     sion...code=3: m
    a620:	6566736f 4e4f2074 6f630d0a 343d6564     osfet ON..code=4
    a630:	6f6d203a 74656673 46464f20 63000d0a     : mosfet OFF...c
    a640:	3d65646f 3a797935 74657320 61655920     ode=5yy: set Yea
    a650:	630d0a72 3d65646f 3a6d6d36 74657320     r..code=6mm: set
    a660:	6e6f4d20 0d0a6874 65646f63 6464373d      Month..code=7dd
    a670:	6573203a 61442074 000d0a79 65646f63     : set Day...code
    a680:	6868383d 6573203a 6f482074 0d0a7275     =8hh: set Hour..
    a690:	65646f63 6d6d393d 6573203a 694d2074     code=9mm: set Mi
    a6a0:	6574756e 63000d0a 3d65646f 3332312a     nute...code=*123
    a6b0:	37363534 20233938 2033203a 756e696d     456789# : 3 minu
    a6c0:	20736574 64657263 0a0d7469 736c6500     tes credit...els
    a6d0:	6f632065 69206564 61642073 63207379     e code is days c
    a6e0:	69646572 31282074 69642034 73746967     redit (14 digits
    a6f0:	0d0a0a29 3e3e3e00 646f6220 745f3333     )....>>> bod33_t
    a700:	3d706972 53206425 5045454c 3c3c2021     rip=%d SLEEP! <<
    a710:	000d0a3c 203e3e3e 33646f62 6b6f2033     <...>>> bod33 ok
    a720:	6b617720 20707565 0a3c3c3c 4953000d      wakeup <<<...SI
    a730:	7661204d 616c6961 0a656c62 5b20000d     M available... [
    a740:	253a5249 3a786c30 005d6325 0023332a     IR:%0lx:%c].*3#.
    a750:	0023342a 0023352a 2330312a 31312a00     *4#.*5#.*10#.*11
    a760:	6e450023 20726574 2077656e 64657263     #.Enter new cred
    a770:	63207469 2065646f 77206f74 65746972     it code to write
    a780:	616c6620 0a216873 6c41000d 216d7261      flash!...Alarm!
    a790:	736f6d20 20746566 2146464f 41000d0a               mosfet OFF!...

0000a79f <xload>:
    a79f:	42414141 46444343 4c4a4947 5452504e     AAABCCDFGIJLNPRT
    a7af:	5e5b5957 67656360 706e6c6a 77757472     WY[^`cegjlnprtuw
    a7bf:	7b7b7a78 7d7d7d7c                       xz{{|}}}

0000a7c7 <yload>:
    a7c7:	30323537 27292b2d 20212325 1b1c1d1e     7520-+)'%#! ....
    a7d7:	19191a1a 1a1a1919 1e1d1c1b 25232120     ............ !#%
    a7e7:	2d2b2927 37353230 64656c6f 43324920     ')+-0257oled I2C
    a7f7:	73656d20 65676173 6f6f7420 6e6f6c20      message too lon
    a807:	0a212167 0212000d                                g!!...

0000a80d <u8g2_font_9x15_mn>:
    a80d:	02040212 03010404 000f0805 0cfd0cfd     ................
    a81d:	000000fd 20200100 9f93f906 f9122a7f     ......  .....*..
    a82d:	8a971f93 56aa24d4 55489a89 2b00359e     .....$.V..HU.5.+
    a83d:	9f93f90e 18355834 a4f582a4 f90b2c00     ....4X5......,..
    a84d:	748f9f93 0010bac2 93f90b2d 20c1a39f     ...t....-...... 
    a85d:	2e0011cf 9f93f909 027a748f 93f90f2f     .........tz./...
    a86d:	e60b9a1f b985730a 3000113c 1f93f915     .....s..<..0....
    a87d:	4554cab6 24549152 52454915 013daa99     ..TER.T$.IER..=.
    a88d:	93f91031 2593971f af609152 1a3c8306     1......%R.`...<.
    a89d:	93f91132 a4d0351f 1f5ca922 3479060e     2....5..".\...y4
    a8ad:	f9123300 18341f93 cb757304 332a4960     .3....4..su.`I*3
    a8bd:	3401c3d0 1f93f914 52259399 28a65091     ...4......%R.P.(
    a8cd:	82e41833 350070f5 1f93f914 82441834     3....p.5....4.D.
    a8dd:	288c8315 199524d8 3600e1e8 1f93f916     ...(.$.....6....
    a8ed:	82e50836 288c8315 22a48a92 0f40cca9     6......(..."..@.
    a8fd:	f9123707 18341f93 5cc17304 05cc1730     .7....4..s.\0...
    a90d:	380024f3 1f93f912 6554cab6 aa9956aa     .$.8......Te.V..
    a91d:	b5532a48 f9153927 d0351f93 48a922a4     H*S.'9....5..".H
    a92d:	0cd2122a d0bac112 0b3a4f20 919f93f9     *....... O:.....
    a93d:	d3a44f4e 00000013 65000000                       NO.........

0000a948 <u8g2_cb_mirror>:
    a948:	00003365 00003461                       e3..a4..

0000a950 <u8g2_cb_r3>:
    a950:	00003409 000034e1                       .4...4..

0000a958 <u8g2_cb_r2>:
    a958:	000033cd 000034b1                       .3...4..

0000a960 <u8g2_cb_r1>:
    a960:	00003395 00003489                       .3...4..

0000a968 <u8g2_cb_r0>:
    a968:	00003365 0000344d                       e3..M4..

0000a970 <u8x8_d_ssd1306_128x64_noname_powersave0_seq>:
    a970:	19af1518 ae1518ff                                .....

0000a975 <u8x8_d_ssd1306_128x64_noname_powersave1_seq>:
    a975:	19ae1518 a11518ff                                .....

0000a97a <u8x8_d_ssd1306_128x64_noname_flip0_seq>:
    a97a:	15a11518 18ff19c8                                .......

0000a981 <u8x8_d_ssd1306_128x64_noname_flip1_seq>:
    a981:	15a01518 18ff19c0                                .......

0000a988 <u8x8_d_ssd1306_128x64_noname_init_seq>:
    a988:	15ae1518 158016d5 153f16a8 150016d3     ..........?.....
    a998:	168d1540 16201514 15a11500 16da15c8     @..... .........
    a9a8:	16811512 16d915cf 16db15f1 152e1540     ............@...
    a9b8:	19a615a4 000000ff                       ........

0000a9c0 <u8x8_ssd1306_128x64_noname_display_info>:
    a9c0:	0a140100 32326464 007a1200 96280400     ....dd22..z...(.
    a9d0:	00000810 00400080                       ......@.

0000a9d8 <u8x8_d_ssd1306_128x64_vcomh0_init_seq>:
    a9d8:	15ae1518 158016d5 153f16a8 150016d3     ..........?.....
    a9e8:	168d1540 16201514 15a11500 16da15c8     @..... .........
    a9f8:	16811512 16d915ef 16db15a1 152e1500     ................
    aa08:	19a615a4 ae1518ff                                .....

0000aa0d <u8x8_d_ssd1306_128x64_alt0_init_seq>:
    aa0d:	15ae1518 158016d5 153f16a8 150016d3     ..........?.....
    aa1d:	168d1540 16201514 15a11500 16da15c8     @..... .........
    aa2d:	16811502 16d915cf 16db15f1 152e1540     ............@...
    aa3d:	19a615a4 000000ff                                .......

0000aa44 <u8x8_sh1106_128x64_noname_display_info>:
    aa44:	0a140100 32326464 007a1200 96280403     ....dd22..z...(.
    aa54:	02020810 00400080                       ......@.

0000aa5c <u8x8_d_sh1106_128x64_winstar_init_seq>:
    aa5c:	15ae1518 16d515a4 16a81550 16d3153f     ........P...?...
    aa6c:	15401500 158b16ad 152216d9 153516db     ..@......."...5.
    aa7c:	16811532 15a615ff 191216da 000000ff     2...............

0000aa8c <CSWTCH.87>:
    aa8c:	0000ae72 0000ae7a 0000ae82 0000ae8a     r...z...........

0000aa9c <CSWTCH.90>:
    aa9c:	0000ae56 0000ae5d 0000ae64 0000ae6b     V...]...d...k...

0000aaac <CSWTCH.92>:
    aaac:	0000ae41 0000ae48 0000ae4f              A...H...O...

0000aab8 <CSWTCH.94>:
    aab8:	0000ae21 0000ae29 0000ae31 0000ae39     !...)...1...9...
    aac8:	3f3f3f20 003f3f3f 00204b4f 00205858      ??????.OK .XX .
    aad8:	3f3f2020 73003f3f 6d5f6363 74696e6f       ????.scc_monit
    aae8:	255b726f 303d5d64 0a782578 504d000d     or[%d]=0x%x...MP
    aaf8:	253d5450 5b003a64 7c3c3c3c 5d202020     PT=%d:.[<<<|   ]
    ab08:	5b000d0a 7c3c2020 5d202020 5b000d0a     ...[  <|   ]...[
    ab18:	7c202020 5d3e3e3e 5b000d0a 7c202020        |>>>]...[   |
    ab28:	5d20203e 5b000d0a 7c202020 5d202020     >  ]...[   |   ]
    ab38:	31000d0a 65686320 75736b63 7265206d     ...1 checksum er
    ab48:	0d726f72 255b000a 76205d64 6f5f7670     ror...[%d] vpv_o
    ab58:	64253d63 5b000d0a 205d6425 5f767076     c=%d...[%d] vpv_
    ab68:	253d7073 000d0a64 5b636373 205d6425     sp=%d...scc[%d] 
    ab78:	253d5746 000d0a78 68632032 736b6365     FW=%x...2 checks
    ab88:	65206d75 726f7272 31000a0d 6d6f6320     um error...1 com
    ab98:	7265206d 0d726f72 2032000a 6d6d6f63     m error...2 comm
    aba8:	72726520 0a0d726f 63637300 63326920      error...scc i2c
    abb8:	72726520 003a726f 5d78255b 63637300      error:.[%x].scc
    abc8:	6425203a 43435320 64207327 63657465     : %d SCC's detec
    abd8:	0a646574 6373000d 64255b63 78303d5d     ted...scc[%d]=0x
    abe8:	0d0a7825 63637300 7465735f 616f6c5f     %x...scc_set_loa
    abf8:	64252864 000d0a29 5f636373 5f6c6163     d(%d)...scc_cal_
    ac08:	706d6574 29642528 73000d0a 635f6363     temp(%d)...scc_c
    ac18:	625f6c61 28747461 0a296425 6373000d     al_batt(%d)...sc
    ac28:	65735f63 68615f74 7461625f 64252874     c_set_ah_batt(%d
    ac38:	000d0a29 5f636373 72617473 71655f74     )...scc_start_eq
    ac48:	696c6175 2928657a 73000d0a 725f6363     ualize()...scc_r
    ac58:	5f646165 74746162 5b797265 0a5d6425     ead_battery[%d].
    ac68:	255b000d 41205d64 6c253d73 73412064     ..[%d] As=%ld As
    ac78:	78616d5f 646c253d 75716520 7a696c61     _max=%ld equaliz
    ac88:	64253d65 0d000d0a 4343530a 2020203a     e=%d.....SCC:   
    ac98:	73797320 206d6574 74746162 73207473      system battst s
    aca8:	74736c6f 436f5320 56202020 20207670     olst SoC   Vpv  
    acb8:	61686349 20656772 61625620 20207474     Icharge  Vbatt  
    acc8:	616f6c49 65742064 6c20706d 7364616f     Iload temp loads
    acd8:	65746174 2d0a0d00 2d2d2d2d 2d2d2d2d     tate...---------
    ace8:	2d2d2d2d 2d2d2b2d 2d2d2d2d 2d2d2d2b     -----+------+---
    acf8:	2d2b2d2d 2d2b2d2d 2d2d2d2d 2d2d2b2d     --+---+------+--
    ad08:	2d2d2d2d 2d2b2d2d 2d2d2d2d 2d2d2d2b     ------+-----+---
    ad18:	2b2d2d2d 2d2d2d2d 2d2d2d2b 2d2d2d2d     ---+----+-------
    ad28:	0d002d2d 32255b0a 003a5d78 20007325     --...[%2x]:.%s. 
    ad38:	20643325 20202000 64342520 20200020     %3d .    %4d .  
    ad48:	32252020 0d002064 4343530a 6420203a       %2d ...SCC:  d
    ad58:	20737961 61647920 20206c79 20684120     ays  ydayl   Ah 
    ad68:	6f532020 00204343 2d2d0a0d 2d2d2d2d       SoCC ...------
    ad78:	2d2d2d2d 2d2d2d2b 2b2d2d2d 2d2d2d2d     ----+------+----
    ad88:	2d2b2d2d 2b2d2d2d 25202000 20006434     --+----+.  %4d. 
    ad98:	64352520 25202000 0d006433 4343530a      %5d.  %3d...SCC
    ada8:	2020203a 73797320 206d6574 74746162     :    system batt
    adb8:	73207473 74736c6f 436f5320 56202020     st solst SoC   V
    adc8:	20207670 61686349 20656772 61625620     pv  Icharge  Vba
    add8:	20207474 616f6c49 65742064 6c20706d     tt  Iload temp l
    ade8:	7364616f 0d746174 7325000a 0d000a0d     oadstat...%s....
    adf8:	4343530a 6420203a 20737961 61647920     .SCC:  days  yda
    ae08:	20206c79 20684120 6f532020 0a0d4343     yl   Ah   SoCC..
    ae18:	25202000 0a0d6433 464f2000 4b4f2046     .  %3d... OFF OK
    ae28:	4e4f2000 4b4f2020 464f2000 283a2046     . ON  OK. OFF :(
    ae38:	4e4f2000 283a2020 4f202000 0020204b     . ON  :(.  OK  .
    ae48:	4f4c2020 20002057 47494820 4e490048       LOW .  HIGH.IN
    ae58:	20205449 49415700 00202054 52414843     IT  .WAIT  .CHAR
    ae68:	45004547 524f5252 4e200020 414d524f     GE.ERROR . NORMA
    ae78:	4620004c 204c4c55 45200020 5954504d     L. FULL  . EMPTY
    ae88:	47200021 21454e4f 0d0a0020 6c667872     !. GONE! ...rxfl
    ae98:	3a687375 730d0a00 725f6d69 3a646165     ush:...sim_read:
    aea8:	00305c00 5c006e5c 63250072 6d697300     .\0.\n.\r.%c.sim
    aeb8:	6d697420 74756f65 0a000d0a 6e656c0d      timeout.....len
    aec8:	0a64253d 0d0a000d 5f6d6973 64616572     =%d.....sim_read
    aed8:	6c756d5f 003a6974 69730d0a 72775f6d     _multi:...sim_wr
    aee8:	3a657469 4d495300 5341545f 54535f4b     ite:.SIM_TASK_ST
    aef8:	5f455441 52415453 000d0a54 657a6973     ATE_START...size
    af08:	2064253d 3d6e656c 0d0a6425 6e657300     =%d len=%d...sen
    af18:	736d7364 0a73253a 5441000d 474d432b     dsms:%s...AT+CMG
    af28:	00223d53 0d227325 61003e00 74726f62     S=".%s"..>.abort
    af38:	53000d0a 545f4d49 5f4b5341 54415453     ...SIM_TASK_STAT
    af48:	45535f45 4d53444e 45525f53 4e4f5053     E_SENDSMS_RESPON
    af58:	0d0a4553 4d432b00 2d005347 4d49533e     SE...+CMGS.->SIM
    af68:	5341545f 54535f4b 5f455441 494e4946     _TASK_STATE_FINI
    af78:	44454853 41000d0a 4d432b54 313d4447     SHED...AT+CMGD=1
    af88:	5441000d 474d432b 52000d4c 55204345     ..AT+CMGL..REC U
    af98:	4145524e 0a0d0044 0a0d4b4f 6f687000     NREAD...OK...pho
    afa8:	726e656e 6e00203a 6968746f 0d0a676e     nenr: .nothing..
    afb8:	6f687000 6e20656e 65626d75 4b4f2072     .phone number OK
    afc8:	41000d0a 4d432b54 3d414447 4c454422     ...AT+CMGDA="DEL
    afd8:	4c4c4120 4e000d22 4d492d4f 41004945      ALL"..NO-IMEI.A
    afe8:	53472b54 62000d4e 69206461 0069656d     T+GSN..bad imei.
    aff8:	432b5441 000d5153 432b0a0d 203a5153     AT+CSQ....+CSQ: 
    b008:	252c6425 53430064 64253a51 4c000d0a     %d,%d.CSQ:%d...L
    b018:	7461636f 3a6e6f69 41000d0a 4c432b54     ocation:...AT+CL
    b028:	343d5342 000d312c 432b5441 54535049     BS=4,1..AT+CIPST
    b038:	53555441 5453000d 3a455441 54410020     ATUS..STATE: .AT
    b048:	5041532b 333d5242 222c312c 746e6f43     +SAPBR=3,1,"Cont
    b058:	22657079 5047222c 0d225352 2b544100     ype","GPRS"..AT+
    b068:	42504153 2c333d52 53002c31 545f4d49     SAPBR=3,1,.SIM_T
    b078:	5f4b5341 54415453 54535f45 32545241     ASK_STATE_START2
    b088:	45475f47 49535f54 4154534d 0d0a4554     G_GET_SIMSTATE..
    b098:	3a673200 74617473 73253d65 49000d0a     .2g:state=%s...I
    b0a8:	4e492050 41495449 5049004c 41545320     P INITIAL.IP STA
    b0b8:	49005452 50472050 43415352 50490054     RT.IP GPRSACT.IP
    b0c8:	41545320 00535554 20504450 43414544      STATUS.PDP DEAC
    b0d8:	49530054 41545f4d 535f4b53 45544154     T.SIM_TASK_STATE
    b0e8:	4154535f 47325452 494e495f 000d0a54     _START2G_INIT...
    b0f8:	532b5441 52425041 312c333d 5041222c     AT+SAPBR=3,1,"AP
    b108:	222c224e 2b544100 42504153 2c333d52     N",".AT+SAPBR=3,
    b118:	55222c31 22524553 4100222c 41532b54     1,"USER",".AT+SA
    b128:	3d524250 2c312c33 44575022 00222c22     PBR=3,1,"PWD",".
    b138:	432b5441 3d545453 73250022 00222c22     AT+CSTT=".%s",".
    b148:	432b5441 3d545453 4d495300 5341545f     AT+CSTT=.SIM_TAS
    b158:	54535f4b 5f455441 52415453 5f473254     K_STATE_START2G_
    b168:	52415453 000d0a54 432b5441 52434949     START...AT+CIICR
    b178:	4953000d 41545f4d 535f4b53 45544154     ..SIM_TASK_STATE
    b188:	4154535f 47325452 4154535f 575f5452     _START2G_START_W
    b198:	31544941 53000d0a 545f4d49 5f4b5341     AIT1...SIM_TASK_
    b1a8:	54415453 54535f45 32545241 54535f47     STATE_START2G_ST
    b1b8:	32545241 53000d0a 545f4d49 5f4b5341     ART2...SIM_TASK_
    b1c8:	54415453 54535f45 32545241 50475f47     STATE_START2G_GP
    b1d8:	43415352 000d0a54 432b5441 52534649     RSACT...AT+CIFSR
    b1e8:	002e000d 5f4d4953 4b534154 4154535f     ....SIM_TASK_STA
    b1f8:	535f4554 54524154 535f4732 55544154     TE_START2G_STATU
    b208:	000d0a53 532b5441 52425041 312c313d     S...AT+SAPBR=1,1
    b218:	4953000d 41545f4d 535f4b53 45544154     ..SIM_TASK_STATE
    b228:	4154535f 47325452 4154535f 32535554     _START2G_STATUS2
    b238:	53000d0a 545f4d49 5f4b5341 54415453     ...SIM_TASK_STAT
    b248:	54535f45 32545241 45445f47 0a544341     E_START2G_DEACT.
    b258:	5441000d 5049432b 54554853 4853000d     ..AT+CIPSHUT..SH
    b268:	4f205455 000a0d4b 482b5441 49505454     UT OK...AT+HTTPI
    b278:	0d54494e 2b544100 50545448 4d524554     NIT..AT+HTTPTERM
    b288:	4953000d 41545f4d 535f4b53 45544154     ..SIM_TASK_STATE
    b298:	4e45535f 5f473244 50545448 41524150     _SEND2G_HTTPPARA
    b2a8:	4449435f 41000d0a 54482b54 41505054     _CID...AT+HTTPPA
    b2b8:	223d4152 22444943 000d312c 482b5441     RA="CID",1..AT+H
    b2c8:	50505454 3d415241 4d495300 5341545f     TTPPARA=.SIM_TAS
    b2d8:	54535f4b 5f455441 444e4553 485f4732     K_STATE_SEND2G_H
    b2e8:	50505454 5f415241 0a4c5255 6573000d     TTPPARA_URL...se
    b2f8:	6732646e 0a73253a 5441000d 5454482b     nd2g:%s...AT+HTT
    b308:	52415050 55223d41 2c224c52 65730022     PPARA="URL",".se
    b318:	6732646e 6e65733a 0d0a2174 68636500     nd2g:sent!...ech
    b328:	6572206f 000d0a63 5f4d4953 4b534154     o rec...SIM_TASK
    b338:	4154535f 535f4554 32444e45 54485f47     _STATE_SEND2G_HT
    b348:	43415054 4e4f4954 41000d0a 54482b54     TPACTION...AT+HT
    b358:	43415054 4e4f4954 000d303d 5f4d4953     TPACTION=0..SIM_
    b368:	4b534154 4154535f 535f4554 32444e45     TASK_STATE_SEND2
    b378:	54485f47 43415054 4e4f4954 4941575f     G_HTTPACTION_WAI
    b388:	0d0a3154 4d495300 5341545f 54535f4b     T1...SIM_TASK_ST
    b398:	5f455441 444e4553 485f4732 41505454     ATE_SEND2G_HTTPA
    b3a8:	4f495443 0d0a324e 4d495300 5341545f     CTION2...SIM_TAS
    b3b8:	54535f4b 5f455441 444e4553 485f4732     K_STATE_SEND2G_H
    b3c8:	52505454 0a444145 5441000d 5454482b     TTPREAD...AT+HTT
    b3d8:	41455250 2c303d44 0d353532 4d495300     PREAD=0,255..SIM
    b3e8:	5341545f 54535f4b 5f455441 444e4553     _TASK_STATE_SEND
    b3f8:	485f4732 53505454 55544154 000d0a53     2G_HTTPSTATUS...
    b408:	482b5441 53505454 55544154 000d3f53     AT+HTTPSTATUS?..
    b418:	5f4d4953 4b534154 4154535f 535f4554     SIM_TASK_STATE_S
    b428:	32444e45 54485f47 54535054 53555441     END2G_HTTPSTATUS
    b438:	4941575f 0d0a3154 4d495300 5341545f     _WAIT1...SIM_TAS
    b448:	54535f4b 5f455441 444e4553 485f4732     K_STATE_SEND2G_H
    b458:	53505454 55544154 41575f53 0a325449     TTPSTATUS_WAIT2.
    b468:	4953000d 41545f4d 535f4b53 45544154     ..SIM_TASK_STATE
    b478:	4e45535f 5f473244 50545448 54415453     _SEND2G_HTTPSTAT
    b488:	0a325355 4547000d 2c302c54 00302c30     US2...GET,0,0,0.
    b498:	5f4d4953 4b534154 4154535f 535f4554     SIM_TASK_STATE_S
    b4a8:	32444e45 45545f47 0d0a4d52 69617700     END2G_TERM...wai
    b4b8:	64252074 726f6d20 65732065 646e6f63     t %d more second
    b4c8:	000d0a73 532b5441 52425041 312c303d     s...AT+SAPBR=0,1
    b4d8:	4953000d 41545f4d 535f4b53 45544154     ..SIM_TASK_STATE
    b4e8:	4f54535f 5f473250 54494157 53000d0a     _STOP2G_WAIT...S
    b4f8:	545f4d49 5f4b5341 54415453 54535f45     IM_TASK_STATE_ST
    b508:	4732504f 5041535f 525f5242 4f505345     OP2G_SAPBR_RESPO
    b518:	0a45534e 4953000d 41545f4d 535f4b53     NSE...SIM_TASK_S
    b528:	45544154 4f54535f 5f473250 4d524554     TATE_STOP2G_TERM
    b538:	53000d0a 545f4d49 5f4b5341 54415453     ...SIM_TASK_STAT
    b548:	54535f45 4732504f 5245545f 41575f4d     E_STOP2G_TERM_WA
    b558:	0d0a5449 2b544100 47455243 0d000d3f     IT...AT+CREG?...
    b568:	52432b0a 203a4745 64252c30 45524300     .+CREG: 0,%d.CRE
    b578:	64253a47 63000d0a 3d676572 0d0a6425     G:%d...creg=%d..
    b588:	2b544100 3d434649 0d322c32 2b544100     .AT+IFC=2,2..AT+
    b598:	4c435343 0d303d4b 2b544100 46474d43     CSCLK=0..AT+CMGF
    b5a8:	000d313d 432b5441 3f4e4950 4552000d     =1..AT+CPIN?..RE
    b5b8:	00594441 70747468 002f2f3a 616e612f     ADY.http://./ana
    b5c8:	6974796c 642f7363 70617461 746e696f     lytics/datapoint
    b5d8:	6361625f 646e656b 61643f2f 003d6174     _backend/?data=.
    b5e8:	6c393025 46003b64 004c4941 5f4d4953     %09ld;.FAIL.SIM_
    b5f8:	4b534154 4154535f 505f4554 5245574f     TASK_STATE_POWER
    b608:	4c55505f 4e4f4553 53000d0a 545f4d49     _PULSEON...SIM_T
    b618:	5f4b5341 54415453 4f505f45 5f524557     ASK_STATE_POWER_
    b628:	534c5550 5f4e4f45 54494157 53000d0a     PULSEON_WAIT...S
    b638:	545f4d49 5f4b5341 54415453 4f505f45     IM_TASK_STATE_PO
    b648:	5f524557 534c5550 5f4e4f45 54494157     WER_PULSEON_WAIT
    b658:	000d0a35 000d5441 5f4d4953 4b534154     5...AT..SIM_TASK
    b668:	4154535f 505f4554 5245574f 5455415f     _STATE_POWER_AUT
    b678:	5541424f 000d0a44 5f4d4953 4b534154     OBAUD...SIM_TASK
    b688:	4154535f 505f4554 5245574f 5445535f     _STATE_POWER_SET
    b698:	5845545f 444f4d54 000d0a45 5f4d4953     _TEXTMODE...SIM_
    b6a8:	4b534154 4154535f 505f4554 5245574f     TASK_STATE_POWER
    b6b8:	4c45445f 47534d5f 000d0a53 5f4d4953     _DEL_MSGS...SIM_
    b6c8:	4b534154 4154535f 505f4554 5245574f     TASK_STATE_POWER
    b6d8:	5445535f 4f4c465f 52544357 000d0a4c     _SET_FLOWCTRL...
    b6e8:	5f4d4953 4b534154 4154535f 505f4554     SIM_TASK_STATE_P
    b6f8:	5245574f 4145525f 4d495f44 0d0a4945     OWER_READ_IMEI..
    b708:	454d4900 73253d49 50000d0a 68636e69     .IMEI=%s...Pinch
    b718:	3d6b6365 0d0a7325 6d697300 7361745f     eck=%s...sim_tas
    b728:	64615f6b 64255b64 6425285d 000d0a29     k_add[%d](%d)...
    b738:	5f6d6973 6b736174 6464615f 29642528     sim_task_add(%d)
    b748:	49414620 000d0a4c 5f6d6973 6b736174      FAIL...sim_task
    b758:	6978655f 313d7473 73000d0a 745f6d69     _exist=1...sim_t
    b768:	5f6b7361 73697865 0a303d74 4952000d     ask_exist=0...RI
    b778:	0d0a474e 6d697300 7361745f 64255b6b     NG...sim_task[%d
    b788:	0d0a3a5d 4d495300 5341545f 4f505f4b     ]:...SIM_TASK_PO
    b798:	0a524557 4953000d 41545f4d 535f4b53     WER...SIM_TASK_S
    b7a8:	54524154 0a47325f 4953000d 41545f4d     TART_2G...SIM_TA
    b7b8:	535f4b53 5f504f54 0d0a4732 4d495300     SK_STOP_2G...SIM
    b7c8:	5341545f 45535f4b 325f444e 000d0a47     _TASK_SEND_2G...
    b7d8:	5f4d4953 4b534154 4e45535f 4d535f44     SIM_TASK_SEND_SM
    b7e8:	000d0a53 5f4d4953 4b534154 4941575f     S...SIM_TASK_WAI
    b7f8:	000d0a54 5f4d4953 4b534154 4145525f     T...SIM_TASK_REA
    b808:	4d535f44 000d0a53 5f4d4953 4b534154     D_SMS...SIM_TASK
    b818:	4552435f 000d0a47 756e6168 2d6e616d     _CREG...hanuman-
    b828:	67617473 6d616b2e 6b726f77 6f632e73     stag.kamworks.co
    b838:	4d43006d 0054454e 432b5441 0d524d47     m.CMNET.AT+CGMR.
    b848:	00544200                                .BT.

0000b84c <CSWTCH.19>:
    b84c:	4f435749                                         IWC

0000b84f <CSWTCH.21>:
    b84f:	30484c4f                                         OLH

0000b852 <CSWTCH.23>:
    b852:	0d663130 436f530a 70562020 49202076     01f..SoC  Vpv  I
    b862:	72616863 20206567 74616256 49202074     charge  Vbatt  I
    b872:	64616f6c 6d657420 50202070 50206e69     load temp  Pin P
    b882:	2074756f 5f735720 20206e69 6f5f7357     out  Ws_in  Ws_o
    b892:	20207475 69747075 0a0d656d 35252000     ut  uptime... %5
    b8a2:	0020646c 6c362520 33002064 253b302e     ld . %6ld .3.0;%
    b8b2:	64252e64 2563253b 25632563 63253b63     d.%d;%c%c%c%c;%c
    b8c2:	63256325 253b6325 253b756c 25632563     %c%c%c;%lu;%c%c%
    b8d2:	3b632563 3b642500 253b6425 6c253b64     c%c;.%d;%d;%d;%l
    b8e2:	6c253b75 6c253b75 63253b75 63256325     u;%lu;%lu;%c%c%c
    b8f2:	003b6325 253b6425 64253b64 3b64253b     %c;.%d;%d;%d;%d;
    b902:	253b6425 64253b64 6425003b 3b64253b     %d;%d;%d;.%d;%d;
    b912:	253b6425 3b303b64 25003b30 64253b64     %d;%d;0;0;.%d;%d
    b922:	3b64253b 3b756c25 543e2d00 5f4b5341     ;%d;%lu;.->TASK_
    b932:	54415453 49465f45 4853494e 0d0a4445     STATE_FINISHED..
    b942:	756c4200 6f6f7465 6d206874 61737365     .Bluetooth messa
    b952:	72206567 69656365 3a646576 0d0a7325     ge received:%s..
    b962:	43435300 4353003f 003f4443 504d4554     .SCC?.SCCD?.TEMP
    b972:	4142003d 003d4f54 003d4841 454e5552     =.BATO=.AH=.RUNE
    b982:	2d2d0051 5341542d 494d5f4b 2d2d2d4e     Q.---TASK_MIN---
    b992:	2d000d0a 41542d2d 435f4b53 2d474552     ...---TASK_CREG-
    b9a2:	0d0a2d2d 4d495300 61766120 62616c69     --...SIM availab
    b9b2:	6220656c 6e207475 6f20746f 000d0a6e     le but not on...
    b9c2:	542d2d2d 5f4b5341 2d2d4732 000d0a2d     ---TASK_2G---...
    b9d2:	542d2d2d 5f4b5341 52554f48 0a2d2d2d     ---TASK_HOUR---.
    b9e2:	2d2d000d 5341542d 41445f4b 2d2d2d59     ..---TASK_DAY---
    b9f2:	00000d0a                                ....

0000b9f6 <CSWTCH.29>:
    b9f6:	02000100 04000300 05000000 06000000     ................
    ba06:	07000000 3a633269 0a6e6f20 3269000d     ....i2c: on...i2
    ba16:	73203a63 0a706f74 3269000d 64203a63     c: stop...i2c: d
    ba26:	62617369 0d0a656c 63326900 666f203a     isable...i2c: of
    ba36:	000d0a66 3a633269 73657220 0d0a7465     f...i2c: reset..
    ba46:	63326900 7274203a 65722079 7361656c     .i2c: try releas
    ba56:	44532065 70203a41 65736c75 4c435320     e SDA: pulse SCL
    ba66:	64250020 000d0a78 3a633269 4f545320      .%dx...i2c: STO
    ba76:	000d0a50                                P...

0000ba7a <digitlut>:
    ba7a:	06020701 08090004 56230305                       ..........

0000ba84 <seqlut>:
    ba84:	5d455623 0f4a3f63 1a525854 373a2b32     #VE]c?J.TXR.2+:7
    ba94:	60344761 1438430d 13092e1b 02012649     aG4`.C8.....I&..
    baa4:	3905404d 1f151903 4b08103d 1e4e5c18     M@.9....=..K.\N.
    bab4:	2c0a0621 5f355348 2a120b31 114c1c28     !..,HS5_1..*(.L.
    bac4:	500c0e00 6244572f 51273320 362d223e     ...P/WDb 3'Q>"-6
    bad4:	25042455 465b4229 5e4f3c59 07165a1d     U$.%)B[FY<O^.Z..
    bae4:	173b3041 00008464 00008324 00008324     A0;.d...$...$...
    baf4:	00008320 0000843c 0000843c 0000842e      ...<...<.......
    bb04:	00008320 0000843c 0000842e 0000843c      ...<.......<...
    bb14:	00008320 00008444 00008444 00008444      ...D...D...D...
    bb24:	00008648 4f500043 00584953              H...C.POSIX.

0000bb30 <_ctype_>:
    bb30:	20202000 20202020 28282020 20282828     .         ((((( 
    bb40:	20202020 20202020 20202020 20202020                     
    bb50:	10108820 10101010 10101010 10101010      ...............
    bb60:	04040410 04040404 10040404 10101010     ................
    bb70:	41411010 41414141 01010101 01010101     ..AAAAAA........
    bb80:	01010101 01010101 01010101 10101010     ................
    bb90:	42421010 42424242 02020202 02020202     ..BBBBBB........
    bba0:	02020202 02020202 02020202 10101010     ................
    bbb0:	00000020 00000000 00000000 00000000      ...............
	...

0000bc34 <__sf_fake_stderr>:
	...

0000bc54 <__sf_fake_stdin>:
	...

0000bc74 <__sf_fake_stdout>:
	...
    bc94:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    bca4:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    bcb4:	31300046 35343332 39383736 64636261     F.0123456789abcd
    bcc4:	00006665 0000bce6 0000bce9 0000bcec     ef..............
    bcd4:	61462d41 3938662d 33323130 37363534     A-Fa-f8901234567
    bce4:	2d2b005d 00303000 00005878              ].+-.00.xX..

0000bcf0 <_init>:
    bcf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bcf2:	46c0      	nop			; (mov r8, r8)
    bcf4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    bcf6:	bc08      	pop	{r3}
    bcf8:	469e      	mov	lr, r3
    bcfa:	4770      	bx	lr

0000bcfc <__init_array_start>:
    bcfc:	000000cd 	.word	0x000000cd

0000bd00 <_fini>:
    bd00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bd02:	46c0      	nop			; (mov r8, r8)
    bd04:	bcf8      	pop	{r3, r4, r5, r6, r7}
    bd06:	bc08      	pop	{r3}
    bd08:	469e      	mov	lr, r3
    bd0a:	4770      	bx	lr

0000bd0c <__fini_array_start>:
    bd0c:	000000a5 	.word	0x000000a5
